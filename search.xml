<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数学基础面试题</title>
    <url>/2024/03/19/deep_learning/ch1/</url>
    <content><![CDATA[<h1>数学基础</h1>
<p>深度学习通常又需要哪些数学基础？深度学习里的数学到底难在哪里？通常初学者都会有这些问题，在网络推荐及书本推荐里，经常看到会列出一系列数学科目，比如微积分、线性代数、概率论、复变函数、数值计算、优化理论、信息论等等。这些数学知识有相关性，但实际上按照这样的知识范围来学习，学习成本会很久，而且会很枯燥，本章我们通过选举一些数学基础里容易混淆的一些概念做以介绍，帮助大家更好的理清这些易混淆概念之间的关系。</p>
<h2 id="1-1-向量和矩阵">1.1 向量和矩阵</h2>
<h3 id="1-1-1-标量、向量、矩阵、张量之间的联系">1.1.1 标量、向量、矩阵、张量之间的联系</h3>
<p><strong>标量（scalar）</strong><br>
一个标量表示一个单独的数，它不同于线性代数中研究的其他大部分对象（通常是多个数的数组）。我们用斜体表示标量。标量通常被赋予小写的变量名称。</p>
<p><strong>向量（vector）</strong><br>
​一个向量表示一组有序排列的数。通过次序中的索引，我们可以确定每个单独的数。通常我们赋予向量粗体的小写变量名称，比如xx。向量中的元素可以通过带脚标的斜体表示。向量 $X$ 的第一个元素是 $X_1$ ，第二个元素是 $X_2$ ，以此类推。我们也会注明存储在向量中的元素的类型（实数、虚数等）。</p>
<p><strong>矩阵（matrix）</strong><br>
​矩阵是具有相同特征和纬度的对象的集合，表现为一张二维数据表。其意义是一个对象表示为矩阵中的一行，一个特征表示为矩阵中的一列，每个特征都有数值型的取值。通常会赋予矩阵粗体的大写变量名称，比如 $A$ 。</p>
<p><strong>张量（tensor）</strong><br>
​在某些情况下，我们会讨论坐标超过两维的数组。一般地，一个数组中的元素分布在若干维坐标的规则网格中，我们将其称之为张量。使用  $A$  来表示张量“A”。张量 $A$ 中坐标为 $(i,j,k)$ 的元素记作 $A_{(i,j,k)}$ 。</p>
<p><strong>四者之间关系</strong></p>
<blockquote>
<p>标量是0阶张量，向量是一阶张量。举例：<br>
​标量就是知道棍子的长度，但是你不会知道棍子指向哪儿。<br>
​向量就是不但知道棍子的长度，还知道棍子指向前面还是后面。<br>
​张量就是不但知道棍子的长度，也知道棍子指向前面还是后面，还能知道这棍子又向上/下和左/右偏转了多少。</p>
</blockquote>
<h3 id="1-1-2-张量与矩阵的区别">1.1.2 张量与矩阵的区别</h3>
<ul>
<li>从代数角度讲， 矩阵它是向量的推广。向量可以看成一维的“表格”（即分量按照顺序排成一排）， 矩阵是二维的“表格”（分量按照纵横位置排列）， 那么 $n$ 阶张量就是所谓的 $n$ 维的“表格”。 张量的严格定义是利用线性映射来描述。</li>
<li>从几何角度讲， 矩阵是一个真正的几何量，也就是说，它是一个不随参照系的坐标变换而变化的东西。向量也具有这种特性。</li>
<li>张量可以用3×3矩阵形式来表达。</li>
<li>表示标量的数和表示向量的三维数组也可分别看作1×1，1×3的矩阵。</li>
</ul>
<h3 id="1-1-3-矩阵和向量相乘结果">1.1.3 矩阵和向量相乘结果</h3>
<p>若使用爱因斯坦求和约定（Einstein summation convention），矩阵 $A$ ,  $B$ 相乘得到矩阵 $C$ 可以用下式表示：</p>
 $$ a_{ik}*b_{kj}=c_{ij} \tag{1.3-1} $$  
<p>其中， $a_{ik}$ ,  $b_{kj}$ ,  $c_{ij}$ 分别表示矩阵 $A, B, C$ 的元素， $k$ 出现两次，是一个哑变量（Dummy Variables）表示对该参数进行遍历求和。<br>
而矩阵和向量相乘可以看成是矩阵相乘的一个特殊情况，例如：矩阵 $B$ 是一个 $n \times 1$ 的矩阵。</p>
<h3 id="1-1-4-向量和矩阵的范数归纳">1.1.4 向量和矩阵的范数归纳</h3>
<p><strong>向量的范数(norm)</strong><br>
​	定义一个向量为： $\vec{a}=[-5, 6, 8, -10]$ 。任意一组向量设为 $\vec{x}=(x_1,x_2,...,x_N)$ 。其不同范数求解如下：</p>
<ul>
<li>向量的1范数：向量的各个元素的绝对值之和，上述向量 $\vec{a}$ 的1范数结果就是：29。</li>
</ul>
 $$
\Vert\vec{x}\Vert_1=\sum_{i=1}^N\vert{x_i}\vert
$$ 
<ul>
<li>向量的2范数：向量的每个元素的平方和再开平方根，上述 $\vec{a}$ 的2范数结果就是：15。</li>
</ul>
 $$
\Vert\vec{x}\Vert_2=\sqrt{\sum_{i=1}^N{\vert{x_i}\vert}^2}
$$ 
<ul>
<li>向量的负无穷范数：向量的所有元素的绝对值中最小的：上述向量 $\vec{a}$ 的负无穷范数结果就是：5。</li>
</ul>
 $$
\Vert\vec{x}\Vert_{-\infty}=\min{|{x_i}|}
$$ 
<ul>
<li>向量的正无穷范数：向量的所有元素的绝对值中最大的：上述向量 $\vec{a}$ 的正无穷范数结果就是：10。</li>
</ul>
 $$
\Vert\vec{x}\Vert_{+\infty}=\max{|{x_i}|}
$$ 
<ul>
<li>向量的p范数：</li>
</ul>
 $$
L_p=\Vert\vec{x}\Vert_p=\sqrt[p]{\sum_{i=1}^{N}|{x_i}|^p}
$$ 
<p><strong>矩阵的范数</strong></p>
<p>定义一个矩阵 $A=[-1, 2, -3; 4, -6, 6]$ 。 任意矩阵定义为： $A_{m\times n}$ ，其元素为  $a_{ij}$ 。</p>
<p>矩阵的范数定义为</p>
 $$
\Vert{A}\Vert_p :=\sup_{x\neq 0}\frac{\Vert{Ax}\Vert_p}{\Vert{x}\Vert_p}
$$ 
<p>当向量取不同范数时, 相应得到了不同的矩阵范数。</p>
<ul>
<li>
<p><strong>矩阵的1范数（列范数）</strong>：矩阵的每一列上的元</p>
<p>素绝对值先求和，再从中取个最大的,（列和最大），上述矩阵 $A$ 的1范数先得到 $[5,8,9]$ ，再取最大的最终结果就是：9。</p>
</li>
</ul>
 $$
\Vert A\Vert_1=\max_{1\le j\le n}\sum_{i=1}^m|{a_{ij}}|
$$ 
<ul>
<li><strong>矩阵的2范数</strong>：矩阵 $A^TA$ 的最大特征值开平方根，上述矩阵 $A$ 的2范数得到的最终结果是：10.0623。</li>
</ul>
 $$
\Vert A\Vert_2=\sqrt{\lambda_{max}(A^T A)}
$$ 
<p>其中，  $\lambda_{max}(A^T A)$  为  $A^T A​$  的特征值绝对值的最大值。</p>
<ul>
<li><strong>矩阵的无穷范数（行范数）</strong>：矩阵的每一行上的元素绝对值先求和，再从中取个最大的，（行和最大），上述矩阵 $A$ 的行范数先得到 $[6；16]$ ，再取最大的最终结果就是：16。</li>
</ul>
 $$
\Vert A\Vert_{\infty}=\max_{1\le i \le m}\sum_{j=1}^n |{a_{ij}}|
$$ 
<ul>
<li>
<p><strong>矩阵的核范数</strong>：矩阵的奇异值（将矩阵svd分解）之和，这个范数可以用来低秩表示（因为最小化核范数，相当于最小化矩阵的秩——低秩），上述矩阵A最终结果就是：10.9287。</p>
</li>
<li>
<p><strong>矩阵的L0范数</strong>：矩阵的非0元素的个数，通常用它来表示稀疏，L0范数越小0元素越多，也就越稀疏，上述矩阵 $A$ 最终结果就是：6。</p>
</li>
<li>
<p><strong>矩阵的L1范数</strong>：矩阵中的每个元素绝对值之和，它是L0范数的最优凸近似，因此它也可以表示稀疏，上述矩阵 $A$ 最终结果就是：22。</p>
</li>
<li>
<p><strong>矩阵的F范数</strong>：矩阵的各个元素平方之和再开平方根，它通常也叫做矩阵的L2范数，它的优点在于它是一个凸函数，可以求导求解，易于计算，上述矩阵A最终结果就是：10.0995。</p>
</li>
</ul>
 $$
\Vert A\Vert_F=\sqrt{(\sum_{i=1}^m\sum_{j=1}^n{| a_{ij}|}^2)}
$$ 
<ul>
<li><strong>矩阵的L21范数</strong>：矩阵先以每一列为单位，求每一列的F范数（也可认为是向量的2范数），然后再将得到的结果求L1范数（也可认为是向量的1范数），很容易看出它是介于L1和L2之间的一种范数，上述矩阵 $A$ 最终结果就是：17.1559。</li>
<li><strong>矩阵的 p范数</strong></li>
</ul>
 $$
\Vert A\Vert_p=\sqrt[p]{(\sum_{i=1}^m\sum_{j=1}^n{| a_{ij}|}^p)}
$$ 
<h3 id="1-1-5-如何判断一个矩阵为正定">1.1.5 如何判断一个矩阵为正定</h3>
<p>判定一个矩阵是否为正定，通常有以下几个方面：</p>
<ul>
<li>顺序主子式全大于0；</li>
<li>存在可逆矩阵 $C$ 使 $C^TC$ 等于该矩阵；</li>
<li>正惯性指数等于 $n$ ；</li>
<li>合同于单位矩阵 $E$ （即：规范形为 $E$ ）</li>
<li>标准形中主对角元素全为正；</li>
<li>特征值全为正；</li>
<li>是某基的度量矩阵。</li>
</ul>
<h2 id="1-2-导数和偏导数">1.2 导数和偏导数</h2>
<h3 id="1-2-1-导数偏导计算">1.2.1 导数偏导计算</h3>
<p><strong>导数定义</strong>:</p>
<p>导数(derivative)代表了在自变量变化趋于无穷小的时候，函数值的变化与自变量的变化的比值。几何意义是这个点的切线。物理意义是该时刻的（瞬时）变化率。<br>
​</p>
<p><em>注意</em>：在一元函数中，只有一个自变量变动，也就是说只存在一个方向的变化率，这也就是为什么一元函数没有偏导数的原因。在物理学中有平均速度和瞬时速度之说。平均速度有</p>
 $$
v=\frac{s}{t}
$$ 
<p>其中 $v$ 表示平均速度， $s$ 表示路程， $t$ 表示时间。这个公式可以改写为</p>
 $$
\bar{v}=\frac{\Delta s}{\Delta t}=\frac{s(t_0+\Delta t)-s(t_0)}{\Delta t}
$$ 
<p>其中 $\Delta s$ 表示两点之间的距离，而 $\Delta t$ 表示走过这段距离需要花费的时间。当 $\Delta t$ 趋向于0（ $\Delta t \to 0$ ）时，也就是时间变得很短时，平均速度也就变成了在 $t_0$ 时刻的瞬时速度，表示成如下形式：</p>
 $$
v(t_0)=\lim_{\Delta t \to 0}{\bar{v}}=\lim_{\Delta t \to 0}{\frac{\Delta s}{\Delta t}}=\lim_{\Delta t \to 0}{\frac{s(t_0+\Delta t)-s(t_0)}{\Delta t}}
$$ 
<p>实际上，上式表示的是路程 $s$ 关于时间 $t$ 的函数在 $t=t_0$ 处的导数。一般的，这样定义导数：如果平均变化率的极限存在，即有</p>
 $$
\lim_{\Delta x \to 0}{\frac{\Delta y}{\Delta x}}=\lim_{\Delta x \to 0}{\frac{f(x_0+\Delta x)-f(x_0)}{\Delta x}}
$$ 
<p>则称此极限为函数  $y=f(x)$  在点  $x_0$  处的导数。记作  $f'(x_0)$  或  $y'\vert_{x=x_0}$  或  $\frac{dy}{dx}\vert_{x=x_0}$  或  $\frac{df(x)}{dx}\vert_{x=x_0}$ 。</p>
<p>通俗地说，导数就是曲线在某一点切线的斜率。</p>
<p><strong>偏导数</strong>:</p>
<p>既然谈到偏导数(partial derivative)，那就至少涉及到两个自变量。以两个自变量为例， $z=f(x,y)​$ ，从导数到偏导数，也就是从曲线来到了曲面。曲线上的一点，其切线只有一条。但是曲面上的一点，切线有无数条。而偏导数就是指多元函数沿着坐标轴的变化率。</p>
<p><em>注意</em>：直观地说，偏导数也就是函数在某一点上沿坐标轴正方向的的变化率。</p>
<p>设函数 $z=f(x,y)​$ 在点 $(x_0,y_0)​$ 的领域内有定义，当 $y=y_0​$ 时， $z​$ 可以看作关于 $x​$ 的一元函数 $f(x,y_0)​$ ，若该一元函数在 $x=x_0​$ 处可导，即有</p>
 $$
\lim_{\Delta x \to 0}{\frac{f(x_0+\Delta x,y_0)-f(x_0,y_0)}{\Delta x}}=A
$$ 
<p>函数的极限 $A$ 存在。那么称 $A$ 为函数 $z=f(x,y)$ 在点 $(x_0,y_0)$ 处关于自变量 $x$ 的偏导数，记作 $f_x(x_0,y_0)$ 或 $\frac{\partial z}{\partial x}\vert_{y=y_0}^{x=x_0}$ 或 $\frac{\partial f}{\partial x}\vert_{y=y_0}^{x=x_0}$ 或 $z_x\vert_{y=y_0}^{x=x_0}$ 。</p>
<p>偏导数在求解时可以将另外一个变量看做常数，利用普通的求导方式求解，比如 $z=3x^2+xy$ 关于 $x$ 的偏导数就为 $z_x=6x+y$ ，这个时候 $y$ 相当于 $x$ 的系数。</p>
<p>某点 $(x_0,y_0)$ 处的偏导数的几何意义为曲面 $z=f(x,y)$ 与面 $x=x_0$ 或面 $y=y_0$ 交线在 $y=y_0$ 或 $x=x_0$ 处切线的斜率。</p>
<h3 id="1-2-2-导数和偏导数有什么区别？">1.2.2 导数和偏导数有什么区别？</h3>
<p>导数和偏导没有本质区别，如果极限存在，都是当自变量的变化量趋于0时，函数值的变化量与自变量变化量比值的极限。</p>
<blockquote>
<ul>
<li>一元函数，一个 $y$ 对应一个 $x$ ，导数只有一个。</li>
<li>二元函数，一个 $z$ 对应一个 $x$ 和一个 $y$ ，有两个导数：一个是 $z$ 对 $x$ 的导数，一个是 $z$ 对 $y$ 的导数，称之为偏导。</li>
<li>求偏导时要注意，对一个变量求导，则视另一个变量为常数，只对改变量求导，从而将偏导的求解转化成了一元函数的求导。</li>
</ul>
</blockquote>
<h2 id="1-3-特征值和特征向量">1.3 特征值和特征向量</h2>
<h3 id="1-3-1-特征值分解与特征向量">1.3.1 特征值分解与特征向量</h3>
<ul>
<li>
<p>特征值分解可以得到特征值(eigenvalues)与特征向量(eigenvectors)；</p>
</li>
<li>
<p>特征值表示的是这个特征到底有多重要，而特征向量表示这个特征是什么。</p>
<p>如果说一个向量 $\vec{v}$ 是方阵 $A$ 的特征向量，将一定可以表示成下面的形式：</p>
</li>
</ul>
 $$
A\nu = \lambda \nu
$$ 
 $\lambda$ 为特征向量 $\vec{v}$ 对应的特征值。特征值分解是将一个矩阵分解为如下形式： 
 $$
A=Q\sum Q^{-1}
$$ 
<p>其中， $Q$ 是这个矩阵 $A$ 的特征向量组成的矩阵， $\sum$ 是一个对角矩阵，每一个对角线元素就是一个特征值，里面的特征值是由大到小排列的，这些特征值所对应的特征向量就是描述这个矩阵变化方向（从主要的变化到次要的变化排列）。也就是说矩阵 $A$ 的信息可以由其特征值和特征向量表示。</p>
<h3 id="1-3-2-奇异值与特征值有什么关系">1.3.2 奇异值与特征值有什么关系</h3>
<p>那么奇异值和特征值是怎么对应起来的呢？我们将一个矩阵 $A$ 的转置乘以 $A$ ，并对 $A^TA​$ 求特征值，则有下面的形式：</p>
 $$
(A^TA)V = \lambda V
$$ 
<p>这里 $V​$ 就是上面的右奇异向量，另外还有：</p>
 $$
\sigma_i = \sqrt{\lambda_i}, u_i=\frac{1}{\sigma_i}AV
$$ 
<p>这里的 $\sigma​$ 就是奇异值， $u​$ 就是上面说的左奇异向量。【证明那个哥们也没给】<br>
​奇异值 $\sigma​$ 跟特征值类似，在矩阵 $\sum​$ 中也是从大到小排列，而且 $\sigma​$ 的减少特别的快，在很多情况下，前10%甚至1%的奇异值的和就占了全部的奇异值之和的99%以上了。也就是说，我们也可以用前 $r​$ （ $r​$ 远小于 $m、n​$ ）个的奇异值来近似描述矩阵，即部分奇异值分解：</p>
 $$
A_{m\times n}\approx U_{m \times r}\sum_{r\times r}V_{r \times n}^T
$$ 
<p>右边的三个矩阵相乘的结果将会是一个接近于 $A$ 的矩阵，在这儿， $r$ 越接近于 $n$ ，则相乘的结果越接近于 $A$ 。</p>
<h2 id="1-4-概率分布与随机变量">1.4 概率分布与随机变量</h2>
<h3 id="1-4-1-机器学习为什么要使用概率">1.4.1 机器学习为什么要使用概率</h3>
<p>事件的概率是衡量该事件发生的可能性的量度。虽然在一次随机试验中某个事件的发生是带有偶然性的，但那些可在相同条件下大量重复的随机试验却往往呈现出明显的数量规律。<br>
​机器学习除了处理不确定量，也需处理随机量。不确定性和随机性可能来自多个方面，使用概率论来量化不确定性。<br>
​概率论在机器学习中扮演着一个核心角色，因为机器学习算法的设计通常依赖于对数据的概率假设。</p>
<blockquote>
<p>​	例如在机器学习（Andrew Ng）的课中，会有一个朴素贝叶斯假设就是条件独立的一个例子。该学习算法对内容做出假设，用来分辨电子邮件是否为垃圾邮件。假设无论邮件是否为垃圾邮件，单词x出现在邮件中的概率条件独立于单词y。很明显这个假设不是不失一般性的，因为某些单词几乎总是同时出现。然而，最终结果是，这个简单的假设对结果的影响并不大，且无论如何都可以让我们快速判别垃圾邮件。</p>
</blockquote>
<h3 id="1-4-2-变量与随机变量有什么区别">1.4.2 变量与随机变量有什么区别</h3>
<p><strong>随机变量</strong>（random variable）</p>
<p>表示随机现象（在一定条件下，并不总是出现相同结果的现象称为随机现象）中各种结果的实值函数（一切可能的样本点）。例如某一时间内公共汽车站等车乘客人数，电话交换台在一定时间内收到的呼叫次数等，都是随机变量的实例。<br>
​随机变量与模糊变量的不确定性的本质差别在于，后者的测定结果仍具有不确定性，即模糊性。</p>
<p><strong>变量与随机变量的区别：</strong><br>
​当变量的取值的概率不是1时,变量就变成了随机变量；当随机变量取值的概率为1时,随机变量就变成了变量。</p>
<blockquote>
<p>比如：<br>
​	当变量 $x$ 值为100的概率为1的话,那么 $x=100$ 就是确定了的,不会再有变化,除非有进一步运算.<br>
​	当变量 $x$ 的值为100的概率不为1,比如为50的概率是0.5,为100的概率是0.5,那么这个变量就是会随不同条件而变化的,是随机变量,取到50或者100的概率都是0.5,即50%。</p>
</blockquote>
<h3 id="1-4-3-随机变量与概率分布的联系">1.4.3 随机变量与概率分布的联系</h3>
<p>一个随机变量仅仅表示一个可能取得的状态，还必须给定与之相伴的概率分布来制定每个状态的可能性。用来描述随机变量或一簇随机变量的每一个可能的状态的可能性大小的方法，就是 <strong>概率分布(probability distribution)</strong>.</p>
<p>随机变量可以分为离散型随机变量和连续型随机变量。</p>
<p>相应的描述其概率分布的函数是</p>
<p>概率质量函数(Probability Mass Function, PMF):描述离散型随机变量的概率分布，通常用大写字母  $P$ 表示。</p>
<p>概率密度函数(Probability Density Function, PDF):描述连续型随机变量的概率分布，通常用小写字母 $p$ 表示。</p>
<h3 id="1-4-4-离散型随机变量和概率质量函数">1.4.4 离散型随机变量和概率质量函数</h3>
<p>PMF 将随机变量能够取得的每个状态映射到随机变量取得该状态的概率。</p>
<ul>
<li>一般而言， $P(x)​$  表示时 $X=x​$ 的概率.</li>
<li>有时候为了防止混淆，要明确写出随机变量的名称 $P(​$ x $=x)​$</li>
<li>有时候需要先定义一个随机变量，然后制定它遵循的概率分布x服从 $P(​$ x​ $)​$</li>
</ul>
<p>PMF 可以同时作用于多个随机变量，即联合概率分布(joint probability distribution)  $P(X=x,Y=y)$ *表示  $X=x$ 和 $Y=y$ 同时发生的概率，也可以简写成  $P(x,y)$ .</p>
<p>如果一个函数 $P​$ 是随机变量  $X​$  的 PMF， 那么它必须满足如下三个条件</p>
<ul>
<li>
$P​$ 的定义域必须是的所有可能状态的集合
</li>
<li>
$∀x∈​$ x,  $0 \leq P(x) \leq 1 ​$ . 
</li>
<li>
$∑_{x∈X} P(x)=1$ . 我们把这一条性质称之为 归一化的(normalized)
</li>
</ul>
<h3 id="1-4-5-连续型随机变量和概率密度函数">1.4.5 连续型随机变量和概率密度函数</h3>
<p>如果一个函数 $p​$ 是x的PDF，那么它必须满足如下几个条件</p>
<ul>
<li>
$p$ 的定义域必须是x的所有可能状态的集合。
</li>
<li>
$∀x∈X,p(x)≥0$ . 注意，我们并不要求 $ p(x)≤1$ ，因为此处  $p(x)$ 不是表示的对应此状态具体的概率，而是概率的一个相对大小(密度)。具体的概率，需要积分去求。
</li>
<li>
$∫p(x)dx=1$ , 积分下来，总和还是1，概率之和还是1.
</li>
</ul>
<p>注：PDF $p(x)$ 并没有直接对特定的状态给出概率，给出的是密度，相对的，它给出了落在面积为  $δx$ 的无线小的区域内的概率为 $ p(x)δx$ . 由此，我们无法求得具体某个状态的概率，我们可以求得的是 某个状态  $x$  落在 某个区间 $[a,b]$ 内的概率为 $ \int_{a}^{b}p(x)dx$ .</p>
<h3 id="1-4-6-举例理解条件概率">1.4.6 举例理解条件概率</h3>
<p>条件概率公式如下：</p>
 $$
P(A|B) = P(A\cap B) / P(B)
$$ 
<p>说明：在同一个样本空间 $\Omega$ 中的事件或者子集 $A$ 与 $B$ ，如果随机从 $\Omega$ 中选出的一个元素属于 $B$ ，那么下一个随机选择的元素属于 $A$  的概率就定义为在 $B$ 的前提下 $A$ 的条件概率。条件概率文氏图示意如图1.1所示。<br>
<img src="conditional_probability.jpg" alt="条件概率"></p>
<p>图1.1 条件概率文氏图示意</p>
<p>根据文氏图，可以很清楚地看到在事件B发生的情况下，事件A发生的概率就是 $P(A\bigcap B)$ 除以 $P(B)$ 。<br>
​举例：一对夫妻有两个小孩，已知其中一个是女孩，则另一个是女孩子的概率是多少？（面试、笔试都碰到过）<br>
​<strong>穷举法</strong>：已知其中一个是女孩，那么样本空间为男女，女女，女男，则另外一个仍然是女生的概率就是1/3。<br>
​<strong>条件概率法</strong>： $P(女|女)=P(女女)/P(女)$ ,夫妻有两个小孩，那么它的样本空间为女女，男女，女男，男男，则 $P(女女)$ 为1/4， $P（女）= 1-P(男男)=3/4$ ,所以最后 $1/3$ 。<br>
这里大家可能会误解，男女和女男是同一种情况，但实际上类似姐弟和兄妹是不同情况。</p>
<h3 id="1-4-7-联合概率与边缘概率联系区别">1.4.7 联合概率与边缘概率联系区别</h3>
<p><strong>区别：</strong><br>
​联合概率：联合概率指类似于 $P(X=a,Y=b)$ 这样，包含多个条件，且所有条件同时成立的概率。联合概率是指在多元的概率分布中多个随机变量分别满足各自条件的概率。<br>
​边缘概率：边缘概率是某个事件发生的概率，而与其它事件无关。边缘概率指类似于 $P(X=a)$ ， $P(Y=b)$ 这样，仅与单个随机变量有关的概率。</p>
<p><strong>联系：</strong><br>
​联合分布可求边缘分布，但若只知道边缘分布，无法求得联合分布。</p>
<h3 id="1-4-8-条件概率的链式法则">1.4.8 条件概率的链式法则</h3>
<p>由条件概率的定义，可直接得出下面的乘法公式：<br>
​乘法公式 设 $A, B$ 是两个事件，并且 $P(A) > 0$ , 则有</p>
 $$
P(AB) = P(B|A)P(A)
$$ 
<p>推广</p>
 $$
P(ABC)=P(C|AB)P(B|A)P(A)
$$ 
<p>一般地，用归纳法可证：若 $P(A_1A_2...A_n)>0$ ，则有</p>
 $$
P(A_1A_2...A_n)=P(A_n|A_1A_2...A_{n-1})P(A_{n-1}|A_1A_2...A_{n-2})...P(A_2|A_1)P(A_1)
=P(A_1)\prod_{i=2}^{n}P(A_i|A_1A_2...A_{i-1})
$$ 
<p>任何多维随机变量联合概率分布，都可以分解成只有一个变量的条件概率相乘形式。</p>
<h3 id="1-4-9-独立性和条件独立性">1.4.9 独立性和条件独立性</h3>
<p><strong>独立性</strong><br>
​两个随机变量 $x$ 和 $y$ ，概率分布表示成两个因子乘积形式，一个因子只包含 $x$ ，另一个因子只包含 $y$ ，两个随机变量相互独立(independent)。<br>
​条件有时为不独立的事件之间带来独立，有时也会把本来独立的事件，因为此条件的存在，而失去独立性。<br>
​举例： $P(XY)=P(X)P(Y)$ , 事件 $X$ 和事件 $Y$ 独立。此时给定 $Z$ ，</p>
 $$
P(X,Y|Z) \not = P(X|Z)P(Y|Z)
$$ 
<p>事件独立时，联合概率等于概率的乘积。这是一个非常好的数学性质，然而不幸的是，无条件的独立是十分稀少的，因为大部分情况下，事件之间都是互相影响的。</p>
<p><strong>条件独立性</strong><br>
​给定 $Z$ 的情况下, $X$ 和 $Y$ 条件独立，当且仅当</p>
 $$
X\bot Y|Z \iff P(X,Y|Z) = P(X|Z)P(Y|Z)
$$ 
 $X$ 和 $Y$ 的关系依赖于 $Z$ ，而不是直接产生。  
<blockquote>
<p><strong>举例</strong>定义如下事件：</p>
 $X$ ：明天下雨；  
 $Y$ ：今天的地面是湿的；  
 $Z$ ：今天是否下雨；  
 $Z$ 事件的成立，对 $X$ 和 $Y$ 均有影响，然而，在 $Z$ 事件成立的前提下，今天的地面情况对明天是否下雨没有影响。 
</blockquote>
<h2 id="1-5-常见概率分布">1.5 常见概率分布</h2>
<h3 id="1-5-1-Bernoulli分布">1.5.1 Bernoulli分布</h3>
<p><strong>Bernoulli分布</strong>(伯努利分布，0-1分布)是单个二值随机变量分布, 单参数 $\phi$ ∈[0,1]控制, $\phi$ 给出随机变量等于1的概率. 主要性质有:</p>
 $$
\begin{align*}
P(x=1) &= \phi \\
P(x=0) &= 1-\phi  \\
概率质量函数：P(x=x) &= \phi^x(1-\phi)^{1-x} \\
\end{align*}
$$ 
<p>其期望和方差为：</p>
 $$
\begin{align*}
E_x[x] &= \phi \\
Var_x(x) &= \phi{(1-\phi)}
\end{align*}
$$ 
<p><strong>适用范围</strong>: <strong>伯努利分布</strong>适合对<strong>离散型</strong>随机变量建模.</p>
<p><strong>Multinoulli分布</strong>也叫<strong>范畴分布</strong>, 是单个<em>k</em>值随机分布,经常用来表示<strong>对象分类的分布</strong>. 其中 $k$ 是有限值.Multinoulli分布由向量 $\vec{p}\in[0,1]^{k-1}$ 参数化,每个分量 $p_i$ 表示第 $i$ 个状态的概率, 且 $p_k=1-1^Tp$ .这里 $1^T$ 表示元素全为1的列向量的转置，其实就是对于向量p中除了k的概率之和。可以重写为 $p_k=1-\sum_{0}^{k-1}p_i$  。</p>
<p>补充二项分布、多项分布：</p>
<p>二项分布，通俗点硬币抛多次。二项分布(Binomial distribution)是<strong>n重伯努利试验</strong>成功次数的离散概率分布。</p>
<p>多项式分布(Multinomial Distribution)是二项式分布的推广。二项式做n次伯努利实验，规定了每次试验的结果只有两个，如果现在还是做n次试验，只不过每次试验的结果可以有多m个，且m个结果发生的概率互斥且和为1，则发生其中一个结果X次的概率就是多项式分布。</p>
<h3 id="1-5-2-高斯分布">1.5.2 高斯分布</h3>
<p>高斯也叫正态分布(Normal Distribution), 概率度函数如下:</p>
 $$
N(x;\mu,\sigma^2) = \sqrt{\frac{1}{2\pi\sigma^2}}exp\left ( -\frac{1}{2\sigma^2}(x-\mu)^2 \right )
$$ 
<p>其中,  $\mu​$ 和 $\sigma​$ 分别是均值和标准差, 中心峰值x坐标由 $\mu​$ 给出, 峰的宽度受 $\sigma​$ 控制, 最大点在 $x=\mu​$ 处取得, 拐点为 $x=\mu\pm\sigma​$</p>
<p>正态分布中，±1 $\sigma$ 、±2 $\sigma$ 、±3 $\sigma$ 下的概率分别是68.3%、95.5%、99.73%，这3个数最好记住。</p>
<p>此外, 令 $\mu=0,\sigma=1​$ 高斯分布即简化为标准正态分布:</p>
 $$
N(x;\mu,\sigma^2) = \sqrt{\frac{1}{2\pi}}exp\left ( -\frac{1}{2}x^2 \right )
$$ 
<p>对概率密度函数高效求值:</p>
 $$
N(x;\mu,\beta^{-1})=\sqrt{\frac{\beta}{2\pi}}exp\left(-\frac{1}{2}\beta(x-\mu)^2\right)
$$ 
<p>其中， $\beta=\frac{1}{\sigma^2}$ 通过参数 $\beta∈（0，\infty）​$ 来控制分布精度。</p>
<h3 id="1-5-3-何时采用正态分布">1.5.3 何时采用正态分布</h3>
<p>问: 何时采用正态分布?<br>
答: 缺乏实数上分布的先验知识, 不知选择何种形式时, 默认选择正态分布总是不会错的, 理由如下:</p>
<ol>
<li>中心极限定理告诉我们, 很多独立随机变量均近似服从正态分布, 现实中很多复杂系统都可以被建模成正态分布的噪声, 即使该系统可以被结构化分解.</li>
<li>正态分布是具有相同方差的所有概率分布中, 不确定性最大的分布, 换句话说, 正态分布是对模型加入先验知识最少的分布.</li>
</ol>
<p>正态分布的推广:<br>
正态分布可以推广到 $R^n$ 空间, 此时称为<strong>多位正态分布</strong>, 其参数是一个正定对称矩阵 $\Sigma​$ :</p>
 $$
N(x;\vec\mu,\Sigma)=\sqrt{\frac{1}{(2\pi)^ndet(\Sigma)}}exp\left(-\frac{1}{2}(\vec{x}-\vec{\mu})^T\Sigma^{-1}(\vec{x}-\vec{\mu})\right)
$$ 
<p>对多为正态分布概率密度高效求值:</p>
 $$
N(x;\vec{\mu},\vec\beta^{-1}) = \sqrt{det(\vec\beta)}{(2\pi)^n}exp\left(-\frac{1}{2}(\vec{x}-\vec\mu)^T\beta(\vec{x}-\vec\mu)\right)
$$ 
<p>此处， $\vec\beta$ 是一个精度矩阵。</p>
<h3 id="1-5-4-指数分布">1.5.4 指数分布</h3>
<p>深度学习中, 指数分布用来描述在 $x=0​$ 点处取得边界点的分布, 指数分布定义如下:</p>
 $$
p(x;\lambda)=\lambda I_{x\geq 0}exp(-\lambda{x})
$$ 
<p>指数分布用指示函数 $I_{x\geq 0}​$ 来使 $x​$ 取负值时的概率为零。</p>
<h3 id="1-5-5-Laplace-分布（拉普拉斯分布）">1.5.5 Laplace 分布（拉普拉斯分布）</h3>
<p>一个联系紧密的概率分布是 Laplace 分布（Laplace distribution），它允许我们在任意一点  $\mu$ 处设置概率质量的峰值</p>
 $$
Laplace(x;\mu;\gamma)=\frac{1}{2\gamma}exp\left(-\frac{|x-\mu|}{\gamma}\right)
$$ 
<h3 id="1-5-6-Dirac分布和经验分布">1.5.6 Dirac分布和经验分布</h3>
<p>Dirac分布可保证概率分布中所有质量都集中在一个点上. Diract分布的狄拉克 $\delta​$ 函数(也称为<strong>单位脉冲函数</strong>)定义如下:</p>
 $$
p(x)=\delta(x-\mu), x\neq \mu
$$ 
 $$
\int_{a}^{b}\delta(x-\mu)dx = 1, a < \mu < b
$$ 
<p>Dirac 分布经常作为 经验分布（empirical distribution）的一个组成部分出现</p>
 $$
\hat{p}(\vec{x})=\frac{1}{m}\sum_{i=1}^{m}\delta(\vec{x}-{\vec{x}}^{(i)})
$$ 
<p>, 其中, m个点 $x^{1},...,x^{m}$ 是给定的数据集, <strong>经验分布</strong>将概率密度 $\frac{1}{m}​$ 赋给了这些点.</p>
<p>当我们在训练集上训练模型时, 可以认为从这个训练集上得到的经验分布指明了<strong>采样来源</strong>.</p>
<p><strong>适用范围</strong>: 狄拉克δ函数适合对<strong>连续型</strong>随机变量的经验分布.</p>
<blockquote></blockquote>
<h2 id="1-6-期望、方差、协方差、相关系数">1.6 期望、方差、协方差、相关系数</h2>
<h3 id="1-6-1-期望">1.6.1 期望</h3>
<p>在概率论和统计学中，数学期望（或均值，亦简称期望）是试验中每次可能结果的概率乘以其结果的总和。它反映随机变量平均取值的大小。</p>
<ul>
<li>线性运算：  $E(ax+by+c) = aE(x)+bE(y)+c$</li>
<li>推广形式：  $E(\sum_{k=1}^{n}{a_ix_i+c}) = \sum_{k=1}^{n}{a_iE(x_i)+c}$</li>
<li>函数期望：设 $f(x)$ 为 $x$ 的函数，则 $f(x)$ 的期望为
<ul>
<li>离散函数：  $E(f(x))=\sum_{k=1}^{n}{f(x_k)P(x_k)}$</li>
<li>连续函数：  $E(f(x))=\int_{-\infty}^{+\infty}{f(x)p(x)dx}$</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：</p>
<ul>
<li>函数的期望大于等于期望的函数（Jensen（詹森）不等式，即 $E(f(x))\geqslant f(E(x))$</li>
<li>一般情况下，乘积的期望不等于期望的乘积。</li>
<li>如果 $X$ 和 $Y$ 相互独立，则 $E(xy)=E(x)E(y)​$ 。</li>
</ul>
</blockquote>
<h3 id="1-6-2-方差">1.6.2 方差</h3>
<p>概率论中方差用来度量随机变量和其数学期望（即均值）之间的偏离程度。方差是一种特殊的期望。定义为：</p>
 $$
Var(x) = E((x-E(x))^2)
$$ 
<blockquote>
<p>方差性质：</p>
<p>1） $Var(x) = E(x^2) -E(x)^2$<br>
2）常数的方差为0;<br>
3）方差不满足线性性质;<br>
4）如果 $X$ 和 $Y$ 相互独立,  $Var(ax+by)=a^2Var(x)+b^2Var(y)$</p>
</blockquote>
<h3 id="1-6-3-协方差">1.6.3 协方差</h3>
<p>协方差是衡量两个变量线性相关性强度及变量尺度。  两个随机变量的协方差定义为：</p>
 $$
Cov(x,y)=E((x-E(x))(y-E(y)))
$$ 
<p>方差是一种特殊的协方差。当 $X=Y$ 时， $Cov(x,y)=Var(x)=Var(y)$ 。</p>
<blockquote>
<p>协方差性质：</p>
<p>1）独立变量的协方差为0。<br>
2）协方差计算公式：</p>
</blockquote>
 $$
Cov(\sum_{i=1}^{m}{a_ix_i}, \sum_{j=1}^{m}{b_jy_j}) = \sum_{i=1}^{m} \sum_{j=1}^{m}{a_ib_jCov(x_iy_i)}
$$ 
<blockquote>
<p>3）特殊情况：</p>
</blockquote>
 $$
Cov(a+bx, c+dy) = bdCov(x, y)
$$ 
<h3 id="1-6-4-相关系数">1.6.4 相关系数</h3>
<p>相关系数是研究变量之间线性相关程度的量。两个随机变量的相关系数定义为：</p>
 $$
Corr(x,y) = \frac{Cov(x,y)}{\sqrt{Var(x)Var(y)}}
$$ 
<blockquote>
<p>相关系数的性质：<br>
1）有界性。相关系数的取值范围是 [-1,1]，可以看成无量纲的协方差。<br>
2）值越接近1，说明两个变量正相关性（线性）越强。越接近-1，说明负相关性越强，当为0时，表示两个变量没有相关性。</p>
</blockquote>
<h2 id="参考文献">参考文献</h2>
<p>[1]Ian，Goodfellow，Yoshua，Bengio，Aaron…深度学习[M]，人民邮电出版，2017</p>
<p>[2]周志华.机器学习[M].清华大学出版社，2016.</p>
<p>[3]同济大学数学系.高等数学（第七版）[M]，高等教育出版社，2014.</p>
<p>[4]盛骤，试式千，潘承毅等编. 概率论与数理统计（第4版）[M]，高等教育出版社，2008</p>
]]></content>
      <categories>
        <category>算法面试</category>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>刷八股</tag>
      </tags>
  </entry>
  <entry>
    <title>强化学习面试题</title>
    <url>/2024/03/19/deep_learning/ch10/</url>
    <content><![CDATA[<h1>强化学习</h1>
<h2 id="10-1-强化学习的主要特点？">10.1 强化学习的主要特点？</h2>
<p>其他许多机器学习算法中学习器都是学得怎样做，而RL是在尝试的过程中学习到在特定的情境下选择哪种行动可以得到最大的回报。在很多场景中，当前的行动不仅会影响当前的rewards，还会影响之后的状态和一系列的rewards。RL最重要的3个特定在于：<br>
(1)	基本是以一种闭环的形式；<br>
(2)	不会直接指示选择哪种行动（actions）；<br>
(3)	一系列的actions和奖励信号（reward signals）都会影响之后较长的时间。</p>
<h3 id="10-1-1-定义">10.1.1 定义</h3>
<p>强化学习是机器学习的一个重要分支，是多学科多领域交叉的一个产物，它的本质是解决 decision making 问题，即自动进行决策，并且可以做连续决策。<br>
它主要包含四个元素，agent，环境状态，行动，奖励, 强化学习的目标就是获得最多的累计奖励。<br>
我们列举几个形象的例子：<br>
小孩想要走路，但在这之前，他需要先站起来，站起来之后还要保持平衡，接下来还要先迈出一条腿，是左腿还是右腿，迈出一步后还要迈出下一步。<br>
小孩就是 agent，他试图通过采取行动（即行走）来操纵环境（行走的表面），并且从一个状态转变到另一个状态（即他走的每一步），当他完成任务的子任务（即走了几步）时，孩子得到奖励（给巧克力吃），并且当他不能走路时，就不会给巧克力。</p>
<p><img src="10-1.png" alt></p>
<p>上图中agent代表自身，如果是自动驾驶，agent就是车；如果你玩游戏它就是你当前控制的游戏角色，如马里奥，马里奥往前走时环境就一直在发生变化，有小怪物或者障碍物出现，它需要通过跳跃来进行躲避，就是要做action（如向前走和跳起的动作）；无人驾驶的action就是车左转、右转或刹车等等，它无时无刻都在与环境产生交互，action会反馈给环境，进而改变环境，如果自动驾驶的车行驶目标是100米，它向前开了10米，那环境就发生了变化，所以每次产生action都会导致环境改变，环境的改变会反馈给自身（agent），就是这样的一个循环；反馈又两种方式：1、做的好（reward）即正反馈，2、做得不好（punishment惩罚）即负反馈。Agent可能做得好，也可能做的不好，环境始终都会给它反馈，agent会尽量去做对自身有利的决策，通过反反复复这样的一个循环，agent会越来越做的好，就像孩子在成长过程中会逐渐明辨是非，这就是强化学习。</p>
<h2 id="10-2-强化学习应用实例">10.2 强化学习应用实例</h2>
<p>（1）Manufacturing</p>
<p>例如一家日本公司 Fanuc，工厂机器人在拿起一个物体时，会捕捉这个过程的视频，记住它每次操作的行动，操作成功还是失败了，积累经验，下一次可以更快更准地采取行动。</p>
<p><img src="10-2.png" alt></p>
<p>（2）Inventory Management</p>
<p>在库存管理中，因为库存量大，库存需求波动较大，库存补货速度缓慢等阻碍使得管理是个比较难的问题，可以通过建立强化学习算法来减少库存周转时间，提高空间利用率。</p>
<p>（3）Dynamic pricing</p>
<p>强化学习中的 Q-learning 可以用来处理动态定价问题。</p>
<p>（4）Customer Delivery</p>
<p>制造商在向各个客户运输时，想要在满足客户的所有需求的同时降低车队总成本。通过 multi-agents 系统和 Q-learning，可以降低时间，减少车辆数量。</p>
<p>（5）ECommerce Personalization</p>
<p>在电商中，也可以用强化学习算法来学习和分析顾客行为，定制产品和服务以满足客户的个性化需求。</p>
<p>（6）Ad Serving</p>
<p>例如算法 LinUCB （属于强化学习算法 bandit 的一种算法），会尝试投放更广范围的广告，尽管过去还没有被浏览很多，能够更好地估计真实的点击率。<br>
再如双 11 推荐场景中，阿里巴巴使用了深度强化学习与自适应在线学习，通过持续机器学习和模型优化建立决策引擎，对海量用户行为以及百亿级商品特征进行实时分析，帮助每一个用户迅速发现宝贝，提高人和商品的配对效率。还有，利用强化学习将手机用户点击率提升了 10-20%。</p>
<p>（7）Financial Investment Decisions</p>
<p>例如这家公司 <a href="http://Pit.ai">Pit.ai</a>，应用强化学习来评价交易策略，可以帮助用户建立交易策略，并帮助他们实现其投资目标。</p>
<p>（8）Medical Industry</p>
<p>动态治疗方案（DTR）是医学研究的一个主题，是为了给患者找到有效的治疗方法。 例如癌症这种需要长期施药的治疗，强化学习算法可以将患者的各种临床指标作为输入 来制定治疗策略。</p>
<h2 id="10-3-强化学习和监督式学习、非监督式学习的区别">10.3 强化学习和监督式学习、非监督式学习的区别</h2>
<p>在机器学习中，我们比较熟知的是监督式学习，非监督学习，此外还有一个大类就是强化学习：<br>
当前的机器学习算法可以分为3种：有监督的学习（Supervised Learning）、无监督的学习（Unsupervised Learning）和强化学习（Reinforcement Learning），结构图如下所示：</p>
<p><img src="10-3.png" alt></p>
<h3 id="10-3-1-强化学习和监督式学习的区别：">10.3.1 强化学习和监督式学习的区别：</h3>
<p>监督式学习就好比你在学习的时候，有一个导师在旁边指点，他知道怎么是对的怎么是错的，但在很多实际问题中，例如 chess，go，这种有成千上万种组合方式的情况，不可能有一个导师知道所有可能的结果。</p>
<p>而这时，强化学习会在没有任何标签的情况下，通过先尝试做出一些行为得到一个结果，通过这个结果是对还是错的反馈，调整之前的行为，就这样不断的调整，算法能够学习到在什么样的情况下选择什么样的行为可以得到最好的结果。</p>
<p>就好比你有一只还没有训练好的小狗，每当它把屋子弄乱后，就减少美味食物的数量（惩罚），每次表现不错时，就加倍美味食物的数量（奖励），那么小狗最终会学到一个知识，就是把客厅弄乱是不好的行为。</p>
<p>两种学习方式都会学习出输入到输出的一个映射，监督式学习出的是之间的关系，可以告诉算法什么样的输入对应着什么样的输出，强化学习出的是给机器的反馈 reward function，即用来判断这个行为是好是坏。<br>
另外强化学习的结果反馈有延时，有时候可能需要走了很多步以后才知道以前的某一步的选择是好还是坏，而监督学习做了比较坏的选择会立刻反馈给算法。</p>
<p>而且强化学习面对的输入总是在变化，每当算法做出一个行为，它影响下一次决策的输入，而监督学习的输入是独立同分布的。</p>
<p>通过强化学习，一个 agent 可以在探索和开发（exploration and exploitation）之间做权衡，并且选择一个最大的回报。</p>
<p>exploration 会尝试很多不同的事情，看它们是否比以前尝试过的更好。</p>
<p>exploitation 会尝试过去经验中最有效的行为。</p>
<p>一般的监督学习算法不考虑这种平衡，就只是是 exploitative。</p>
<h3 id="10-3-2-强化学习和非监督式学习的区别：">10.3.2 强化学习和非监督式学习的区别：</h3>
<p>非监督式不是学习输入到输出的映射，而是模式。例如在向用户推荐新闻文章的任务中，非监督式会找到用户先前已经阅读过类似的文章并向他们推荐其一，而强化学习将通过向用户先推荐少量的新闻，并不断获得来自用户的反馈，最后构建用户可能会喜欢的文章的“知识图”。</p>
<p>对非监督学习来说，它通过对没有概念标记的训练例进行学习，以发现训练例中隐藏的结构性知识。这里的训练例的概念标记是不知道的，因此训练样本的歧义性最高。对强化学习来说，它通过对没有概念标记、但与一个延迟奖赏或效用（可视为延迟的概念标记）相关联的训练例进行学习，以获得某种从状态到行动的映射。这里本来没有概念标记的概<br>
念，但延迟奖赏可被视为一种延迟概念标记，因此其训练样本的歧义性介于监督学习和非监督学习之间。</p>
<p>需要注意的是，监督学习和非监督学习从一开始就是相对的，而强化学习在提出时并没有从训练样本歧义性的角度考虑其与监督学习和非监督学习的区别，因此，一些早期的研究中把强化学习视为一种特殊的非监督学习。事实上，对强化学习的定位到目前仍然是有争议的，有的学者甚至认为它是与“从例子中学习”同一级别的概念。</p>
<p>从训练样本歧义性角度进行的分类体系，在近几年可望有一些扩展，例如多示例学习（multi-instancelearning）等从训练样本歧义性方面来看很特殊的新的学习框架有可能会进入该体系。但到目前为止，没有任何新的框架得到了公认的地位。另外，半监督学习（semi-supervisedlearning）也有一定希望，它的障碍是半监督学习中的歧义性并不是与生俱来的，而是人为的，即用户期望用未标记的样本来辅助对已标记样本的学习。这与监督学习、非监督学习、强化学习等天生的歧义性完全不同。半监督学习中人为的歧义性在解决工程问题上是需要的、有用的（对大量样本进行标记的代价可能是极为昂贵的），但可能不太会导致方法学或对学习问题视点的大的改变。</p>
<p><strong>强化学习和前二者的本质区别</strong>:没有前两者具有的明确数据概念，它不知道结果，只有目标。数据概念就是大量的数据，有监督学习、无监督学习需要大量数据去训练优化你建立的模型，就像猫狗识别，用n多张猫狗图片去训练模型，经过训练优化后，你用一张崭新的猫狗图片让模型作出判断，这个模型就知道是猫还是狗。</p>
<h2 id="10-4-强化学习主要有哪些算法？">10.4 强化学习主要有哪些算法？</h2>
<p>强化学习不需要监督信号,可以在模型未知的环境中平衡探索和利用, 其主要算法有蒙特卡罗强化学习, 时间差分(temporal difference: TD)学习, 策略梯度等。典型的深度强化学习算法特点及性能比较如下图所示：</p>
<p><img src="10-4.png" alt></p>
<p>除了上述深度强化学习算法，还有深度迁移强化学习、分层深度强化学习、深度记忆强化学习以及多智能体强化学习等算法。</p>
<h2 id="10-5-深度迁移强化学习算法">10.5 深度迁移强化学习算法</h2>
<p>传统深度强化学习算法每次只能解决一种游戏任务, 无法在一次训练中完成多种任务. 迁移学习和强化学习的结合也是深度强化学习的一种主要思路。</p>
<p>Parisotto等提出了一种基于行为模拟的深度迁移强化学习算法. 该算法通过监督信号的指导, 使得单一的策略网络学习各自的策略, 并将知识迁移到新任务中. Rusa等提出策略蒸馏(policy distillation)深度迁移强化学习算法. 策略蒸馏算法中分为学习网络和指导网络, 通过这两个网络Q值的偏差来确定目标函数,引导学习网络逼近指导网络的值函数空间. 此后,Rusa等又提出了一种基于渐进神经网络(progressive neural networks, PNN)的深度迁移强化学习算法.PNN是一种把神经网络和神经网络连起来的算法. 它在一系列序列任务中, 通过渐进的方式来存储知识和提取特征, 完成了对知识的迁移. PNN最终实现多个独立任务的训练, 通过迁移加速学习过程, 避免灾难性遗忘. Fernando 等提出了路径网络(PathNet)[45].PathNet可以说是PNN的进阶版. PathNet把网络中每一层都看作一个模块, 把构建一个网络看成搭积木,也就是复用积木. 它跟PNN非常类似, 只是这里不再有列, 而是不同的路径. PathNet将智能体嵌入到神经网络中, 其中智能体的任务是为新任务发现网络中可以复用的部分. 智能体是网络之中的路径, 其决定了反向传播过程中被使用和更新的参数范围. 在一系列的Atari强化学习任务上, PathNet都实现了正迁移, 这表明PathNet在训练神经网络上具有通用性应用能力.PathNet也可以显著提高A3C算法超参数选择的鲁棒性. Schaul等提出了一种通用值函数逼近器(universalvalue function approximators, UVFAs)来泛化状态和目标空间．UVFAs可以将学习到的知识迁移到环境动态特性相同但目标不同的新任务中.</p>
<h2 id="10-6-分层深度强化学习算法">10.6 分层深度强化学习算法</h2>
<p>分层强化学习可以将最终目标分解为多个子任务来学习层次化的策略, 并通过组合多个子任务的策略形成有效的全局策略. Kulkarni等提出了分层DQN(hierarchical deep Q-network, h–DQN) 算法. h–DQN基于时空抽象和内在激励分层, 通过在不同的时空尺度上设置子目标对值函数进行层次化处理. 顶层的值函数用于确定宏观决策, 底层的值函数用于确定具体行动．Krishnamurthy等在h–DQN的基础上提出了基于内部选择的分层深度强化学习算法. 该模型结合时空抽象和深度神经网络, 自动地完成子目标的学习, 避免了特定的内在激励和人工设定中间目标,加速了智能体的学习进程, 同时也增强了模型的泛化能力. Kulkarni等基于后续状态表示法提出了深度后续强化学习(deep successor reinforcement learning,DSRL)．DSRL通过阶段性地分解子目标和学习子目标策略, 增强了对未知状态空间的探索, 使得智能体更加适应那些存在延迟反馈的任务．Vezhnevets等受封建(feudal)强化学习算法的启发, 提出一种分层深度强化学习的架构FeUdal网络(FuNs)[49]. FuNs框架使用一个管理员模块和一个工人模块. 管理员模块在较低的时间分辨率下工作, 设置抽象目标并传递给工人模块去执行. FuNs框架创造了一个稳定的自然层次结构, 并且允许两个模块以互补的方式学习. 实验证明, FuNs有助于处理长期信用分配和记忆任务,在Atari视频游戏和迷宫游戏中都取得了不错的效果。</p>
<h2 id="10-7-深度记忆强化学习算法">10.7 深度记忆强化学习算法</h2>
<p>传统的深度强化学习模型不具备记忆、认知、推理等高层次的能力, 尤其是在面对状态部分可观察和延迟奖赏的情形时. Junhyuk等通过在传统的深度强化学习模型中加入外部的记忆网络部件和反馈控制机制, 提出反馈递归记忆Q网络(feedback recurrent memory Q-network, FRMQN)). FRMQN模型具备了一定的记忆与推理功能, 通过反馈控制机制,FRMQN整合过去存储的有价值的记忆和当前时刻的上下文状态, 评估动作值函数并做出决策. FRMQN初步模拟了人类的主动认知与推理能力, 并完成了一些高层次的认知任务. 在一些未经过训练的任务中,FRMQN模型表现出了很强的泛化能力．Blundell等设计出一种模型无关的情节控制算法(model-free episode control, MFEC). MFEC可以快速存储和回放状态转移序列, 并将回放的序列整合到结构化知识系统中, 使得智能体在面对一些复杂的决策任务时, 能快速达到人类玩家的水平．MFEC通过反向经验回放, 使智能体拥有初步的情节记忆. 实验表明, 基于MFEC算法的深度强化学习不仅可以在Atari游戏中学习到有效策略, 还可以处理一些三维场景的复杂任务. Pritzel等在MFEC的基础上进一步提出了神经情节控制(neural episodic control, NEC),有效提高了深度强化学习智能体的记忆能力和学习效率[53]. NEC能快速吸收新经验并依据新经验来采取行动. 价值函数包括价值函数渐变状态表示和价值函数快速更新估计两部分. 大量场景下的研究表明,NEC的学习速度明显快于目前最先进的通用深度强化学习智能体.</p>
<h2 id="10-8-多智能体深度强化学习算法">10.8 多智能体深度强化学习算法</h2>
<p>在一些复杂场景中, 涉及到多智能体的感知决策问题, 这时需要将单一模型扩展为多个智能体之间相互合作、通信及竞争的多智能体深度强化学习系统.Foerster等提出了一种称为分布式深度递归Q网络(deep distributed recurrent Q-networks, DDRQN) 的模型, 解决了状态部分可观测状态下的多智能体通信与合作的挑战性难题[54]. 实验表明, 经过训练的DDRQN模型最终在多智能体之间达成了一致的通信协1536 控制理论与应用第34 卷议, 成功解决了经典的红蓝帽子问题.让智能体学会合作与竞争一直以来都是人工智能领域内的一项重要研究课题, 也是实现通用人工智能的必要条件. Lowe等提出了一种用于合作–竞争混合环境的多智能体actor-critic 算法(multi-agent deepdeterministic policy gradient, MADDPG)[55]. MADDPG对DDPG强化学习算法进行了延伸, 可实现多智能体的集中式学习和分布式执行, 让智能体学习彼此合作和竞争. 在多项测试任务中, MADDPG的表现都优于DDPG.</p>
<h2 id="10-9-强化学习开源框架">10.9 强化学习开源框架</h2>
<p>谷歌TensorFlow Agents —TensorFlow的加强版,它提供许多工具，通过强化学习可以实现各类智能应用程序的构建与训练。这个框架能够将OpoenAI Gym接口扩展至多个并行环境，并允许各代理立足TensorFlow之内实现以执行批量计算。其面向OpoenAI Gy环境的批量化接口可与TensorFlow实现全面集成，从而高效执行各类算法。该框架还结合有BatchPPO，一套经过优化的近端策略优化算法实现方案。其核心组件包括一个环境打包器，用于在外部过程中构建OpenAI Gym环境; 一套批量集成，用于实现TensorFlow图步并以强化学习运算的方式重置函数; 外加用于将TensorFlow图形批处理流程与强化学习算法纳入训练特内单一却步的组件。</p>
<p>Roboschool：Roboschool 提供开源软件以通过强化学习构建并训练机器人模拟。其有助于在同一环境当中对多个代理进行强化学习训练。通过多方训练机制，您可以训练同一代理分别作为两方玩家（因此能够自我对抗）、使用相同算法训练两套代理，或者设置两种算法进行彼此对抗。Roboschool由OpenAI开发完成，这一非营利性组织的背后赞助者包括Elon Musk、Sam Altman、Reid Hoffman以及Peter Thiel。其与OpenAI Gym相集成，后者是一套用于开发及评估强化学习算法的开源工具集。OpenAI Gym与TensorFlow、Theano以及其它多种深度学习库相兼容。OpenAI Gym当中包含用于数值计算、游戏以及物理引擎的相关代码。Roboschool基于Bullet物理引擎，这是一套开源许可物理库，并被其它多种仿真软件——例如Gazebo与Virtual Robot Experimentation Platform（简称V-REP）所广泛使用。其中包含多种强化学习算法，具体以怨报德 异步深度强化学习方法、Actor-Critic with Experience Replay、Actor- Critic using Kronecker-Factored Trust Region、深度确定性策略梯度、近端策略优化以及信任域策略优化等等。</p>
<p>Coach：英特尔公司的开源强化学习框架，可以对游戏、机器人以及其它基于代理的智能应用进行智能代理的建模、训练与评估。Coach 提供一套模块化沙箱、可复用组件以及用于组合新强化学习算法并在多种应用领域内训练新智能应用的Python API。该框架利用OpenAI Gym作为主工具，负责与不同强化学习环境进行交换。其还支持其它外部扩展，具体包括Roboschool、gym-extensions、PyBullet以及ViZDoom。Coach的环境打包器允许用户向其中添加自定义强化学习环境，从而解决其它学习问题。该框架能够在桌面计算机上高效训练强化学习代理，并利用多核CPU处理相关任务。其能够为一部分强化学习算法提供单线程与多线程实现能力，包括异步优势Actor-Critic、深度确定性策略梯度、近端策略优化、直接未来预测以及规范化优势函数。所有算法皆利用面向英特尔系统作出优化的TensorFLow完成，其中部分算法亦适用于英特尔的Neon深度学习框架。Coach 当中包含多种强化学习代理实现方案，具体包括从单线程实现到多线程实现的转换。其能够开发出支持单与多工作程序（同步或异步）强化学习实现方法的新代理。此外，其还支持连续与离散操作空间，以及视觉观察空间或仅包含原始测量指标的观察空间。</p>
<h2 id="10-10-深度强化学习算法小结">10.10 深度强化学习算法小结</h2>
<p>基于值函数概念的DQN及其相应的扩展算法在离散状态、离散动作的控制任务中已经表现了卓越的性能, 但是受限于值函数离散型输出的影响, 在连续型控制任务上显得捉襟见肘. 基于策略梯度概念的,以DDPG, TRPO等为代表的策略型深度强化学习算法则更适用于处理基于连续状态空间的连续动作的控制输出任务, 并且算法在稳定性和可靠性上具有一定的理论保证, 理论完备性较强. 采用actor-critic架构的A3C算法及其扩展算法, 相比于传统DQN算法, 这类算法的数据利用效率更高, 学习速率更快, 通用性、可扩展应用性更强, 达到的表现性能更优, 但算法的稳定性无法得到保证. 而其他的如深度迁移强化学习、分层深度强化学习、深度记忆强化学习和多智能体深度强化学习等算法都是现在的研究热点, 通过这些算法能应对更为复杂的场景问题、系统环境及控制任务, 是目前深度强化学习算法研究的前沿领域.</p>
<p>展望未来，人工智能开发者们需要尽可能掌握上述框架以及其中所使用的各类强化学习算法。此外，还需要强化自身对于多代理强化学习架构的理解，因为其中多种框架都大量利用前沿博弈论研究成果。最后，还需要熟悉深度强化学习知识。</p>
]]></content>
      <categories>
        <category>算法面试</category>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>刷八股</tag>
      </tags>
  </entry>
  <entry>
    <title>迁移学习面试题</title>
    <url>/2024/03/19/deep_learning/ch11/</url>
    <content><![CDATA[<h1>迁移学习</h1>
<p>​	本章主要简明地介绍了迁移学习的基本概念、迁移学习的必要性、研究领域和基本方法。重点介绍了几大类常用的迁移学习方法：数据分布自适应方法、特征选择方法、子空间学习方法、以及目前最热门的深度迁移学习方法。除此之外，我们也结合最近的一些研究成果对未来迁移学习进行了一些展望。并提供了一些迁移学习领域的常用学习资源，以方便感兴趣的读者快速开始学习。</p>
<h2 id="11-1-迁移学习基础知识">11.1 迁移学习基础知识</h2>
<h3 id="11-1-1-什么是迁移学习？">11.1.1 什么是迁移学习？</h3>
<p>找到目标问题的相似性，迁移学习任务就是从相似性出发，将旧领域(domain)学习过的模型应用在新领域上。</p>
<h3 id="11-1-2-为什么需要迁移学习？">11.1.2 为什么需要迁移学习？</h3>
<ol>
<li><strong>大数据与少标注的矛盾</strong>：虽然有大量的数据，但往往都是没有标注的，无法训练机器学习模型。人工进行数据标定太耗时。</li>
<li><strong>大数据与弱计算的矛盾</strong>：普通人无法拥有庞大的数据量与计算资源。因此需要借助于模型的迁移。</li>
<li><strong>普适化模型与个性化需求的矛盾</strong>：即使是在同一个任务上，一个模型也往往难以满足每个人的个性化需求，比如特定的隐私设置。这就需要在不同人之间做模型的适配。</li>
<li><strong>特定应用（如冷启动）的需求</strong>。</li>
</ol>
<h3 id="11-1-3-迁移学习的基本问题有哪些？">11.1.3 迁移学习的基本问题有哪些？</h3>
<p>基本问题主要有3个：</p>
<ul>
<li><strong>How to transfer</strong>： 如何进行迁移学习？（设计迁移方法）</li>
<li><strong>What to transfer</strong>： 给定一个目标领域，如何找到相对应的源领域，然后进行迁移？（源领域选择）</li>
<li><strong>When to transfer</strong>： 什么时候可以进行迁移，什么时候不可以？（避免负迁移）</li>
</ul>
<h3 id="11-1-4-迁移学习有哪些常用概念？">11.1.4 迁移学习有哪些常用概念？</h3>
<ul>
<li>基本定义
<ul>
<li><strong>域(Domain)</strong>：数据特征和特征分布组成，是学习的主体
<ul>
<li><strong>源域 (Source domain)</strong>：已有知识的域</li>
<li><strong>目标域 (Target domain)</strong>：要进行学习的域</li>
</ul>
</li>
<li><strong>任务 (Task)</strong>：由目标函数和学习结果组成，是学习的结果</li>
</ul>
</li>
<li>按特征空间分类
<ul>
<li><strong>同构迁移学习（Homogeneous TL）</strong>： 源域和目标域的特征空间相同， $D_s=D_t$</li>
<li><strong>异构迁移学习（Heterogeneous TL）</strong>：源域和目标域的特征空间不同， $D_s\ne D_t$</li>
</ul>
</li>
<li>按迁移情景分类
<ul>
<li><strong>归纳式迁移学习（Inductive TL）</strong>：源域和目标域的学习任务不同</li>
<li><strong>直推式迁移学习（Transductive TL)</strong>：源域和目标域不同，学习任务相同</li>
<li><strong>无监督迁移学习（Unsupervised TL)</strong>：源域和目标域均没有标签</li>
</ul>
</li>
<li>按迁移方法分类
<ul>
<li><strong>基于实例的迁移 (Instance based TL)</strong>：通过权重重用源域和目标域的样例进行迁移</li>
<li><strong>基于特征的迁移 (Feature based TL)</strong>：将源域和目标域的特征变换到相同空间</li>
<li><strong>基于模型的迁移 (Parameter based TL)</strong>：利用源域和目标域的参数共享模型</li>
<li><strong>基于关系的迁移 (Relation based TL)</strong>：利用源域中的逻辑网络关系进行迁移</li>
</ul>
</li>
</ul>
<p><img src="1542972502781.png" alt="1542972502781"></p>
<p><img src="1542974131814.png" alt="1542974131814"></p>
<h3 id="11-1-5-迁移学习与传统机器学习有什么区别？">11.1.5 迁移学习与传统机器学习有什么区别？</h3>
<table>
<thead>
<tr>
<th></th>
<th>迁移学习</th>
<th>传统机器学习</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据分布</td>
<td>训练和测试数据不需要同分布</td>
<td>训练和测试数据同分布</td>
</tr>
<tr>
<td>数据标签</td>
<td>不需要足够的数据标注</td>
<td>足够的数据标注</td>
</tr>
<tr>
<td>建模</td>
<td>可以重用之前的模型</td>
<td>每个任务分别建模</td>
</tr>
</tbody>
</table>
<p><img src="1542973960796.png" alt="1542973960796"></p>
<h3 id="11-1-6-迁移学习的核心及度量准则？">11.1.6 迁移学习的核心及度量准则？</h3>
<p><strong>迁移学习的总体思路可以概括为</strong>：开发算法来最大限度地利用有标注的领域的知识，来辅助目标领域的知识获取和学习。</p>
<p><strong>迁移学习的核心是</strong>：找到源领域和目标领域之间的相似性，并加以合理利用。这种相似性非常普遍。比如，不同人的身体构造是相似的；自行车和摩托车的骑行方式是相似的；国际象棋和中国象棋是相似的；羽毛球和网球的打球方式是相似的。这种相似性也可以理解为不变量。以不变应万变，才能立于不败之地。</p>
<p>**有了这种相似性后，下一步工作就是， 如何度量和利用这种相似性。**度量工作的目标有两点：一是很好地度量两个领域的相似性，不仅定性地告诉我们它们是否相似，更定量地给出相似程度。二是以度量为准则，通过我们所要采用的学习手段，增大两个领域之间的相似性，从而完成迁移学习。</p>
<p><strong>一句话总结： 相似性是核心，度量准则是重要手段。</strong></p>
<h3 id="11-1-7-迁移学习与其他概念的区别？">11.1.7 迁移学习与其他概念的区别？</h3>
<ol>
<li>迁移学习与多任务学习关系：
<ul>
<li><strong>多任务学习</strong>：多个相关任务一起协同学习；</li>
<li><strong>迁移学习</strong>：强调信息复用，从一个领域(domain)迁移到另一个领域。</li>
</ul>
</li>
<li>迁移学习与领域自适应：<strong>领域自适应</strong>：使两个特征分布不一致的domain一致。</li>
<li>迁移学习与协方差漂移：<strong>协方差漂移</strong>：数据的条件概率分布发生变化。</li>
</ol>
<p>Reference：</p>
<ol>
<li><a href="https%EF%BC%9A//github.com/jindongwang/transferlearning-tutorial">王晋东，迁移学习简明手册</a></li>
<li>Ben-David, S., Blitzer, J., Crammer, K., Kulesza, A., Pereira, F., &amp; Vaughan, J. W. (2010). A theory of learning from different domains. Machine learning, 79(1-2), 151-175.</li>
<li>Tan, B., Song, Y., Zhong, E. and Yang, Q., 2015, August. Transitive transfer learning. In Proceedings of the 21th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining (pp. 1155-1164). ACM.</li>
</ol>
<h3 id="11-1-8-什么是负迁移？产生负迁移的原因有哪些？">11.1.8 什么是负迁移？产生负迁移的原因有哪些？</h3>
<p>负迁移(Negative Transfer)指的是，在源域上学习到的知识，对于目标域上的学习产生负面作用。</p>
<p>产生负迁移的原因主要有：</p>
<ul>
<li>数据问题：源域和目标域压根不相似，谈何迁移？</li>
<li>方法问题：源域和目标域是相似的，但是，迁移学习方法不够好，没找到可迁移的成分。</li>
</ul>
<p>负迁移给迁移学习的研究和应用带来了负面影响。在实际应用中，找到合理的相似性，并且选择或开发合理的迁移学习方法，能够避免负迁移现象。</p>
<h3 id="11-1-9-迁移学习的基本思路？">11.1.9 迁移学习的基本思路？</h3>
<p>迁移学习的总体思路可以概括为：开发算法来最大限度地利用有标注的领域的知识，来辅助目标领域的知识获取和学习。</p>
<ol>
<li>找到目标问题的相似性，迁移学习任务就是从相似性出发，将旧领域(domain)学习过的模型应用在新领域上。</li>
<li>迁移学习，是指利用数据、任务、或模型之间的相似性，将在旧领域学习过的模型，应用于新领域的一种学习过程。</li>
<li>迁移学习<strong>最有用的场合</strong>是，如果你尝试优化任务B的性能，通常这个任务数据相对较少。<br>
例如，在放射科中你知道很难收集很多射线扫描图来搭建一个性能良好的放射科诊断系统，所以在这种情况下，你可能会找一个相关但不同的任务，如图像识别，其中你可能用 1 百万张图片训练过了，并从中学到很多低层次特征，所以那也许能帮助网络在任务在放射科任务上做得更好，尽管任务没有这么多数据。</li>
<li>迁移学习什么时候是有意义的？它确实可以<strong>显著提高</strong>你的<strong>学习任务的性能</strong>，但我有时候也见过有些场合使用迁移学习时，任务实际上数据量比任务要少， 这种情况下增益可能不多。</li>
</ol>
<blockquote>
<p>什么情况下可以使用迁移学习？</p>
<p>假如两个领域之间的区别特别的大，<strong>不可以直接采用迁移学习</strong>，因为在这种情况下效果不是很好。在这种情况下，推荐使用[3]的工作，在两个相似度很低的domain之间一步步迁移过去（踩着石头过河）。</p>
</blockquote>
<blockquote>
<ol>
<li>迁移学习主要解决方案有哪些？</li>
<li>除直接看infer的结果的Accurancy以外，如何衡量迁移学习学习效果？</li>
<li>对抗网络是如何进行迁移的？</li>
</ol>
</blockquote>
<p>Reference：</p>
<ol>
<li><a href="https%EF%BC%9A//github.com/jindongwang/transferlearning-tutorial">王晋东，迁移学习简明手册</a></li>
<li>Ben-David, S., Blitzer, J., Crammer, K., Kulesza, A., Pereira, F., &amp; Vaughan, J. W. (2010). A theory of learning from different domains. Machine learning, 79(1-2), 151-175.</li>
<li>Tan, B., Song, Y., Zhong, E. and Yang, Q., 2015, August. Transitive transfer learning. In Proceedings of the 21th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining (pp. 1155-1164). ACM.</li>
</ol>
<h2 id="11-2-迁移学习的基本思路有哪些？">11.2 迁移学习的基本思路有哪些？</h2>
<p>​	迁移学习的基本方法可以分为四种。这四种基本的方法分别是：基于样本的迁移， 基于模型 的迁移， 基于特征的迁移，及基于关系的迁移。</p>
<h3 id="11-2-1-基于样本迁移">11.2.1 基于样本迁移</h3>
<p>​	基于样本的迁移学习方法 (Instance based Transfer Learning) 根据一定的权重生成规则，对数据样本进行重用，来进行迁移学习。图<a href="#bookmark90">14</a>形象地表示了基于样本迁移方法的思想源域中存在不同种类的动物，如狗、鸟、猫等，目标域只有狗这一种类别。在迁移时，为了最大限度地和目标域相似，我们可以人为地提高源域中属于狗这个类别的样本权重。</p>
<p><img src="631e5aab4e0680c374793804817bfbb6.jpg" alt></p>
<center>图 14: 基于样本的迁移学习方法示意图
<p>​	在迁移学习中，对于源域D~s~和目标域D~t~，通常假定产生它们的概率分布是不同且未知的(P(X~s~) =P(X~t~))。另外，由于实例的维度和数量通常都非常大，因此，直接对 P(X~s~) 和P(X~t~) 进行估计是不可行的。因而，大量的研究工作 [<a href="#bookmark267">Khan and Heisterkamp,2016</a>, <a href="#bookmark319">Zadrozny, 2004</a>, <a href="#bookmark242">Cortes et al.,2008</a>, <a href="#bookmark243">Dai et al., 2007</a>, <a href="#bookmark302">Tan et al.,2015</a>, <a href="#bookmark303">Tan et al., 2017</a>] 着眼于对源域和目标域的分布比值进行估计(P(<strong>X</strong>t)/P(<strong>X</strong>s))。所估计得到的比值即为样本的权重。这些方法通常都假设P(<strong>x</strong>s) &lt;并且源域和目标域的条件概率分布相同(P(y|x~s~)=<em>P</em>(y|x~t~))。特别地，上海交通大学Dai等人[<a href="#bookmark243">Dai et al.,2007</a>]提出了 TrAdaboost方法，将AdaBoost的思想应用于迁移学习中，提高有利于目标分类任务的实例权重、降低不利于目标分类任务的实例权重，并基于PAC理论推导了模型的泛化误差上界。TrAdaBoost方法是此方面的经典研究之一。文献 [<a href="#bookmark264">Huang et al., 2007</a>]提出核均值匹配方法 (Kernel Mean atching, KMM)对于概率分布进行估计，目标是使得加权后的源域和目标域的概率分布尽可能相近。在最新的研究成果中，香港科技大学的Tan等人扩展了实例迁移学习方法的应用场景，提出 了传递迁移学习方法(Transitive Transfer Learning, TTL) [<a href="#bookmark302">Tan etal., 2015</a>] 和远域迁移学习 (Distant Domain Transfer Learning,DDTL) [<a href="#bookmark303">Tan et al., 2017</a>]，利用联合矩阵分解和深度神经网络，将迁移学习应用于多个不相似的领域之间的知识共享，取得了良好的效果。</p>
<p>​	虽然实例权重法具有较好的理论支撑、容易推导泛化误差上界，但这类方法通常只在领域间分布差异较小时有效，因此对自然语言处理、计算机视觉等任务效果并不理想。而基于特征表示的迁移学习方法效果更好,是我们研究的重点。</p>
<h3 id="11-2-2-基于特征迁移">11.2.2 基于特征迁移</h3>
<p>​	基于特征的迁移方法 (Feature based Transfer Learning) 是指将通过特征变换的方式互相迁移 [<a href="#bookmark272">Liu et al., 2011</a>, <a href="#bookmark327">Zheng et al.,2008</a>, <a href="#bookmark263">Hu and Yang, 2011</a>],来减少源域和目标域之间的差距；或者将源域和目标域的数据特征变换到统一特征空间中 [<a href="#bookmark288">Pan et al.,2011</a>, <a href="#bookmark278">Long et al., 2014b</a>, <a href="#bookmark248">Duan et al.,2012</a>],然后利用传统的机器学习方法进行分类识别。根据特征的同构和异构性,又可以分为同构和异构迁移学习。图<a href="#bookmark93">15</a>很形象地表示了两种基于特 征的迁移学习方法。</p>
<p><img src="fa08900e89bfd53cc28345d21bc6aca0.jpg" alt></p>
<center>图 15: 基于特征的迁移学习方法示意图
<p>​	基于特征的迁移学习方法是迁移学习领域中最热门的研究方法,这类方法通常假设源域和目标域间有一些交叉的特征。香港科技大学的 Pan 等人 [<a href="#bookmark288">Pan et al.,2011</a>] 提出的迁移 成分分析方法 (Transfer Component Analysis, TCA)是其中较为典型的一个方法。该方法的 核心内容是以最大均值差异 (Maximum MeanDiscrepancy, MMD) [<a href="#bookmark236">Borgwardt et al., 2006</a>]作为度量准则,将不同数据领域中的分布差异最小化。加州大学伯克利分校的 Blitzer 等人 [<a href="#bookmark235">Blitzer et al., 2006</a>] 提出了一种基于结构对应的学习方法(Structural Corresponding Learning,SCL),该算法可以通过映射将一个空间中独有的一些特征变换到其他所有空间中的轴特征上,然后在该特征上使用机器学习的算法进行分类预测。清华大学龙明盛等人[<a href="#bookmark278">Long et al.,2014b</a>]提出在最小化分布距离的同时，加入实例选择的迁移联合匹配(Tran-fer Joint Matching, TJM) 方法,将实例和特征迁移学习方法进行了有机的结合。澳大利亚卧龙岗大学的 Jing Zhang 等人 [<a href="#bookmark321">Zhang et al., 2017a</a>]提出对于源域和目标域各自训练不同 的变换矩阵,从而达到迁移学习的目标。</p>
<h3 id="11-2-3-基于模型迁移">11.2.3 基于模型迁移</h3>
<p>​	基于模型的迁移方法 (Parameter/Model based Transfer Learning) 是指从源域和目标域中找到他们之间共享的参数信息,以实现迁移的方法。这种迁移方式要求的假设条件是： 源域中的数据与目标域中的数据可以共享一些模型的参数。其中的代表性工作主要有［<a href="#bookmark324">Zhao et al., 2010</a>, <a href="#bookmark325">Zhao et al., 2011</a>, <a href="#bookmark287">Panet al., 2008b</a>, <a href="#bookmark286">Pan et al., 2008a</a>］。图<a href="#bookmark96">16</a>形象地 表示了基于模型的迁移学习方法的基本思想。</p>
<p><img src="602723a1d3ce0f3abe7c591a8e4bb6ec.jpg" alt></p>
<center>图 16: 基于模型的迁移学习方法示意图
<p>​	其中，中科院计算所的Zhao等人[<a href="#bookmark325">Zhao et al., 2011</a>]提出了TransEMDT方法。该方法首先针对已有标记的数据，利用决策树构建鲁棒性的行为识别模型，然后针对无标定数据，利用K-Means聚类方法寻找最优化的标定参数。西安邮电大学的Deng等人[<a href="#bookmark245">Deng et al.,2014</a>] 也用超限学习机做了类似的工作。香港科技大学的Pan等人[<a href="#bookmark286">Pan etal., 2008a</a>]利用HMM，针对Wifi室内定位在不同设备、不同时间和不同空间下动态变化的特点，进行不同分布下的室内定位研究。另一部分研究人员对支持向量机 SVM 进行了改进研究 [<a href="#bookmark285">Nater et al.,2011</a>, <a href="#bookmark269">Li et al., 2012</a>]。这些方法假定 SVM中的权重向量 <strong>w</strong> 可以分成两个部分： <strong>w</strong> = <strong>wo</strong>+<strong>v</strong>， 其中 <strong>w</strong>0代表源域和目标域的共享部分， <strong>v</strong> 代表了对于不同领域的特定处理。在最新的研究成果中，香港科技大学的 Wei 等人 [<a href="#bookmark313">Wei et al., 2016b</a>]将社交信息加入迁移学习方法的 正则项中，对方法进行了改进。清华大学龙明盛等人[<a href="#bookmark275">Long et al., 2015a</a>, <a href="#bookmark276">Long et al., 2016</a>, <a href="#bookmark280">Long etal., 2017</a>]改进了深度网络结构，通过在网络中加入概率分布适配层，进一步提高了深度迁移学习网络对于大数据的泛化能力。</p>
<h3 id="11-2-4-基于关系迁移">11.2.4 基于关系迁移</h3>
<p>​	基于关系的迁移学习方法 (Relation Based Transfer Learning) 与上述三种方法具有截然不同的思路。这种方法比较关注源域和目标域的样本之间的关系。图<a href="#bookmark82">17</a>形象地表示了不 同领域之间相似的关系。</p>
<p>​	就目前来说，基于关系的迁移学习方法的相关研究工作非常少，仅有几篇连贯式的文章讨论： [<a href="#bookmark283">Mihalkova et al., 2007</a>, <a href="#bookmark284">Mihalkova and Mooney,2008</a>, <a href="#bookmark244">Davis and Domingos, 2009</a>]。这些文章都借助于马尔科夫逻辑网络(Markov Logic Net)来挖掘不同领域之间的关系相似性。</p>
<p>​	我们将重点讨论基于特征和基于模型的迁移学习方法，这也是目前绝大多数研究工作的热点。</p>
<p><img src="aa10d36f758430dd4ff72d2bf6a76a6c.jpg" alt></p>
<center>图 17: 基于关系的迁移学习方法示意图
<p><img src="1542812440636.png" alt="1542812440636"></p>
<center>图 18: 基于马尔科夫逻辑网的关系迁移
<h2 id="11-3-迁移学习的常用方法">11.3 迁移学习的常用方法</h2>
<h3 id="11-3-1-数据分布自适应">11.3.1 数据分布自适应</h3>
<p>​	数据分布自适应 (Distribution Adaptation) 是一类最常用的迁移学习方法。这种方法的基本思想是,由于源域和目标域的数据概率分布不同,那么最直接的方式就是通过一些变换,将不同的数据分布的距离拉近。</p>
<p>​	图 <a href="#bookmark84">19</a>形象地表示了几种数据分布的情况。简单来说，数据的边缘分布不同，就是数据整体不相似。数据的条件分布不同，就是数据整体相似，但是具体到每个类里，都不太相似。</p>
<p><img src="1542812748062.png" alt="1542812748062"></p>
<center>图 19: 不同数据分布的目标域数据
<p>​	根据数据分布的性质,这类方法又可以分为边缘分布自适应、条件分布自适应、以及联合分布自适应。下面我们分别介绍每类方法的基本原理和代表性研究工作。介绍每类研究工作时,我们首先给出基本思路,然后介绍该类方法的核心,最后结合最近的相关工作介绍该类方法的扩展。</p>
<h3 id="11-3-2-边缘分布自适应">11.3.2 边缘分布自适应</h3>
<p>​	边缘分布自适应方法 (Marginal Distribution Adaptation) 的目标是减小源域和目标域的边缘概率分布的距离,从而完成迁移学习。从形式上来说,边缘分布自适应方法是用P(X~s~)和 P(X~t~)之间的距离来近似两个领域之间的差异。即：</p>
<p>​	 $DISTANCE(D~s~,D~t~)\approx\lVert P(X_s)-P(X_t)\Vert$  (6.1)</p>
<p>​	边缘分布自适应对应于图<a href="#bookmark84">19</a>中由图<a href="#bookmark101">19(a)</a>迁移到图<a href="#bookmark83">19(b)</a>的情形。</p>
<h3 id="11-3-3-条件分布自适应">11.3.3 条件分布自适应</h3>
<p>​	条件分布自适应方法 (Conditional Distribution Adaptation) 的目标是减小源域和目标域的条件概率分布的距离，从而完成迁移学习。从形式上来说，条件分布自适应方法是用  P(y~s~|X~s~) 和 P (y~t~|X~t~) 之间的距离来近似两个领域之间的差异。即：</p>
<p>​	 $DISTANCE(D~s~,D~t~)\approx\lVert P(y_s|X_s)-P(y_t|X_t)\Vert$ (6.8)</p>
<p>​	条件分布自适应对应于图<a href="#bookmark84">19</a>中由图<a href="#bookmark101">19(a)</a>迁移到图<a href="#bookmark85">19©</a>的情形。</p>
<p>​	目前单独利用条件分布自适应的工作较少，这些工作主要可以在 [<a href="#bookmark292">Saito et al.,2017</a>] 中找到。最近，中科院计算所的 Wang 等人提出了 STL 方法(Stratified Transfer Learn­ing) [<a href="#bookmark309">Wang tal.,2018</a>]。作者提出了类内迁移 (Intra-class Transfer)的思想。指出现有的 绝大多数方法都只是学习一个全局的特征变换(Global DomainShift)，而忽略了类内的相 似性。类内迁移可以利用类内特征，实现更好的迁移效果。</p>
<p>​	STL 方法的基本思路如图所示。首先利用大多数投票的思想，对无标定的位置行为生成伪标；然后在再生核希尔伯特空间中，利用类内相关性进行自适应地空间降维，使得不同情境中的行为数据之间的相关性增大；最后，通过二次标定，实现对未知标定数据的精准标定。</p>
<p><img src="1542817481582.png" alt="1542817481582"></p>
<center>图 21: STL 方法的示意图
### 11.3.4 联合分布自适应
<p>​	联合分布自适应方法 (Joint Distribution Adaptation) 的目标是减小源域和目标域的联合概率分布的距离，从而完成迁移学习。从形式上来说，联合分布自适应方法是用<em>P</em>(<strong>x</strong>s) 和P(<strong>x</strong>t)之间的距离、以及P(ys|<strong>x</strong>s)和P(yt|<strong>x</strong>t)之间的距离来近似两个领域之间的差异。即:</p>
<p>​	 $DISTANCE(D~s~,D~t~)\approx\lVert P(X_s)-P(X_t)\Vert-\lVert P(y_s|X_s)-P(y_t|X_t)\Vert​$ (6.10)</p>
<p>​	联合分布自适应对应于图<a href="#bookmark84">19</a>中由图<a href="#bookmark101">19(a)</a>迁移到图<a href="#bookmark83">19(b)</a>的情形、以及图<a href="#bookmark101">19(a)</a>迁移到<br>
图<a href="#bookmark85">19©</a>的情形。</p>
<h3 id="11-3-4-概率分布自适应方法优劣性比较">11.3.4 概率分布自适应方法优劣性比较</h3>
<p>综合上述三种概率分布自适应方法，我们可以得出如下的结论：</p>
<ol>
<li>精度比较： BDA &gt;JDA &gt;TCA &gt;条件分布自适应。</li>
<li>将不同的概率分布自适应方法用于神经网络，是一个发展趋势。图<a href="#bookmark119">23</a>展示的结果表明将概率分布适配加入深度网络中，往往会取得比非深度方法更好的结果。</li>
</ol>
<p><img src="1542823019007.png" alt="1542823019007"></p>
<center>图 22: BDA 方法的效果第二类方法：特征选择
### 11.3.6 特征选择
<p>​	特征选择法的基本假设是：源域和目标域中均含有一部分公共的特征，在这部分公共的特征，源领域和目标领域的数据分布是一致的。因此，此类方法的目标就是，通过机器学习方法，选择出这部分共享的特征，即可依据这些特征构建模型。</p>
<p>​	图 <a href="#bookmark122">24</a>形象地表示了特征选择法的主要思路。</p>
<p><img src="1542823210556.png" alt="1542823210556"></p>
<center>图 23: 不同分布自适应方法的精度比较
<p><img src="a3db84158d9b6454adff88dbe4fa5d28.jpg" alt></p>
<center>图 24: 特征选择法示意图
<p>​	这这个领域比较经典的一个方法是发表在 2006 年的 ECML-PKDD 会议上,作者提出了一个叫做 SCL 的方法 (Structural Correspondence Learning) [<a href="#bookmark235">Blitzer et al.,2006</a>]。这个方法的目标就是我们说的,找到两个领域公共的那些特征。作者将这些公共的特征叫做Pivot feature。找出来这些Pivot feature,就完成了迁移学习的任务。</p>
<p><img src="4abacd82901988c3e0a98bdb07b2abc6.jpg" alt></p>
<center>图 25: 特征选择法中的 Pivot feature 示意图
<p>​	图 <a href="#bookmark124">25</a>形象地展示了 Pivot feature 的含义。 Pivot feature指的是在文本分类中,在不同领域中出现频次较高的那些词。总结起来：</p>
<ul>
<li>特征选择法从源域和目标域中选择提取共享的特征,建立统一模型</li>
<li>通常与分布自适应方法进行结合</li>
<li>通常采用稀疏表示 ||<strong>A</strong>||2,1 实现特征选择</li>
</ul>
<h3 id="11-3-5-统计特征对齐方法">11.3.5 统计特征对齐方法</h3>
<p>​	统计特征对齐方法主要将数据的统计特征进行变换对齐。对齐后的数据，可以利用传统机器学习方法构建分类器进行学习。SA方法(Subspace Alignment，子空间对齐)[<a href="#bookmark249">Fernando et al.,2013</a>]是其中的代表性成果。SA方法直接寻求一个线性变换<strong>M</strong>，将不同的数据实现变换对齐。SA方法的优化目标如下：</p>
<p><img src="1542823438846.png" alt="1542823438846"></p>
<p>则变换 <strong>M</strong> 的值为：</p>
<p><img src="1542823455820.png" alt="1542823455820"></p>
<p>可以直接获得上述优化问题的闭式解：</p>
<p><img src="1542823474720.png" alt="1542823474720"></p>
<p>​	SA 方法实现简单，计算过程高效，是子空间学习的代表性方法。</p>
<h3 id="11-3-6-流形学习方法">11.3.6 流形学习方法</h3>
<p><strong>什么是流形学习</strong></p>
<p>​	流形学习自从 2000 年在 Science 上被提出来以后,就成为了机器学习和数据挖掘领域的热门问题。它的基本假设是,现有的数据是从一个高维空间中采样出来的,所以,它具有高维空间中的低维流形结构。流形就是是一种几何对象（就是我们能想像能观测到的）。通俗点说就是,我们无法从原始的数据表达形式明显看出数据所具有的结构特征,那我把它想像成是处在一个高维空间,在这个高维空间里它是有个形状的。一个很好的例子就是星座。满天星星怎么描述？我们想像它们在一个更高维的宇宙空间里是有形状的,这就有了各自星座,比如织女座、猎户座。流形学习的经典方法有Isomap、locally linear embedding、 laplacian eigenmap 等。</p>
<p>​	流形空间中的距离度量：两点之间什么最短？在二维上是直线（线段）,可在三维呢？地球上的两个点的最短距离可不是直线,它是把地球展开成二维平面后画的那条直线。那条线在三维的地球上就是一条曲线。这条曲线就表示了两个点之间的最短距离,我们叫它测地线。更通俗一点, 两点之间，测地线最短。在流形学习中,我们遇到测量距离的时候更多的时候用的就是这个测地线。在我们要介绍的 GFK 方法中,也是利用了这个测地线距离。比如在下面的图中,从 A 到 C 最短的距离在就是展开后的线段,但是在三维球体上看它却是一条曲线。</p>
<p><img src="fcbe02803e45f6455a4602b645b472c5.jpg" alt></p>
<center>图 28: 三维空间中两点之间的距离示意图
<p>​	由于在流形空间中的特征通常都有着很好的几何性质,可以避免特征扭曲,因此我们首先将原始空间下的特征变换到流形空间中。在众多已知的流形中, Grassmann 流形G（d） 可以通过将原始的 d 维子空间 （特征向量）看作它基础的元素,从而可以帮助学习分类 器。在 Grassmann流形中,特征变换和分布适配通常都有着有效的数值形式,因此在迁移学习问题中可以被很高效地表示和求解 [<a href="#bookmark260">Hamm and Lee,2008</a>]。因此,利用 Grassmann流形空间中来进行迁移学习是可行的。现存有很多方法可以将原始特征变换到流形空间 中[<a href="#bookmark257">Gopalan et al., 2011</a>, <a href="#bookmark230">Baktashmotlagh et al.,2014</a>]。</p>
<p>​	在众多的基于流形变换的迁移学习方法中，GFK(Geodesic Flow Kernel)方法[<a href="#bookmark255">Gong et<br>
al., 2012</a>]是最为代表性的一个。GFK是在2011年发表在ICCV上的SGF方法[<a href="#bookmark257">Gopalan et al.,<br>
2011</a>]发展起来的。我们首先介绍SGF方法。</p>
<p>​	SGF 方法从增量学习中得到启发：人类从一个点想到达另一个点，需要从这个点一步一步走到那一个点。那么，如果我们把源域和目标域都分别看成是高维空间中的两个点，由源域变换到目标域的过程不就完成了迁移学习吗？也就是说， 路是一步一步走出来的。</p>
<p>​	于是 SGF 就做了这个事情。它是怎么做的呢？把源域和目标域分别看成高维空间 (即Grassmann流形)中的两个点，在这两个点的测地线距离上取d个中间点，然后依次连接起来。这样，源域和目标域就构成了一条测地线的路径。我们只需要找到合适的每一步的变换，就能从源域变换到目标域了。图 <a href="#bookmark133">29</a>是 SGF 方法的示意图。</p>
<p><img src="103de3658cbb97ad4c24bafe28f9d957.jpg" alt></p>
<center>图 29: SGF 流形迁移学习方法示意图
<p>​	SGF 方法的主要贡献在于：提出了这种变换的计算及实现了相应的算法。但是它有很明显的缺点：到底需要找几个中间点？ SGF也没能给出答案，就是说这个参数d是没法估计的，没有一个好的方法。这个问题在 GFK 中被回答了。</p>
<p>​	GFK方法首先解决SGF的问题：如何确定中间点的个数d。它通过提出一种核学习的方法，利用路径上的无穷个点的积分，把这个问题解决了。这是第一个贡献。然后，它又解决了第二个问题：当有多个源域的时候，我们如何决定使用哪个源域跟目标域进行迁移？ GFK通过提出Rank of Domain度量，度量出跟目标域最近的源域，来解决这个问题。图 <a href="#bookmark134">30</a>是 GFK 方法的示意图。</p>
<p><img src="e654d14df0b44ee4e8a0e505c654044b.jpg" alt></p>
<center>图 30: GFK 流形迁移学习方法示意图
<p>​	用Ss和St分别表示源域和目标域经过主成分分析(PCA)之后的子空间，则G可以视为所有的d维子空间的集合。每一个d维的原始子空间都可以被看作G上的一个点。因此，在两点之间的测地线｛\ $(t) :0 \< t \<1｝可以在两个子空间之间构成一条路径。如果我 们令ss="\$" (0)，st="\" $(1)，则寻找一条从\$ (0)到\ $(1)的测地线就等同于将原始的特征变换到一个无穷维度的空间中，最终减小域之间的漂移现象。这种方法可以被看作是一种从\$ $(1)的増量式“行走”方法。 ​ 特别地，流形空间中的特征可以被表示为**z**="\$" (t)t<strong>x。变换后的特征<strong>Z</strong>i和<strong>Z</strong>j的内积定义了一个半正定 (positive semidefinite) 的测地线流式核</1｝可以在两个子空间之间构成一条路径。如果我></p>
<p><img src="1542823895008.png" alt="1542823895008"></p>
<p>​	GFK 方法详细的计算过程可以参考原始的文章，我们在这里不再赘述。</p>
<h3 id="11-3-7-什么是finetune？">11.3.7 什么是finetune？</h3>
<p>​	深度网络的finetune也许是最简单的深度网络迁移方法。<strong>Finetune</strong>,也叫微调、fine-tuning, 是深度学习中的一个重要概念。简而言之，finetune就是利用别人己经训练好的网络，针对自己的任务再进行调整。从这个意思上看，我们不难理解finetune是迁移学习的一部分。</p>
<p><strong>为什么需要已经训练好的网络？</strong></p>
<p>​	在实际的应用中,我们通常不会针对一个新任务,就去从头开始训练一个神经网络。这样的操作显然是非常耗时的。尤其是，我们的训练数据不可能像ImageNet那么大，可以训练出泛化能力足够强的深度神经网络。即使有如此之多的训练数据,我们从头开始训练,其代价也是不可承受的。</p>
<p>​	那么怎么办呢？迁移学习告诉我们,利用之前己经训练好的模型,将它很好地迁移到自己的任务上即可。</p>
<p><strong>为什么需要 finetune？</strong></p>
<p>​	因为别人训练好的模型,可能并不是完全适用于我们自己的任务。可能别人的训练数据和我们的数据之间不服从同一个分布；可能别人的网络能做比我们的任务更多的事情；可能别人的网络比较复杂,我们的任务比较简单。</p>
<p>​	举一个例子来说,假如我们想训练一个猫狗图像二分类的神经网络,那么很有参考价值的就是在 CIFAR-100 上训练好的神经网络。但是 CIFAR-100 有 100 个类别,我们只需要 2个类别。此时,就需要针对我们自己的任务,固定原始网络的相关层,修改网络的输出层以使结果更符合我们的需要。</p>
<p>​	图<a href="#bookmark148">36</a>展示了一个简单的finetune过程。从图中我们可以看到，我们采用的预训练好的网络非常复杂,如果直接拿来从头开始训练,则时间成本会非常高昂。我们可以将此网络进行改造,固定前面若干层的参数,只针对我们的任务,微调后面若干层。这样,网络训练速度会极大地加快,而且对提高我们任务的表现也具有很大的促进作用。</p>
<p><img src="b1630ca5d004d4b430672c8b8ce7fb90.jpg" alt></p>
<center>图 36: 一个简单的 finetune 示意图
**Finetune 的优势**
<p>​	Finetune 的优势是显然的，包括:</p>
<ul>
<li>不需要针对新任务从头开始训练网络，节省了时间成本；</li>
<li>预训练好的模型通常都是在大数据集上进行的，无形中扩充了我们的训练数据，使得模型更鲁棒、泛化能力更好；</li>
<li>Finetune 实现简单，使得我们只关注自己的任务即可。</li>
</ul>
<p><strong>Finetune 的扩展</strong></p>
<p>​	在实际应用中，通常几乎没有人会针对自己的新任务从头开始训练一个神经网络。Fine-tune 是一个理想的选择。</p>
<p>​	Finetune 并不只是针对深度神经网络有促进作用，对传统的非深度学习也有很好的效果。例如， finetune对传统的人工提取特征方法就进行了很好的替代。我们可以使用深度网络对原始数据进行训练，依赖网络提取出更丰富更有表现力的特征。然后，将这些特征作为传统机器学习方法的输入。这样的好处是显然的: 既避免了繁复的手工特征提取，又能自动地提取出更有表现力的特征。</p>
<p>​	比如，图像领域的研究，一直是以 SIFT、SURF 等传统特征为依据的，直到 2014 年，伯克利的研究人员提出了 DeCAF特征提取方法［<a href="#bookmark246">Donahue et al.,2014</a>］，直接使用深度卷积神经网络进行特征提取。实验结果表明，该特征提取方法对比传统的图像特征，在精度上有着无可匹敌的优势。另外，也有研究人员用卷积神经网络提取的特征作为SVM分类器的输 入［<a href="#bookmark291">Razavian et al.,014</a>］，显著提升了图像分类的精度。</p>
<h3 id="11-3-8-finetune为什么有效？">11.3.8 finetune为什么有效？</h3>
<p>​	随着 AlexNet [<a href="#bookmark268">Krizhevsky et al., 2012</a>] 在 2012 年的 ImageNet大赛上获得冠军，深度学习开始在机器学习的研究和应用领域大放异彩。尽管取得了很好的结果，但是神经网络本身就像一个黑箱子，看得见，摸不着，解释性不好。由于神经网络具有良好的层次结构很自然地就有人开始关注，能否通过这些层次结构来很好地解释网络？于是，有了我们熟知的例子：假设一个网络要识别一只猫，那么一开始它只能检测到一些边边角角的东西，和猫根本没有关系；然后可能会检测到一些线条和圆形；慢慢地，可以检测到有猫的区域；接着是猫腿、猫脸等等。图 <a href="#bookmark137">32</a>是一个简单的示例。</p>
<p><img src="1542824195602.png" alt="1542824195602"></p>
<center>图 32: 深度神经网络进行特征提取到分类的简单示例
<p>​	这表达了一个什么事实呢？概括来说就是：前面几层都学习到的是通用的特征（general feature）；随着网络层次的加深，后面的网络更偏重于学习任务特定的特征（specific feature）。<br>
这非常好理解，我们也都很好接受。那么问题来了：如何得知哪些层能够学习到 general feature，哪些层能够学习到specific feature。更进一步：如果应用于迁移学习，如何决定该迁移哪些层、固定哪些层？</p>
<p>​	这个问题对于理解神经网络以及深度迁移学习都有着非常重要的意义。</p>
<p>​	来自康奈尔大学的 Jason Yosinski 等人 [<a href="#bookmark318">Yosinski et al., 2014</a>]率先进行了深度神经网络可迁移性的研究，将成果发表在2014年机器学习领域顶级会议NIPS上并做了口头汇报。该论文是一篇实验性质的文章（通篇没有一个公式）。其目的就是要探究上面我们提到的几个关键性问题。因此，文章的全部贡献都来自于实验及其结果。（别说为啥做实验也能发文章：都是高考，我只上了个普通一本，我高中同学就上了清华）</p>
<p>​	在ImageNet的1000类上，作者把1000类分成两份（A和B），每份500个类别。然后，分别对A和B基于Caffe训练了一个AlexNet网络。一个AlexNet网络一共有8层， 除去第8层是类别相关的网络无法迁移以外，作者在 1 到 7这 7层上逐层进行 finetune 实验，探索网络的可迁移性。</p>
<p>​	为了更好地说明 finetune 的结果，作者提出了有趣的概念： AnB 和 BnB。</p>
<p>​	迁移A网络的前n层到B （AnB） vs固定B网络的前n层（BnB）</p>
<p>​	简单说一下什么叫AnB:（所有实验都是针对数据B来说的）将A网络的前n层拿来并将它frozen，剩下的8 - n层随机初始化，然后对B进行分类。</p>
<p>​	相应地，有BnB:把训练好的B网络的前n层拿来并将它frozen，剩下的8 - n层随机初始化，然后对 B 进行分类。</p>
<p>​	<strong>实验结果</strong></p>
<p>​	实验结果如下图（图<a href="#bookmark145">33</a>） 所示:</p>
<p>​	这个图说明了什么呢？我们先看蓝色的BnB和BnB+（就是BnB加上finetune）。对 BnB而言，原训练好的 B 模型的前 3 层直接拿来就可以用而不会对模型精度有什么损失到了第4 和第5 层，精度略有下降，不过还是可以接受。然而到了第6 第第7层，精度居然奇迹般地回升了！这是为什么？原因如下:对于一开始精度下降的第4 第 5 层来说，确</p>
<p><img src="1542824318155.png" alt="1542824318155"></p>
<center>图 33: 深度网络迁移实验结果 1
<p>实是到了这一步，feature变得越来越specific,所以下降了。那对于第6第7层为什么精度又不变了？那是因为，整个网络就8层，我们固定了第6第7层，这个网络还能学什么呢？所以很自然地，精度和原来的 B 网络几乎一致！</p>
<p>​	对 BnB+ 来说，结果基本上都保持不变。说明 finetune 对模型结果有着很好的促进作用！</p>
<p>​	我们重点关注AnB和AnB+。对AnB来说，直接将A网络的前3层迁移到B,貌似不会有什么影响，再一次说明，网络的前3层学到的几乎都是general feature!往后，到了第4第5层的时候，精度开始下降，我们直接说：一定是feature不general 了！然而，到了第6第7层，精度出现了小小的提升后又下降，这又是为什么？作者在这里提出两点co-adaptation和feature representation。就是说，第4第5层精度下降的时候，主要是由于A和B两个数据集的差异比较大，所以会下降；至I」了第6第7层，由于网络几乎不迭代了，学习能力太差，此时 feature 学不到，所以精度下降得更厉害。</p>
<p>​	再看AnB+。加入了 finetune以后，AnB+的表现对于所有的n几乎都非常好，甚至 比baseB<br>
（最初的B）还要好一些！这说明：finetune对于深度迁移有着非常好的促进作用!</p>
<p>​	把上面的结果合并就得到了下面一张图 （图<a href="#bookmark138">34</a>）：</p>
<p>​	至此， AnB 和 BnB 基本完成。作者又想，是不是我分 A 和 B 数据的时候，里面存在一些比较相似的类使结果好了？比如说A里有猫，B里有狮子，所以结果会好？为了排除这些影响，作者又分了一下数据集，这次使得A和B里几乎没有相似的类别。在这个条件下再做AnB,与原来精度比较（0%为基准）得到了下图（图<a href="#bookmark139">35</a>）:</p>
<p>​	这个图说明了什么呢？简单：随着可迁移层数的增加，模型性能下降。但是，前3层仍然还是可以迁移的！同时,与随机初始化所有权重比较,迁移学习的精度是很高的!总之：</p>
<ul>
<li>
<p>深度迁移网络要比随机初始化权重效果好；</p>
</li>
<li>
<p>网络层数的迁移可以加速网络的学习和优化。</p>
</li>
</ul>
<h3 id="11-3-9-什么是深度网络自适应？">11.3.9 什么是深度网络自适应？</h3>
<p><strong>基本思路</strong></p>
<p>​	深度网络的 finetune 可以帮助我们节省训练时间，提高学习精度。但是 finetune 有它的先天不足:它无法处理训练数据和测试数据分布不同的情况。而这一现象在实际应用中比比皆是。因为 finetune 的基本假设也是训练数据和测试数据服从相同的数据分布。这在迁移学习中也是不成立的。因此，我们需要更进一步，针对深度网络开发出更好的方法使之更好地完成迁移学习任务。</p>
<p>​	以我们之前介绍过的数据分布自适应方法为参考，许多深度学习方法［<a href="#bookmark307">Tzeng et al.,2014</a>, <a href="#bookmark275">Long et al.,2015a</a>］都开发出了自适应层(AdaptationLayer)来完成源域和目标域数据的自适应。自适应能够使得源域和目标域的数据分布更加接近，从而使得网络的效果更好。</p>
<p>​	从上述的分析我们可以得出，深度网络的自适应主要完成两部分的工作:</p>
<p>​	一是哪些层可以自适应，这决定了网络的学习程度；</p>
<p>​	二是采用什么样的自适应方法 (度量准则)，这决定了网络的泛化能力。</p>
<p>​	深度网络中最重要的是网络损失的定义。绝大多数深度迁移学习方法都采用了以下的损失定义方式:</p>
<p><img src="1542824918145.png" alt="1542824918145"></p>
<p>​	其中，I表示网络的最终损失，lc(Ds,<strong>y</strong>s)表示网络在有标注的数据(大部分是源域)上的常规分类损失(这与普通的深度网络完全一致)，Ia(Ds,Dt)表示网络的自适应损失。最后一部分是传统的深度网络所不具有的、迁移学习所独有的。此部分的表达与我们先前讨论过的源域和目标域的分布差异，在道理上是相同的。式中的A是权衡两部分的权重参数。</p>
<p>​	上述的分析指导我们设计深度迁移网络的基本准则：决定自适应层，然后在这些层加入自适应度量，最后对网络进行 finetune。</p>
<h3 id="11-3-10-GAN在迁移学习中的应用">11.3.10 GAN在迁移学习中的应用</h3>
<p>生成对抗网络 GAN(Generative Adversarial Nets) [<a href="#bookmark256">Goodfellow et al.,2014</a>] 是目前人工智能领域最炙手可热的概念之一。其也被深度学习领军人物 Yann Lecun 评为近年来最令人欣喜的成就。由此发展而来的对抗网络，也成为了提升网络性能的利器。本小节介绍深度对抗网络用于解决迁移学习问题方面的基本思路以及代表性研究成果。</p>
<p><strong>基本思路</strong></p>
<p>​	GAN 受到自博弈论中的二人零和博弈 (two-player game) 思想的启发而提出。它一共包括两个部分：一部分为生成网络(Generative Network)，此部分负责生成尽可能地以假乱真的样本，这部分被成为生成器(Generator)；另一部分为判别网络(Discriminative Network), 此部分负责判断样本是真实的，还是由生成器生成的，这部分被成为判别器(Discriminator) 生成器和判别器的互相博弈，就完成了对抗训练。</p>
<p>​	GAN 的目标很明确：生成训练样本。这似乎与迁移学习的大目标有些许出入。然而，由于在迁移学习中，天然地存在一个源领域，一个目标领域，因此，我们可以免去生成样本的过程，而直接将其中一个领域的数据 (通常是目标域) 当作是生成的样本。此时，生成器的职能发生变化，不再生成新样本，而是扮演了特征提取的功能：不断学习领域数据的特征使得判别器无法对两个领域进行分辨。这样，原来的生成器也可以称为特征提取器<br>
(Feature Extractor)。</p>
<p>​	通常用 Gf 来表示特征提取器，用 Gd 来表示判别器。正是基于这样的领域对抗的思想，深度对抗网络可以被很好地运用于迁移学习问题中。与深度网络自适应迁移方法类似，深度对抗网络的损失也由两部分构成：网络训练的损失lc*和领域判别损失Id：</p>
<p><img src="1542826334834.png" alt="1542826334834"></p>
<p><strong>DANN</strong></p>
<p>Yaroslav Ganin 等人 [<a href="#bookmark251">Ganin et al., 2016</a>]首先在神经网络的训练中加入了对抗机制，作者将他们的网络称之为DANN(Domain-Adversarial Neural Network)。在此研宄中，网络的学习目标是：生成的特征尽可能帮助区分两个领域的特征，同时使得判别器无法对两个领域的差异进行判别。该方法的领域对抗损失函数表示为：</p>
<p><img src="1542826461988.png" alt="1542826461988"></p>
<p>Id = max 其中的 Ld 表示为</p>
<p><img src="1542826475517.png" alt="1542826475517"></p>
<h2 id="参考文献">参考文献</h2>
<p>王晋东，迁移学习简明手册</p>
<p>[Baktashmotlagh et al., 2013] Baktashmotlagh, M., Harandi, M. T., Lovell, B. C.,and Salz- mann, M. (2013). Unsupervised domain adaptation by domain invariant projection. In <em>ICCV,</em> pages 769-776.</p>
<p>[Baktashmotlagh et al., 2014] Baktashmotlagh, M., Harandi, M. T., Lovell, B. C., and Salz- mann, M. (2014). Domain adaptation on the statistical manifold. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition*,pages 2481-2488.</p>
<p>[Ben-David et al., 2010] Ben-David, S., Blitzer, J., Crammer, K., Kulesza, A., Pereira, F., and Vaughan, J. W. (2010). A theory of learning from different domains. <em>Machine learning,</em> 79(1-2):151-175.</p>
<p>[Ben-David et al., 2007] Ben-David, S., Blitzer, J., Crammer, K., and Pereira, F. (2007). Analysis of representations for domain adaptation. In <em>NIPS</em>, pages 137-144.</p>
<p>[Blitzer et al., 2008] Blitzer, J., Crammer, K., Kulesza, A., Pereira, F., and Wortman, J. (2008). Learning bounds for domain adaptation. In <em>Advances in neural information processing systems</em>, pages 129-136.</p>
<p>[Blitzer et al., 2006] Blitzer, J., McDonald, R., and Pereira, F. (2006). Domain adaptation with structural correspondence learning. In <em>Proceedings of the 2006 conference on empiri­cal methods in natural language processing</em>, pages 120-128. Association for Computational Linguistics.</p>
<p>[Borgwardt et al., 2006] Borgwardt, K. M., Gretton, A., Rasch, M. J., Kriegel, H.-P., Scholkopf, B., and Smola, A. J. (2006). Integrating structured biological data by kernel maximum mean discrepancy. <em>Bioinformatics</em>, 22(14):e49-e57.</p>
<p>[Bousmalis et al., 2016] Bousmalis, K., Trigeorgis, G., Silberman, N., Krishnan, D., and Erhan, D. (2016). Domain separation networks. In <em>Advances in Neural Information Processing Systems</em>, pages 343-351.</p>
<p>[Cai et al., 2011] Cai, D., He, X., Han, J., and Huang, T. S. (2011). Graph regularized nonnegative matrix factorization for data representation. <em>IEEE Transactions on Pattern Analysis and Machine Intelligence</em>, 33(8):1548-1560.</p>
<p>[Cao et al., 2017] Cao, Z., Long, M., Wang, J., and Jordan, M. I. (2017). Partial transfer learning with selective adversarial networks. <em>arXiv preprint arXiv:1707.07901</em>.</p>
<p>[Carlucci et al., 2017] Carlucci, F. M., Porzi, L., Caputo, B., Ricci, E., and Bulo, S. R. (2017). Autodial: Automatic domain alignment layers. In International Conference on* Computer Vision.</p>
<p>[Cook et al., 2013] Cook, D., Feuz, K. D., and Krishnan, N. C. (2013). Transfer learning for activity recognition: A survey. <em>Knowledge and information systems</em>, 36(3):537-556.</p>
<p>[Cortes et al., 2008] Cortes, C., Mohri, M., Riley, M., and Rostamizadeh, A. (2008). Sample selection bias correction theory. In <em>International Conference on Algorithmic Learning Theory</em>, pages 38-53, Budapest, Hungary. Springer.</p>
<p>[Dai et al., 2007] Dai, W., Yang, Q., Xue, G.-R., and Yu, Y. (2007). Boosting for transfer learning. In <em>ICML</em>, pages 193-200. ACM.</p>
<p>[Davis and Domingos, 2009] Davis, J. and Domingos, P. (2009). Deep transfer via second- order markov logic. In <em>Proceedings of the 26th annual international conference on machine learning</em>, pages 217-224. ACM.</p>
<p>[Denget al., 2014] Deng,W.,Zheng,Q.,andWang,Z.(2014).Cross-personactivityrecog-nition using reduced kernel extreme learning machine. <em>Neural Networks,</em> 53:1-7.</p>
<p>[Donahue et al., 2014] Donahue, J., Jia, Y., et al. (2014). Decaf: A deep convolutional activation feature for generic visual recognition. In <em>ICML</em>, pages 647-655.</p>
<p>[Dorri and Ghodsi, 2012] Dorri, F. and Ghodsi, A. (2012). Adapting component analysis. In <em>Data Mining (ICDM), 2012 IEEE 12th International Conference on</em>, pages 846-851. IEEE.</p>
<p>[Duan et al., 2012] Duan, L., Tsang, I. W., and Xu, D. (2012). Domain transfer multi­ple kernel learning. <em>IEEE Transactions on Pattern Analysis and Machine Intelligence</em>, 34(3):465-479.</p>
<p>[Fernando et al., 2013] Fernando, B., Habrard, A., Sebban, M., and Tuytelaars, T. (2013). Unsupervised visual domain adaptation using subspace alignment. In ICCV*, pages 2960­2967.</p>
<p>[Fodor, 2002] Fodor, I. K. (2002). A survey of dimension reduction techniques. Center for Applied Scientific Computing, Lawrence Livermore National Laboratory*, 9:1-18.</p>
<p>[Ganin et al., 2016] Ganin, Y., Ustinova, E., Ajakan, H., Germain, P., Larochelle, H., Lavi- olette, F., Marchand, M., and Lempitsky, V. (2016).Domain-adversarial training of neural networks. <em>Journal of Machine Learning<br>
Research</em>, 17(59):1-35.</p>
<p>[Gao et al., 2012] Gao, C., Sang, N., and Huang, R. (2012). Online transfer boosting for object tracking. In <em>Pattern Recognition (ICPR), 2012 21st International Conference on</em>, pages 906-909. IEEE.</p>
<p>[Ghifary et al., 2017] Ghifary, M., Balduzzi, D., Kleijn, W. B., and Zhang, M. (2017). Scat­ter component analysis: A unified framework for domain adaptation and domain general­ization. <em>IEEE transactions on pattern analysis and machine intelligence</em>, 39(7):1414-1430.</p>
<p>[Ghifary et al., 2014] Ghifary, M., Kleijn, W. B., and Zhang, M. (2014). Domain adaptive neural networks for object recognition. In <em>PRICAI</em>, pages 898-904.</p>
<p>[Gong et al., 2012] Gong, B., Shi, Y., Sha, F., and Grauman, K. (2012). Geodesic flow kernel for unsupervised domain adaptation. In <em>CVPR</em>, pages 2066-2073.</p>
<p>[Goodfellow et al., 2014] Goodfellow, I., Pouget-Abadie, J., Mirza, M., Xu, B.,  Warde- Farley, D., Ozair, S., Courville, A., and Bengio, Y. (2014). Generative adversarial nets. In <em>Advances in neural information processing systems</em>, pages 2672-2680.</p>
<p>[Gopalan et al., 2011] Gopalan, R., Li, R., and Chellappa, R. (2011). Domain adaptation for object recognition: An unsupervised approach. In <em>ICCV</em>, pages 999-1006. IEEE.</p>
<p>[Gretton et al., 2012] Gretton, A., Sejdinovic, D., Strathmann, H., Balakrishnan, S., Pontil, M., Fukumizu, K., and Sriperumbudur, B. K. (2012). Optimal kernel choice for large- scale two-sample tests. In <em>Advances in neural information processing systems</em>, pages 1205-1213.</p>
<p>[Gu et al., 2011] Gu, Q., Li, Z., Han, J., et al. (2011). Joint feature selection and subspace learning. In <em>IJCAI Proceedings-International Joint Conference on Artificial Intel ligence</em>, volume 22, page 1294.</p>
<p>[Hamm and Lee, 2008] Hamm, J. and Lee, D. D. (2008). Grassmann discriminant analysis: a unifying view on subspace-based learning. In <em>ICML</em>, pages 376-383. ACM.</p>
<p>[Hou et al., 2015] Hou, C.-A., Yeh, Y.-R., and Wang, Y.-C. F. (2015). An unsupervised domain adaptation approach for cross-domain visual classification. In <em>Advanced Video and Signal Based Surveil lance (AVSS), 2015 12th IEEE International Conference on</em>,pages 1-6. IEEE.</p>
<p>[Hsiao et al., 2016] Hsiao, P.-H., Chang, F.-J., and Lin, Y.-Y. (2016). Learning discrim­inatively reconstructed source data for object recognition with few examples. <em>IEEE</em>Transactions on Image Processing*, 25(8):3518-3532.</p>
<p>[Hu and Yang, 2011] Hu, D. H. and Yang, Q. (2011). Transfer learning for activity recog­nition via sensor mapping. In <em>IJCAI Proceedings-International Joint Conference on Artificial Intelligence</em>, volume 22, page 1962, Barcelona, Catalonia, Spain. IJCAI.</p>
<p>[Huang et al., 2007] Huang, J., Smola, A. J., Gretton, A., Borgwardt, K. M., Scholkopf, B., et al. (2007). Correcting sample selection bias by unlabeled  data. <em>Advances in neural information processing systems</em>, 19:601.</p>
<p>[Jaini et al., 2016] Jaini, P., Chen, Z., Carbajal, P., Law, E., Middleton, L., Regan, K., Schaekermann, M., Trimponias, G., Tung, J., and Poupart, P. (2016). Online bayesian transfer learning for sequential data modeling. In <em>ICLR 2017</em>.</p>
<p>[Kermany et al., 2018] Kermany, D. S., Goldbaum, M., Cai, W., Valentim, C. C., Liang, H., Baxter, S. L., McKeown, A., Yang, G., Wu, X., Yan, F., et al. (2018). Identifying medical diagnoses and treatable diseases by image-based deep learning. <em>Cell</em>, 172(5):1122-1131.</p>
<p>[Khan and Heisterkamp, 2016] Khan, M. N. A. and Heisterkamp, D. R. (2016). Adapting instance weights for unsupervised domain adaptation using quadratic mutual informa­tion and subspace learning. In <em>Pattern Recognition (ICPR), 2016 23rd International Conference on</em>, pages 1560-1565, Mexican City. IEEE.</p>
<p>[Krizhevsky et al., 2012] Krizhevsky, A., Sutskever, I., and Hinton, G. E. (2012). Imagenet classification with deep convolutional neural networks. In Advances in neural information processing systems*, pages 1097-1105.</p>
<p>[Li et al., 2012] Li, H., Shi, Y., Liu, Y., Hauptmann, A. G., and Xiong, Z. (2012). Cross­domain video concept detection: A joint discriminative and generative active learning approach. <em>Expert Systems with Applications</em>,<br>
39(15):12220-12228.</p>
<p>[Li et al., 2016] Li, J., Zhao, J., and Lu, K. (2016). Joint feature selection and structure preservation for domain adaptation. In <em>Proceedings of the Twenty-Fifth International Joint Conference on Artificial Intelligence</em>, pages<br>
1697-1703. AAAI Press.</p>
<p>[Li et al., 2018] Li, Y., Wang, N., Shi, J., Hou, X., and Liu, J. (2018). Adaptive batch normalization for practical domain adaptation. <em>Pattern Recognition</em>, 80:109-117.</p>
<p>[Liu et al., 2011] Liu, J., Shah, M., Kuipers, B., and Savarese, S. (2011). Cross-view action recognition via view knowledge transfer. In <em>Computer Vision and Pattern Recognition (CVPR), 2011 IEEE Conference on</em>, pages 3209-3216, Colorado Springs, CO, USA. IEEE.</p>
<p>[Liu and Tuzel, 2016] Liu, M.-Y. and Tuzel, O. (2016). Coupled generative adversarial networks. In <em>Advances in neural information processing systems</em>, pages 469-477.</p>
<p>[Liu et al., 2017] Liu, T., Yang, Q., and Tao, D. (2017). Understanding how  feature struc­ture transfers in transfer learning. In <em>IJCAI</em>.</p>
<p>[Long et al., 2015a] Long, M., Cao, Y., Wang, J., and Jordan, M. (2015a). Learning trans­ferable features with deep adaptation networks. In <em>ICML</em>, pages 97-105.</p>
<p>[Long et al., 2016] Long, M., Wang, J., Cao, Y., Sun, J., and Philip, S. Y. (2016). Deep learning of transferable representation for scalable domain  adaptation. <em>IEEE Transac­tions on Knowledge and Data Engineering</em>,<br>
28(8):2027-2040.</p>
<p>[Long et al., 2014a] Long, M., Wang, J., Ding, G., Pan, S. J., and Yu, P. S. (2014a). Adaptation regularization: A general framework for transfer learning.*IEEE TKDE, 26(5):1076-1089.</p>
<p>[Long et al., 2014b] Long, M., Wang, J., Ding, G., Sun, J., and Yu, P. S. (2014b). Transfer joint matching for unsupervised domain adaptation. In *CVPR ,pages 1410-1417.</p>
<p>[Long et al., 2013] Long, M., Wang, J., et al. (2013). Transfer feature learning with joint distribution adaptation. In <em>ICCV</em>, pages 2200-2207.</p>
<p>[Long et al., 2017] Long, M., Wang, J., and Jordan, M. I. (2017). Deep transfer learning with joint adaptation networks. In <em>ICML</em>, pages 2208-2217.</p>
<p>[Long et al., 2015b] Long, M., Wang, J., Sun, J., and Philip, S. Y. (2015b). Domain invari­ant transfer kernel learning. <em>IEEE Transactions on Knowledge and Data Engineering</em>, 27(6):1519-1532.</p>
<p>[Luo et al., 2017] Luo, Z., Zou, Y., Hoffman, J., and Fei-Fei, L. F. (2017). Label efficient learning of transferable representations acrosss domains and tasks. In <em>Advances in Neural Information Processing Systems</em>, pages 164-176.</p>
<p>[Mihalkova et al., 2007] Mihalkova, L., Huynh, T., and Mooney, R. J. (2007). Mapping and revising markov logic networks for transfer learning. In <em>AAAI</em>, volume 7, pages 608-614.</p>
<p>[Mihalkova and Mooney, 2008] Mihalkova, L. and Mooney, R. J. (2008). Transfer learning by mapping with minimal target data. In <em>Proceedings of the AAAI-08 workshop on transfer learning for complex tasks</em>.</p>
<p>[Nater et al., 2011] Nater, F., Tommasi, T., Grabner, H., Van Gool, L., and Caputo, B. (2011). Transferring activities: Updating human behavior analysis. In <em>Computer Vision Workshops (ICCV Workshops), 2011 IEEE International Conference on</em>, pages 1737­1744, Barcelona, Spain. IEEE.</p>
<p>[Pan et al., 2008a] Pan, S. J., Kwok, J. T., and Yang, Q. (2008a). Transfer learning via dimensionality reduction. In <em>Proceedings of the 23rd AAAI conference on Artificial in­telligence</em>, volume 8, pages 677-682.</p>
<p>[Pan et al., 2008b] Pan, S. J., Shen, D., Yang, Q., and Kwok, J. T. (2008b). Transferring localization models across space. In <em>Proceedings of the 23rd AAAI Conference on Artificial Intelligence</em>, pages 1383-1388.</p>
<p>[Pan et al., 2011] Pan, S. J., Tsang, I. W., Kwok, J. T., and Yang, Q. (2011). Domain adaptation via transfer component analysis. <em>IEEE TNN</em>, 22(2):199-210.</p>
<p>[PanandYang, 2010] Pan,S.J.andYang,Q.(2010). A survey on transfer learning. IEEE TKDE*, 22(10):1345-1359.</p>
<p>[Patil and Phursule, 2013] Patil, D. M. and Phursule, R. (2013). Knowledge transfer using cost sensitive online learning classification. <em>International Journal of Science and Research</em>, pages 527-529.</p>
<p>[Razavian et al., 2014] Razavian, A. S., Azizpour, H., Sullivan, J., and Carlsson, S. (2014). Cnn features off-the-shelf: an astounding baseline for recognition. In <em>Computer Vision and Pattern Recognition Workshops (CVPRW), 2014 IEEE Conference on</em>, pages 512­519. IEEE.</p>
<p>[Saito et al., 2017] Saito, K., Ushiku, Y., and Harada, T. (2017). Asymmetric tri-training for unsupervised domain adaptation. In <em>International Conference on Machine Learning</em>.</p>
<p>[Sener et al., 2016] Sener, O., Song, H. O., Saxena, A., and Savarese, S. (2016). Learning transferrable representations for unsupervised domain adaptation. In <em>Advances in Neural Information Processing Systems</em>, pages 2110-2118.</p>
<p>[Shen et al., 2018] Shen, J., Qu, Y., Zhang, W., and Yu, Y. (2018). Wasserstein distance guided representation learning for domain adaptation. In <em>AAAI</em>.</p>
<p>[Si et al., 2010] Si, S., Tao, D., and Geng, B. (2010). Bregman divergence-based regu­larization for transfer subspace learning. <em>IEEE Transactions on Knowledge and Data Engineering</em>, 22(7):929-942.</p>
<p>[Silver et al., 2017] Silver, D., Schrittwieser, J., Simonyan, K., Antonoglou, I., Huang, A., Guez, A., Hubert, T., Baker, L., Lai, M., Bolton, A., et al. (2017). Mastering the game of go without human knowledge. <em>Nature</em>, 550(7676):354.</p>
<p>[Stewart and Ermon, 2017] Stewart, R. and Ermon, S. (2017). Label-free supervision of neural networks with physics and domain knowledge. In <em>AAAI</em>, pages 2576-2582.</p>
<p>[Sun et al., 2016] Sun, B., Feng, J., and Saenko, K. (2016). Return of frustratingly easy domain adaptation. In <em>AAAI</em>, volume 6, page 8.</p>
<p>[Sun and Saenko, 2015] Sun, B. and Saenko, K. (2015). Subspace distribution alignment for unsupervised domain adaptation. In <em>BMVC</em>, pages 24-1.</p>
<p>[Sun and Saenko, 2016] Sun, B. and Saenko, K. (2016). Deep coral: Correlation alignment for deep domain adaptation. In <em>European Conference on Computer Vision</em>, pages 443-450. Springer.</p>
<p>[Tahmoresnezhad and Hashemi, 2016] Tahmoresnezhad, J. and Hashemi, S. (2016). Visual domain adaptation via transfer feature learning. <em>Knowledge and Information Systems</em>, pages 1-21.</p>
<p>[Tan et al., 2015] Tan, B., Song, Y., Zhong, E., and Yang, Q. (2015). Transitive trans­fer learning. In <em>Proceedings of the 21th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining</em>, pages 1155-1164. ACM.</p>
<p>[Tan et al., 2017] Tan, B., Zhang, Y., Pan, S. J., and Yang, Q. (2017). Distant domain transfer learning. In <em>Thirty-First AAAI Conference on Artificial Intelligence</em>.</p>
<p>[Taylor and Stone, 2009] Taylor, M. E. and Stone, P. (2009). Transfer learning for reinforce­ment learning domains: A survey. <em>Journal of Machine Learning Research</em>, 10(Jul):1633- 1685.</p>
<p>[Tzeng et al., 2015] Tzeng, E., Hoffman, J., Darrell, T., and Saenko, K. (2015). Simulta­neous deep transfer across domains and tasks. In <em>Proceedings of the IEEE International Conference on Computer Vision</em>, pages 4068-4076, Santiago, Chile. IEEE.</p>
<p>[Tzeng et al., 2017] Tzeng, E., Hoffman, J., Saenko, K., and Darrell, T. (2017). Adversarial discriminative domain adaptation. In <em>CVPR</em>, pages 2962-2971.</p>
<p>[Tzeng et al., 2014] Tzeng, E., Hoffman, J., Zhang, N., et al. (2014). Deep domain confu­sion: Maximizing for domain invariance. <em>arXiv preprint arXiv:1412.3474</em>.</p>
<p>[Wang et al., 2017] Wang, J., Chen, Y., Hao, S., et al. (2017). Balanced distribution adap­tation for transfer learning. In <em>ICDM</em>, pages 1129-1134.</p>
<p>[Wang et al., 2018] Wang, J., Chen, Y., Hu, L., Peng, X., and Yu, P. S. (2018). Strati­fied transfer learning for cross-domain activity recognition. In <em>2018 IEEE International Conference on Pervasive Computing and Communications (PerCom)</em>.</p>
<p>[Wang et al., 2014] Wang, J., Zhao, P., Hoi, S. C., and Jin, R. (2014). Online feature selection and its applications. <em>IEEE Transactions on Knowledge and Data Engineering</em>, 26(3):698-710.</p>
<p>[Wei et al., 2016a] Wei, P., Ke, Y., and Goh, C. K. (2016a). Deep nonlinearfeature coding for unsupervised domain adaptation. In <em>IJCAI</em>, pages 2189-2195.</p>
<p>[Wei et al., 2017] Wei, Y., Zhang, Y., and Yang, Q. (2017). Learning totransfer. <em>arXiv</em> preprint arXiv:1708.05629*.</p>
<p>[Wei et al., 2016b] Wei, Y., Zhu, Y., Leung, C. W.-k., Song, Y., and Yang, Q. (2016b). Instilling social to physical: Co-regularized heterogeneous transfer learning. In <em>Thirtieth</em> AAAI Conference on Artificial Intelligence*.</p>
<p>[Weiss et al., 2016] Weiss, K., Khoshgoftaar, T. M., and Wang, D. (2016). A survey of transfer learning. <em>Journal of Big Data</em>, 3(1):1-40.</p>
<p>[Wu et al., 2017] Wu, Q., Zhou, X., Yan, Y., Wu, H., and Min, H. (2017). Online transfer learning by leveraging multiple source domains. <em>Knowledge and Information Systems</em>, 52(3):687-707.</p>
<p>[xinhua, 2016] xinhua (2016). <a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYzNzAyMQ==&amp;">http://mp.weixin.qq.com/s?__biz=MjM5ODYzNzAyMQ==&amp;</a> mid=2651933920&amp;idx=1\&amp;sn=ae2866bd12000f1644eae1094497837e.</p>
<p>[Yan et al., 2017] Yan, Y., Wu, Q., Tan, M., Ng, M. K., Min, H., and Tsang, I. W. (2017). Online heterogeneous transfer by hedge ensemble of offline and online decisions. <em>IEEE transactions on neural networks and learning systems</em>.</p>
<p>[Yosinski et al., 2014] Yosinski, J., Clune, J., Bengio, Y., and Lipson, H. (2014). How transferable are features in deep neural networks? In <em>Advances in neural information processing systems</em>, pages 3320-3328.</p>
<p>[Zadrozny, 2004] Zadrozny, B. (2004). Learning and evaluating classifiers under sample selection bias. In <em>Proceedings of the twenty-first international conference on Machine learning</em>, page 114, Alberta, Canada. ACM.</p>
<p>[Zellinger et al., 2017] Zellinger, W., Grubinger, T., Lughofer, E., Natschlager, T., and Saminger-Platz, S. (2017). Central moment discrepancy (cmd) for domain-invariant rep­resentation learning. <em>arXiv preprint arXiv:1702.08811</em>.</p>
<p>[Zhang et al., 2017a] Zhang, J., Li, W., and Ogunbona, P. (2017a). Joint geometrical and statistical alignment for visual domain adaptation. In <em>CVPR</em>.</p>
<p>[Zhang et al., 2017b] Zhang, X., Zhuang, Y., Wang, W., and Pedrycz, W. (2017b). On­line feature transformation learning for cross-domain object category recognition. <em>IEEE transactions on neural networks and learning systems</em>.</p>
<p>[Zhao and Hoi, 2010] Zhao, P. and Hoi, S. C. (2010). Otl: A framework of online transfer learning. In <em>Proceedings of the 27th international conference on machine learning (ICML- 10)</em>, pages 1231-1238.</p>
<p>[Zhao et al., 2010] Zhao, Z., Chen, Y., Liu, J., and Liu, M. (2010). Cross-mobile elm based activity recognition. <em>International Journal of Engineering and Industries</em>, 1(1):30-38.</p>
<p>[Zhao et al., 2011] Zhao, Z., Chen, Y., Liu, J., Shen, Z., and Liu, M. (2011). Cross-people mobile-phone based activity recognition. In <em>Proceedings of the Twenty-Second interna­tional joint conference on Artificial Intelligence (IJCAI)</em>, volume 11, pages 2545-2550. Citeseer.</p>
<p>[Zheng et al., 2009] Zheng, V. W., Hu, D. H., and Yang, Q. (2009). Cross-domain activity recognition. In <em>Proceedings of the 11th international conference on Ubiquitous computing</em>, pages 61-70. ACM.</p>
<p>[Zheng et al., 2008] Zheng, V. W., Pan, S. J., Yang, Q., and Pan, J. J. (2008). Transferring multi-device localization models using latent multi-task learning. In <em>AAAI</em>, volume 8, pages 1427-1432, Chicago, Illinois, USA. AAAI.</p>
<p>[Zhuang et al., 2015] Zhuang, F., Cheng, X., Luo, P., Pan, S. J., and He, Q. (2015). Su­pervised representation learning: Transfer learning with deep autoencoders. In <em>IJCAI</em>,pages 4119-4125.</p>
<p>[Zhuo et al., 2017] Zhuo, J., Wang, S., Zhang, W., and Huang, Q. (2017). Deep unsuper­vised convolutional domain adaptation. In <em>Proceedings of the 2017 ACM on Multimedia Conference</em>, pages 261-269. ACM.</p>
</center></center></center></center></center></center></center></center></center></center></center></center></center></center></center></center></center>]]></content>
      <categories>
        <category>算法面试</category>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>刷八股</tag>
      </tags>
  </entry>
  <entry>
    <title>网络搭建及训练面试题</title>
    <url>/2024/03/19/deep_learning/ch12/</url>
    <content><![CDATA[<h1>网络搭建及训练</h1>
<h1>12.1 TensorFlow</h1>
<h2 id="12-1-1-TensorFlow是什么？">12.1.1 TensorFlow是什么？</h2>
<p>  TensorFlow支持各种异构平台，支持多CPU/GPU、服务器、移动设备，具有良好的跨平台的特性；TensorFlow架构灵活，能够支持各种网络模型，具有良好的通用性；此外，TensorFlow架构具有良好的可扩展性，对OP的扩展支持，Kernel特化方面表现出众。</p>
<p>  TensorFlow最初由Google大脑的研究员和工程师开发出来，用于机器学习和神经网络方面的研究，于2015.10宣布开源，在众多深度学习框架中脱颖而出，在Github上获得了最多的Star量。</p>
<h2 id="12-1-2-TensorFlow的设计理念是什么？">12.1.2 TensorFlow的设计理念是什么？</h2>
<p>TensorFlow的设计理念主要体现在两个方面：</p>
<p>（1）将图定义和图运算完全分开。<br>
  TensorFlow 被认为是一个“符号主义”的库。我们知道，编程模式通常分为命令式编程（imperative style programming）和符号式编程（symbolic style programming）。命令式编程就是编写我们理解的通常意义上的程序，很容易理解和调试，按照原有逻辑执行。符号式编程涉及很多的嵌入和优化，不容易理解和调试，但运行速度相对有所提升。现有的深度学习框架中，Torch 是典型的命令式的，Caffe、MXNet 采用了两种编程模式混合的方法，而 TensorFlow 完全采用符号式编程。</p>
<p>  符号式计算一般是先定义各种变量，然后建立一个数据流图，在数据流图中规定各个变量间的计算关系，最后需要对据流图进行编译，但此时的数据流图还是一个空壳儿，里面没有任何实际数据，只有把需要运算的输入放进去后，才能在整个模型中形成数据流，从而形成输出值。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t = 8 + 9</span><br><span class="line">print(t)</span><br></pre></td></tr></table></figure>
<p>  在传统的程序操作中，定义了 t 的运算，在运行时就执行了，并输出 17。而在 TensorFlow中，数据流图中的节点，实际上对应的是 TensorFlow API 中的一个操作，并没有真正去运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line">t = tf.add(8,9)</span><br><span class="line">print(t)</span><br><span class="line"></span><br><span class="line">#输出  Tensor&#123;&quot;Add_1:0&quot;,shape=&#123;&#125;,dtype=int32&#125;</span><br></pre></td></tr></table></figure>
<p>  （2）TensorFlow 中涉及的运算都要放在图中，而图的运行只发生在会话（session）中。开启会话后，就可以用数据去填充节点，进行运算；关闭会话后，就不能进行计算了。因此，会话提供了操作运行和 Tensor 求值的环境。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line">#创建图</span><br><span class="line">a = tf.constant([4.0,5.0])</span><br><span class="line">b = tf.constant([6.0,7.0])</span><br><span class="line">c = a * b</span><br><span class="line">#创建会话</span><br><span class="line">sess  = tf.Session()</span><br><span class="line">#计算c</span><br><span class="line">print(sess.run(c))   #进行矩阵乘法，输出[24.,35.]</span><br><span class="line">sess.close()</span><br></pre></td></tr></table></figure>
<h2 id="12-1-3-TensorFlow特点有哪些？">12.1.3 TensorFlow特点有哪些？</h2>
<h3 id="1-高度的灵活性">1.高度的灵活性</h3>
<p>  TensorFlow 并不仅仅是一个深度学习库，只要可以把你的计算过程表示称一个数据流图的过程，我们就可以使用 TensorFlow 来进行计算。TensorFlow 允许我们用计算图的方式建立计算网络，同时又可以很方便的对网络进行操作。用户可以基于 TensorFlow 的基础上用 python 编写自己的上层结构和库，如果TensorFlow没有提供我们需要的API的，我们也可以自己编写底层的 C++ 代码，通过自定义操作将新编写的功能添加到 TensorFlow 中。</p>
<h3 id="2-真正的可移植性">2.真正的可移植性</h3>
<p>  TensorFlow 可以在 CPU 和 GPU 上运行，可以在台式机、服务器、移动设备上运行。你想在你的笔记本上跑一下深度学习的训练，或者又不想修改代码，想把你的模型在多个CPU上运行， 亦或想将训练好的模型放到移动设备上跑一下，这些TensorFlow都可以帮你做到。</p>
<h3 id="3-多语言支持">3.多语言支持</h3>
<p>  TensorFlow采用非常易用的python来构建和执行我们的计算图，同时也支持 C++ 的语言。我们可以直接写python和C++的程序来执行TensorFlow，也可以采用交互式的ipython来方便的尝试我们的想法。当然，这只是一个开始，后续会支持更多流行的语言，比如Lua，JavaScript 或者R语言。</p>
<h3 id="4-丰富的算法库">4.丰富的算法库</h3>
<p>  TensorFlow提供了所有开源的深度学习框架里，最全的算法库，并且在不断的添加新的算法库。这些算法库基本上已经满足了大部分的需求，对于普通的应用，基本上不用自己再去自定义实现基本的算法库了。</p>
<h3 id="5-完善的文档">5.完善的文档</h3>
<p>  TensorFlow的官方网站，提供了非常详细的文档介绍，内容包括各种API的使用介绍和各种基础应用的使用例子，也包括一部分深度学习的基础理论。</p>
<p>  自从宣布开源以来，大量人员对TensorFlow做出贡献，其中包括Google员工，外部研究人员和独立程序员，全球各地的工程师对TensorFlow的完善，已经让TensorFlow社区变成了Github上最活跃的深度学习框架。</p>
<h2 id="12-1-4-TensorFlow的系统架构是怎样的？">12.1.4 TensorFlow的系统架构是怎样的？</h2>
<h3 id="整个系统从底层到上层可分为七层：">  整个系统从底层到上层可分为七层：</h3>
<p><img src="img%5Cch12%5C1.bmp" alt></p>
<p>  设备层：硬件计算资源，支持CPU、GPU</p>
<p>  网络层：支持两种通信协议</p>
<p>  数值计算层：提供最基础的计算，有线性计算、卷积计算</p>
<p>  高维计算层：数据的计算都是以数组的形式参与计算</p>
<p>  计算图层：用来设计神经网络的结构</p>
<p>  工作流层：提供轻量级的框架调用</p>
<p>  构造层：最后构造的深度学习网络可以通过TensorBoard服务端可视化</p>
<h2 id="12-1-5-TensorFlow编程模型是怎样的？">12.1.5 TensorFlow编程模型是怎样的？</h2>
<p>TensorFlow的编程模型：让向量数据在计算图里流动。那么在编程时至少有这几个过程：1.构建图，2.启动图，3.给图输入数据并获取结果。</p>
<h3 id="1-构建图">1.构建图</h3>
<p>TensorFlow的图的类型是tf.Graph，它包含着计算节点和tensor的集合。</p>
<p>  这里引用了两个新概念：tensor和计算节点。<br>
  我们先介绍tensor，一开始我们就介绍了，我们需要把数据输入给启动的图才能获取计算结果。那么问题来了，在构建图时用什么表示中间计算结果？这个时候tensor的概念就需要引入了。<br>
  类型是tf.Tensor，代表某个计算节点的输出，一定要看清楚是“代表”。它主要有两个作用：</p>
<p>1.构建不同计算节点之间的数据流</p>
<p>2.在启动图时，可以设置某些tensor的值，然后获取指定tensor的值。这样就完成了计算的输入输出功能。</p>
<p>如下代码所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inImage = tf.placeholder(tf.float32,[32,32,3],&quot;inputImage&quot;)</span><br><span class="line">processedImage = tf.image.per_image_standardization(inImage,&quot;processedImage&quot;)</span><br></pre></td></tr></table></figure>
<p>  这里inImage和processedImage都是tensor类型。它们代表着计算节点输出的数据，数据的值具体是多少在启动图的时候才知道。上面两个方法调用都传递了一个字符串，它是计算节点的名字，最好给节点命名，这样我们可以在图上调用get_tensor_by_name(name)获取对应的tensor对象，十分方便。（tensor名字为“&lt;计算节点名字&gt;:&lt;tensor索引&gt;”）</p>
<p>  创建tensor时，需要指定类型和shape。对不同tensor进行计算时要求类型相同，可以使用 tf.cast 进行类型转换。同时也要求 shape (向量维度)满足运算的条件，我们可以使用 tf.reshape 改变shape。</p>
<p>  现在了解计算节点的概念，其功能是对tensor进行计算、创建tensor或进行其他操作，类型是tf.Operation。获取节点对象的方法为get_operation_by_name(name)。</p>
<p>构建图，如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g=tf.Graph()</span><br><span class="line"></span><br><span class="line">with g.as_default():</span><br><span class="line">    input_data=tf.placeholder(tf.float32,[None,2],&quot;input_data&quot;)</span><br><span class="line">    input_label=tf.placeholder(tf.float32,[None,2],&quot;input_label&quot;)</span><br><span class="line"></span><br><span class="line">    W1=tf.Variable(tf.truncated_normal([2,2]),name=&quot;W1&quot;)</span><br><span class="line">    B1=tf.Variable(tf.zeros([2]),name=&quot;B1&quot;)</span><br><span class="line"></span><br><span class="line">    output=tf.add(tf.matmul(input_data,W1),B1,name=&quot;output&quot;)</span><br><span class="line">    cross_entropy=tf.nn.softmax_cross_entropy_with_logits(logits=output,labels=input_label)</span><br><span class="line"></span><br><span class="line">    train_step=tf.train.AdamOptimizer().minimize(cross_entropy,name=&quot;train_step&quot;)</span><br><span class="line"></span><br><span class="line">    initer=tf.global_variables_initializer()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  上面的代码中我们创建了一个图，并在上面添加了很多节点。我们可以通过调用get_default_graph()获取默认的图。</p>
<p>  Input_data，input_label，W1，B1，output，cross_entropy都是tensor类型，train_step，initer，是节点类型。</p>
<p>有几类tensor或节点比较重要，下面介绍一下：</p>
<h4 id="1-placeholder">1.placeholder</h4>
<p>  Tensorflow，顾名思义， tensor代表张量数据，flow代表流，其最初的设计理念就是构建一张静态的数据流图。图是有各个计算节点连接而成，计算节点之间流动的便是中间的张量数据。要想让张量数据在我们构建的静态计算图中流动起来，就必须有最初的输入数据流。而placeholder，翻译过来叫做占位符，顾名思义，是给我们的输入数据提供一个接口，也就是说我们的一切输入数据，例如训练样本数据，超参数数据等都可以通过占位符接口输送到数据流图之中。使用实例如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line">x = tf.placeholder(dtype=tf.float32,shape=[],name=&#x27;x&#x27;)</span><br><span class="line">y = tf.placeholder(dtpe=tf.float32,shape=[],nmae=&#x27;y&#x27;)</span><br><span class="line">z = x*y</span><br><span class="line">with tf.Session() as sess:</span><br><span class="line">	prod = sess.run(z,feed_dict=&#123;x:1.,y:5.2&#125;)</span><br><span class="line">	print(prod)</span><br><span class="line">[out]:5.2</span><br></pre></td></tr></table></figure>
<h4 id="2-variable">2. variable</h4>
<p>  无论是传统的机器学习算法，例如线性支持向量机（Support Vector Machine, SVM)，其数学模型为y = &lt;w,x&gt; + b，还是更先进的深度学习算法，例如卷积神经网络（Convolutional Neural Network， CNN）单个神经元输出的模型y = w*x + b。可以看到，w和b就是我们要求的模型，模型的求解是通过优化算法（对于SVM，使用<br>
SMO[1]算法，对于CNN，一般基于梯度下降法）来一步一步更新w和b的值直到满足停止条件。因此，大多数机器学习的模型中的w和b实际上是以变量的形式出现在代码中的，这就要求我们在代码中定义模型变量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line">a = tf.Variable(2.)</span><br><span class="line">b = tf.Variable(3.)</span><br><span class="line">with tf.Session() as sess:</span><br><span class="line">	sess.run(tf.global_variables_initializer()) #变量初始化</span><br><span class="line">    print(sess.run(a*b))</span><br><span class="line">[out]:6.</span><br></pre></td></tr></table></figure>
<p>[1] Platt, John. “Sequential minimal optimization: A fast algorithm for training support vector machines.” (1998).</p>
<h4 id="3-initializer">3. initializer</h4>
<p>  由于tensorflow构建的是静态的计算流图，在开启会话之前，所有的操作都不会被执行。因此为了执行在计算图中所构建的赋值初始化计算节点，需要在开启会话之后，在会话环境下运行初始化。如果计算图中定义了变量，而会话环境下为执行初始化命令，则程序报错，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line">a = tf.Variable(2.)</span><br><span class="line">b = tf.Variable(3.)</span><br><span class="line">with tf.Session() as sess:</span><br><span class="line">	#sess.run(tf.global_variables_initializer()) #注释掉初始化命令</span><br><span class="line">    print(sess.run(a*b))</span><br><span class="line">[Error]: Attempting to use uninitialized value Variable</span><br></pre></td></tr></table></figure>
<h3 id="2-启动图">2.启动图</h3>
<p>  先了解session的概念，然后才能更好的理解图的启动。<br>
  图的每个运行实例都必须在一个session里，session为图的运行提供环境。Session的类型是tf.Session，在实例化session对象时我们需要给它传递一个图对象，如果不显示给出将使用默认的图。Session有一个graph属性，我们可以通过它获取session对应的图。</p>
<p>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">numOfBatch=5</span><br><span class="line">datas=np.zeros([numOfBatch,2],np.float32)</span><br><span class="line">labels=np.zeros([numOfBatch,2],np.float32)</span><br><span class="line"></span><br><span class="line">sess=tf.Session(graph=g)</span><br><span class="line">graph=sess.graph</span><br><span class="line">sess.run([graph.get_operation_by_name(&quot;initer&quot;)])</span><br><span class="line"></span><br><span class="line">dataHolder=graph.get_tensor_by_name(&quot;input_data:0&quot;)</span><br><span class="line">labelHolder=graph.get_tensor_by_name(&quot;input_label:0&quot;)</span><br><span class="line">train=graph.get_operation_by_name(&quot;train_step&quot;)</span><br><span class="line">out=graph.get_tensor_by_name(&quot;output:0&quot;)</span><br><span class="line"></span><br><span class="line">for i inrange(200):</span><br><span class="line">   result=sess.run([out,train],feed_dict=&#123;dataHolder:datas,labelHolder:labels&#125;)</span><br><span class="line">   if i%100==0:</span><br><span class="line">       saver.save(sess,&quot;./moules&quot;)</span><br><span class="line"></span><br><span class="line">sess.close()</span><br></pre></td></tr></table></figure>
<p>代码都比较简单，就不介绍了。不过要注意2点：1.别忘记运行初始化节点，2.别忘记close掉session对象以释放资源。</p>
<h4 id="3-给图输入数据并获取结果">3.给图输入数据并获取结果</h4>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i inrange(200):</span><br><span class="line">    result=sess.run([out,train],feed_dict=&#123;dataHolder:datas,labelHolder:labels&#125;)</span><br></pre></td></tr></table></figure>
<p>  这里主要用到了session对象的run方法，它用来运行某个节点或tensor并获取对应的值。我们一般会一次传递一小部分数据进行mini-batch梯度下降来优化模型。</p>
<p>  我们需要把我们需要运行的节点或tensor放入一个列表，然后作为第一个参数(不考虑self)传递给run方法，run方法会返回一个计算结果的列表，与我们传递的参数一一对应。</p>
<p>  如果我们运行的节点依赖某个placeholder，那我们必须给这个placeholder指定值，怎么指定代码里面很清楚，给关键字参数feed_dict传递一个字典即可，字典里的元素的key是placeholder对象，value是我们指定的值。值的数据的类型必须和placeholder一致，包括shape。值本身的类型是numpy数组。</p>
<p>这里再解释一个细节，在定义placeholder时代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">input_data=tf.placeholder(tf.float32,[None,2],&quot;input_data&quot;)</span><br><span class="line">input_label=tf.placeholder(tf.float32,[None,2],&quot;input_label&quot;)</span><br></pre></td></tr></table></figure>
<p>  shape为[None,2]，说明数据第一个维度是不确定的，然后TensorFlow会根据我们传递的数据动态推断第一个维度，这样我们就可以在运行时改变batch的大小。比如一个数据是2维，一次传递10个数据对应的tensor的shape就是[10,2]。可不可以把多个维度指定为None？理论上不可以！</p>
<h2 id="12-1-6-如何基于tensorflow搭建VGG16">12.1.6 如何基于tensorflow搭建VGG16</h2>
<p>​	介绍完关于tensorflow的基础知识，是时候来一波网络搭建实战了。虽然网上有很多相关教程，但我想从最标准的tensorflow代码和语法出发（而不是调用更高级的API，失去了原来的味道），向大家展示如何搭建其标准的VGG16网络架构。话不多说，上代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_weight_variable</span>(<span class="params">shape</span>):</span><br><span class="line">    <span class="keyword">return</span> tf.get_variable(<span class="string">&#x27;weight&#x27;</span>, shape=shape, initializer=tf.truncated_normal_initializer(stddev=<span class="number">0.1</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_bias_variable</span>(<span class="params">shape</span>):</span><br><span class="line">    <span class="keyword">return</span> tf.get_variable(<span class="string">&#x27;bias&#x27;</span>, shape=shape, initializer=tf.constant_initializer(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">conv2d</span>(<span class="params">x, w, padding = <span class="string">&#x27;SAME&#x27;</span>, s=<span class="number">1</span></span>):</span><br><span class="line">    x = tf.nn.conv2d(x, w, strides=[<span class="number">1</span>, s, s, <span class="number">1</span>], padding = padding)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">maxPoolLayer</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> tf.nn.max_pool(x, ksize = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>],</span><br><span class="line">                          strides = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>], padding = <span class="string">&#x27;SAME&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">conv2d_layer</span>(<span class="params">x,in_chs, out_chs, ksize, layer_name</span>):</span><br><span class="line">    <span class="keyword">with</span> tf.variable_scope(layer_name):</span><br><span class="line">        w = get_weight_variable([ksize, ksize, in_chs, out_chs])</span><br><span class="line">        b = get_bias_variable([out_chs])</span><br><span class="line">        y = tf.nn.relu(tf.bias_add(conv2d(x,w,padding = <span class="string">&#x27;SAME&#x27;</span>, s=<span class="number">1</span>), b))</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fc_layer</span>(<span class="params">x,in_kernels, out_kernels, layer_name</span>):</span><br><span class="line">    <span class="keyword">with</span> tf.variable_scope(layer_name):</span><br><span class="line">        w = get_weight_variable([in_kernels,out_kernels])</span><br><span class="line">        b = get_bias_variable([out_kernels])</span><br><span class="line">        y = tf.nn.relu(tf.bias_add(tf.matmul(x,w),b))</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">VGG16</span>(<span class="params">x</span>):</span><br><span class="line">    conv1_1 = conv2d_layer(x,tf.get_shape(x).as_list()[-<span class="number">1</span>], <span class="number">64</span>, <span class="number">3</span>, <span class="string">&#x27;conv1_1&#x27;</span>)</span><br><span class="line">    conv1_2 = conv2d_layer(conv1_1,<span class="number">64</span>, <span class="number">64</span>, <span class="number">3</span>, <span class="string">&#x27;conv1_2&#x27;</span>)</span><br><span class="line">    pool_1 = maxPoolLayer(conv1_2)</span><br><span class="line">    </span><br><span class="line">    conv2_1 = conv2d_layer(pool1,<span class="number">64</span>, <span class="number">128</span>, <span class="number">3</span>, <span class="string">&#x27;conv2_1&#x27;</span>)</span><br><span class="line">    conv2_2 = conv2d_layer(conv2_1,<span class="number">128</span>, <span class="number">128</span>, <span class="number">3</span>, <span class="string">&#x27;conv2_2&#x27;</span>)</span><br><span class="line">    pool2 = maxPoolLayer(conv2_2)</span><br><span class="line">    </span><br><span class="line">	conv3_1 = conv2d_layer(pool2,<span class="number">128</span>, <span class="number">256</span>, <span class="number">3</span>, <span class="string">&#x27;conv3_1&#x27;</span>)</span><br><span class="line">    conv3_2 = conv2d_layer(conv3_1,<span class="number">256</span>, <span class="number">256</span>, <span class="number">3</span>, <span class="string">&#x27;conv3_2&#x27;</span>)</span><br><span class="line">	conv3_3 = conv2d_layer(conv3_2,<span class="number">256</span>, <span class="number">256</span>, <span class="number">3</span>, <span class="string">&#x27;conv3_3&#x27;</span>)</span><br><span class="line">    pool3 = maxPoolLayer(conv3_3)</span><br><span class="line">    </span><br><span class="line">	conv4_1 = conv2d_layer(pool3,<span class="number">256</span>, <span class="number">512</span>, <span class="number">3</span>, <span class="string">&#x27;conv4_1&#x27;</span>)</span><br><span class="line">    conv4_2 = conv2d_layer(conv4_1,<span class="number">512</span>, <span class="number">512</span>, <span class="number">3</span>, <span class="string">&#x27;conv4_2&#x27;</span>)</span><br><span class="line">	conv4_3 = conv2d_layer(conv4_2,<span class="number">512</span>, <span class="number">512</span>, <span class="number">3</span>, <span class="string">&#x27;conv4_3&#x27;</span>)</span><br><span class="line">    pool4 = maxPoolLayer(conv4_3)</span><br><span class="line">    </span><br><span class="line">	conv5_1 = conv2d_layer(pool4,<span class="number">512</span>, <span class="number">512</span>, <span class="number">3</span>, <span class="string">&#x27;conv5_1&#x27;</span>)</span><br><span class="line">    conv5_2 = conv2d_layer(conv5_1,<span class="number">512</span>, <span class="number">512</span>, <span class="number">3</span>, <span class="string">&#x27;conv5_2&#x27;</span>)</span><br><span class="line">	conv5_3 = conv2d_layer(conv5_1,<span class="number">512</span>, <span class="number">512</span>, <span class="number">3</span>, <span class="string">&#x27;conv5_3&#x27;</span>)</span><br><span class="line">    pool5 = maxPoolLayer(conv5_3)</span><br><span class="line">    </span><br><span class="line">	pool5_flatten_dims = <span class="built_in">int</span>(np.prod(pool5.get_shape().as_list()[<span class="number">1</span>:]))</span><br><span class="line">    pool5_flatten = tf.reshape(pool5,[-<span class="number">1</span>,pool5_flatten_dims])</span><br><span class="line">    </span><br><span class="line">    fc_6 = fc_layer(pool5_flatten, pool5_flatten_dims, <span class="number">4096</span>, <span class="string">&#x27;fc6&#x27;</span>)</span><br><span class="line">	fc_7 = fc_layer(fc_6, <span class="number">4096</span>, <span class="number">4096</span>, <span class="string">&#x27;fc7&#x27;</span>)</span><br><span class="line">	fc_8 = fc_layer(fc_7, <span class="number">4096</span>, <span class="number">10</span>, <span class="string">&#x27;fc8&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> fc_8</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<h1>12.2 Pytorch</h1>
<h2 id="12-2-1-Pytorch是什么？">12.2.1 Pytorch是什么？</h2>
<p>  Pytorch是torch的python版本，是由Facebook开源的神经网络框架，专门针对 GPU 加速的深度神经网络（DNN）编程。Torch 是一个经典的对多维矩阵数据进行操作的张量（tensor ）库，在机器学习和其他数学密集型应用有广泛应用。与Tensorflow的静态计算图不同，pytorch的计算图是动态的，可以根据计算需要实时改变计算图。但由于Torch语言采用 Lua，导致在国内一直很小众，并逐渐被支持 Python 的 Tensorflow 抢走用户。作为经典机器学习库 Torch 的端口，PyTorch 为 Python 语言使用者提供了舒适的写代码选择。</p>
<h2 id="12-2-2-为什么选择-Pytorch？">12.2.2 为什么选择 Pytorch？</h2>
<h3 id="1-简洁：">1.简洁：</h3>
<p>  PyTorch的设计追求最少的封装，尽量避免重复造轮子。不像 TensorFlow 中充斥着session、graph、operation、name_scope、variable、tensor、layer等全新的概念，PyTorch 的设计遵循tensor→variable(autograd)→nn.Module 三个由低到高的抽象层次，分别代表高维数组（张量）、自动求导（变量）和神经网络（层/模块），而且这三个抽象之间联系紧密，可以同时进行修改和操作。<br>
简洁的设计带来的另外一个好处就是代码易于理解。PyTorch的源码只有TensorFlow的十分之一左右，更少的抽象、更直观的设计使得PyTorch的源码十分易于阅读。</p>
<h3 id="2-速度：">2.速度：</h3>
<p>  PyTorch 的灵活性不以速度为代价，在许多评测中，PyTorch 的速度表现胜过 TensorFlow和Keras 等框架。框架的运行速度和程序员的编码水平有极大关系，但同样的算法，使用PyTorch实现的那个更有可能快过用其他框架实现的。</p>
<h3 id="3-易用：">3.易用：</h3>
<p>  PyTorch 是所有的框架中面向对象设计的最优雅的一个。PyTorch的面向对象的接口设计来源于Torch，而Torch的接口设计以灵活易用而著称，Keras作者最初就是受Torch的启发才开发了Keras。PyTorch继承了Torch的衣钵，尤其是API的设计和模块的接口都与Torch高度一致。PyTorch的设计最符合人们的思维，它让用户尽可能地专注于实现自己的想法，即所思即所得，不需要考虑太多关于框架本身的束缚。</p>
<h3 id="4-活跃的社区：">4.活跃的社区：</h3>
<p>  PyTorch 提供了完整的文档，循序渐进的指南，作者亲自维护的论坛 供用户交流和求教问题。Facebook 人工智能研究院对 PyTorch 提供了强力支持，作为当今排名前三的深度学习研究机构，FAIR的支持足以确保PyTorch获得持续的开发更新，不至于像许多由个人开发的框架那样昙花一现。</p>
<h2 id="12-2-3-PyTorch-的架构是怎样的？">12.2.3 PyTorch 的架构是怎样的？</h2>
<p>  PyTorch(Caffe2) 通过混合前端，分布式训练以及工具和库生态系统实现快速，灵活的实验和高效生产。PyTorch 和 TensorFlow 具有不同计算图实现形式，TensorFlow 采用静态图机制(预定义后再使用)，PyTorch采用动态图机制(运行时动态定义)。PyTorch 具有以下高级特征：</p>
<p>  混合前端:新的混合前端在急切模式下提供易用性和灵活性，同时无缝转换到图形模式，以便在C ++运行时环境中实现速度，优化和功能。<br>
  分布式训练:通过利用本地支持集合操作的异步执行和可从Python和C ++访问的对等通信，优化了性能。<br>
  Python优先: PyTorch为了深入集成到Python中而构建的，因此它可以与流行的库和Cython和Numba等软件包一起使用。<br>
  丰富的工具和库:活跃的研究人员和开发人员社区建立了丰富的工具和库生态系统，用于扩展PyTorch并支持从计算机视觉到强化学习等领域的开发。<br>
  本机ONNX支持:以标准ONNX（开放式神经网络交换）格式导出模型，以便直接访问与ONNX兼容的平台，运行时，可视化工具等。<br>
  C++前端：C++前端是PyTorch的纯C++接口，它遵循已建立的Python前端的设计和体系结构。它旨在实现高性能，低延迟和裸机C++应用程序的研究。<br>
使用GPU和CPU优化的深度学习张量库。</p>
<h2 id="12-2-4-Pytorch-与-tensorflow-之间的差异在哪里？">12.2.4 Pytorch 与 tensorflow 之间的差异在哪里？</h2>
<p>  上面也将了PyTorch 最大优势是建立的神经网络是动态的, 对比静态的 Tensorflow, 它能更有效地处理一些问题, 比如说 RNN 变化时间长度的输出。各有各的优势和劣势。两者都是大公司发布的, Tensorflow（Google）宣称在分布式训练上下了很大的功夫, 那就默认 Tensorflow 在分布式训练上要超出 Pytorch（Facebook），还有tensorboard可视化工具, 但是 Tensorflow 的静态计算图使得在 RNN 上有一点点被动 (虽然它用其他途径解决了), 不过用 PyTorch 的时候, 会对这种动态的 RNN 有更好的理解。而且 Tensorflow 的高度工业化, 它的底层代码很难看懂， Pytorch 好那么一点点, 如果深入 PytorchAPI, 至少能比看 Tensorflow 多看懂一点点 Pytorch 的底层在干啥。</p>
<h2 id="12-2-5-Pytorch有哪些常用工具包？">12.2.5 Pytorch有哪些常用工具包？</h2>
<p>  torch ：类似 NumPy 的张量库，强 GPU 支持 ；<br>
  torch.autograd ：基于 tape 的自动区别库，支持 torch 之中的所有可区分张量运行；<br>
  torch.nn ：为最大化灵活性未涉及、与 autograd 深度整合的神经网络库；<br>
  torch.optim：与 torch.nn 一起使用的优化包，包含 SGD、RMSProp、LBFGS、Adam 等标准优化方式；<br>
  torch.multiprocessing： python 多进程并发，进程之间 torch Tensors 的内存共享；<br>
  torch.utils：数据载入器。具有训练器和其他便利功能；<br>
  torch.legacy(.nn/.optim) ：处于向后兼容性考虑，从 Torch 移植来的 legacy 代码；</p>
<h1>12.3 Caffe</h1>
<h2 id="12-3-1-什么是-Caffe？">12.3.1 什么是 Caffe？</h2>
<p>  Caffe的全称应该是Convolutional Architecture for Fast Feature Embedding，它是一个清晰、高效的深度学习框架，它是开源的，核心语言是C++，它支持命令行、Python和Matlab接口，它既可以在CPU上运行也可以在GPU上运行。它的license是BSD 2-Clause。</p>
<h2 id="12-3-2-Caffe的特点是什么？">12.3.2 Caffe的特点是什么？</h2>
<p>(1)、模块化：Caffe从一开始就设计得尽可能模块化，允许对新数据格式、网络层和损失函数进行扩展。</p>
<p>(2)、表示和实现分离：Caffe的模型(model)定义是用Protocol Buffer语言写进配置文件的。以任意有向无环图的形式，Caffe支持网络架构。Caffe会根据网络的需要来正确占用内存。通过一个函数调用，实现CPU和GPU之间的切换。</p>
<p>(3)、测试覆盖：在Caffe中，每一个单一的模块都对应一个测试。</p>
<p>(4)、python和Matlab接口：同时提供Python和Matlab接口。</p>
<p>(5)、预训练参考模型：针对视觉项目，Caffe提供了一些参考模型，这些模型仅应用在学术和非商业领域，它们的license不是BSD。</p>
<h2 id="12-3-3-Caffe的设计思想是怎样的？">12.3.3 Caffe的设计思想是怎样的？</h2>
<p>  基本上，Caffe 沿用了神经网络的一个简单假设----所有的计算都是以layer的形式表示的，layer做的事情就是take一些数据，然后输出一些计算以后的结果，比如说卷积，就是输入一个图像，然后和这一层的参数（filter）做卷积，然后输出卷积的结果。每一个layer需要做两个计算：forward是从输入计算输出，然后backward是从上面给的gradient来计算相对于输入的gradient，只要这两个函数实现了以后，我们就可以把很多层连接成一个网络，这个网络做的事情就是输入我们的数据（图像或者语音或者whatever），然后来计算我们需要的输出（比如说识别的label），在training的时候，我们可以根据已有的label来计算loss和gradient，然后用gradient来update网络的参数，这个就是Caffe的一个基本流程。</p>
<p>  基本上，最简单地用Caffe上手的方法就是先把数据写成Caffe的格式，然后设计一个网络，然后用Caffe提供的solver来做优化看效果如何，如果你的数据是图像的话，可以从现有的网络，比如说alexnet或者googlenet开始，然后做fine tuning，如果你的数据稍有不同，比如说是直接的float vector，你可能需要做一些custom的configuration，Caffe的logistic regression example兴许会很有帮助。</p>
<p>  Fine tune方法：fine tuning的想法就是说，在imagenet那么大的数据集上train好一个很牛的网络了，那别的task上肯定也不错，所以我们可以把pretrain的网络拿过来，然后只重新train最后几层，重新train的意思是说，比如我以前需要classify imagenet的一千类，现在我只想识别是狗还是猫，或者是不是车牌，于是我就可以把最后一层softmax从一个4096<em>1000的分类器变成一个4096</em>2的分类器，这个strategy在应用中非常好使，所以我们经常会先在imagenet上pretrain一个网络，因为我们知道imagenet上training的大概过程会怎么样。</p>
<h2 id="12-3-4-Caffe架构是怎样的？">12.3.4 Caffe架构是怎样的？</h2>
<p>  Caffe的架构与其它的深度学习框架稍微不同，它没有根据算法实现过程的方式来进行编码，而是以系统级的抽象作为整体架构，逐层的封装实现细节，使得上层的架构变得很清晰。Caffe的整体架构如下：</p>
<h3 id="1-SyncedMem">1. SyncedMem</h3>
<p>  这个类的主要功能是封装CPU和GPU的数据交互操作。一般来说，数据的流动形式都是：硬盘-&gt;CPU内存-&gt;GPU内存-&gt;CPU内存-&gt;（硬盘），所以在写代码的过程中经常会写CPU/GPU之间数据传输的代码，同时还要维护CPU和GPU两个处理端的内存指针。这些事情处理起来不会很难，但是会很繁琐。因此SyncedMem的出现就是把CPU/GPU的数据传输操作封装起来，只需要调用简单的接口就可以获得两个处理端同步后的数据。</p>
<h3 id="2-Blob">2. Blob</h3>
<p>  Blob是用于存储数据的对象，在Caffe中各种数据(图像输入、模型参数)都是以Blob的形式在网络中传输的，Blob提供统一的存储操作接口，可用来保存训练数据、模型参数等，同时Blob还能在CPU和GPU之间进行同步以支持CPU/GPU的混合运算。<br>
  这个类做了两个封装：一个是操作数据的封装，使用Blob可以操纵高维的数据，快速访问其中的数据，变换数据的维度等；另一个是对原始数据和更新量的封装，每一个Blob中都有data和diff两个数据指针，data用于存储原始数据，diff 用于存储反向传播（Backpropagation）的梯度更新值。Blob使用了SyncedMem，这样便于访问不同的处理端。Blob基本实现了整个Caffe数据结构部分的封装，在Net类中可以看到所有的前后向数据和参数都用Blob来表示就足够了。数据的抽象到这个就可以了，接下来作层级的抽象。神经网络的前后向计算可以做到层与层之间完全独立，只要每个层按照一定的接口规则实现，就可以确保整个网络的正确性。</p>
<h3 id="3-Layer">3. Layer</h3>
<p>  Layer是网络Net的基本单元，也是Caffe中能在外部进行调整的最小网络结构单元，每个Layer都有输入Blob和输出Blob。Layer（层）是Caffe中最庞大最繁杂的模块，它是神经网络的基本计算单元。由于Caffe强调模块化设计，因此只允许每个layer完成一类特定的计算，例如convolution操作、pooling、非线性变换、内积运算，以及数据加载、归一化和损失计算等。Caffe中layer的种类有很多，具体的种类及功能请看官方文档。在创建一个Caffe模型的时候，也是以Layer为基础进行的。Layer是一个父类，它的下面还有各种实现特定功能的子类，例如data_layer，conv_layer，loss_layer等。Layer是通过LayFactory来创建的。</p>
<h3 id="4-Net">4. Net</h3>
<p>  Net是一个完整的深度网络，包含输入层、隐藏层、输出层，在Caffe中一般是一个卷积神经网络(Convolution Neural Networ，CNN)。通过定义不同类型的Layer，并用Blob将不同的Layer连接起来，就能产生一个Net。Net将数据Blob和层Layer组合起来做进一步的封装，对外提供了初始化和前后传播的接口，使得整体看上去和一个层的功能类似，但内部的组合可以是多种多样的。值得一提的是，每一层的输入输出数据统一保存在Net中，同时每个层内的参数指针也保存在Net中，不同的层可以通过WeightShare共享相同的参数，因此可以通过配置来实现多个神经网络层之间共享参数的功能。一个Net由多个Layer组成。一个典型的网络从data layer（从磁盘中载入数据）出发到loss layer结束。</p>
<h3 id="5-Solver">5. Solver</h3>
<p>  有了Net就可以进行神经网络的前后向传播计算了，但是还缺少神经网络的训练和预测功能，Solver类进一步封装了训练和预测相关的一些功能。它还提供了两个接口：一个是更新参数的接口，继承Solver可以实现不同的参数更新方法，如Momentum，Nesterov，Adagrad等，因此可以使用不同的优化算法。另一个接口是训练过程中每一轮特定状态下的可注入的一些回调函数，在代码中这个回调点的直接使用者就是多GPU训练算法。Solver定义了针对Net网络模型的求解方法，记录网络的训练过程，保存网络模型参数，中断并恢复网络的训练过程。自定义Solver能够实现不同的神经网络求解方式。阅读Solver的代码可以了解网络的求解优化过程。Solver是一个父类，它下面还有实现不同优化方法的子类，例如sgd_solver，adagrad_sovler等，Solver是通过SolverFactory来创建的。</p>
<h3 id="6-Proto">6. Proto</h3>
<p>  caffe.proto位于…/src/caffe/proto目录下，在这个文件夹下还有一个.pb.cc和一个.pb.h文件，这两个文件都是由caffe.proto编译而来的。 在caffe.proto中定义了很多结构化数据，包括：<br>
BlobProto、Datum、FillerParameter、NetParameter、SolverParameter、SolverState、LayerParameter、ConcatParameter、ConvolutionParameter、DataParameter、DropoutParameter、HDF5DataParameter、HDF5OutputParameter、ImageDataParameter、InfogainLossParameter、InnerProductParameter、LRNParameter、MemoryDataParameter、PoolingParameter、PowerParameter、WindowDataParameter、V0LayerParameter。</p>
<h3 id="7-IO">7. IO</h3>
<p>  除了上面的东西之外，还需要输入数据和参数。DataReader和DataTransformer帮助准备输入数据，Filler对参数进行初始化，一些Snapshot方法可以对模型进行持久化。</p>
<h2 id="12-3-5-Caffe的有哪些接口？">12.3.5 Caffe的有哪些接口？</h2>
<p>  Caffe深度学习框架支持多种编程接口，包括命令行、Python和Matlab,下面将介绍如何使用这些接口。</p>
<h3 id="1-Caffe-Python接口">1. Caffe Python接口</h3>
<p>  Caffe提供 Python 接口，即Pycaffe，具体实现在caffe、python文件夹内。在Python代码中import caffe，可以load models（导入模型）、forward and backward （前向、反向迭代）、handle IO（数据输入输出）、visualize networks（绘制net）和instrument model solving（自定义优化方法)。所有的模型数据、计算参数都是暴露在外、可供读写的。<br>
  (1)<a href="http://caffe.Net">caffe.Net</a> 是主要接口，负责导入数据、校验数据、计算模型。<br>
  (2)caffe.Classsifier 用于图像分类。<br>
  (3)caffe.Detector 用于图像检测。<br>
  (4)caffe.SGDSolver 是露在外的 solver 的接口。<br>
  (5)<a href="http://caffe.io">caffe.io</a> 处理输入输出，数据预处理。<br>
  (6)caffe.draw 可视化 net 的结构。<br>
  (7)caffe blobs 以 numpy ndarrys 的形式表示，方便而且高效。</p>
<h3 id="2-Caffe-MATLAB接口">2. Caffe MATLAB接口</h3>
<p>  MATLAB接口（Matcaffe）在 caffe/matlab 目录的 caffe 软件包。在 matcaffe 的基础上，可将Caffe整合到MATLAB代码中。<br>
  MATLAB接口包括：<br>
  (1)MATLAB 中创建多个网络结构。<br>
  (2)网络的前向传播（Forward）与反向传播（Backward）计算。<br>
  (3)网络中的任意一层以及参数的存取。<br>
  (4)网络参数保存至文件或从文件夹加载。<br>
  (5)blob 和 network 形状调整。<br>
  (6)网络参数编辑和调整。<br>
  (7)创建多个 solvers 进行训练。<br>
  (8)从solver 快照（Snapshots）恢复并继续训练。<br>
  (9)访问训练网络（Train nets）和测试网络(Test nets)。<br>
  (10)迭代后网络交由 MATLAB 控制。<br>
  (11)MATLAB代码融合梯度算法。</p>
<h3 id="3-Caffe-命令行接口">3. Caffe 命令行接口</h3>
<p>  命令行接口 Cmdcaffe 是 Caffe 中用来训练模型、计算得分以及方法判断的工具。Cmdcaffe 存放在 caffe/build/tools 目录下。</p>
<h4 id="1-caffe-train">1. caffe train</h4>
<p>  caffe train 命令用于模型学习，具体包括：<br>
  (1)caffe train 带 solver.prototxt 参数完成配置。<br>
  (2)caffe train 带 snapshot mode_iter_1000.solverstate 参数加载 solver snapshot。<br>
  (3)caffe train 带 weights 参数 model.caffemodel 完成 Fine-tuning 模型初始化。</p>
<h4 id="2-caffe-test">2. caffe test</h4>
<p>  caffe test 命令用于测试运行模型的得分，并且用百分比表示网络输出的最终结果，比如 accuracyhuoloss 作为其结果。测试过程中，显示每个 batch 的得分，最后输出全部 batch 的平均得分值。</p>
<h4 id="3-caffe-time">3. caffe time</h4>
<p>  caffe time 命令用来检测系统性能和测量模型相对执行时间，此命令通过逐层计时与同步，执行模型检测。</p>
<p>参考文献：<br>
1.深度学习：Caffe之经典模型讲解与实战/ 乐毅，王斌</p>
<h3 id="10-4-网络搭建有什么原则？">10.4 网络搭建有什么原则？</h3>
<h3 id="10-4-1新手原则。">10.4.1新手原则。</h3>
<p>刚入门的新手不建议直接上来就开始搭建网络模型。比较建议的学习顺序如下：</p>
<ul>
<li>1.了解神经网络工作原理，熟悉基本概念及术语。</li>
<li>2.阅读经典网络模型论文+实现源码(深度学习框架视自己情况而定)。</li>
<li>3.找数据集动手跑一个网络，可以尝试更改已有的网络模型结构。</li>
<li>4.根据自己的项目需要设计网络。</li>
</ul>
<h3 id="10-4-2深度优先原则。">10.4.2深度优先原则。</h3>
<p>通常增加网络深度可以提高准确率，但同时会牺牲一些速度和内存。但深度不是盲目堆起来的，一定要在浅层网络有一定效果的基础上，增加深度。深度增加是为了增加模型的准确率，如果浅层都学不到东西，深了也没效果。</p>
<h3 id="10-4-3卷积核size一般为奇数。">10.4.3卷积核size一般为奇数。</h3>
<p>卷积核为奇数有以下好处：</p>
<ul>
<li>1 保证锚点刚好在中间，方便以 central pixel为标准进行滑动卷积，避免了位置信息发生偏移 。</li>
<li>2 保证在填充（Padding）时，在图像之间添加额外的零层，图像的两边仍然对称。</li>
</ul>
<h3 id="10-4-4卷积核不是越大越好。">10.4.4卷积核不是越大越好。</h3>
<p>AlexNet中用到了一些非常大的卷积核，比如11×11、5×5卷积核，之前人们的观念是，卷积核越大，感受野越大，看到的图片信息越多，因此获得的特征越好。但是大的卷积核会导致计算量的暴增，不利于模型深度的增加，计算性能也会降低。于是在VGG、Inception网络中，利用2个3×3卷积核的组合比1个5×5卷积核的效果更佳，同时参数量（3×3×2+1=19&lt;26=5×5×1+1）被降低，因此后来3×3卷积核被广泛应用在各种模型中。</p>
<h2 id="10-5-有哪些经典的网络模型值得我们去学习的？">10.5 有哪些经典的网络模型值得我们去学习的？</h2>
<p>提起经典的网络模型就不得不提起计算机视觉领域的经典比赛：ILSVRC .其全称是 ImageNet Large Scale Visual Recognition Challenge.正是因为ILSVRC 2012挑战赛上的AlexNet横空出世，使得全球范围内掀起了一波深度学习热潮。这一年也被称作“深度学习元年”。而在历年ILSVRC比赛中每次刷新比赛记录的那些神经网络也成为了人们心中的经典，成为学术界与工业届竞相学习与复现的对象，并在此基础上展开新的研究。</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>年份</th>
<th>网络名称</th>
<th>获得荣誉</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2012</td>
<td>AlexNet</td>
<td>ILSVRC图像分类冠军</td>
</tr>
<tr>
<td>2</td>
<td>2014</td>
<td>VGGNet</td>
<td>ILSVRC图像分类亚军</td>
</tr>
<tr>
<td>3</td>
<td>2014</td>
<td>GoogLeNet</td>
<td>ILSVRC图像分类冠军</td>
</tr>
<tr>
<td>4</td>
<td>2015</td>
<td>ResNet</td>
<td>ILSVRC图像分类冠军</td>
</tr>
<tr>
<td>5</td>
<td>2017</td>
<td>SeNet</td>
<td>ILSVRC图像分类冠军</td>
</tr>
</tbody>
</table>
<blockquote>
<ul>
<li>1 AlexNet<br>
论文:<a href="https://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf">ImageNet Classification with Deep Convolutional Neural Networks</a><br>
代码实现:<a href="https://github.com/tensorflow/tensorflow/blob/361a82d73a50a800510674b3aaa20e4845e56434/tensorflow/contrib/slim/python/slim/nets/alexnet.py">tensorflow</a><br>
主要特点：</li>
</ul>
<blockquote>
<ul>
<li>1.第一次使用非线性激活函数ReLU。</li>
<li>2.增加防加过拟合方法：Droupout层,提升了模型鲁棒性。</li>
<li>3.首次使用数据增强。</li>
<li>4.首次使用GPU加速运算。</li>
</ul>
</blockquote>
</blockquote>
<blockquote>
<ul>
<li>2 VGGNet<br>
论文:<a href="https://arxiv.org/abs/1409.1556">Very Deep Convolutional Networks for Large-Scale Image Recognition</a><br>
代码实现:<a href="https://github.com/tensorflow/tensorflow/blob/361a82d73a50a800510674b3aaa20e4845e56434/tensorflow/contrib/slim/python/slim/nets/vgg.py">tensorflow</a><br>
主要特点：</li>
</ul>
<blockquote>
<ul>
<li>1.网络结构更深。</li>
<li>2.普遍使用小卷积核。</li>
</ul>
</blockquote>
</blockquote>
<blockquote>
<ul>
<li>3 GoogLeNet<br>
论文:<a href="https://arxiv.org/abs/1409.4842">Going Deeper with Convolutions</a><br>
代码实现:<a href="https://github.com/tensorflow/tensorflow/blob/361a82d73a50a800510674b3aaa20e4845e56434/tensorflow/contrib/slim/python/slim/nets/inception_v1.py">tensorflow</a><br>
主要特点：</li>
</ul>
<blockquote>
<ul>
<li>1.增强卷积模块功能。<br>
主要的创新在于他的Inception，这是一种网中网（Network In Network）的结构，即原来的结点也是一个网络。Inception一直在不断发展，目前已经V2、V3、V4。其中1*1卷积主要用来降维，用了Inception之后整个网络结构的宽度和深度都可扩大，能够带来2-3倍的性能提升。</li>
<li>2.连续小卷积代替大卷积，保证感受野不变的同时，减少了参数数目。</li>
</ul>
</blockquote>
<ul>
<li>4 ResNet<br>
论文:<a href="https://arxiv.org/abs/1512.03385">Deep Residual Learning for Image Recognition</a><br>
代码实现:<a href="https://github.com/tensorflow/tensorflow/blob/361a82d73a50a800510674b3aaa20e4845e56434/tensorflow/contrib/slim/python/slim/nets/inception_v1.py">tensorflow</a><br>
主要特点:</li>
</ul>
<blockquote>
<p>解决了“退化”问题，即当模型的层次加深时，错误率却提高了。</p>
</blockquote>
<ul>
<li>5 SeNet<br>
论文:<a href="https://arxiv.org/abs/1709.01507">Squeeze-and-Excitation Networks</a><br>
代码实现:<a href="https://github.com/ry/tensorflow-resnet">tensorflow</a><br>
主要特点:</li>
</ul>
<blockquote>
<p>提出了feature recalibration，通过引入 attention 重新加权，可以得到抑制无效特征，提升有效特征的权重，并很容易地和现有网络结合，提升现有网络性能，而计算量不会增加太多。</p>
</blockquote>
</blockquote>
<p><strong>CV领域网络结构演进历程：</strong><br>
<img src="%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%E6%BC%94%E8%BF%9B.png" alt="CV领域网络结构演进历程"></p>
<p><strong>ILSVRC挑战赛历年冠军:</strong><br>
<img src="%E5%8E%86%E5%B9%B4%E5%86%A0%E5%86%9B.png" alt="ILSVRC挑战赛历年冠军"></p>
<p>此后，ILSVRC挑战赛的名次一直是衡量一个研究机构或企业技术水平的重要标尺。<br>
ILSVRC 2017 已是最后一届举办.2018年起，将由WebVision竞赛（Challenge on Visual Understanding by Learning from Web Data）来接棒。因此，即使ILSVRC挑战赛停办了，但其对深度学习的深远影响和巨大贡献，将永载史册。</p>
<h2 id="10-6-网络训练有哪些技巧吗？">10.6 网络训练有哪些技巧吗？</h2>
<h3 id="10-6-1-合适的数据集。">10.6.1.合适的数据集。</h3>
<ul>
<li>1 没有明显脏数据(可以极大避免Loss输出为NaN)。</li>
<li>2 样本数据分布均匀。</li>
</ul>
<h3 id="10-6-2-合适的预处理方法。">10.6.2.合适的预处理方法。</h3>
<p>关于数据预处理，在Batch Normalization未出现之前预处理的主要做法是减去均值，然后除去方差。在Batch Normalization出现之后，减均值除方差的做法已经没有必要了。对应的预处理方法主要是数据筛查、数据增强等。</p>
<h3 id="10-6-3-网络的初始化。">10.6.3.网络的初始化。</h3>
<p>网络初始化最粗暴的做法是参数赋值为全0，这是绝对不可取的。因为如果所有的参数都是0，那么所有神经元的输出都将是相同的，那在back propagation的时候同一层内所有神经元的行为也是相同的，这可能会直接导致模型失效，无法收敛。吴恩达视频中介绍的方法是将网络权重初始化均值为0、方差为1符合的正态分布的随机数据。</p>
<h3 id="10-6-4-小规模数据试练。">10.6.4.小规模数据试练。</h3>
<p>在正式开始训练之前，可以先用小规模数据进行试练。原因如下：</p>
<ul>
<li>1 可以验证自己的训练流程对否。</li>
<li>2 可以观察收敛速度，帮助调整学习速率。</li>
<li>3 查看GPU显存占用情况，最大化batch_size(前提是进行了batch normalization，只要显卡不爆，尽量挑大的)。</li>
</ul>
<h3 id="10-6-5-设置合理Learning-Rate。">10.6.5.设置合理Learning Rate。</h3>
<ul>
<li>1 太大。Loss爆炸、输出NaN等。</li>
<li>2 太小。收敛速度过慢，训练时长大大延长。</li>
<li>3 可变的学习速率。比如当输出准确率到达某个阈值后，可以让Learning Rate减半继续训练。</li>
</ul>
<h3 id="10-6-6-损失函数">10.6.6.损失函数</h3>
<p>损失函数主要分为两大类:分类损失和回归损失</p>
<blockquote>
<p>1.回归损失：</p>
<blockquote>
<ul>
<li>1 均方误差(MSE 二次损失 L2损失)<br>
它是我们的目标变量与预测值变量差值平方。</li>
<li>2 平均绝对误差(MAE L1损失)<br>
它是我们的目标变量与预测值变量差值绝对值。<br>
关于MSE与MAE的比较。MSE更容易解决问题，但是MAE对于异常值更加鲁棒。更多关于MAE和MSE的性能，可以参考<a href="https://rishy.github.io/ml/2015/07/28/l1-vs-l2-loss/">L1vs.L2 Loss Function</a></li>
</ul>
</blockquote>
</blockquote>
<blockquote>
<p>2.分类损失：</p>
<blockquote>
<ul>
<li>1 交叉熵损失函数。<br>
是目前神经网络中最常用的分类目标损失函数。</li>
<li>2 合页损失函数<br>
合页损失函数广泛在支持向量机中使用，有时也会在损失函数中使用。缺点:合页损失函数是对错误越大的样本施以更严重的惩罚，但是这样会导致损失函数对噪声敏感。</li>
</ul>
</blockquote>
</blockquote>
]]></content>
      <categories>
        <category>算法面试</category>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>刷八股</tag>
      </tags>
  </entry>
  <entry>
    <title>优化算法面试题</title>
    <url>/2024/03/19/deep_learning/ch13/</url>
    <content><![CDATA[<h1>优化算法</h1>
<h2 id="13-1-如何解决训练样本少的问题">13.1 如何解决训练样本少的问题</h2>
<p>目前大部分的深度学习模型仍然需要海量的数据支持。例如 ImageNet 数据就拥有1400多万的图片。而现实生产环境中，数据集通常较小，只有几万甚至几百个样本。这时候，如何在这种情况下应用深度学习呢?<br>
（1）利用预训练模型进行迁移微调（fine-tuning），预训练模型通常在特征上拥有很好的语义表达。此时，只需将模型在小数据集上进行微调就能取得不错的效果。这也是目前大部分小数据集常用的训练方式。视觉领域内，通常会ImageNet上训练完成的模型。自然语言处理领域，也有BERT模型等预训练模型可以使用。<br>
  <br>
（2）单样本或者少样本学习（one-shot，few-shot learning），这种方式适用于样本类别远远大于样本数量的情况等极端数据集。例如有1000个类别，每个类别只提供1-5个样本。少样本学习同样也需要借助预训练模型，但有别于微调的在于，微调通常仍然在学习不同类别的语义，而少样本学习通常需要学习样本之间的距离度量。例如孪生网络（Siamese Neural Networks）就是通过训练两个同种结构的网络来判别输入的两张图片是否属于同一类。<br>
​	上述两种是常用训练小样本数据集的方式。此外，也有些常用的手段，例如数据集增强、正则或者半监督学习等方式来解决小样本数据集的训练问题。</p>
<h2 id="13-2-深度学习是否能胜任所有数据集">13.2 深度学习是否能胜任所有数据集?</h2>
<p>深度学习并不能胜任目前所有的数据环境，以下列举两种情况：</p>
<p>（1）深度学习能取得目前的成果，很大一部分原因依赖于海量的数据集以及高性能密集计算硬件。因此，当数据集过小时，需要考虑与传统机器学习相比，是否在性能和硬件资源效率更具有优势。<br>
（2）深度学习目前在视觉，自然语言处理等领域都有取得不错的成果。这些领域最大的特点就是具有局部相关性。例如图像中，人的耳朵位于两侧，鼻子位于两眼之间，文本中单词组成句子。这些都是具有局部相关性的，一旦被打乱则会破坏语义或者有不同的语义。所以当数据不具备这种相关性的时候，深度学习就很难取得效果。</p>
<h2 id="13-3-有没有可能找到比已知算法更好的算法">13.3 有没有可能找到比已知算法更好的算法?</h2>
<p>在最优化理论发展中，有个没有免费午餐的定律，其主要含义在于，在不考虑具体背景和细节的情况下，任何算法和随机猜的效果期望是一样的。即，没有任何一种算法能优于其他一切算法，甚至不比随机猜好。深度学习作为机器学习领域的一个分支同样符合这个定律。所以，虽然目前深度学习取得了非常不错的成果，但是我们同样不能盲目崇拜。</p>
<p>优化算法本质上是在寻找和探索更符合数据集和问题的算法，这里数据集是算法的驱动力，而需要通过数据集解决的问题就是算法的核心，任何算法脱离了数据都会没有实际价值，任何算法的假设都不能脱离实际问题。因此，实际应用中，面对不同的场景和不同的问题，可以从多个角度针对问题进行分析，寻找更优的算法。</p>
<h2 id="13-4-什么是共线性，如何判断和解决共线性问题">13.4 什么是共线性，如何判断和解决共线性问题?</h2>
<p>对于回归算法，无论是一般回归还是逻辑回归，在使用多个变量进行预测分析时，都可能存在多变量相关的情况，这就是多重共线性。共线性的存在，使得特征之间存在冗余，导致过拟合。</p>
<p>常用判断是否存在共线性的方法有：</p>
<p>（1）相关性分析。当相关性系数高于0.8，表明存在多重共线性；但相关系数低，并不能表示不存在多重共线性；</p>
<p>（2）方差膨胀因子VIF。当VIF大于5或10时，代表模型存在严重的共线性问题；</p>
<p>（3）条件系数检验。 当条件数大于100、1000时，代表模型存在严重的共线性问题。</p>
<p>通常可通过PCA降维、逐步回归法和LASSO回归等方法消除共线性。</p>
<h2 id="13-5-权值初始化方法有哪些？">13.5 权值初始化方法有哪些？</h2>
<p>在深度学习的模型中，从零开始训练时，权重的初始化有时候会对模型训练产生较大的影响。良好的初始化能让模型快速、有效的收敛，而糟糕的初始化会使得模型无法训练。</p>
<p>目前，大部分深度学习框架都提供了各类初始化方式，其中一般常用的会有如下几种：<br>
<strong>1. 常数初始化(constant)</strong></p>
<p>​	把权值或者偏置初始化为一个常数。例如设置为0，偏置初始化为0较为常见，权重很少会初始化为0。TensorFlow中也有zeros_initializer、ones_initializer等特殊常数初始化函数。</p>
<p><strong>2. 高斯初始化(gaussian)</strong></p>
<p>​	 给定一组均值和标准差，随机初始化的参数会满足给定均值和标准差的高斯分布。高斯初始化是很常用的初始化方式。特殊地，在TensorFlow中还有一种截断高斯分布初始化（truncated_normal_initializer），其主要为了将超过两个标准差的随机数重新随机，使得随机数更稳定。</p>
<p><strong>3. 均匀分布初始化(uniform)</strong></p>
<p>​	给定最大最小的上下限，参数会在该范围内以均匀分布方式进行初始化，常用上下限为（0，1）。</p>
<p><strong>4. xavier 初始化(uniform)</strong></p>
<p>​	在batchnorm还未出现之前，要训练较深的网络，防止梯度弥散，需要依赖非常好的初始化方式。xavier 就是一种比较优秀的初始化方式，也是目前最常用的初始化方式之一。其目的是为了使得模型各层的激活值和梯度在传播过程中的方差保持一致。本质上xavier 还是属于均匀分布初始化，但与上述的均匀分布初始化有所不同，xavier 的上下限将在如下范围内进行均匀分布采样：</p>
 $$
[-\sqrt{\frac{6}{n+m}},\sqrt{\frac{6}{n+m}}]
$$ 
<p>​	其中，n为所在层的输入维度，m为所在层的输出维度。</p>
<p><strong>6. kaiming初始化（msra 初始化）</strong></p>
<p>​	kaiming初始化，在caffe中也叫msra 初始化。kaiming初始化和xavier 一样都是为了防止梯度弥散而使用的初始化方式。kaiming初始化的出现是因为xavier存在一个不成立的假设。xavier在推导中假设激活函数都是线性的，而在深度学习中常用的ReLu等都是非线性的激活函数。而kaiming初始化本质上是高斯分布初始化，与上述高斯分布初始化有所不同，其是个满足均值为0，方差为2/n的高斯分布：</p>
 $$
[0,\sqrt{\frac{2}{n}}]
$$ 
<p>​	其中，n为所在层的输入维度。</p>
<p>除上述常见的初始化方式以外，不同深度学习框架下也会有不同的初始化方式，读者可自行查阅官方文档。</p>
<h2 id="13-5-如何防止梯度下降陷入局部最优解">13.5 如何防止梯度下降陷入局部最优解?</h2>
<p>梯度下降法(GD)及其一些变种算法是目前深度学习里最常用于求解凸优化问题的优化算法。神经网络很可能存在很多局部最优解，而非全局最优解。 为了防止陷入局部最优，通常会采用如下一些方法，当然，这并不能保证一定能找到全局最优解，或许能得到一个比目前更优的局部最优解也是不错的：</p>
<p><strong>（1）stochastic GD</strong> /<strong>Mini-Batch GD</strong></p>
<p>​	在GD算法中，每次的梯度都是从所有样本中累计获取的，这种情况最容易导致梯度方向过于稳定一致，且更新次数过少，容易陷入局部最优。而stochastic GD是GD的另一种极端更新方式，其每次都只使用一个样本进行参数更新，这样更新次数大大增加也就不容易陷入局部最优。但引出的一个问题的在于其更新方向过多，导致不易于进一步优化。Mini-Batch GD便是两种极端的折中，即每次更新使用一小批样本进行参数更新。Mini-Batch GD是目前最常用的优化算法，严格意义上Mini-Batch GD也叫做stochastic GD，所以很多深度学习框架上都叫做SGD。<br>
**（2）动量 **<br>
​	动量也是GD中常用的方式之一，SGD的更新方式虽然有效，但每次只依赖于当前批样本的梯度方向，这样的梯度方向依然很可能很随机。动量就是用来减少随机，增加稳定性。其思想是模仿物理学的动量方式，每次更新前加入部分上一次的梯度量，这样整个梯度方向就不容易过于随机。一些常见情况时，如上次梯度过大，导致进入局部最小点时，下一次更新能很容易借助上次的大梯度跳出局部最小点。</p>
<p>**（3）自适应学习率 **</p>
<p>​	无论是GD还是动量重点优化角度是梯度方向。而学习率则是用来直接控制梯度更新幅度的超参数。自适应学习率的优化方法有很多，例如Adagrad和RMSprop。两种自适应学习率的方式稍有差异，但主要思想都是基于历史的累计梯度去计算一个当前较优的学习率。</p>
<h2 id="13-7-为什么需要激活函数？">13.7 为什么需要激活函数？</h2>
<p>（1）非线性：即导数不是常数。这个条件是多层神经网络的基础，保证多层网络不退化成单层线性网络。这也是激活函数的意义所在。</p>
<p>（2）几乎处处可微：可微性保证了在优化中梯度的可计算性。传统的激活函数如sigmoid等满足处处可微。对于分段线性函数比如ReLU，只满足几乎处处可微（即仅在有限个点处不可微）。对于SGD算法来说，由于几乎不可能收敛到梯度接近零的位置，有限的不可微点对于优化结果不会有很大影响[1]。</p>
<p>（3）计算简单：非线性函数有很多。极端的说，一个多层神经网络也可以作为一个非线性函数，类似于Network In Network[2]中把它当做卷积操作的做法。但激活函数在神经网络前向的计算次数与神经元的个数成正比，因此简单的非线性函数自然更适合用作激活函数。这也是ReLU之流比其它使用Exp等操作的激活函数更受欢迎的其中一个原因。</p>
<p>（4）非饱和性（saturation）：饱和指的是在某些区间梯度接近于零（即梯度消失），使得参数无法继续更新的问题。最经典的例子是Sigmoid，它的导数在x为比较大的正值和比较小的负值时都会接近于0。更极端的例子是阶跃函数，由于它在几乎所有位置的梯度都为0，因此处处饱和，无法作为激活函数。ReLU在x&gt;0时导数恒为1，因此对于再大的正值也不会饱和。但同时对于x&lt;0，其梯度恒为0，这时候它也会出现饱和的现象（在这种情况下通常称为dying ReLU）。Leaky ReLU[3]和PReLU[4]的提出正是为了解决这一问题。</p>
<p>（5）单调性（monotonic）：即导数符号不变。这个性质大部分激活函数都有，除了诸如sin、cos等。个人理解，单调性使得在激活函数处的梯度方向不会经常改变，从而让训练更容易收敛。</p>
<p>（6）输出范围有限：有限的输出范围使得网络对于一些比较大的输入也会比较稳定，这也是为什么早期的激活函数都以此类函数为主，如Sigmoid、TanH。但这导致了前面提到的梯度消失问题，而且强行让每一层的输出限制到固定范围会限制其表达能力。因此现在这类函数仅用于某些需要特定输出范围的场合，比如概率输出（此时loss函数中的log操作能够抵消其梯度消失的影响[1]）、LSTM里的gate函数。</p>
<p>（7）接近恒等变换（identity）：即约等于x。这样的好处是使得输出的幅值不会随着深度的增加而发生显著的增加，从而使网络更为稳定，同时梯度也能够更容易地回传。这个与非线性是有点矛盾的，因此激活函数基本只是部分满足这个条件，比如TanH只在原点附近有线性区（在原点为0且在原点的导数为1），而ReLU只在x&gt;0时为线性。这个性质也让初始化参数范围的推导更为简单[5][4]。额外提一句，这种恒等变换的性质也被其他一些网络结构设计所借鉴，比如CNN中的ResNet[6]和RNN中的LSTM。</p>
<p>（8）参数少：大部分激活函数都是没有参数的。像PReLU带单个参数会略微增加网络的大小。还有一个例外是Maxout[7]，尽管本身没有参数，但在同样输出通道数下k路Maxout需要的输入通道数是其它函数的k倍，这意味着神经元数目也需要变为k倍；但如果不考虑维持输出通道数的情况下，该激活函数又能将参数个数减少为原来的k倍。</p>
<p>（9）归一化（normalization）：这个是最近才出来的概念，对应的激活函数是SELU[8]，主要思想是使样本分布自动归一化到零均值、单位方差的分布，从而稳定训练。在这之前，这种归一化的思想也被用于网络结构的设计，比如Batch Normalization[9]。</p>
<h2 id="13-6-常见的损失函数有哪些">13.6 常见的损失函数有哪些?</h2>
<p>机器学习通过对算法中的目标函数进行不断求解优化，得到最终想要的结果。分类和回归问题中，通常使用损失函数或代价函数作为目标函数。</p>
<p>损失函数用来评价预测值和真实值不一样的程度。通常损失函数越好，模型的性能也越好。</p>
<p>损失函数可分为<strong>经验风险损失</strong>和<strong>结构风险损失</strong>。经验风险损失是根据已知数据得到的损失。结构风险损失是为了防止模型被过度拟合已知数据而加入的惩罚项。</p>
<p>下面介绍常用的损失函数:<br>
<strong>（1）0-1 损失函数</strong><br>
  <br>
如果预测值和目标值相等，值为 0，如果不相等，值为 1：</p>
 $$
L(Y,f(x))=
\left\{
\begin{array}{}
1\;\;\;,\;\;Y\ne f(x), \\
0\;\;\;,\;\;Y=f(x).
\end{array}
\right.
$$ 
<p>  <br>
一般的在实际使用中，相等的条件过于严格，可适当放宽条件：</p>
 $$
L(Y,f(x))=
\left\{
\begin{array}{}
1\;\;\;,\;\;|Y - f(x)| \ge T, \\
0\;\;\;,\;\;|Y-f(x)| < T.
\end{array}
\right.
$$ 
<p>  <br>
<strong>（2）绝对值损失函数</strong><br>
  <br>
和 0-1 损失函数相似，绝对值损失函数表示为：</p>
 $$
L(Y,f(x))=|Y-f(x)|.
$$ 
<p>  <br>
<strong>（3）平方损失函数</strong></p>
 $$
L(Y|f(x))=\sum_{N}(Y-f(x))^2.
$$ 
<p>  <br>
这点可从最小二乘法和欧几里得距离角度理解。最小二乘法的原理是，最优拟合曲线应该 使所有点到回归直线的距离和最小。</p>
<p>  <br>
<strong>（4）log 对数损失函数</strong></p>
 $$
L(Y,P(Y|X))=-logP(Y|X).
$$ 
<p>  <br>
常见的逻辑回归使用的就是对数损失函数，有很多人认为逻辑回归的损失函数式平方损失， 其实不然。逻辑回归它假设样本服从伯努利分布，进而求得满足该分布的似然函数，接着取对 数求极值等。逻辑回归推导出的经验风险函数是最小化负的似然函数，从损失函数的角度看， 就是 log 损失函数。</p>
<p>  <br>
<strong>（5）指数损失函数</strong><br>
  <br>
指数损失函数的标准形式为：</p>
 $$
L(Y|f(x))=exp[-yf(x)].
$$ 
<p>  <br>
例如 AdaBoost 就是以指数损失函数为损失函数。</p>
<p>  <br>
<strong>（6）Hinge 损失函数</strong><br>
  <br>
Hinge 损失函数的标准形式如下：</p>
 $$
L(y)=max(0, 1-ty).
$$ 
<p>  <br>
其中 y 是预测值，范围为(-1,1), t 为目标值，其为-1 或 1。<br>
  <br>
在线性支持向量机中，最优化问题可等价于：</p>
 $$
\underset{w,b}{min}\sum_{i=1}^{N}(1-y_i(wx_i+b))+\lambda \lVert w^2 \rVert
$$ 
<p>  </p>
 $$
\frac{1}{m}\sum_{i=1}^{N}l(wx_i+by_i))+\lVert w^2 \rVert
$$ 
<p>  <br>
其中 $l(wx_i+by_i))$ 是Hinge损失函数， $\lVert w^2 \rVert$ 可看做为正则化项。</p>
<h2 id="13-7-如何进行特征选择-feature-selection">13.7 如何进行特征选择(feature selection)?</h2>
<h3 id="13-7-1-特征类型有哪些？">13.7.1 特征类型有哪些？</h3>
<p>对象本身会有许多属性。所谓特征，即能在某方面最能表征对象的一个或者一组属性。一般地，我们可以把特征分为如下三个类型：</p>
<p>（1）相关特征：对于特定的任务和场景具有一定帮助的属性，这些属性通常能有效提升算法性能；</p>
<p>（2）无关特征：在特定的任务和场景下完全无用的属性，这些属性对对象在本目标环境下完全无用；</p>
<p>（3）冗余特征：同样是在特定的任务和场景下具有一定帮助的属性，但这类属性已过多的存在，不具有产生任何新的信息的能力。</p>
<h3 id="13-7-2-如何考虑特征选择">13.7.2 如何考虑特征选择</h3>
<p>当完成数据预处理之后，对特定的场景和目标而言很多维度上的特征都是不具有任何判别或者表征能力的，所以需要对数据在维度上进行筛选。一般地，可以从以下两个方面考虑来选择特征:</p>
<p>（1）特征是否具有发散性：某个特征若在所有样本上的都是一样的或者接近一致，即方差非常小。 也就是说所有样本的都具有一致的表现，那这些就不具有任何信息。</p>
<p>（2）特征与目标的相关性：与目标相关性高的特征，应当优选选择。</p>
<h3 id="13-7-3-特征选择方法分类">13.7.3 特征选择方法分类</h3>
<p>根据特征选择的形式又可以将特征选择方法分为 3 种:<br>
（1）过滤法：按照发散性或者相关性对各个特征进行评分，设定阈值或者待选择阈值的个数，选择特征。</p>
<p>（2）包装法：根据目标函数(通常是预测效果评分)，每次选择若干特征，或者排除若干特征。</p>
<p>（3）嵌入法：先使用某些机器学习的算法和模型进行训练，得到各个特征的权值系数，根据系数从大到小选择特征。</p>
<h3 id="13-7-4-特征选择目的">13.7.4 特征选择目的</h3>
<p>（1）减少特征维度，使模型泛化能力更强，减少过拟合;</p>
<p>（2）降低任务目标的学习难度；</p>
<p>（3）一组优秀的特征通常能有效的降低模型复杂度，提升模型效率</p>
<h2 id="13-8-梯度消失-梯度爆炸原因，以及解决方法">13.8 梯度消失/梯度爆炸原因，以及解决方法</h2>
<h3 id="13-8-1-为什么要使用梯度更新规则">13.8.1 为什么要使用梯度更新规则?</h3>
<p>目前深度学习的火热，其最大的功臣之一就是反向传播。反向传播，即根据损失评价函数计算的误差，计算得到梯度，通过梯度反向传播的方式，指导深度网络权值的更新优化。这样做的原因在于，深层网络由许多非线性层堆叠而来，每一层非线性层都可以视为是一个非线性函数，因此整个深度网络可以视为是一个复合的非线性多元函数：</p>
 $$
F(x)=f_n(\cdots f_3(f_2(f_1(x)*\theta_1+b)*\theta_2+b)\cdots)
$$ 
<p>我们最终的目的是希望这个多元函数可以很好的完成输入到输出之间的映射，假设不同的输入，输出的最优解是g(x) ，那么，优化深度网络就是为了寻找到合适的权值，满足 Loss=L(g(x),F(x))取得极小值点，比如最简单的损失函数：</p>
 $$
Loss = \lVert g(x)-f(x) \rVert^2_2.
$$ 
<p>假设损失函数的数据空间是下图这样的，我们最优的权值就是为了寻找下图中的最小值点， 对于这种数学寻找最小值问题，采用梯度下降的方法再适合不过了。</p>
<p><img src="figure_13_15_1.png" alt></p>
<center>图 13.8.1 </center>
<h3 id="13-8-2-梯度消失-爆炸产生的原因">13.8.2 梯度消失/爆炸产生的原因?</h3>
<p>本质上，梯度消失和爆炸是一种情况。在深层网络中，由于网络过深，如果初始得到的梯度过小，或者传播途中在某一层上过小，则在之后的层上得到的梯度会越来越小，即产生了梯度消失。梯度爆炸也是同样的。一般地，不合理的初始化以及激活函数，如sigmoid等，都会导致梯度过大或者过小，从而引起消失/爆炸。</p>
<p>下面分别从网络深度角度以及激活函数角度进行解释：</p>
<p>（1）网络深度</p>
<p>若在网络很深时，若权重初始化较小，各层上的相乘得到的数值都会0-1之间的小数，而激活函数梯度也是0-1之间的数。那么连乘后，结果数值就会变得非常小，导致<strong>梯度消失</strong>。若权重初始化较大，大到乘以激活函数的导数都大于1，那么连乘后，可能会导致求导的结果很大，形成<strong>梯度爆炸</strong>。</p>
<p>（2）激活函数<br>
如果激活函数选择不合适，比如使用 sigmoid，梯度消失就会很明显了，原因看下图，左图是sigmoid的函数图，右边是其导数的图像，如果使用sigmoid作为损失函数，其梯度是不可能超过0.25的，这样经过链式求导之后，很容易发生梯度消失。<br>
<img src="figure_13_15_2.png" alt></p>
<center>图 13.8.2 sigmod函数与其导数</center>
<h3 id="13-8-3-梯度消失、爆炸的解决方案">13.8.3 梯度消失、爆炸的解决方案</h3>
<p><strong>1、预训练加微调</strong><br>
此方法来自Hinton在2006年发表的一篇论文，Hinton为了解决梯度的问题，提出采取无监督逐层训练方法，其基本思想是每次训练一层隐节点，训练时将上一层隐节点的输出作为输入，而本层隐节点的输出作为下一层隐节点的输入，此过程就是逐层“预训练”（pre-training）；在预训练完成后，再对整个网络进行“微调”（fine-tunning）。Hinton在训练深度信念网络（Deep Belief Networks中，使用了这个方法，在各层预训练完成后，再利用BP算法对整个网络进行训练。此思想相当于是先寻找局部最优，然后整合起来寻找全局最优，此方法有一定的好处，但是目前应用的不是很多了。</p>
<p><strong>2、梯度剪切、正则</strong><br>
梯度剪切这个方案主要是针对梯度爆炸提出的，其思想是设置一个梯度剪切阈值，然后更新梯度的时候，如果梯度超过这个阈值，那么就将其强制限制在这个范围之内。这可以防止梯度爆炸。<br>
另外一种解决梯度爆炸的手段是采用权重正则化（weithts regularization）比较常见的是L1和L2正则。</p>
<p><strong>3、ReLu、leakReLu等激活函数</strong><br>
（1）ReLu：其函数的导数在正数部分是恒等于1，这样在深层网络中，在激活函数部分就不存在导致梯度过大或者过小的问题，缓解了梯度消失或者爆炸。同时也方便计算。当然，其也存在存在一些缺点，例如过滤到了负数部分，导致部分信息的丢失，输出的数据分布不在以0为中心，改变了数据分布。<br>
（2）leakrelu：就是为了解决relu的0区间带来的影响，其数学表达为：leakrelu=max(k*x,0)其中k是leak系数，一般选择0.01或者0.02，或者通过学习而来。</p>
<p><strong>4、batchnorm</strong><br>
Batchnorm是深度学习发展以来提出的最重要的成果之一了，目前已经被广泛的应用到了各大网络中，具有加速网络收敛速度，提升训练稳定性的效果，Batchnorm本质上是解决反向传播过程中的梯度问题。Batchnorm全名是Batch Normalization，简称BN，即批规范化，通过规范化操作将输出信号x规范化到均值为0，方差为1保证网络的稳定性。</p>
<p><strong>5、残差结构</strong><br>
残差的方式，能使得深层的网络梯度通过跳级连接路径直接返回到浅层部分，使得网络无论多深都能将梯度进行有效的回传。</p>
<p><strong>6、LSTM</strong><br>
LSTM全称是长短期记忆网络（long-short term memory networks），是不那么容易发生梯度消失的，主要原因在于LSTM内部复杂的“门”(gates)。在计算时，将过程中的梯度进行了抵消。</p>
<h2 id="13-9-深度学习为什么不用二阶优化？">13.9 深度学习为什么不用二阶优化？</h2>
<p>目前深度学习中，反向传播主要是依靠一阶梯度。二阶梯度在理论和实际上都是可以应用都网络中的，但相比于一阶梯度，二阶优化会存在以下一些主要问题：<br>
（1）计算量大，训练非常慢。<br>
（2）二阶方法能够更快地求得更高精度的解，这在浅层模型是有益的。而在神经网络这类深层模型中对参数的精度要求不高，甚至不高的精度对模型还有益处，能够提高模型的泛化能力。<br>
（3）稳定性。二阶方法能更快求高精度的解，同样对数据本身要的精度也会相应的变高，这就会导致稳定性上的问题。</p>
<h2 id="13-10-为什么要设置单一数字评估指标，设置指标的意义？">13.10 为什么要设置单一数字评估指标，设置指标的意义？</h2>
<p>在训练模型时，无论是调整超参数，还是调整不同的模型算法，我们都需要一个有效的评价指标，这个评价标准能帮助我们快速了解新的尝试后模型的性能是否更优。例如在分类时，我们通常会选择选择准确率，当样本不平衡时，查准率和查全率又会是更好的评价指标。所以在训练模型时，如果设置了单一数字的评估指标通常能很快的反应出我们模型的改进是否直接产生了收益，从而加速我们的算法改进过程。若在训练过程中，发现优化目标进一步深入，现有指标无法完全反应进一步的目标时，就需要重新选择评估指标了。</p>
<h2 id="13-11训练-验证-测试集的定义及划分">13.11训练/验证/测试集的定义及划分</h2>
<p>训练、验证、测试集在机器学习领域是非常重要的三个内容。三者共同组成了整个项目的性能的上限和走向。</p>
<p>训练集：用于模型训练的样本集合，样本占用量是最大的；</p>
<p>验证集：用于训练过程中的模型性能评价，跟着性能评价才能更好的调参；</p>
<p>测试集：用于最终模型的一次最终评价，直接反应了模型的性能。</p>
<p>在划分上，可以分两种情况：</p>
<p>1、在样本量有限的情况下，有时候会把验证集和测试集合并。实际中，若划分为三类，那么训练集：验证集：测试集=6:2:2；若是两类，则训练集：验证集=7:3。这里需要主要在数据量不够多的情况，验证集和测试集需要占的数据比例比较多，以充分了解模型的泛化性。</p>
<p>2、在海量样本的情况下，这种情况在目前深度学习中会比较常见。此时由于数据量巨大，我们不需要将过多的数据用于验证和测试集。例如拥有1百万样本时，我们按训练集：验证集：测试集=98:1:1的比例划分，1%的验证和1%的测试集都已经拥有了1万个样本。这已足够验证模型性能了。</p>
<p>此外，三个数据集的划分不是一次就可以的，若调试过程中发现，三者得到的性能评价差异很大时，可以重新划分以确定是数据集划分的问题导致还是由模型本身导致的。其次，若评价指标发生变化，而导致模型性能差异在三者上很大时，同样可重新划分确认排除数据问题，以方便进一步的优化。</p>
<h2 id="13-12-什么是TOP5错误率？">13.12 什么是TOP5错误率？</h2>
<p>通常对于分类系统而言，系统会对某个未知样本进行所有已知样本的匹配，并给出该未知样本在每个已知类别上的概率。其中最大的概率就是系统系统判定最可能的一个类别。TOP5则就是在前五个最大概率的类别。TOP5错误率，即预测最可能的五类都不是该样本类别的错误率。</p>
<p>TOP5错误率通常会用于在类别数量很多或者细粒度类别的模型系统。典型地，例如著名的ImageNet ，其包含了1000个类别。通常就会采用TOP5错误率。</p>
<h2 id="13-13-什么是泛化误差，如何理解方差和偏差？">13.13 什么是泛化误差，如何理解方差和偏差？</h2>
<p>一般情况下，我们评价模型性能时都会使用泛化误差。泛化误差越低，模型性能越好。泛化误差可分解为方差、偏差和噪声三部分。这三部分中，噪声是个不可控因素，它的存在是算法一直无法解决的问题，很难约减，所以我们更多考虑的是方差和偏差。</p>
<p>方差和偏差在泛化误差上可做如下分解，假设我们的预测值为g(x)，真实值为f(x)，则均方误差为</p>
 $$
E((g(x)−f(x))2)
$$ 
<p>这里假设不考虑噪声，g来代表预测值，f代表真实值，g¯=E(g)代表算法的期望预测，则有如下表达：</p>
 $$
\begin{align}
E(g-f)^2&=E(g^2-2gf+f^2)
\\&=E(g^2)-\bar g^2+(\bar g-f)^2
\\&=E(g^2)-2\bar g^2+\bar g^2+(\bar g-f)^2
\\&=E(g^2-2g\bar g^2+\bar g^2)+(\bar g-f)^2
\\&=\underbrace{E(g-\bar g)^2}_{var(x)}+\underbrace{(\bar g-f)^2}_{bias^2(x)}
\end{align}
$$ 
<p>有上述公式可知，方差描述是理论期望和预测值之间的关系，这里的理论期望通常是指所有适用于模型的各种不同分布类型的数据集；偏差描述为真实值和预测值之间的关系，这里的真实值通常指某一个特定分布的数据集合。</p>
<p>所以综上方差表现为模型在各类分布数据的适应能力，方差越大，说明数据分布越分散，而偏差则表现为在特定分布上的适应能力，偏差越大越偏离真实值。</p>
<h2 id="13-14-如何提升模型的稳定性？">13.14 如何提升模型的稳定性？</h2>
<p>评价模型不仅要从模型的主要指标上的性能，也要注重模型的稳定性。模型的稳定性体现在对不同样本之间的体现的差异。如模型的方差很大，那可以从如下几个方面进行考虑：</p>
<p>（1）正则化（L2, L1, dropout）：模型方差大，很可能来自于过拟合。正则化能有效的降低模型的复杂度，增加对更多分布的适应性。</p>
<p>（2）提前停止训练：提前停止是指模型在验证集上取得不错的性能时停止训练。这种方式本质和正则化是一个道理，能减少方差的同时增加的偏差。目的为了平衡训练集和未知数据之间在模型的表现差异。</p>
<p>（3）扩充训练集：正则化通过控制模型复杂度，来增加更多样本的适应性。那增加训练集让模型适应不同类型的数据本身就是一种最简单直接的方式提升模型稳定的方法，也是最可靠的一种方式。  与正则有所不同的是，扩充数据集既可以减小偏差又能减小方差。</p>
<p>（4）特征选择：过高的特征维度会使模型过拟合，减少特征维度和正则一样可能会处理好方差问题，但是同时会增大偏差。但需要注意的是若过度删减特征，很可能会删除很多有用的特征，降低模型的性能。所以需要多注意删减的特征对模型的性能的影响。</p>
<h2 id="13-15-有哪些改善模型的思路">13.15 有哪些改善模型的思路</h2>
<p>改善模型本质是如何优化模型，这本身是个很宽泛的问题。也是目前学界一直探索的目的，而从目前常规的手段上来说，一般可取如下几点。</p>
<h3 id="13-15-1-数据角度">13.15.1 数据角度</h3>
<p>增强数据集。无论是有监督还是无监督学习，数据永远是最重要的驱动力。更多的类型数据对良好的模型能带来更好的稳定性和对未知数据的可预见性。对模型来说，“看到过的总比没看到的更具有判别的信心”。但增大数据并不是盲目的，模型容限能力不高的情况下即使增大数据也对模型毫无意义。而从数据获取的成本角度，对现有数据进行有效的扩充也是个非常有效且实际的方式。良好的数据处理，常见的处理方式如数据缩放、归一化和标准化等。</p>
<h3 id="13-15-2-模型角度">13.15.2 模型角度</h3>
<p>模型的容限能力决定着模型可优化的空间。在数据量充足的前提下，对同类型的模型，增大模型规模来提升容限无疑是最直接和有效的手段。但越大的参数模型优化也会越难，所以需要在合理的范围内对模型进行参数规模的修改。而不同类型的模型，在不同数据上的优化成本都可能不一样，所以在探索模型时需要尽可能挑选优化简单，训练效率更高的模型进行训练。</p>
<h3 id="13-15-3-调参优化角度">13.15.3 调参优化角度</h3>
<p>如果你知道模型的性能为什么不再提高了，那已经向提升性能跨出了一大步。 超参数调整本身是一个比较大的问题。一般可以包含模型初始化的配置，优化算法的选取、学习率的策略以及如何配置正则和损失函数等等。这里需要提出的是对于同一优化算法，相近参数规模的前提下，不同类型的模型总能表现出不同的性能。这实际上就是模型优化成本。从这个角度的反方向来考虑，同一模型也总能找到一种比较适合的优化算法。所以确定了模型后选择一个适合模型的优化算法也是非常重要的手段。</p>
<h3 id="13-15-4-训练角度">13.15.4 训练角度</h3>
<p>很多时候我们会把优化和训练放一起。但这里我们分开来讲，主要是为了强调充分的训练。在越大规模的数据集或者模型上，诚然一个好的优化算法总能加速收敛。但你在未探索到模型的上限之前，永远不知道训练多久算训练完成。所以在改善模型上充分训练永远是最必要的过程。充分训练的含义不仅仅只是增大训练轮数。有效的学习率衰减和正则同样是充分训练中非常必要的手段。</p>
<h2 id="13-16-如何快速构建有效初始模型？">13.16 如何快速构建有效初始模型？</h2>
<p>​	构建一个有效的初始模型能帮助我们快速了解数据的质量和确定模型构建的方向。构建一个良好的初始模型，一般需要注意如下几点：</p>
<p>​	1、了解&quot;对手&quot;。这里的“对手”通常是指数据，我们在得到数据时，第一步是需要了解数据特点和使用场合。了解数据特点能帮助我们快速定位如何进行建模。确定使用场合能帮助我们进一步确定模型需要优化的方向。数据特点一般需要了解例如数据集规模、训练集和验证集是否匹配、样本的分布是否均匀、数据是否存在缺失值等等。</p>
<p>​	2、站在巨人肩膀上。根据数据特点，我们通常能匹配到一个现有比较优秀的模型。这类模型都通常能在类似数据上表现出一个比较不错的性能。</p>
<p>​	3、一切从简。初始模型的作用在于迅速了解数据质量和特点，所以模型的性能通常不需要达到很高，模型复杂度也不需要很高。例如，做图像分类时，我们在使用预训练模型时，不需要一开始就使用例如ResNet152这类模型巨大，复杂度过高的模型。这在数据量较小时，很容易造成过拟合而导致出现我们对数据产生一些误导性的判断，此外也增加了额外训练构建时间。所以使用更小更简单的模型以及损失函数来试探数据是相比更明智的选择。</p>
<p>​	4、总比瞎猜强。构建模型的意义在于建立一个高效的模型，虽然初始模型我们不对性能做过高的要求。但前提在于必须要比随机猜测好，不然构建模型的意义就不存在了。</p>
<p>​	5、解剖模型。一旦确定了一个初始模型时，无论你对该模型多熟悉，当其面对一批新数据时，你永远需要重新去认识这个模型，因为你永远不确定模型内部到底发生了些什么。解剖模型一般需要在训练时注意误差变化、注意训练和验证集的差异；出现一些NAN或者INf等情况时，需要打印观察内部输出，确定问题出现的时间和位置；在完成训练后，需要测试模型的输出是否正确合理，以确认评价指标是否符合该数据场景。无论使用任何一种模型，我们都不能把它当做黑盒去看待。</p>
<h2 id="13-17-如何通过模型重新观察数据？">13.17 如何通过模型重新观察数据？</h2>
<p>​	对于这个问题，与其说如何做，倒不如说这个问题是用来强调这样做的重要性。如何重新观察数据其实不难，而是很多读者，会忽略这一项过程的重要性。</p>
<p>​	通过模型重新观察数据，不仅能让我们了解模型情况，也能让我们对数据质量产生进一步的理解。目前深度学习在监督学习领域成就是非常显著的。监督学习需要依赖大量的人为标注，人为标注很难确定是否使用的数据中是否存在错误标注或者漏标注等问题。这无论是哪种情况都会影响我们对模型的判断。所以通过模型重新验证数据质量是非常重要的一步。很多初学者，通常会忽略这一点，而导致出现对模型的一些误判，严重时甚至会影响整个建模方向。此外，对于若出现一些过拟合的情况，我们也可以通过观察来了解模型。例如分类任务，样本严重不平衡时，模型全预测到了一边时，其正确率仍然很高，但显然模型已经出现了问题。</p>
<h2 id="13-18-如何解决数据不匹配问题？">13.18 如何解决数据不匹配问题？</h2>
<h3 id="13-18-1-如何定位数据不匹配">13.18.1 如何定位数据不匹配?</h3>
<p>​	数据不匹配问题是个不容易定位和解决的问题。这个问题出现总会和模型过拟合表现很相似,即在训练集上能体现非常不错的性能,但在测试集上表现总是差强人意但区别在于如果遇到是数据不匹配的问题,通常在用一批和训<br>
练集有看相同或者相似分布的数据上仍然能取得不错的结果。但很多时候,当测试集上结果表现很差时,很多初学<br>
者可能会直接将问题定位在模型过拟合上,最后对模型尝试各种方法后,性能却始终不能得到有效提升。当遇到这<br>
种情况时,建议先定位出是否存在数据不匹配的问题。最简单的验证方式就是可以从训练集中挑选出一部分数据作<br>
为验证集,重新划分后训练和验证模型表现。</p>
<h3 id="13-18-2-举例常见几个数据不匹配的场景">13.18.2 举例常见几个数据不匹配的场景?</h3>
<p>​	例如设计款识别物体的app时,实际场景的图片均来自于手机拍摄,而训练集确是来自于网上各类抓取下来的图<br>
片。例如在图像去噪、去模糊、去雾、超分辨率等图像处理场景时,由于大量数据的难以获取,因此都会采用人为<br>
假设合成的图像进行训练,这时候应用到实际场景中也容易出现不匹配的问题</p>
<h3 id="13-18-3-如何解决数据不匹配问题">13.18.3 如何解决数据不匹配问题?</h3>
<p>​	数据不匹配是个很难有固定方法来解决的问题。这里提供几条供参考的途径：<br>
​	1、收集更多符合实际场最需要的数据。这似乎是最简单但也最难方式<br>
​	2、对结果做错误分析。找出数据集中出错的数据和正确数据之间的特点和区别,这对你无论是进行后续模型的分析或者是数据的处理提供非常有效的思路。注意,这里的数据集包括训练集和测试集<br>
​	3、数据集增强。数据集增强并不意味看数据集越大越好,其目的是丰富数据的分布以适应更多的变化当遇到数<br>
据不匹配时,对数据处理般可以有两种方式。其一,合成或处理更多接近需要的数据特点。其二,对所有数据包<br>
括实际场景数据都进行处理,将所有数据都统一到另一个分布上,统一出一种新的特点。</p>
<h3 id="13-18-4-如何提高深度学习系统的性能">13.18.4 如何提高深度学习系统的性能</h3>
<p>​	当我们要试图提高深度学习系统的性能时，目前我们大致可以从三方面考虑：</p>
<p>​	1、提高模型的结构，比如增加神经网络的层数，或者将简单的神经元单位换成复杂的 LSTM 神经元，比如在自然语言处理领域内，利用 LSTM 模型挖掘语法分析的优势。</p>
<p>​	2、改进模型的初始化方式，保证早期梯度具有某些有益的性质，或者具备大量的稀疏性，或者利用线性代数原理的优势。</p>
<p>​	3、选择更强大的学习算法，比如对度梯度更新的方式，也可以是采用除以先前梯度 L2 范数来更新所有参数，甚至还可以选用计算代价较大的二阶算法。</p>
<h2 id="参考文献">参考文献</h2>
<p>[1] 冯宇旭, 李裕梅. 深度学习优化器方法及学习率衰减方式综述[J]. 数据挖掘, 2018, 8(4): 186-200</p>
]]></content>
      <categories>
        <category>算法面试</category>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>刷八股</tag>
      </tags>
  </entry>
  <entry>
    <title>异构计算， GPU和框架选型指南面试题</title>
    <url>/2024/03/19/deep_learning/ch15/</url>
    <content><![CDATA[<h1>异构计算， GPU和框架选型指南</h1>
<p>深度学习训练和推理的过程中，会涉及到大量的向量(vector)，矩阵(matrix)和张量(tensor)操作，通常需要大量的浮点计算，包括高精度（在训练的时候）和低精度（在推理和部署的时候）。GPU， 作为一种通用可编程的加速器，最初设计是用来进行图形处理和渲染功能，但是从2007年开始，英伟达(NVIDIA)公司提出了第一个可编程通用计算平台（GPU），同时提出了CUDA框架，从此开启了GPU用于通用计算的新纪元。此后，不计其数的科研人员和开发者，对各种不同类型的算法用CUDA进行（部分）改写，从而达到几倍到数百倍的加速效果。尤其是在机器学习，特别是深度学习的浪潮来临后，GPU加速已经是各类工具实现的基本底层构架之一。本章里，会简单介绍GPU的基本架构，性能指标，框架选择等等和深度学习相关的内容。</p>
<h2 id="15-1-什么是异构计算？">15.1 什么是异构计算？</h2>
<p>异构计算是基于一个更加朴素的概念，”异构现象“，也就是不同计算平台之间，由于硬件结构（包括计算核心和内存），指令集和底层软件实现等方面的不同而有着不同的特性。异构计算就是使用结合了两个或者多个不同的计算平台，并进行协同运算。比如，比较常见的，在深度学习和机器学习中已经比较成熟的架构：CPU和GPU的异构计算;此外还有比较新的Google推出的协处理器（TPU），根据目的而定制的ASIC，可编程的FPGA等也都是现在在异构计算中使用比较多的协处理器。而，本章中会着重介绍和深度学习共同繁荣的图形加算器，也就是常说的GPU。</p>
<h2 id="15-2-什么是GPU？">15.2 什么是GPU？</h2>
<p>GPU,就如名字所包含的内容，原本开发的目的是为了进行计算机图形渲染，而减少对于CPU的负载。由于图像的原始特性，也就是像素间的独立性，所以GPU在设计的时候就遵从了“单指令流多数据流（SIMD）”架构，使得同一个指令（比如图像的某种变换），可以同时在多一个像素点上进行计算，从而得到比较大的吞吐量，才能使得计算机可以实时渲染比较复杂的2D/3D场景。在最初的应用场景里，GPU并不是作为一种通用计算平台出现的，直到2007年左右，一家伟大的公司将GPU带到通用计算的世界里，使得其可以在相对比较友好的编程环境（CUDA/OpenCL）里加速通用程序成了可能。从此之后，GPU通用计算，也就是GPU就成了学界和工业界都频繁使用的技术，在深度学习爆发的年代里，GPU成了推动这股浪潮非常重要的力量。</p>
<h2 id="15-3-GPU架构简介">15.3 GPU架构简介</h2>
<p>GPU，图形显示芯片作为不同于CPU的设计逻辑和应用场景，有着非常不同的架构，本部分将简单介绍GPU究竟是如何架构，其中的计算核心有哪些特性。</p>
<h3 id="15-3-1-如何通俗理解GPU的架构？">15.3.1 如何通俗理解GPU的架构？</h3>
<p>首先，下图简单地展示了几个GPU不同于CPU的特性：</p>
<ul>
<li>计算核心： 图中的CPU,i7-5960，Intel的第五代Broadwell架构，其中包括了8个CPU核心(支持16线程)，也就是理论上可以有16个不同的运算同时进行。除了8个核心计算单元，大部分的芯片面积是被3级缓存，内存和控制电路占据了。同样的，来自Nvidia的GTX980GPU，在差不多的芯片面积上，大部分是计算单元，16个SM，也就是流处理单元，每个流处理单元中包含着128个CUDA计算核心，所以总共来说，有2048个GPU运算单元，相应地这颗GPU理论上可以在一个时钟周期内可以进行2048次单精度运算。</li>
</ul>
<p><img src="cpu_gpu.png" alt="CPU和GPU的简单架构对比图"></p>
<ul>
<li>计算核心频率：时钟频率，代表每一秒中内能进行同步脉冲次数，也是从一个侧面反映一个计算元件的工作速度。下图中对比了个别早期产品，比如Intel的x5650和几款Nvidia的GPU。可以看出核心频率而言，CPU要远高于GPU。对于CPU而言，在不考虑能源消耗和制程工艺限制的情况下，追求更高的主频。但，在GPU的设计中，采用了多核心设计，即使是提高一些频率，其实对于总体性能影像不会特别大。当然，其中还有能耗方面的考虑，避免发热过高，也进行了权衡。还有一个可能的原因是，在一个流处理器中的每个核心（CUDA核心）的运行共享非常有限的缓存和寄存器，由于共享内存也是有性能极限的，所以即使每个GPU核心频率提高，如果被缓存等拖累也是无法展现出高性能的。</li>
</ul>
<p><img src="cpu_specs.png" alt="CPU简单信息"></p>
<p><img src="gpu_specs.png" alt="GPU的简单信息对比"></p>
<ul>
<li>内存架构：GPU的多层内存架构包括全局内存（也就是通常意义上大部分比较关注的内存，在若干到16GB之间，截至到当前最新），2级缓存，和芯片上的存储（包括寄存器，和1级缓存共用的共享内存，只读/纹理缓存和常量缓存）。通常来说，最高速的共享内存/缓存和寄存器都是非常有限的，比如在Tesla的K20中，只有48K的缓存可以作为共享内存或者1级缓存使用，所以在很多用GPU加速算法实现的过程中，有效地利用这些高速缓存是使得性能提升的非常重要的方面。</li>
</ul>
<p><img src="gpu_memory_arch.png" alt="GPU的简单信息对比"></p>
<p><img src="gpu_memory.png" alt="GPU的内存架构容量信息"></p>
<h3 id="15-3-2-CUDA-核心是什么？">15.3.2 CUDA 核心是什么？</h3>
<p>上面提到在一个GPU芯片里，会很几千个CUDA核心，被分布在多个流处理单元（SM）中，比如上面提到早期的GTX980中的16个SM中各包含了128个CUDA核心。如下图所示，作为GPU架构中的最小单元，其实它的设计和CPU有着非常类似的结构，其中包括了一个浮点运算单元和整型运算单元，和控制单元。同一个流处理器中，所有的CUDA核心将同步执行同一个指令，但是作用于不同的数据点上。</p>
<p><img src="cudacore.jpg" alt="CUDA简单介绍"></p>
<p>一般来说，更加多的CUDA核心意味着有更多的并行执行单元，所以也就可以片面地认为是有更加高的性能。但是，其实这个也是取决于很多方面，最重要的是算法在并行实现的时候有没有高效地调度和内存的使用优化。在现在我们使用的大部分GPU加速的深度学习框架里，包括Tensorflow，PyTorch等都是依赖于底层的GPU的矩阵加速代码的实现。为此Nvidia公司也是制定和实现了统一的接口，比如cuDNN，方便上层框架更好的利用GPU的性能。</p>
<h3 id="15-3-3-为什么要使用GPU？">15.3.3 为什么要使用GPU？</h3>
<p>对于并行计算来说，可以非常粗略地分为：</p>
<ul>
<li>并行指令： 也就是多个指令可以同时分配到不同的计算核心上同时进行，而他们的操作是不同的，并且他们之间相互独立，不需要额外的同步和信息共享。</li>
<li>并行数据流： 如果数据本身存在的天然的独立性，比如图像中的每一个像素，那么在对这个图像做处理的过程中，同一个指令可以同时作用于每一个像素。在这种情况下，这个对于完整图像的操作可以并行化。理论上，如果内存不是问题，并且计算单元的数量大于整个图像中总像素点的话，这个操作可以在一个时钟周期内完成。</li>
</ul>
<p>GPU整体的架构而言，某种意义上是同时支持以上两种并行模式。在同一个流处理器中，采用了“单一指令并行数据流的模式”，而在多个流处理器中，同一时间可以派发不同的指令。从这一点出发，GPU芯片算是一个非常灵活的架构。一个芯片中，流处理器的个数和其中包含的CUDA核心的数量也是一种面向应用设计时候找到的一个平衡点。</p>
<p>基于深度学习中大部分的操作的天然并行性（大量的矩阵操作），GPU在当下还是一种非常适合的计算平台。一个非常典型的例子就是常见的矩阵相乘（如下图），要计算Z = X×Y，通过并行计算，X和Y中的行向量和列向量的逐元素相乘就可以同时进行，只要得到结果后再进行累加，而且累加的过程中也是可以进行并行化，使得效率有非常大的提高。Nvidia也是制定和开发了一套底层类库，CUBlas方便开发者。我们熟悉的几大框架(e.g. Tensorflow, PyTorch等)也是遵循和使用了这些并行类库，所以才使得训练和部署性能有了非常多的提高。</p>
<p><img src="mat_mul_gpu.png" alt="CUDA 矩阵乘法示例"></p>
<h3 id="15-3-4-深度学习中的GPU应用">15.3.4 深度学习中的GPU应用</h3>
<p>深度学习在最近几年内出现的井喷现象背后也是GPU的存在和发展作为坚实的推动力量。</p>
<p>哪些场景使用GPU</p>
<p>ImageNet的例子</p>
<h3 id="15-3-5-新图灵架构里的tensor-core对深度学习有什么作用？">15.3.5 新图灵架构里的tensor core对深度学习有什么作用？</h3>
<h2 id="15-4-CUDA-框架">15.4 CUDA 框架</h2>
<h3 id="15-4-1-做CUDA编程难不难？">15.4.1 做CUDA编程难不难？</h3>
<h3 id="15-4-2-cuDNN">15.4.2 cuDNN</h3>
<h2 id="15-5-GPU硬件环境配置推荐">15.5 GPU硬件环境配置推荐</h2>
<h3 id="15-5-1-GPU主要性能指标">15.5.1 GPU主要性能指标</h3>
<p>GPU的性能主要由以下三个参数构成：</p>
<ol>
<li>计算能力。通常我们关心的是32位浮点计算能力。16位浮点训练也开始流行，如果只做预测的话也可以用8位整数。</li>
<li>内存大小。当模型越大，或者训练时的批量越大时，所需要的GPU内存就越多。</li>
<li>内存带宽。只有当内存带宽足够时才能充分发挥计算能力。</li>
</ol>
<p>对于大部分用户来说，只要考虑计算能力就可以了。GPU内存尽量不小于4GB。但如果GPU要同时显示图形界面，那么推荐的内存大小至少为6GB。内存带宽通常相对固定，选择空间较小。</p>
<p>下图描绘了GTX 900和1000系列里各个型号的32位浮点计算能力和价格的对比。其中价格为Wikipedia的建议价格。</p>
<p><img src="gtx.png" alt="浮点计算能力和价格的对比。"></p>
<p>我们可以从图中读出两点信息：</p>
<ol>
<li>在同一个系列里面，价格和性能大体上成正比。但后发布的型号性价比更高，例如980 TI和1080 TI。</li>
<li>GTX 1000系列比900系列在性价比上高出2倍左右。</li>
</ol>
<p>如果大家继续比较GTX较早的系列，也可以发现类似的规律。据此，我们推荐大家在能力范围内尽可能买较新的GPU。</p>
<p>对于RTX系列，新增了Tensor Cores单元及支持FP16，使得显卡的可选择范围更加多元。</p>
<h3 id="15-5-2-购买建议">15.5.2 购买建议</h3>
<p>首先给出一些总体的建议：</p>
<p>性价比高但较贵：RTX 2070，GTX 1080 Ti</p>
<p>性价比高又便宜：RTX 2060，GTX 1060（6GB）</p>
<p>当使用数据集&gt; 250GB：GTX Titan X（Maxwell） ，NVIDIA Titan X Pascal或NVIDIA Titan Xp</p>
<p>没有足够的钱：GTX 1060（6GB）</p>
<p>几乎没有钱，入门级：GTX 1050 Ti（4GB）</p>
<p>做Kaggle比赛：RTX 2070、GTX 1060（6GB）适用于任何“正常”比赛，GTX 1080 Ti（预算足够可以选择RTX 2080 Ti）用于“深度学习竞赛”</p>
<p>计算机视觉研究员：RTX 2080 Ti（涡轮散热或水冷散热较好，方便后期增加新的显卡）如果网络很深可以选择Titan RTX</p>
<p>一名NLP研究人员：RTX 2080 Ti，并使用FP16来训练</p>
<p>搭建一个GPU集群：这个有点复杂，另做探讨。</p>
<p>刚开始进行深度学习研究：从RTX 2060或GTX 1060（6GB）开始，根据你下一步兴趣（入门，Kaggle比赛，研究，应用深度学习）等等，再进行选择。目前，RTX 2060和GTX 1060都比较合适入门的选择。</p>
<p>想尝试下深度学习，但没有过多要求：GTX 1050 ti（4或2GB）</p>
<p>目前独立GPU主要有AMD和Nvidia两家厂商。其中Nvidia在深度学习布局较早，对深度学习框架支持更好。因此，目前大家主要会选择Nvidia的GPU。</p>
<p>Nvidia有面向个人用户（例如GTX系列）和企业用户（例如Tesla系列）的两类GPU。这两类GPU的计算能力相当。然而，面向企业用户的GPU通常使用被动散热并增加了内存校验，从而更适合数据中心，并通常要比面向个人用户的GPU贵上10倍。</p>
<p>如果你是拥有100台机器以上的大公司用户，通常可以考虑针对企业用户的Nvidia Tesla系列。如果你是拥有10到100台机器的实验室和中小公司用户，预算充足的情况下可以考虑Nvidia DGX系列，否则可以考虑购买如Supermicro之类的性价比比较高的服务器，然后再购买安装GTX系列的GPU。</p>
<p>Nvidia一般每一两年发布一次新版本的GPU，例如2017年发布的是GTX 1000系列。每个系列中会有数个不同的型号，分别对应不同的性能。</p>
<h2 id="15-6-软件环境搭建">15.6 软件环境搭建</h2>
<p>深度学习其实就是指基于一套完整的软件系统来构建算法，训练模型。如何搭建一套完整的软件系统，比如操作系统的选择？安装环境中遇到的问题等等，本节做一个简单的总结。</p>
<h3 id="15-6-1-操作系统选择？">15.6.1 操作系统选择？</h3>
<p>针对硬件厂商来说，比如NVIDIA，对各个操作系统的支持都是比较好的 ，比如Windows系列,Linux系列，但是由于Linux系统对专业技术人员比较友好，所以目前几乎所有的深度学习系统构建都是基于Linux的，比较常用的系统如Ubuntu系列，CentOS系列等等。<br>
在构建系统的时候，如何选择合适的操作系是一个刚刚入门深度学习的工作者面临的问题，在这里给出几点建议：<br>
（1）刚刚入门，熟悉Windows系统，但是对Linux和深度学习都不太熟，这个时候可以基于windows系列系统来做入门学习<br>
（2）简单了解Linux的使用，不太懂深度学习相关知识，可以直接基于Linux系统来搭建框架，跑一些开源的项目，慢慢深入研究学习<br>
（3）熟悉Linux，不熟悉深度学习理论，毫无疑问，强烈推荐使用Linux系统，安装软件简单，工作效率高<br>
总之一句话，如果不熟悉Linux，就先慢慢熟悉，最终还是要回归到Linux系统来构建深度学习系统</p>
<h3 id="15-6-2-常用基础软件安装？">15.6.2 常用基础软件安装？</h3>
<p>目前有众多深度学习框架可供大家使用，但是所有框架基本都有一个共同的特点，目前几乎都是基于Nvidia的GPU来训练模型，要想更好的使用Nvidia的GPU，cuda和cudnn就是必备的软件安装。</p>
<ol>
<li>
<p><strong>安装cuda</strong><br>
上文中有关于cuda的介绍，这里只是简单介绍基于Linux系统安装cuda的具体步骤，可以根据自己的需要安装cuda8.0或者cuda9.0，这两种版本的安装步骤基本一致，这里以最常用的ubuntu 16.04 lts版本为例：</p>
<ol>
<li>官网下载，地址<br>
cuda8.0https://developer.nvidia.com/cuda-80-ga2-download-archive<br>
cuda9.0https://developer.nvidia.com/cuda-90-download-archive<br>
进入网址之后选择对应的系统版本即可，如下图所示：<br>
<img src="cuda8.0.png" alt="cuda8.0"></li>
</ol>
<p><img src="cuda9.0.png" alt="cuda9.0"></p>
<ol start="2">
<li>
<p>命令行中进入到cuda所在的位置，授予运行权限：<br>
cuda8.0: sudo chmod +x cuda_8.0.61_375.26_linux.run<br>
cuda9.0:sudo chmod +x cuda_9.0.176_384.81_linux.run</p>
</li>
<li>
<p>执行命令安装cuda：<br>
cuda8.0:sudo sh cuda_8.0.61_375.26_linux.run<br>
cuda9.0:sudo sh cuda_9.0.176_384.81_linux.run<br>
之后命令之后下面就是安装步骤，cuda8.0和cuda9.0几乎一致：</p>
</li>
</ol>
<ul>
<li>
<p>首先出现cuda软件的版权说明，可以直接按q键跳过阅读</p>
</li>
<li>
<p>Do you accept the previously read EULA?<br>
​accept/decline/quit: <strong>accept</strong></p>
</li>
<li>
<p>Install NVIDIA Accelerated Graphics Driver for Linux-x86_64 384.81?<br>
​(y)es/(n)o/(q)uit:<strong>no</strong></p>
</li>
<li>
<p>Install the CUDA 9.0 Toolkit?<br>
​(y)es/(n)o/(q)uit:<strong>yes</strong></p>
</li>
<li>
<p>Enter Toolkit Location<br>
​ [ default is /usr/local/cuda-9.0 ]:直接按enter键即可</p>
</li>
<li>
<p>Do you want to install a symbolic link at /usr/local/cuda?<br>
​(y)es/(n)o/(q)uit:<strong>yes</strong></p>
</li>
<li>
<p>Install the CUDA 9.0 Samples?<br>
​ (y)es/(n)o/(q)uit:<strong>yes</strong></p>
</li>
</ul>
<p>以上步骤基本就是cuda的安装步骤。</p>
</li>
<li>
<p><strong>安装cudnn</strong><br>
cudnn是Nvidia的专门针对深度学习的加速库。。。</p>
</li>
</ol>
<h3 id="15-6-3-本机安装还是使用docker？">15.6.3 本机安装还是使用docker？</h3>
<h3 id="15-6-4-GPU驱动问题">15.6.4 GPU驱动问题</h3>
<h2 id="15-7-框架选择">15.7 框架选择</h2>
<h3 id="15-7-1-主流框架比较">15.7.1 主流框架比较</h3>
<p>（一个大表格比较）</p>
<h3 id="15-7-2-框架详细信息">15.7.2 框架详细信息</h3>
<ul>
<li>
<p>Tensorflow<br>
Tensorflow是Google于2015年开源的基于数据流编程的深度学习框架，得益于Google强大的技术实力和品牌背书，目前Tensorflow发展迅猛，其用户量远远超过其它框架用户。<br>
优点：</p>
<ol>
<li>由谷歌开发、维护，因此可以保障支持、开发的持续性</li>
<li>巨大、活跃的社区</li>
<li>网络训练的低级、高级接口</li>
<li>「TensorBoard」是一款强大的可视化套件，旨在跟踪网络拓扑和性能，使调试更加简单</li>
<li>TensorFlow 不仅支持深度学习，还有支持强化学习和其他算法的工具<br>
缺点：</li>
<li>计算图是纯 Python 的，因此速度较慢</li>
<li>图构造是静态的，意味着图必须先被「编译」再运行</li>
</ol>
</li>
<li>
<p>PyTorch<br>
pytorch是Facebook于2017年才推出的深度学习框架，相对于其它框架，算是比较晚的了，但是这个同时也是优势，在设计的时候就会避免很多之前框架的问题，所以一经推出，就收到大家极大的欢迎<br>
优点：</p>
<ol>
<li>接口简洁且规范，文档齐全，和python无缝结合，</li>
<li>社区非常活跃，开源实现较多</li>
<li>提供动态计算图（意味着图是在运行时生成的），允许你处理可变长度的输入和输出，例如，在使用 RNN 时非常有用</li>
<li>易于编写自己的图层类型，易于在 GPU 上运行</li>
<li>「TensorBoard」缺少一些关键功能时，「Losswise」可以作为 Pytorch 的替代品</li>
</ol>
</li>
</ul>
<p>缺点:</p>
<ol>
<li>模型部署相对其它框架稍有劣势，不过后续的pytorch1.0版本应该会有很大改善，和caffe2合并后，caffe2的优秀的模型部署能力可以弥补这个不足</li>
<li></li>
<li></li>
</ol>
<p>相关资源链接：</p>
<ol>
<li>官网教程：<a href="https://pytorch.org/tutorials/">https://pytorch.org/tutorials/</a></li>
<li>基于pytorch的开源项目汇总：<a href="https://github.com/bharathgs/Awesome-pytorch-list">https://github.com/bharathgs/Awesome-pytorch-list</a></li>
<li></li>
</ol>
<ul>
<li>
<p>Keras<br>
Keras 是一个更高级、对用户最友好的 API，具有可配置的后端，由 Google Brain 团队成员 Francis Chollet 编写和维护<br>
优点：</p>
<ol>
<li>提供高级 API 来构建深度学习模型，使其易于阅读和使用</li>
<li>编写规范的文档</li>
<li>大型、活跃的社区</li>
<li>位于其他深度学习库（如 Theano 和 TensorFlow，可配置）之上</li>
<li>使用面向对象的设计，因此所有内容都被视为对象（如网络层、参数、优化器等）。所有模型参数都可以作为对象属性进行访问<br>
缺点：</li>
<li>由于用途非常普遍，所以在性能方面比较欠缺</li>
<li>与 TensorFlow 后端配合使用时会出现性能问题（因为并未针对其进行优化），但与 Theano 后端配合使用时效果良好</li>
<li>不像 TensorFlow 或 PyTorch 那样灵活</li>
</ol>
</li>
<li>
<p>Sonnet</p>
</li>
<li>
<p>Caffe<br>
caffe是第一个主流产品级深度学习库，于 2014 年由 UC Berkeley 发布开源<br>
优点：</p>
<ol>
<li>简单网络结构无需编写代码，可快速实现</li>
<li>漂亮的 Matlab 和 Python 接口</li>
<li>完全由c++编程实现，部署方便</li>
</ol>
</li>
</ul>
<p>缺点：</p>
<ol>
<li>不灵活。在 Caffe 中，每个节点被当做一个层，因此如果你想要一种新的层类型，你需要定义完整的前向、后向和梯度更新过程。这些层是网络的构建模块，你需要在无穷无尽的列表中进行选择。（相反，在 TensorFlow 中，每个节点被当做一个张量运算例如矩阵相加、相乘或卷积。你可以轻易地定义一个层作为这些运算的组合。因此 TensorFlow 的构建模块更小巧，允许更灵活的模块化。）</li>
<li>需要大量的非必要冗长代码。如果你希望同时支持 CPU 和 GPU，你需要为每一个实现额外的函数。你还需要使用普通的文本编辑器来定义你的模型。真令人头疼！几乎每个人都希望程序化地定义模型，因为这有利于不同组件之间的模块化。有趣的是，Caffe 的主要架构师现在在 TensorFlow 团队工作</li>
<li>专一性。仅定位在计算机视觉（但做得很不错）</li>
<li>不是以 Python 编写！如果你希望引入新的变动，你需要在 C++和 CUDA 上编程（对于更小的变动，你可以使用它的 Python 和 Matlab 接口）</li>
<li>糟糕的文档</li>
<li>安装比较困难！有大量的依赖包</li>
</ol>
<ul>
<li>
<p>Caffe2</p>
</li>
<li>
<p>MxNet<br>
MxNet是dmlc社区推出的深度学习框架，MXNet由学术界发起，包括数个顶尖大学的多个学科的研究人员的贡献，在2017年被亚马逊指定为官方框架。<br>
mxnet的最知名的优点就是其对多GPU的支持和扩展性强，其优秀的性能使之在工业界占有一席之地，在amazon支持之后，其文档和开发进度明显好很多。除了高可扩展性，MXNet 还提供混合编程模型（命令式和声明式），同时兼容多种编程语言（包括 Python、C ++、R、Scala、Julia、Matlab 和 JavaScript）的代码，目前主要在推python高层接口gluon</p>
</li>
</ul>
<p>优点：</p>
<ol>
<li>多GPU支持好，扩展性强，支持多种编程语言接口，主要是由华人团队开发，中文社区活跃，中文文档资源和课程丰富</li>
<li>针对两大热门领域推出gluoncv和gluonNLP模块，复现经典论文，达到State-of-the-art，接口设计简单，文档齐全，拿来就可以用<br>
缺点:</li>
<li>现在mxnet官方社区主要在推gluon接口，接口稍有混乱，坑较多，入手门槛稍高</li>
<li>偏小众，经典网络和项目的开源实现相对于tensorflow和pytorch还是比较少，很多还是需要自己手动实现<br>
相关资源链接：</li>
<li>官方教程：<a href="http://mxnet.incubator.apache.org">http://mxnet.incubator.apache.org</a> 提供有快速入门教程和详细文档说明</li>
<li>中文教程：<a href="http://zh.gluon.ai/">http://zh.gluon.ai/</a> 官方的中文教程，此课程有对应的中文版视频，主要由李沐大神讲课</li>
<li>中文论坛：<a href="https://discuss.gluon.ai/">https://discuss.gluon.ai/</a> 官方发中文论坛，mxnet的主要作者都在这里，论坛比较活跃，可及时得到作者的回答</li>
<li>基于mxnet的开源项目实现：<a href="https://github.com/chinakook/Awesome-MXNet%E8%BF%99%E9%87%8C%E4%B8%BB%E8%A6%81%E5%88%97%E4%B8%BE%E4%BA%86mxnet%E5%9C%A8%E5%90%84%E4%B8%AA%E9%A2%86%E5%9F%9F%E7%9A%84%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%BC%80%E6%BA%90%E5%AE%9E%E7%8E%B0">https://github.com/chinakook/Awesome-MXNet这里主要列举了mxnet在各个领域的项目的开源实现</a></li>
</ol>
<ul>
<li>
<p>CNTK</p>
</li>
<li>
<p>PaddlePaddle</p>
</li>
<li>
<p>其他国内自主开发开源框架</p>
</li>
</ul>
<h3 id="15-7-3-哪些框架对于部署环境友好？">15.7.3 哪些框架对于部署环境友好？</h3>
<ul>
<li>
<p>Tensorflow Serving</p>
</li>
<li>
<p>ONNX 标准</p>
</li>
<li>
<p>TensorRT</p>
</li>
<li>
<p>ONNPACK</p>
</li>
<li>
<p>Clipper</p>
</li>
</ul>
<h3 id="15-7-4-移动平台的框架如何选择？">15.7.4 移动平台的框架如何选择？</h3>
<ul>
<li>
<p>Tensorflow Lite</p>
</li>
<li>
<p>Caffe2</p>
</li>
</ul>
<h2 id="15-8-其他">15.8 其他</h2>
<h3 id="15-8-1-多GPU环境的配置">15.8.1 多GPU环境的配置</h3>
<ul>
<li>
<p>Tensorflow</p>
</li>
<li>
<p>PyTorch</p>
</li>
</ul>
<h3 id="15-8-2-是不是可以分布式训练？">15.8.2 是不是可以分布式训练？</h3>
<h3 id="15-8-3-可以在SPARK环境里训练或者部署模型吗？">15.8.3 可以在SPARK环境里训练或者部署模型吗？</h3>
<h3 id="15-8-4-怎么进一步优化性能？">15.8.4 怎么进一步优化性能？</h3>
<ul>
<li>
<p>TVM</p>
</li>
<li>
<p>nGraph</p>
</li>
</ul>
<h3 id="15-8-5-TPU和GPU的区别？">15.8.5 TPU和GPU的区别？</h3>
<h3 id="15-8-6-未来量子计算对于深度学习等AI技术的影响？">15.8.6 未来量子计算对于深度学习等AI技术的影响？</h3>
<hr>
<h2 id="15-1-GPU购买指南">15.1 GPU购买指南</h2>
<p>深度学习训练通常需要大量的计算资源。GPU目前是深度学习最常使用的计算加速硬件。相对于CPU来说，GPU更便宜且计算更加密集。一方面，相同计算能力的GPU的价格一般是CPU价格的十分之一。另一方面，一台服务器通常可以搭载8块或者16块GPU。因此，GPU数量可以看作是衡量一台服务器的深度学习计算能力的一个标准。</p>
<h3 id="15-1-1-如何选择GPU">15.1.1 如何选择GPU</h3>
<h3 id="15-1-2-GPU的主要性能指标">15.1.2 GPU的主要性能指标</h3>
<p>在选择GPU时，首先要考虑的第一个GPU性能问题是什么呢：是否为cuda核心？时钟速度多大？内存大小多少？<br>
这些都不是，对于深度学习性能而言，最重要的特征是内存带宽（memory bandwidth）。<br>
简而言之：GPU针对内存带宽进行了优化，但同时牺牲了内存访问时间（延迟）。CPU的设计恰恰相反：如果涉及少量内存（例如几个数字相乘（3 * 6 * 9）），CPU可以快速计算，但是对于大量内存（如矩阵乘法（A * B * C）则很慢。由于内存带宽的限制，当涉及大量内存的问题时，GPU快速计算的优势往往会受到限制。当然，GPU和CPU之间还有更复杂的区别，关于为何GPU如此适用于处理深度学习问题，另做探讨。</p>
<p>所以如果你想购买一个快速的GPU，首先要关注的是GPU的带宽（bandwidth）。</p>
<h3 id="15-1-3-整机配置">15.1.3 整机配置</h3>
<p>通常，我们主要用GPU做深度学习训练。因此，不需要购买高端的CPU。至于整机配置，尽量参考网上推荐的中高档的配置就好。不过，考虑到GPU的功耗、散热和体积，我们在整机配置上也需要考虑以下三个额外因素。</p>
<ol>
<li>机箱体积。GPU尺寸较大，通常考虑较大且自带风扇的机箱。</li>
<li>电源。购买GPU时需要查一下GPU的功耗，例如50W到300W不等。购买电源要确保功率足够，且不会过载机房的供电。</li>
<li>主板的PCIe卡槽。推荐使用PCIe 3.0 16x来保证充足的GPU到主内存的带宽。如果搭载多块GPU，要仔细阅读主板说明，以确保多块GPU一起使用时仍然是16x带宽。注意，有些主板搭载4块GPU时会降到8x甚至4x带宽。</li>
</ol>
<h3 id="15-1-4-小结">15.1.4 小结</h3>
<ul>
<li>在预算范围之内，尽可能买较新的GPU。</li>
<li>整机配置需要考虑到GPU的功耗、散热和体积。</li>
</ul>
<h2 id="15-2-框架选型">15.2 框架选型</h2>
<p>目前常用的框架有tensorflow,keras,pytorch,mxnet等等，各个框架的优缺点在此简单介绍：</p>
<h3 id="15-2-1-常用框架简介">15.2.1 常用框架简介</h3>
<ol>
<li>
<p>tensorflow：<br>
tensorflow由于有google的强大背书，加上其优秀的分布式设计，丰富的教程资源和论坛，工业部署方便，基本很多人都是从tensorflow入门的<br>
优点：google的强大背书，分布式训练，教程资源丰富，常见问题基本都可以在互联网中找到解决办法，工业部署方便<br>
缺点: 接口混乱，官方文档不够简洁，清晰，</p>
</li>
<li>
<p>keras:<br>
keras是一种高层编程接口，其可以选择不同的后端，比如tensorflow，therao等等<br>
优点：接口简洁，上手快，文档好，资源多<br>
缺点: 封装的太好了导致不理解其技术细节</p>
</li>
<li>
<p>pytorch:<br>
PyTorch是一个开源的Python机器学习库，基于Torch，从官方1.0版本开始已经完美结合caffe2，主要应用于人工智能领域，如自然语言处理。它最初由Facebook的人工智能研究团队开发.<br>
优点：文档清晰，兼容NumPy的张量计算，基于带基自动微分系统的深度神经网络，由Facebook开发维护，常见model都有pytorch复现版<br>
缺点：工业部署稍弱（但是合并caffe2后支持全平台部署）</p>
</li>
<li>
<p>mxnet<br>
mxnet是dmlc社区推出的深度学习框架，在2017年被亚马逊指定为官方框架<br>
优点：支持多种语言，代码设计优秀，省显存，华人团队开发，中文社区活跃，官方复现经典论文推出gluoncv和gluonNLP模块，非常方便，拿来就可以用。<br>
缺点:现在mxnet官方社区主要在推gluon接口，接口稍有混乱，坑较多，入手门槛稍高</p>
</li>
<li>
<p>caffe：<br>
目前很多做深度学习比较早的大厂基本都是在用caffe，因为在2013-2015年基本就是caffe的天下，并且caffe的代码设计很优秀，基本所有代码都被翻了很多遍了，被各种分析，大厂基本都是魔改caffe，基于caffe来进行二次开发，所在目前在很多大厂还是在使用caffe<br>
优点：资源丰富，代码容易理解，部署方便<br>
缺点：入门门槛高，文档较少</p>
</li>
</ol>
<p>框架选型总结:</p>
<ol>
<li>新手入门，首推pytorch，上手快，资源丰富,官方文档写的非常好(<a href="https://pytorch.org/tutorials/">https://pytorch.org/tutorials/</a>)</li>
<li>目前工业部署，tensorflow是首选,资源丰富，并且在分布式训练这一块基本一家独大</li>
<li>mxnet的gluon接口有比较丰富的中文资源（教程：<a href="http://zh.gluon.ai">zh.gluon.ai</a>，论坛：<a href="http://discuss.gluon.ai">discuss.gluon.ai</a>）,gluoncv模块（<a href="https://gluon-cv.mxnet.io">https://gluon-cv.mxnet.io</a>）,gluonNLP模块（<a href="https://gluon-nlp.mxnet.io">https://gluon-nlp.mxnet.io</a>）</li>
</ol>
<h2 id="15-3-模型部署">15.3 模型部署</h2>
<p>我们一般都是通过python或者其他语言来编码训练模型，然后基于后端来进行部署<br>
一般的框架都有自身的部署框架，比如tensorflow，pytorch，caffe2，mxnet等等<br>
有一些框架是专门做推理部署使用的，比如<br>
(1)tensorRT<br>
(2)TVM<br>
(3)ONNX</p>
<h2 id="相关文献">相关文献</h2>
<p>[1] Aston Zhang, Mu Li, Zachary C. Lipton, and Alex J. Smola. <a href="https://github.com/d2l-ai/d2l-zh/blob/master/chapter_appendix/buy-gpu.md">《动手学深度学习》附录 购买GPU</a>, 2019.<br>
[2] Tim Dettmers. <a href="http://timdettmers.com/2019/04/03/which-gpu-for-deep-learning/">Which GPU(s) to Get for Deep Learning: My Experience and Advice for Using GPUs in Deep Learning</a>, 2019.</p>
]]></content>
      <categories>
        <category>算法面试</category>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>刷八股</tag>
      </tags>
  </entry>
  <entry>
    <title>超参数调整面试题</title>
    <url>/2024/03/19/deep_learning/ch14/</url>
    <content><![CDATA[<h1>超参数调整</h1>
<h2 id="14-1-写在前面">14.1 写在前面</h2>
<p>​	关于训练深度学习模型最难的事情之一是你要处理的参数的数量。无论是从网络本身的层宽（宽度）、层数（深度）、连接方式，还是损失函数的超参数设计和调试，亦或者是学习率、批样本数量、优化器参数等等。这些大量的参数都会有网络模型最终的有效容限直接或者间接的影响。面对如此众多的参数，如果我们要一一对其优化调整，所需的无论是时间、资源都是不切实际。结果证实一些超参数比其它的更为重要，因此认识各个超参数的作用和其可能会造成的影响是深度学习训练中必不可少的一项重要技能。</p>
<p>​	超参数调整可以说是深度学习中理论和实际联系最重要的一个环节。目前，深度学习仍存在很多不可解释的部分，如何设计优化出好的网络可以为深度学习理论的探索提供重要的支持。超参数调整一般分为手动调整和自动优化超参数两种。读者可先浏览思维导图，本章节不会过多阐述所有超参数的详细原理，如果需要了解这部分，您可以翻阅前面的基础章节或者查阅相关文献资料。当然，下面会讲到的一些超参数优化的建议是根据笔者们的实践以及部分文献资料得到认知建议，并不是非常严格且一定有效的，很多研究者可能会很不同意某些的观点或有着不同的直觉，这都是可保留讨论的，因为这很依赖于数据本身情况。</p>
<p><img src="img%5Cch14%5C%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.png" alt></p>
<p>​</p>
<h2 id="14-2-超参数概念">14.2 超参数概念</h2>
<h3 id="14-2-1-什么是超参数，参数和超参数的区别？">14.2.1 什么是超参数，参数和超参数的区别？</h3>
<p>​	区分两者最大的一点就是是否通过数据来进行调整，模型参数通常是有数据来驱动调整，超参数则不需要数据来驱动，而是在训练前或者训练中人为的进行调整的参数。例如卷积核的具体核参数就是指模型参数，这是有数据驱动的。而学习率则是人为来进行调整的超参数。这里需要注意的是，通常情况下卷积核数量、卷积核尺寸这些也是超参数，注意与卷积核的核参数区分。</p>
<h3 id="14-2-2-神经网络中包含哪些超参数？">14.2.2 神经网络中包含哪些超参数？</h3>
<p>通常可以将超参数分为三类：网络参数、优化参数、正则化参数。</p>
<p>​	网络参数：可指网络层与层之间的交互方式（相加、相乘或者串接等）、卷积核数量和卷积核尺寸、网络层数（也称深度）和激活函数等。</p>
<p>​	优化参数：一般指学习率（learning rate）、批样本数量（batch size）、不同优化器的参数以及部分损失函数的可调参数。</p>
<p>​	正则化：权重衰减系数，丢弃比率（dropout）</p>
<h3 id="14-2-3-为什么要进行超参数调优？">14.2.3 为什么要进行超参数调优？</h3>
<p>​	本质上，这是模型优化寻找最优解和正则项之间的关系。网络模型优化调整的目的是为了寻找到全局最优解（或者相比更好的局部最优解），而正则项又希望模型尽量拟合到最优。两者通常情况下，存在一定的对立，但两者的目标是一致的，即最小化期望风险。模型优化希望最小化经验风险，而容易陷入过拟合，正则项用来约束模型复杂度。所以如何平衡两者之间的关系，得到最优或者较优的解就是超参数调整优化的目的。</p>
<h3 id="14-2-4-超参数的重要性顺序">14.2.4 超参数的重要性顺序</h3>
<ul>
<li>
<p>首先， <strong>学习率，损失函数上的可调参数</strong>。在网络参数、优化参数、正则化参数中最重要的超参数可能就是学习率了。学习率直接控制着训练中网络梯度更新的量级，直接影响着模型的<strong>有效容限能力</strong>；损失函数上的可调参数，这些参数通常情况下需要结合实际的损失函数来调整，大部分情况下这些参数也能很直接的影响到模型的的有效容限能力。这些损失一般可分成三类，第一类辅助损失结合常见的损失函数，起到辅助优化特征表达的作用。例如度量学习中的Center loss，通常结合交叉熵损失伴随一个权重完成一些特定的任务。这种情况下一般建议辅助损失值不高于或者不低于交叉熵损失值的两个数量级；第二类，多任务模型的多个损失函数，每个损失函数之间或独立或相关，用于各自任务，这种情况取决于任务之间本身的相关性，目前笔者并没有一个普适的经验由于提供参考；第三类，独立损失函数，这类损失通常会在特定的任务有显著性的效果。例如RetinaNet中的focal loss，其中的参数γ，α，对最终的效果会产生较大的影响。这类损失通常论文中会给出特定的建议值。</p>
</li>
<li>
<p>其次，<strong>批样本数量，动量优化器（Gradient Descent with Momentum）的动量参数<em>β</em></strong>。批样本决定了数量梯度下降的方向。过小的批数量，极端情况下，例如batch size为1，即每个样本都去修正一次梯度方向，样本之间的差异越大越难以收敛。若网络中存在批归一化（batchnorm），batch size过小则更难以收敛，甚至垮掉。这是因为数据样本越少，统计量越不具有代表性，噪声也相应的增加。而过大的batch size，会使得梯度方向基本稳定，容易陷入局部最优解，降低精度。一般参考范围会取在[1:1024]之间，当然这个不是绝对的，需要结合具体场景和样本情况；动量衰减参数<em>β</em>是计算梯度的指数加权平均数，并利用该值来更新参数，设置为 0.9 是一个常见且效果不错的选择；</p>
</li>
<li>
<p>最后，<strong>Adam优化器的超参数、权重衰减系数、丢弃法比率（dropout）和网络参数</strong>。在这里说明下，这些参数重要性放在最后<strong>并不等价于这些参数不重要</strong>。而是表示这些参数在大部分实践中<strong>不建议过多尝试</strong>，例如Adam优化器中的<em>β1，β2，ϵ</em>，常设为 0.9、0.999、10−8就会有不错的表现。权重衰减系数通常会有个建议值，例如0.0005 ，使用建议值即可，不必过多尝试。dropout通常会在全连接层之间使用防止过拟合，建议比率控制在[0.2,0.5]之间。使用dropout时需要特别注意两点：一、在RNN中，如果直接放在memory cell中,循环会放大噪声，扰乱学习。一般会建议放在输入和输出层；二、不建议dropout后直接跟上batchnorm，dropout很可能影响batchnorm计算统计量，导致方差偏移，这种情况下会使得推理阶段出现模型完全垮掉的极端情况；网络参数通常也属于超参数的范围内，通常情况下增加网络层数能增加模型的容限能力，但模型真正有效的容限能力还和样本数量和质量、层之间的关系等有关，所以一般情况下会选择先固定网络层数，调优到一定阶段或者有大量的硬件资源支持可以在网络深度上进行进一步调整。</p>
</li>
</ul>
<h3 id="14-2-5-部分超参数如何影响模型性能？">14.2.5 部分超参数如何影响模型性能？</h3>
<table>
<thead>
<tr>
<th style="text-align:center">超参数</th>
<th style="text-align:center">如何影响模型容量</th>
<th style="text-align:center">原因</th>
<th style="text-align:center">注意事项</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">学习率</td>
<td style="text-align:center">调至最优，提升有效容量</td>
<td style="text-align:center">过高或者过低的学习率，都会由于优化失败而导致降低模型有效容限</td>
<td style="text-align:center">学习率最优点，在训练的不同时间点都可能变化，所以需要一套有效的学习率衰减策略</td>
</tr>
<tr>
<td style="text-align:center">损失函数部分超参数</td>
<td style="text-align:center">调至最优，提升有效容量</td>
<td style="text-align:center">损失函数超参数大部分情况都会可能影响优化，不合适的超参数会使即便是对目标优化非常合适的损失函数同样难以优化模型，降低模型有效容限。</td>
<td style="text-align:center">对于部分损失函数超参数其变化会对结果十分敏感，而有些则并不会太影响。在调整时，建议参考论文的推荐值，并在该推荐值数量级上进行最大最小值调试该参数对结果的影响。</td>
</tr>
<tr>
<td style="text-align:center">批样本数量</td>
<td style="text-align:center">过大过小，容易降低有效容量</td>
<td style="text-align:center">大部分情况下，选择适合自身硬件容量的批样本数量，并不会对模型容限造成。</td>
<td style="text-align:center">在一些特殊的目标函数的设计中，如何选择样本是很可能影响到模型的有效容限的，例如度量学习（metric learning）中的N-pair loss。这类损失因为需要样本的多样性，可能会依赖于批样本数量。</td>
</tr>
<tr>
<td style="text-align:center">丢弃法</td>
<td style="text-align:center">比率降低会提升模型的容量</td>
<td style="text-align:center">较少的丢弃参数意味着模型参数量的提升，参数间适应性提升，模型容量提升，但不一定能提升模型有效容限</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">权重衰减系数</td>
<td style="text-align:center">调至最优，提升有效容量</td>
<td style="text-align:center">权重衰减可以有效的起到限制参数变化的幅度，起到一定的正则作用</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">优化器动量</td>
<td style="text-align:center">调至最优，可能提升有效容量</td>
<td style="text-align:center">动量参数通常用来加快训练，同时更容易跳出极值点，避免陷入局部最优解。</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">模型深度</td>
<td style="text-align:center">同条件下，深度增加，模型容量提升</td>
<td style="text-align:center">同条件，下增加深度意味着模型具有更多的参数，更强的拟合能力。</td>
<td style="text-align:center">同条件下，深度越深意味着参数越多，需要的时间和硬件资源也越高。</td>
</tr>
<tr>
<td style="text-align:center">卷积核尺寸</td>
<td style="text-align:center">尺寸增加，模型容量提升</td>
<td style="text-align:center">增加卷积核尺寸意味着参数量的增加，同条件下，模型参数也相应的增加。</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h3 id="14-2-6-部分超参数合适的范围">14.2.6 部分超参数合适的范围</h3>
<table>
<thead>
<tr>
<th style="text-align:center">超参数</th>
<th style="text-align:center">建议范围</th>
<th style="text-align:center">注意事项</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">初始学习率</td>
<td style="text-align:center">SGD: [1e-2, 1e-1]<br>momentum: [1e-3, 1e-2]<br>Adagrad: [1e-3, 1e-2]<br>Adadelta: [1e-2, 1e-1]<br>RMSprop: [1e-3, 1e-2]<br>Adam: [1e-3, 1e-2]<br>Adamax: [1e-3, 1e-2]<br>Nadam: [1e-3, 1e-2]</td>
<td style="text-align:center">这些范围通常是指从头开始训练的情况。若是微调，初始学习率可在降低一到两个数量级。</td>
</tr>
<tr>
<td style="text-align:center">损失函数部分超参数</td>
<td style="text-align:center">多个损失函数之间，损失值之间尽量相近，不建议超过或者低于两个数量级</td>
<td style="text-align:center">这是指多个损失组合的情况，不一定完全正确。单个损失超参数需结合实际情况。</td>
</tr>
<tr>
<td style="text-align:center">批样本数量</td>
<td style="text-align:center">[1:1024]</td>
<td style="text-align:center">当批样本数量过大(大于6000)或者等于1时，需要注意学习策略或者内部归一化方式的调整。</td>
</tr>
<tr>
<td style="text-align:center">丢弃法比率</td>
<td style="text-align:center">[0, 0.5]</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">权重衰减系数</td>
<td style="text-align:center">[0, 1e-4]</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">卷积核尺寸</td>
<td style="text-align:center">[7x7],[5x5],[3x3],[1x1], [7x1,1x7]</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h2 id="14-3-网络训练中的超参调整策略">14.3 网络训练中的超参调整策略</h2>
<h3 id="14-3-1-如何调试模型？">14.3.1 如何调试模型？</h3>
<p>在讨论如何调试模型之前，我们先来纠正一个误区。通常理解如何调试模型的时候，我们想到一系列优秀的神经网络模型以及调试技巧。但这里需要指出的是数据才是模型的根本，如果有一批质量优秀的数据，或者说你能将数据质量处理的很好的时候，往往比挑选或者设计模型的收益来的更大。那在这之后才是模型的设计和挑选以及训练技巧上的事情。</p>
<p>1、探索和清洗数据。探索数据集是设计算法之前最为重要的一步，以图像分类为例，我们需要重点知道给定的数据集样本类别和各类别样本数量是否平衡，图像之间是否存在跨域问题（例如网上爬取的图像通常质量各异，存在噪声）。若是类别数远远超过类别样本数（比如类别10000，每个类别却只有10张图像），那通常的方法可能效果并不显著，这时候few-shot learning或者对数据集做进一步增强可能是你比较不错的选择。再如目标检测，待检测目标在数据集中的尺度范围是对检测器的性能有很大影响的部分。因此重点是检测大目标还是小目标、目标是否密集完全取决于数据集本身。所以，探索和进一步清洗数据集一直都是深度学习中最重要的一步。这是很多新手通常会忽略的一点。</p>
<p>2、探索模型结果。探索模型的结果，通常是需要对模型在验证集上的性能进行进一步的分析，这是如何进一步提升模型性能很重要的步骤。将模型在训练集和验证集都进行结果的验证和可视化，可直观的分析出模型是否存在较大偏差以及结果的正确性。以图像分类为例，若类别间样本数量很不平衡时，我们需要重点关注少样本类别在验证集的结果是否和训练集的出入较大，对出错类别可进一步进行模型数值分析以及可视化结果分析，进一步确认模型的行为。</p>
<p>3、监控训练和验证误差。首先很多情况下，我们忽略代码的规范性和算法撰写正确性验证，这点上容易产生致命的影响。在训练和验证都存在问题时，首先请确认自己的代码是否正确。其次，根据训练和验证误差进一步追踪模型的拟合状态。若训练数据集很小，此时监控误差则显得格外重要。确定了模型的拟合状态对进一步调整学习率的策略的选择或者其他有效超参数的选择则会更得心应手。</p>
<p>4、反向传播数值的计算，这种情况通常适合自己设计一个新操作的情况。目前大部分流行框架都已包含自动求导部分，但并不一定是完全符合你的要求的。验证求导是否正确的方式是比较自动求导的结果和有限差分计算结果是否一致。所谓有限差分即导数的定义，使用一个极小的值近似导数。</p>
 $$
f^{'}(x_0) = \lim_{n\rightarrow0}\frac{\Delta y}{\Delta x} = \lim_{n\rightarrow0}\frac{f(x_0+\Delta x -f(x_0))}{\Delta x}
$$ 
<h3 id="14-3-2-为什么要做学习率调整">14.3.2 为什么要做学习率调整?</h3>
<p>​	学习率可以说是模型训练最为重要的超参数。通常情况下，一个或者一组优秀的学习率既能加速模型的训练，又能得到一个较优甚至最优的精度。过大或者过小的学习率会直接影响到模型的收敛。我们知道，当模型训练到一定程度的时候，损失将不再减少，这时候模型的一阶梯度接近零，对应Hessian 矩阵通常是两种情况，一、正定，即所有特征值均为正，此时通常可以得到一个局部极小值，若这个局部极小值接近全局最小则模型已经能得到不错的性能了，但若差距很大，则模型性能还有待于提升，通常情况下后者在训练初最常见。二，特征值有正有负，此时模型很可能陷入了鞍点，若陷入鞍点，模型性能表现就很差。以上两种情况在训练初期以及中期，此时若仍然以固定的学习率，会使模型陷入左右来回的震荡或者鞍点，无法继续优化。所以，学习率衰减或者增大能帮助模型有效的减少震荡或者逃离鞍点。</p>
<h3 id="14-3-3-学习率调整策略有哪些？">14.3.3 学习率调整策略有哪些？</h3>
<p>通常情况下，大部分学习率调整策略都是衰减学习率，但有时若增大学习率也同样起到奇效。这里结合TensorFlow的内置方法来举例。</p>
<p>1、<strong>exponential_decay</strong>和<strong>natural_exp_decay</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">exponential_decay(learning_rate, global_step, decay_steps, decay_rate,</span><br><span class="line">                   staircase=<span class="literal">False</span>, name=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">natural_exp_decay(learning_rate, global_step, decay_steps, decay_rate,</span><br><span class="line">                   staircase=<span class="literal">False</span>, name=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>指数衰减是最常用的衰减方式，这种方式简单直接，在训练初期衰减较大利于收敛，在后期衰减较小利于精调。以上两种均为指数衰减，区别在于后者使用以自然指数下降。</p>
<p><img src="img%5Cch14%5C%E6%8C%87%E6%95%B0%E8%A1%B0%E5%87%8F.jpeg" alt="./"></p>
<p>2、<strong>piecewise_constant</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">piecewise_constant(x, boundaries, values, name=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>分段设置学习率法，跟指数型类似，区别在于每个阶段的衰减并不是按指数调整。可在不同阶段设置手动不同的学习率。这种学习率重点在有利于精调。</p>
<p>3、<strong>polynomial_decay</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">polynomial_decay(learning_rate, global_step, decay_steps,</span><br><span class="line">                  end_learning_rate=<span class="number">0.0001</span>, power=<span class="number">1.0</span>,</span><br><span class="line">                  cycle=<span class="literal">False</span>, name=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>多项式衰减，计算如下：</p>
 $$
global setp = min(global step, decay steps)
$$ 
 $$
lr_{decayed} = (lr-lr_{end})*(1-{globalstep\over decaysteps})^{power} +lr_{end}
$$ 
<p>有别于上述两种，多项式衰减则是在每一步迭代上都会调整学习率。主要看Power参数，若Power为1，则是下图中的红色直线；若power小于1，则是开1/power次方，为蓝色线；绿色线为指数，power大于1。</p>
<p><img src="img%5Cch14%5C%E5%A4%9A%E9%A1%B9%E5%BC%8F%E8%A1%B0%E5%87%8F.jpeg" alt></p>
<p>此外，需要注意的是参数cycle，cycle对应的是一种周期循环调整的方式。这种cycle策略主要目的在后期防止在一个局部极小值震荡，若跳出该区域或许能得到更有的结果。这里说明cycle的方式不止可以在多项式中应用，可配合类似的周期函数进行衰减，如下图。</p>
<p><img src="img%5Cch14%5Ccycle%E8%A1%B0%E5%87%8F.jpeg" alt></p>
<p>4、<strong>inverse_time_decay</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">inverse_time_decay(learning_rate, global_step, decay_steps, decay_rate,</span><br><span class="line">                   staircase=<span class="literal">False</span>, name=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>逆时衰减，这种方式和指数型类似。如图，<img src="img%5Cch14%5C%E9%80%86%E6%97%B6%E8%A1%B0%E5%87%8F.jpeg" alt></p>
<p>5、<strong>cosine_decay</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cosine_decay(learning_rate, global_step, decay_steps, alpha=<span class="number">0.0</span>,</span><br><span class="line">                 name=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>余弦衰减，即按余弦函数的方式衰减学习率，如图</p>
<p><img src="img%5Cch14%5C%E4%BD%99%E5%BC%A6%E8%A1%B0%E5%87%8F.jpeg" alt></p>
<p>6、<strong>cosine_decay_restarts</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cosine_decay_restarts(learning_rate, global_step, first_decay_steps,</span><br><span class="line">                           t_mul=<span class="number">2.0</span>, m_mul=<span class="number">1.0</span>, alpha=<span class="number">0.0</span>, name=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>余弦衰减，即余弦版本的cycle策略，作用与多项式衰减中的cycle相同。区别在于余弦重启衰减会重新回到初始学习率，拉长周期，而多项式版本则会逐周期衰减。</p>
<p><img src="img%5Cch14%5C%E4%BD%99%E5%BC%A6cycle%E8%A1%B0%E5%87%8F.jpeg" alt></p>
<p>7、<strong>linear_cosine_decay</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">linear_cosine_decay(learning_rate, global_step, decay_steps,</span><br><span class="line">                        num_periods=<span class="number">0.5</span>, alpha=<span class="number">0.0</span>, beta=<span class="number">0.001</span>,</span><br><span class="line">                        name=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>线性余弦衰减，主要应用于增强学习领域。</p>
<p><img src="img%5Cch14%5C%E7%BA%BF%E6%80%A7%E4%BD%99%E5%BC%A6%E8%A1%B0%E5%87%8F.jpeg" alt></p>
<p>8、<strong>noisy_linear_cosine_decay</strong></p>
<p>噪声线性余弦衰减，即在线性余弦衰减中加入随机噪声，增大寻优的随机性。</p>
<p><img src="img%5Cch14%5C%E5%99%AA%E5%A3%B0%E7%BA%BF%E6%80%A7%E4%BD%99%E5%BC%A6%E8%A1%B0%E5%87%8F.jpeg" alt></p>
<h3 id="14-3-4-极端批样本数量下，如何训练网络？">14.3.4 极端批样本数量下，如何训练网络？</h3>
<p>​	极端批样本情况一般是指batch size为1或者batch size在6000以上的情况。这两种情况，在使用不合理的情况下都会导致模型最终性能无法达到最优甚至是崩溃的情况。</p>
<p>​	在目标检测、分割或者3D图像等输入图像尺寸较大的场景，通常batch size 会非常小。而在14.2.4中，我们已经讲到这种情况会导致梯度的不稳定以及batchnorm统计的不准确。针对梯度不稳定的问题，通常不会太致命，若训练中发现梯度不稳定导致性能的严重降低时可采用累计梯度的策略，即每次计算完不反向更新，而是累计多次的误差后进行一次更新，这是一种在内存有限情况下实现有效梯度更新的一个策略。batch size过小通常对batchnorm的影响是最大的，若网络模型中存在batchnorm，batch size若只为1或者2时会对训练结果产生非常大的影响。这时通常有两种策略，一、若模型使用了预训练网络，可冻结预训练网络中batchnorm的模型参数，有效降低batch size引起的统计量变化的影响。二、在网络不是过深或者过于复杂时可直接移除batchnorm或者使用groupnorm代替batchnorm，前者不多阐释，后者是有FAIR提出的一种用于减少batch对batchnorm影响，其主要策略是先将特征在通道上进行分组，然后在组内进行归一化。即归一化操作上完全与batch size无关。这种groupnorm的策略被证实在极小批量网络训练上能达到较优秀的性能。当然这里也引入里group这个超参数，一般情况下建议不宜取group为1或者各通道单独为组的group数量，可结合实际网络稍加调试。</p>
<p>​	为了降低训练时间的成本，多机多卡的分布式系统通常会使用超大的batch size进行网络训练。同样的在14.2.4中，我们提到了超大batch size会带来梯度方向过于一致而导致的精度大幅度降低的问题。这时通常可采用层自适应速率缩放（LARS）算法。从理论认知上将，batch size增大会减少反向传播的梯度更新次数，但为了达到相同的模型效果，需要增大学习率。但学习率一旦增大，又会引起模型的不收敛。为了解决这一矛盾，LARS算法就在各层上自适应的计算一个本地学习率用于更新本层的参数，这样能有效的提升训练的稳定性。目前利用LARS算法，腾讯公司使用65536的超大batch size能将ResNet50在ImageNet在4分钟完成训练，而谷歌使用32768的batch size使用TPU能将该时间缩短至2分钟。</p>
<h2 id="14-4-合理使用预训练网络">14.4 合理使用预训练网络</h2>
<h3 id="14-4-1-什么是微调（fine-tune）">14.4.1 什么是微调（fine-tune）</h3>
<p>​	微调（fine-tune），顾名思义指稍微调整参数即可得到优秀的性能，是迁移学习的一种实现方式。微调和从头训练（train from scratch）的本质区别在于模型参数的初始化，train from scratch通常指对网络各类参数进行随机初始化（当然随机初始化也存在一定技巧），随机初始化模型通常不具有任何预测能力，通常需要大量的数据或者特定域的数据进行从零开始的训练，这样需要训练到优秀的模型通常是稍困难的。而微调的网络，网络各类参数已经在其他数据集（例如ImageNet数据集）完成较好调整的，具备了较优秀的表达能力。因此，我们只需要以较小的学习速率在自己所需的数据集领域进行学习即可得到较为优秀的模型。微调通常情况下，无须再重新设计网络结构，预训练模型提供了优秀的结构，只需稍微修改部分层即可。在小数据集上，通常微调的效果比从头训练要好很多，原因在于数据量较小的前提下，训练更多参数容易导致过度拟合。</p>
<h3 id="14-4-2-微调有哪些不同方法？">14.4.2 微调有哪些不同方法？</h3>
<p>​	以图像分类为例，通常情况下由于不同数据集需要的类别数不同，我们需要修改网络的输出顶层。这种情况下有两种微调方式：</p>
<ul>
<li>
<p>不冻结网络模型的任何层，对最后的改动层使用较大的学习率，对未改动层以较小的学习率进行训练全模型训练，进行多轮训练即可。即一步完成训练。</p>
</li>
<li>
<p>冻结除了顶部改动层以外的所有层参数，即不对冻结部分的层进行参数训练更新，进行若干轮的微调训练后，放开顶部层以下的若干层或者全部放开所有层的参数，再次进行若干轮训练即可。即分多步训练。</p>
<p>以上两种都属于微调。目前由于存在大量优秀的预训练模型，如何确定哪个模型适合自己的任务并能得到最佳性能需要花大量的时间探索。此时，上述的前者是种不错训练方式，你无须进行过多分步的操作。而当探索到一个比较适合的模型时，你不妨可以再次重新尝试下以第二种方式进行训练，或许能得到相比于前者稍高些的性能，因为小数据集上调整过多的参数过拟合的机率也会增大，当然这并不是绝对的。</p>
</li>
</ul>
<h3 id="14-4-3-微调先冻结底层，训练顶层的原因？">14.4.3 微调先冻结底层，训练顶层的原因？</h3>
<p>​	14.12中第二种冻结多步训练的方式。首先冻结除了顶部改动层以外的所有层参数，对顶层进行训练，这个过程可以理解为顶层的域适应训练，主要用来训练适应模型的现有特征空间，防止顶层糟糕的初始化，对已经具备一定表达能力的层的干扰和破坏，影响最终的性能。之后，在很多深度学习框架教程中会使用放开顶层往下一半的层数，继续进行微调。这样的好处在于越底层的特征通常是越通用的特征，越往上其整体的高层次语义越完备，这通过感受野很容易理解。所以，若预训练模型的数据和微调训练的数据语义差异越大（例如ImageNet的预模型用于医学图像的训练），那越往顶层的特征语义差异就越大，因此通常也需要进行相应的调整。</p>
<h3 id="14-4-4-不同的数据集特性下如何微调？">14.4.4 不同的数据集特性下如何微调？</h3>
<ul>
<li>数据集数据量少，数据和原数据集类似。这是通常做法只需修改最后的输出层，训练即可，训练过多参数容易过拟合。</li>
<li>数据集数据量少，数据和原数据集差异较大。由于数据差异较大，可以在完成输出顶层的微调后，微调顶层往下一半的层数，进行微调。</li>
<li>数据集数据量大，数据与原数据集差异较大。这种情况下，通常已经不需要用预训练模型进行微调，通常直接重新训练即可。</li>
<li>数据集数据量大，数据与原数据类似。这时预训练模型的参数是个很好的初始化，可利用预训练模型放开所有层以较小的学习率微调即可。</li>
</ul>
<h3 id="14-4-4-目标检测中使用预训练模型的优劣？">14.4.4 目标检测中使用预训练模型的优劣？</h3>
<p>​	目标检测中无论是一阶段的YOLO、SSD或者RetinaNet 还是二阶段的Faster R-CNN、R-FCN 和 FPN都是基于ImageNet上预训练好的分类模型。</p>
<p>​	优势在于：</p>
<p>​	1、正如大部分微调的情况一样，使用预训练网络已拥有优秀的语义特征，能有效的加快训练速度；</p>
<p>​	2、其次，对于大部分二阶段的模型来说，并未实现严格意义上的完全端对端的训练，所以使用预训练模型能直接提取到语义特征，能使两个阶段的网络更容易实现模型的优化。</p>
<p>​	劣势在于，分类模型和检测模型之间仍然存在一定任务上的差异：</p>
<p>​	1、分类模型大部分训练于单目标数据，对同时进行多目标的捕捉能力稍弱，且不关注目标的位置，在一定程度上让模型损失部分空间信息，这对检测模型通常是不利的；</p>
<p>​	2、域适应问题，若预训练模型（ImageNet）和实际检测器的使用场景（医学图像，卫星图像）差异较大时，性能会受到影响；</p>
<p>​	3、使用预训练模型就意味着难以自由改变网络结构和参数限制了应用场合。</p>
<h3 id="14-4-5-目标检测中如何从零开始训练-train-from-scratch-？">14.4.5 目标检测中如何从零开始训练(train from scratch)？</h3>
<p>​	结合FAIR相关的研究，我们可以了解目标检测和其他任务从零训练模型一样，只要拥有足够的数据以及充分而有效的训练，同样能训练出不亚于利用预训练模型的检测器。这里我们提供如下几点建议：</p>
<p>​	1、数据集不大时，同样需要进行数据集增强。</p>
<p>​	2、预训练模型拥有更好的初始化，train from scratch需要更多的迭代次数以及时间训练和优化检测器。而二阶段模型由于并不是严格的端对端训练，此时可能需要更多的迭代次数以及时间，而一阶段检测模型训练会相对更容易些（例如DSOD以ScratchDet及）。</p>
<p>​	3、目标检测中train from scratch最大的问题还是batch size过小。所以可采取的策略是增加GPU使用异步batchnorm增大batch size，若条件限制无法使用更多GPU时，可使用groupnorm代替batchnorm</p>
<p>​	4、由于分类模型存在对多目标的捕捉能力弱以及对物体空间位置信息不敏感等问题，可借鉴DetNet训练一个专属于目标检测的模型网络，增强对多目标、尺度和位置拥有更强的适应性。</p>
<h2 id="14-5-如何改善-GAN-的性能">14.5 如何改善 GAN 的性能</h2>
<p>优化GAN性能通常需要在如下几个方面进行</p>
<ul>
<li>设计或选择更适合目的代价函数。</li>
<li>添加额外的惩罚。</li>
<li>避免判别器过度自信和生成器过度拟合。</li>
<li>更好的优化模型的方法。</li>
<li>添加标签明确优化目标。</li>
</ul>
<p>GAN常用训练技巧</p>
<ul>
<li>
<p>输入规范化到（-1，1）之间，最后一层的激活函数使用tanh（BEGAN除外）</p>
</li>
<li>
<p>使用wassertein GAN的损失函数，</p>
</li>
<li>
<p>如果有标签数据的话，尽量使用标签，也有人提出使用反转标签效果很好，另外使用标签平滑，单边标签平滑或者双边标签平滑</p>
</li>
<li>
<p>使用mini-batch norm， 如果不用batch norm 可以使用instance norm 或者weight norm</p>
</li>
<li>
<p>避免使用RELU和pooling层，减少稀疏梯度的可能性，可以使用leakrelu激活函数</p>
</li>
<li>
<p>优化器尽量选择ADAM，学习率不要设置太大，初始1e-4可以参考，另外可以随着训练进行不断缩小学习率，</p>
</li>
<li>
<p>给D的网络层增加高斯噪声，相当于是一种正则</p>
</li>
</ul>
<h2 id="14-6-AutoML">14.6 AutoML</h2>
<h3 id="14-6-1-什么是AutoML？">14.6.1 什么是AutoML？</h3>
<p>​	目前一个优秀的机器学习和深度学习模型，离不开这几个方面：</p>
<p>​	一、优秀的数据预处理；</p>
<p>​	二、合适的模型结构和功能；</p>
<p>​	三、优秀的训练策略和超参数；</p>
<p>​	四、合适的后处理操作；</p>
<p>​	五、严格的结果分析。</p>
<p>​	这几方面都对最终的结果有着举足轻重的影响，这也是目前的数据工程师和学者们的主要工作。但由于这每一方面都十分繁琐，尤其是在构建模型和训练模型上。而大部分情况下，这些工作有无须过深专业知识就能使用起来。所以AutoML主要的作用就是来帮助实现高效的模型构建和超参数调整。例如深度学习网络的架构搜索、超参数的重要性分析等等。当然AutoML并不简单的进行暴力或者随机的搜索，其仍然需要机器学习方面的知识，例如贝叶斯优化、强化学习、元学习以及迁移学习等等。目前也有些不错的AutoML工具包，例如Alex Honchar的Hyperopt、微软的NNI、Autokeras等。</p>
<p>目前AutoML已经成为最新的研究热点，有兴趣的可以参考<a href="https://www.automl.org/automl/literature-on-neural-architecture-search/">AutoML literature</a>。</p>
<h3 id="14-6-2-自动化超参数搜索方法有哪些？">14.6.2 自动化超参数搜索方法有哪些？</h3>
<p>​	目前自动化搜索主要包含网格搜索，随机搜索，基于模型的超参优化</p>
<p>​	网格搜索：</p>
<p>​		通常当超参数量较少的时候，可以使用网格搜索法。即列出每个超参数的大致候选集合。利用这些集合		进行逐项组合优化。在条件允许的情况下，重复进行网格搜索会当优秀，当然每次重复需要根据上一步得到的最优参数组合，进行进一步的细粒度的调整。网格搜索最大的问题就在于计算时间会随着超参数的数量指数级的增长。</p>
<p>​	随机搜索：</p>
<p>​		随机搜索，是一种用来替代网格搜索的搜索方式。随机搜索有别于网格搜索的一点在于，我们不需要设定一个离散的超参数集合，而是对每个超参数定义一个分布函数来生成随机超参数。随机搜索相比于网格搜索在一些不敏感超参上拥有明显优势。例如网格搜索对于批样本数量（batch size），在[16,32,64]这些范围内进行逐项调试，这样的调试显然收益更低下。当然随机搜索也可以进行细粒度范围内的重复的搜索优化。</p>
<p><img src="img%5Cch14%5C14.14.png" alt></p>
<p>​	基于模型的超参优化：</p>
<p>​		有别于上述两种的搜索策略，基于模型的超参调优问题转化为了优化问题。直觉上会考虑是否进行一个可导建模，然后利用梯度下降进行优化。但不幸的是我们的超参数通常情况下是离散的，而且其计算代价依旧很高。</p>
<p>​		基于模型的搜索算法，最常见的就是贝叶斯超参优化。有别于的网格搜索和随机搜索独立于前几次搜索结果的搜索，贝叶斯则是利用历史的搜索结果进行优化搜索。其主要有四部分组成，1.目标函数，大部分情况下就是模型验证集上的损失。2、搜索空间，即各类待搜索的超参数。3、优化策略，建立的概率模型和选择超参数的方式。4、历史的搜索结果。首先对搜索空间进行一个先验性的假设猜想，即假设一种选择超参的方式，然后不断的优化更新概率模型，最终的目标是找到验证集上误差最小的一组超参数。</p>
<h3 id="14-6-3-什么是神经网络架构搜索（NAS）">14.6.3 什么是神经网络架构搜索（NAS）</h3>
<p>2015至2017年间，是CNN网络设计最兴盛的阶段，大多都是由学者人工设计的网络结构。这个过程通常会很繁琐。其主要原因在于对不同模块组件的组成通常是个黑盒优化的问题，此外，在不同结构超参数以及训练超参数的选择优化上非凸优化问题，或者是个混合优化问题，既有离散空间又有连续空间。NAS（Neural Architecture Search）的出现就是为了解决如何通过机器策略和自动化的方式设计出优秀高效的网络。而这种策略通常不是统一的标准，不同的网络结合实际的需求通常会有不同的设计，比如移动端的模型会在效率和精度之间做平衡。目前，NAS也是AUTOML中最重要的部分。NAS通常会分为三个方面，搜索空间（在哪搜索），搜索策略（如何搜索）及评价预估。</p>
<ul>
<li>
<p>搜索空间，即在哪搜索，定义了优化问题所需变量。不同规模的搜索空间的变量其对于的难度也是不一样的。早期由于网络结构以及层数相对比较简单，参数量较少，因此会更多的使用遗传算法等进化算法对网络的超参数和权重进行优化。深度学习发展到目前，模型网络结构越来越复杂，参数量级越来越庞大，这些进化算法已经无法继续使用。但若我们先验给定一些网络结构和超参数，模型的性能已经被限制在给定的空间，此时搜索的空间已变得有限，所以只需对复杂模型的架构参数和对应的超参数进行优化即可。</p>
</li>
<li>
<p>搜索策略， 即如何搜索，定义了如何快速、准确找到最优的网络结构参数配置的策略。常见的搜索方法包括：随机搜索、贝叶斯优化、强化学习、进化算法以及基于模型的搜索算法。其中主要代表为2017年谷歌大脑的使用强化学习的搜索方法。</p>
</li>
<li>
<p>评价预估，定义了如何高效对搜索的评估策略。深度学习中，数据规模往往是庞大的，模型要在如此庞大的数据规模上进行搜索，这无疑是非常耗时的，对优化也会造成非常大的困难，所以需要一些高效的策略做近似的评估。 这里一般会有如下三种思路：</p>
<p>一、使用些低保真的训练集来训练模型。低保真在实际中可以用不同的理解，比如较少的迭代次数，用一小部分数据集或者保证结构的同时减少通道数等。这些方法都可以在测试优化结构时大大降低计算时间，当然也会存在一定的偏差。但架构搜索从来并不是要一组固定的参数，而是一种优秀的模型结构。最终选取时，只需在较优秀的几组结构中进行全集训练，进行择优选取即可。</p>
<p>二、使用代理模型。除了低保真的训练方式外，学者们提出了一种叫做代理模型的回归模型，采用例如插值等策略对已知的一些参数范围进行预测，目的是为了用尽可能少的点预测到最佳的结果。</p>
<p>三、参数级别的迁移。例如知识蒸馏等。用已训练好的模型权重参数对目标问题搜索，通常会让搜索拥有一个优秀的起点。由于积累了大量的历史寻优数据，对新问题的寻优将会起到很大的帮助。</p>
</li>
</ul>
<h3 id="14-6-4-NASNet的设计策略">14.6.4 NASNet的设计策略</h3>
<p>NASNet是最早由google brain 通过网络架构搜索策略搜索并成功训练ImageNet的网络，其性能超越所有手动设计的网络模型。关于NASNet的搜索策略，首先需要参考google brain发表在ICLR2017的论文《Neural Architecture Search with Reinforcement Learning》。该论文是最早成功通过架构搜索策略在cifar-10数据集上取得比较不错效果的工作。NASNet很大程度上是沿用该搜索框架的设计思想。</p>
<p>NASNet的核心思想是利用强化学习对搜索空间内的结构进行反馈探索。架构搜索图如下，定义了一个以RNN为核心的搜索控制器。在搜索空间以概率p对模型进行搜索采样。得到网络模型A后，对该模型进行训练，待模型收敛得到设定的准确率R后，将梯度传递给控制器RNN进行梯度更新。</p>
<p><img src="img%5Cch14%5CNAS%E6%90%9C%E7%B4%A2%E7%AD%96%E7%95%A5.png" alt></p>
<p>​									架构搜索策略流程</p>
<p>RNN控制器会对卷积层的滤波器的尺寸、数量以及滑动间隔进行预测。每次预测的结果都会作为下一级的输入，档层数达到设定的阈值时，会停止预测。而这个阈值也会随着训练的进行而增加。这里的控制器之预测了卷积，并没有对例如inception系列的分支结构或者ResNet的跳级结构等进行搜索。所以，控制器需要进一步扩展到预测这些跳级结构上，这样搜索空间相应的也会增大。为了预测这些结构，RNN控制器内每一层都增加了一个预测跳级结构的神经元，文中称为锚点，稍有不同的是该锚点的预测会由前面所有层的锚点状态决定。</p>
<p><img src="img%5Cch14%5CRNN%E6%8E%A7%E5%88%B6%E5%99%A8.png" alt></p>
<p>​									RNN控制器</p>
<p>NASNet大体沿用了上述生成网络结构的机器，并在此基础上做了如下两点改进：</p>
<p>1、先验行地加入inception系列和ResNet的堆叠模块的思想。其定义了两种卷积模块，Normal Cell和Reduction Cell，前者不进行降采样，而后者是个降采样的模块。而由这两种模块组成的结构可以很方便的通过不同数量的模块堆叠将其从小数据集搜索到的架构迁移到大数据集上，大大提高了搜索效率。</p>
<p><img src="img%5Cch14%5CNASNet%E7%9A%84RNN%E6%8E%A7%E5%88%B6%E5%99%A8.png" alt></p>
<p>​									NASNet的RNN控制器</p>
<p>2、对RNN控制进行优化，先验性地将各种尺寸和类型的卷积和池化层加入到搜索空间内，用预测一个卷积模块代替原先预测一层卷积。如图，控制器RNN不在预测单个卷积内的超参数组成，而是对一个模块内的每一个部分进行搜索预测，搜索的空间则限定在如下这些操作中：</p>
<p>​						• identity					  • 1x3 then 3x1 convolution<br>
​						• 1x7 then 7x1 convolution	  • 3x3 dilated convolution<br>
​						• 3x3 average pooling 			  • 3x3 max pooling<br>
​						• 5x5 max pooling			  • 7x7 max pooling<br>
​						• 1x1 convolution				  • 3x3 convolution<br>
​						• 3x3 depthwise-separable conv • 5x5 depthwise-seperable conv<br>
​						• 7x7 depthwise-separable conv</p>
<p>在模块内的连接方式上也提供了element-wise addition和concatenate两种方式。NASNet的搜索方式和过程对NAS的一些后续工作都具有非常好的参考借鉴意义。</p>
<h3 id="14-6-5-网络设计中，为什么卷积核设计尺寸都是奇数">14.6.5 网络设计中，为什么卷积核设计尺寸都是奇数</h3>
<p>我们发现在很多大部分网络设计时都会使用例如3x3/5x5/7x7等奇数尺寸卷积核，主要原因有两点：</p>
<ul>
<li>保证像素点中心位置，避免位置信息偏移</li>
<li>填充边缘时能保证两边都能填充，原矩阵依然对称</li>
</ul>
<h3 id="14-6-6-网络设计中，权重共享的形式有哪些，为什么要权重共享">14.6.6 网络设计中，权重共享的形式有哪些，为什么要权重共享</h3>
<p>权重共享的形式：</p>
<ul>
<li>深度学习中，权重共享最具代表性的就是卷积网络的卷积操作。卷积相比于全连接神经网络参数大大减少；</li>
<li>多任务网络中，通常为了降低每个任务的计算量，会共享一个骨干网络。</li>
<li>一些相同尺度下的结构化递归网络</li>
</ul>
<p>权重共享的好处：</p>
<p>​	权重共享一定程度上能增强参数之间的联系，获得更好的共性特征。同时很大程度上降低了网络的参数，节省计算量和计算所需内存（当然，结构化递归并不节省计算量）。此外权重共享能起到很好正则的作用。正则化的目的是为了降低模型复杂度，防止过拟合，而权重共享则正好降低了模型的参数和复杂度。</p>
<p>​	因此一个设计优秀的权重共享方式，在降低计算量的同时，通常会较独享网络有更好的效果。</p>
<p>权重共享不仅在人工设计（human-invented）的网络结构中有简化参数，降低模型复杂度的作用，在神经网络搜索（NAS）的网络结构中可以使得child model的计算效率提升，使得搜索过程可以在单卡GPU上复现，见Efficient NAS(<a href="https://arxiv.org/abs/1802.03268">ENAS</a>)。</p>
]]></content>
      <categories>
        <category>算法面试</category>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>刷八股</tag>
      </tags>
  </entry>
  <entry>
    <title>NLP面试题</title>
    <url>/2024/03/19/deep_learning/ch16/</url>
    <content><![CDATA[<h1>NLP</h1>
<h2 id="16-0-NLP-发展史简述">16.0 NLP 发展史简述</h2>
<p>50多年来 NLP 的历史发展可以分为三个浪潮，前两波以理性主义和经验主义的形式出现，为当前的深度学习浪潮铺平了道路。NLP的深层学习革命的主要支柱是: （1）语言嵌入实体的分布式表征，（2）由于嵌入而产生的语义泛化， （3）自然语言的大跨度深序列建模，（4）能够从低到高表示语言层次的分层网络，以及（5）解决许多联合 NLP 问题的端对端深度学习方法。</p>
<h3 id="第一个浪潮：理性主义">第一个浪潮：理性主义</h3>
<p>在第一个浪潮中，NLP的实验持续了很长一段时间，可以追溯到20世纪50年代。1950年，阿兰·图灵提出了图灵测试，以评估计算机表现出与人类无法区分的智能行为的能力。这项测试是基于人类和计算机之间的自然语言对话，旨在生成类似人类的反应。1954年，George-IBM 实验产出了能够将60多个俄语句子翻译成英语的rrst机器翻译系统。</p>
<p>这些方法是基于这样一种信念，即人类思维中的语言知识是由泛型继承提前进行的，而这种信念，在大约1960年至1980年代后期，占据了NLP的大部分研究中的主导地位。这些方法被称为理性主义方法（Church 2007）。理性主义方法在 NLP 中的主导地位主要是由于诺姆·乔姆斯基（Noam Chomsky）关于先天语言结构的论点被广泛接受以及他对 N-grams 方法的批评（Chomsky 1957）。理性主义者一般假设语言的关键部分在出生时就被硬连接到大脑中，作为人类遗传遗传的一部分，因此他们试图设计手工制作的规则，将知识和推理机制纳入智能 NLP 系统。直到20世纪80年代，最著名的成功的NLP系统，如为模拟 Rogerian psychotherapist 的 ELIZA 系统和为了规则化真实世界信息为规则本体的 MARGIE 系统，都是基于复杂的手写规则。</p>
<p>这一时期恰逢以专家知识工程为特点的早期智能的早期发展，即领域专家根据其所掌握的（非常狭窄的）应用领域的知识设计计算机程序（Nilsson 1982; Winston 1993）。专家们使用符号逻辑规则设计了这些程序，这些规则基于对这些知识的仔细表征和工程。这些以知识为基础的智能系统往往通过检测&quot;Head&quot;或最重要的参数，并就每种特殊情况采取特定的解决办法，而这在解决狭义问题方面往往是有效的。这些“Head”参数由人类专家预先确定，使“tail”参数和案例不受影响。由于缺乏学习能力，他们有必要将解决方案推广到新的情况和领域。这一时期的典型方法是专家系统所提供的证据，这是一个模拟人类专家决策能力的计算机系统。这种系统旨在通过知识推理来解决复杂的问题（Nilsson 1982）。第一个专家系统建立于1970年代，然后在1980年代推广。使用的主要&quot;算法&quot;是以&quot;if-then-else&quot;为形式的推断规则（Jackson 1998）。这些智能系统的主要优点是其在进行逻辑推理方面（有限）能力的透明度和可解释性。像NLP系统，如 ELIZA 和 MARGIE ，一般专家系统在早期使用手工制作的专家知识，这往往是有效的狭隘的问题，虽然推理无法处理不确定性，是普遍存在的实际应用。</p>
<p>同样，语音识别研究和系统设计，这又是另一个长期存在的 NLP 和反智能挑战，在这个理性主义时代，主要基于专家知识工程的范式，如elegantly analyzed in（Church and Mercer 1993）。在1970年代和1980年代初，专家系统的语音识别方法相当流行（Reddy 1976; Zue 1985）。然而，研究人员敏锐地认识到，缺乏从数据中学习和处理推理不确定性的能力，导致了接下来描述的第二波语音识别、NLP和对于文本的人工智能浪潮也走向失败。</p>
<h3 id="第二波浪潮：经验主义">第二波浪潮：经验主义</h3>
<p>第二波 NLP 浪潮的特点是利用语料库数据以及基于（浅层）机器学习、统计学等来利用这些数据（Manning and Schtze 1999）。由于许多自然语言的结构和理论都被贬低或抛弃，而倾向于数据驱动的方法，这个时代发展的主要方法被称为经验或务实的方法（ChurchandMercer 1993;Church 2014）。NLP 的一个主要会议甚至被命名为“自然语言处理的经验方法（Empirical Methods in Natural Language Processing）（EMNLP）”，最直接地反映了NLP研究人员在那个时代对经验方法的强烈积极情绪。</p>
<p>与理性主义方法相反，经验方法认为人类的思维只是从关联、模式识别和泛化的常规操作开始。丰富的感官输入需要使大脑学习自然语言的详细结构。经验主义盛行于1920年至1960年间，自1990年以来一直在兴起。NLP的早期经验方法主要是开发生成模型，如隐马尔可夫模型 （HMM） （Baum and Petrie 1966）， IBM 翻译模型 （Brown et al. 1993）， 和 head-driven parsing 模型（Collins 1997），以发现大型语料库的规律性。自1990年代后期以来，在各种NLP任务中，歧视性模式已成为事实上的做法。NLP的典型判别模型和方法包括最大熵模型（ratnaparkhi 1997）、支持向量机（Vapnik 1998）、条件随机（Lafferty et al. 2001）、最大相互信息和最小区分器错误（He et al. 2008）还有感知器（Collins 2002）。</p>
<p>在这种经验主义时代中、NLP 与同样的智能方法如语音识别和计算机视觉是平行的。这是在明确的证据表明，学习和感知能力对复杂的智能系统至关重要，但在前一波流行的专家系统中却不存在。例如，当 DARPA 开始对自动驾驶提出重大挑战时，大多数车辆随后依赖于基于知识的智能智能。正如语音识别和NLP 一样，自主驾驶和计算机视觉研究人员意识到基于知识的范式的局限性，因为机器学习需要进行不确定性处理和泛化能力。</p>
<p>在第二波浪潮中，NLP的经验主义和语音识别是基于数据密集型机器学习的，我们现在称之为“shallow”，因为在下一节中描述的第三波浪潮中，数据的多层或“deep”表征通常缺乏抽象结构。在机器学习中，在第一次浪潮中，研究人员不需要考虑构造精确规则，为知识为基础的 NLP 和语音系统。相反，他们把重点放在统计模型（Bishop 2006; Murphy 2012）或作为一个基本引擎的简单的神经网络（Bishop 1995）。然后，他们使用足够的训练数据进行自动学习或“tune（调整）”系统的参数，使它们能够处理不确定性，并尝试从一个条件泛化到另一个条件，从一个领域泛化到另一个领域。机器学习的关键算法和方法包括EM （期望最大化）、贝叶斯网络、支持向量机、决策树以及神经网络的反向传播算法。</p>
<p>一般来说，基于机器学习的NLP、语音和其他智能系统的性能比早期的基于知识的智能系统要好得多。成功的例子包括语音识别 （Jelinek 1998）， 脸部识别 （Viola and Jones 2004）， 实体识别 （Fei-Fei and Perona 2005）， 手写字体识别 （Plamondon and Srihari 2000）， 以及机器翻译 （Och 2003）。</p>
<p>在语音识别方面，从20世纪80年代初到2010年前后近30年，利用基于 HMM 与高斯混合模型相结合的统计生成模型，以及其推广的各种版本（Baker et al. 2009a，b; Deng and O’Shaughnessy 2003; Rabiner and Juang 1993）的统计生成模式。泛化 HMM 的许多版本都是基于统计和神经网络的隐动态模型（Deng 1998; Bridle et al. 1998; Deng and Yu 2007）。前者采用 EM 和 switching extended Kalman ﬁlter 算法学习模型参数（Ma and Deng 2004; Lee et al. 2004），后者采用反向传播（Picone et al. 1999），两者都广泛地利用多个潜在层表示法进行语音分析的生成过程。将这种“深度”生成过程转化为端到端过程的对应方案，导致了深度学习的工业化成功（Deng et al. 2010， 2013; Hinton et al. 2012） ，从而形成了第三波浪潮的驱动力。</p>
<h3 id="第三波浪潮：深度学习">第三波浪潮：深度学习</h3>
<p>在第二波浪潮中开发的 NLP 系统，包括语音识别、语言理解和机器翻译，表现得比在第一波浪潮时更好，鲁棒性更高，但它们远远没有达到人的水平，而这留下了很多需求。除了少数例外，NLP的（浅层）机器学习模型通常没有足够的容量来吸收大量的训练数据。此外，学习算法、方法和基础设施也都不够强大。所有这一切都在几年前发生了变化，而这导致了第三波 NLP 浪潮，这股浪潮是由深层机器学习或深度学习的新范式推动的（Bengio 2009; Deng and Yu 2014; LeCun et al. 2015; Goodfellow et al. 2016）。</p>
<p>深度学习起源于人工神经网络，它可以被看作是受生物神经系统启发的细胞类型的级联模型。随着反向传播算法的出现（Rumelhart et al. 1986），90年代对深度神经网络的训练引起了广泛关注。在没有大量训练数据和没有适当的设计和学习范式的情况下，在神经网络训练过程中，学习信号随着层次数（或更严格的信用分配深度）在层层传播时呈指数形式消失，使得调整深层神经网络特别是递归的版本的连接权重变得异常艰难。Hinton 等人（2006）克服了这个问题，使用无人监督的预训练模型来进行学习有用的特征探测器。然后，通过监督学习进一步训练网络，对标记数据进行分类。因此，可以学习使用低维表征的方式来学习高维的表征的分布。这项开创性的工作标志着神经网络的复兴。此后提出和发展了各种网络结构，包括 Deep Belief 网络（Hinton et al.2006）、堆积自编码器（Vincent et al.2010）、深层玻尔兹曼机（Hinton and Salakhutdinov 2012）、深度卷积神经网络（Krizhevsky et al. 2012），深层堆积网络 （Deng et al. 2012），和深层 Q-networks （Mnih et al. 2015）。深度学习自2010年以来已成功地应用于实际智能领域的实际任务，包括语音识别（Yu et al. 2010; Hinton et al. 2012），图像识别（Krizhevsky et al. 2012; He et al. 2016），以及 NLP 绝大多数领域。</p>
<p>其中由于微软公司在工业化上的成功，以及愈来愈高的准确率等迹象，这些2010-2011年语音识别的惊人成功预示着 NLP 的第三波浪潮和人工智能的到来。随着深度学习在语音识别方面取得成功，计算机视觉（Krizhevsky et al. 2012）和机器翻译（Bahdanau et al. 2015）被类似的深度学习范式所取代。特别是，虽然 Bengio 等人在2001的工作，在2011年就开发了强大的神经词嵌入技术（Bengio et al. 2001），但由于大数据的可用性和更快的计算，它直到10多年后才被证明在一个大规模和实际有用的规模上才能够实际有用（Mikolov et al. 2013）。此外，许多其他现实世界的NLP应用，如图像字幕（Karpathy and Fei-Fei 2015; Fang et al. 2015; Gan et al. 2017），视觉问题回答（Fei-Fei and Perona 2016），语音理解系统（Mesnil et al. 2013），网络搜索（Huang et al. 2013b）和推荐系统由于深度学习而取得成功，此外还有许多非NLP任务，包括药物发现和药理学、客户关系管理、推荐系统、手势识别、医学信息、广告投放、医学图像分析、机器人、自动驾驶车辆、纸板和电子游戏（例如 Atari， Go， Poker， and the latest， DOTA2）等。详情请参阅维基上的深度学习领域。</p>
<p>在更多基于文本的应用领域中，机器翻译可能受到深度学习的影响最大。从 NLP 第二波浪潮中发展起来的浅层——统计机器翻译开始看起的话，目前在实际应用中最好的机器翻译系统是基于深神经网络的。例如，谷歌在2016年9月宣布了其转向神经机器翻译的阶段，两个月后微软也发布了类似的声明。Facebook已经进行了大约一年的机器神经网络翻译的转换工作，到2017年8月它已经完全将这个系统部署成功。</p>
<p>在口语理解和对话系统领域，深度学习也正在产生巨大影响。目前流行的技术以多种方式维护和扩展了第二波时代浪潮中发展起来的统计方法。与经验（浅层）机器学习方法一样，深度学习也是基于数据密集型方法，以降低手工制作规则的成本，对噪声环境下的语音识别错误和语言理解错误具有很强的鲁棒性，并利用决策过程和强化学习的力量来设计对话策略，例如（Gasic et al. 2017; Dhingra et al. 2017）。与早期的方法相比，深度神经网络模型和表征方法更强大，它们使端到端学习成为可能。然而，深度学习也没有解决可解释性和领域泛化问题。</p>
<p>将深度学习应用于 NLP 问题方面的最近的两个重要技术突破是序列到序列学习（Sutskevar et al. 2014）和注意力机制建模（Bahdanau et al. 2015），以及最近的 BERT模型（Jacob el al.2018） 。序列到序列学习引入了一个强大的学习范式，即使用递归神经网络以端到端的方式进行编码和解码。注意力机制建模最初是为了克服编码一个长序列的难度而开发的，后来的持续发展又扩展了它的能力，提供了两个任意序列的高度可塑对齐能力，而其两个可以同时学习神经网络参数。而 BERT 则是实现了双向建模获取以得到更好的语言表征能力。序列到序列学习和注意力机制的关键概念在基于统计学习和词局部表征的最佳系统上提高了基于分布式单词嵌入的神经机器翻译的性能，而 BERT 更重要的意义是双向获取同一文段的高维意义。在这一成功之后，这些概念也被成功地应用到许多其他与NLP相关的任务中，如图像字幕（Karpathy and Fei-Fei 2015; Devlin et al. 2015）、语音识别（Chorowski et al. 2015）、一次性学习、句法分析、唇读、文本理解、摘要以及问答系统等。撇开他们巨大的经验成功不谈，基于神经网络的深度学习模型往往比早期浪潮中的传统机器学习模型更简单、更容易设计。在许多应用中，在端到端的任务中，模型的所有部分都同时进行深度学习，从特征抽取到预测。导致神经网络模型相对简单的另一个因素是，相同的模型构建成的块（即不同类型的层）通常在许多不同的应用中使用。为多种任务使用相同的构建块，这种方法使得模型更容易迁移到其它任务和数据上。此外，谷歌等公司还开发了软件工具包，以便更快、更有效地实现这些模型。由于以上这些原因，神经网络在数据量大而且基于云的方式上，是更常用的。</p>
<p>尽管深度学习在重塑语音、图像和视频的处理方面被证明是有效的，而且具有它的革命性，但在将深度学习与基于文本的 NLP 相结合方面的有效性并不那么明确，尽管它在一些实用的 NLP 任务中取得了经验上的成功。在语音、图像和视频处理中，深度学习通过直接从原始数据学习规律来解决语义差距问题。然而，在 NLP 中，人们提出了更强的理论和结构化模型，即语音、语法和语义，来提取理解和生成自然语言的基本机制，这些机制与神经网络不那么容易兼容。与语音、图像和视频信号相比，从文本数据中学习的神经表征可以对自然语言提供同样直接的见解，但是这个也不够直接。因此，将神经网络，特别是那些具有复杂层次结构的神经网络应用于 NLP，已成为 NLP 和深度学习社区中最活跃的领域，近年来取得了非常显著的进展（Deng 2016; Manning and Socher 2017;Jacob el al.2018）。</p>
<h2 id="16-1-如何理解序列到序列模型？">16.1 如何理解序列到序列模型？</h2>
<h2 id="16-2-序列到序列模型有什么限制吗？">16.2 序列到序列模型有什么限制吗？</h2>
<h2 id="16-3-如果不采用序列到序列模型，可以考虑用其它模型方法吗？">16.3 如果不采用序列到序列模型，可以考虑用其它模型方法吗？</h2>
<h2 id="16-4-如何理解词向量？">16.4 如何理解词向量？</h2>
<h2 id="16-5-词向量哪家好？">16.5 词向量哪家好？</h2>
<h2 id="16-6-解释一下注意力机制的原理？">16.6 解释一下注意力机制的原理？</h2>
<h2 id="16-7-注意力机制是不是适用于所有场景呢？它的鲁棒性如何？">16.7 注意力机制是不是适用于所有场景呢？它的鲁棒性如何？</h2>
<h2 id="16-8-怎么将原有的模型加上注意力机制呢？">16.8 怎么将原有的模型加上注意力机制呢？</h2>
<h2 id="16-9-通俗地解释一下词法分析是什么？有什么应用场景？">16.9 通俗地解释一下词法分析是什么？有什么应用场景？</h2>
<h2 id="16-10-深度学习中的词法分析有哪些常见模型呢？">16.10 深度学习中的词法分析有哪些常见模型呢？</h2>
<h2 id="16-11-通俗地解释一下知识图谱是什么？有什么应用场景？">16.11 通俗地解释一下知识图谱是什么？有什么应用场景？</h2>
<h2 id="16-12-深度学习中的知识图谱有哪些常见模型呢？">16.12 深度学习中的知识图谱有哪些常见模型呢？</h2>
<h2 id="16-13-深度学习中的机器翻译有哪些常见模型呢？">16.13 深度学习中的机器翻译有哪些常见模型呢？</h2>
<h2 id="16-14-机器翻译的通俗实现以及部署过程是怎样的呢？">16.14 机器翻译的通俗实现以及部署过程是怎样的呢？</h2>
<h2 id="16-15-通俗地解释一下文本情感分析是什么？常见的应用场景是？">16.15 通俗地解释一下文本情感分析是什么？常见的应用场景是？</h2>
<h2 id="16-16-最常用的情感分析模型是什么呢？如何快速部署呢？">16.16 最常用的情感分析模型是什么呢？如何快速部署呢？</h2>
<h2 id="16-17-通俗地解释一下问答系统？它涵盖哪些领域？常见的应用场景是？">16.17 通俗地解释一下问答系统？它涵盖哪些领域？常见的应用场景是？</h2>
<h2 id="16-18-常见的问答系统模型是什么？如何快速部署呢？">16.18 常见的问答系统模型是什么？如何快速部署呢？</h2>
<h2 id="16-19-图像文字生成是什么？它的技术原理是什么？">16.19 图像文字生成是什么？它的技术原理是什么？</h2>
<h2 id="16-20-常见的图像文字生成模型是什么？">16.20 常见的图像文字生成模型是什么？</h2>
<h2 id="16-21-NLP-的无监督学习发展动态是怎样的？有哪些领域在尝试无监督学习？">16.21 NLP 的无监督学习发展动态是怎样的？有哪些领域在尝试无监督学习？</h2>
<h2 id="16-22-NLP-和强化学习的结合方式是怎样的？有哪些方向在尝试强化学习？">16.22 NLP 和强化学习的结合方式是怎样的？有哪些方向在尝试强化学习？</h2>
<h2 id="16-23-NLP-和元学习？元学习如何能够和-NLP-结合起来？">16.23 NLP 和元学习？元学习如何能够和 NLP 结合起来？</h2>
<h2 id="16-24-能说一下各自领域最常用且常见的基准模型有哪些吗">16.24 能说一下各自领域最常用且常见的基准模型有哪些吗</h2>
]]></content>
      <categories>
        <category>算法面试</category>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>刷八股</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习基础面试题</title>
    <url>/2024/03/19/deep_learning/ch2/</url>
    <content><![CDATA[<h1>机器学习基础</h1>
<p>​	机器学习起源于上世纪50年代，1959年在IBM工作的Arthur Samuel设计了一个下棋程序，这个程序具有学习的能力，它可以在不断的对弈中提高自己。由此提出了“机器学习”这个概念，它是一个结合了多个学科如概率论，优化理论，统计等，最终在计算机上实现自我获取新知识，学习改善自己的这样一个研究领域。机器学习是人工智能的一个子集，目前已经发展出许多有用的方法，比如支持向量机，回归，决策树，随机森林，强化方法，集成学习，深度学习等等，一定程度上可以帮助人们完成一些数据预测，自动化，自动决策，最优化等初步替代脑力的任务。本章我们主要介绍下机器学习的基本概念、监督学习、分类算法、逻辑回归、代价函数、损失函数、LDA、PCA、决策树、支持向量机、EM算法、聚类和降维以及模型评估有哪些方法、指标等等。</p>
<h2 id="2-1-基本概念">2.1 基本概念</h2>
<h3 id="2-1-1-大话理解机器学习本质">2.1.1 大话理解机器学习本质</h3>
<p>​	机器学习(Machine Learning, ML)，顾名思义，让机器去学习。这里，机器指的是计算机，是算法运行的物理载体，你也可以把各种算法本身当做一个有输入和输出的机器。那么到底让计算机去学习什么呢？对于一个任务及其表现的度量方法，设计一种算法，让算法能够提取中数据所蕴含的规律，这就叫机器学习。如果输入机器的数据是带有标签的，就称作有监督学习。如果数据是无标签的，就是无监督学习。</p>
<h3 id="2-1-2-什么是神经网络">2.1.2 什么是神经网络</h3>
<p>​	神经网络就是按照一定规则将多个神经元连接起来的网络。不同的神经网络，具有不同的连接规则。例如全连接(Full Connected, FC)神经网络，它的规则包括：</p>
<p>（1）有三种层：输入层，输出层，隐藏层。</p>
<p>（2）同一层的神经元之间没有连接。</p>
<p>（3）fully connected的含义：第 N 层的每个神经元和第 N-1 层的所有神经元相连，第 N-1 层神经元的输出就是第 N 层神经元的输入。</p>
<p>（4）每个连接都有一个权值。</p>
<p><strong>神经网络架构</strong><br>
​	图2-1就是一个神经网络系统，它由很多层组成。输入层负责接收信息，比如一只猫的图片。输出层是计算机对这个输入信息的判断结果，它是不是猫。隐藏层就是对输入信息的传递和加工处理。<br>
<img src="2.5.1.png" alt="图2-2 神经网络系统"></p>
<p>​								图2-1 神经网络系统</p>
<h3 id="2-1-3-各种常见算法图示">2.1.3 各种常见算法图示</h3>
<p>​	日常使用机器学习的任务中，我们经常会遇见各种算法，图2-2是各种常见算法的图示。</p>
<table>
<thead>
<tr>
<th style="text-align:center">回归算法</th>
<th style="text-align:center">聚类算法</th>
<th style="text-align:center">正则化方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="2.1/1.jpg" alt></td>
<td style="text-align:center"><img src="2.1/2.jpg" alt></td>
<td style="text-align:center"><img src="2.1/3.jpg" alt></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">决策树学习</th>
<th style="text-align:center">贝叶斯方法</th>
<th style="text-align:center">基于核的算法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="2.2.4.png" alt></td>
<td style="text-align:center"><img src="2.1/5.jpg" alt></td>
<td style="text-align:center"><img src="2.1/6.jpg" alt></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">聚类算法</th>
<th style="text-align:center">关联规则学习</th>
<th style="text-align:center">人工神经网络</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="2.1/7.jpg" alt></td>
<td style="text-align:center"><img src="2.2.8.png" alt></td>
<td style="text-align:center"><img src="2.2.09.png" alt></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">深度学习</th>
<th style="text-align:center">降低维度算法</th>
<th style="text-align:center">集成算法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="2.2.10.png" alt></td>
<td style="text-align:center"><img src="2.2.11.png" alt></td>
<td style="text-align:center"><img src="2.2.12.png" alt></td>
</tr>
</tbody>
</table>
<p>​										图2-2 各种常见算法图示</p>
<h3 id="2-1-4-计算图的导数计算">2.1.4 计算图的导数计算</h3>
<p>​	计算图导数计算是反向传播，利用链式法则和隐式函数求导。</p>
<p>​	假设  $z = f(u,v)$  在点  $(u,v)$  处偏导连续， $(u,v)$ 是关于  $t$  的函数，在  $t$  点可导，求  $z$  在  $t$  点的导数。</p>
<p>根据链式法则有</p>
 $$
\frac{dz}{dt}=\frac{\partial z}{\partial u}.\frac{du}{dt}+\frac{\partial z}{\partial v}
				.\frac{dv}{dt}
$$ 
<p>​	链式法则用文字描述:“由两个函数凑起来的复合函数，其导数等于里边函数代入外边函数的值之导数，乘以里边函数的导数。<br>
​	为了便于理解，下面举例说明：</p>
 $$
f(x)=x^2,g(x)=2x+1
$$ 
<p>​	则:</p>
 $$
{f[g(x)]}'=2[g(x)] \times g'(x)=2[2x+1] \times 2=8x+4
$$ 
<h3 id="2-1-5-理解局部最优与全局最优">2.1.5 理解局部最优与全局最优</h3>
<p>​	笑谈局部最优和全局最优</p>
<blockquote>
<p>​	柏拉图有一天问老师苏格拉底什么是爱情？苏格拉底叫他到麦田走一次，摘一颗最大的麦穗回来，不许回头，只可摘一次。柏拉图空着手出来了，他的理由是，看见不错的，却不知道是不是最好的，一次次侥幸，走到尽头时，才发现还不如前面的，于是放弃。苏格拉底告诉他：“这就是爱情。”这故事让我们明白了一个道理，因为生命的一些不确定性，所以全局最优解是很难寻找到的，或者说根本就不存在，我们应该设置一些限定条件，然后在这个范围内寻找最优解，也就是局部最优解——有所斩获总比空手而归强，哪怕这种斩获只是一次有趣的经历。<br>
​	柏拉图有一天又问什么是婚姻？苏格拉底叫他到树林走一次,选一棵最好的树做圣诞树，也是不许回头，只许选一次。这次他一身疲惫地拖了一棵看起来直挺、翠绿，却有点稀疏的杉树回来，他的理由是，有了上回的教训，好不容易看见一棵看似不错的，又发现时间、体力已经快不够用了，也不管是不是最好的，就拿回来了。苏格拉底告诉他：“这就是婚姻。”</p>
</blockquote>
<p>​	优化问题一般分为局部最优和全局最优。其中，</p>
<p>（1）局部最优，就是在函数值空间的一个有限区域内寻找最小值；而全局最优，是在函数值空间整个区域寻找最小值问题。</p>
<p>（2）函数局部最小点是它的函数值小于或等于附近点的点，但是有可能大于较远距离的点。</p>
<p>（3）全局最小点是那种它的函数值小于或等于所有的可行点。</p>
<h3 id="2-1-5-大数据与深度学习之间的关系">2.1.5 大数据与深度学习之间的关系</h3>
<p>首先来看大数据、机器学习及数据挖掘三者简单的定义：</p>
<p><strong>大数据</strong>通常被定义为“超出常用软件工具捕获，管理和处理能力”的数据集。<br>
<strong>机器学习</strong>关心的问题是如何构建计算机程序使用经验自动改进。<br>
<strong>数据挖掘</strong>是从数据中提取模式的特定算法的应用，在数据挖掘中，重点在于算法的应用，而不是算法本身。</p>
<p><strong>机器学习和数据挖掘</strong>之间的关系如下：<br>
数据挖掘是一个过程，在此过程中机器学习算法被用作提取数据集中的潜在有价值模式的工具。<br>
大数据与深度学习关系总结如下：</p>
<p>（1）深度学习是一种模拟大脑的行为。可以从所学习对象的机制以及行为等等很多相关联的方面进行学习，模仿类型行为以及思维。</p>
<p>（2）深度学习对于大数据的发展有帮助。深度学习对于大数据技术开发的每一个阶段均有帮助，不管是数据的分析还是挖掘还是建模，只有深度学习，这些工作才会有可能一一得到实现。</p>
<p>（3）深度学习转变了解决问题的思维。很多时候发现问题到解决问题，走一步看一步不是一个主要的解决问题的方式了，在深度学习的基础上，要求我们从开始到最后都要基于一个目标，为了需要优化的那个最终目标去进行处理数据以及将数据放入到数据应用平台上去，这就是端到端（End to End）。</p>
<p>（4）大数据的深度学习需要一个框架。在大数据方面的深度学习都是从基础的角度出发的，深度学习需要一个框架或者一个系统。总而言之，将你的大数据通过深度分析变为现实，这就是深度学习和大数据的最直接关系。</p>
<h2 id="2-2-机器学习学习方式">2.2 机器学习学习方式</h2>
<p>​	根据数据类型的不同，对一个问题的建模有不同的方式。依据不同的学习方式和输入数据，机器学习主要分为以下四种学习方式。</p>
<h3 id="2-2-1-监督学习">2.2.1 监督学习</h3>
<p>​	特点：监督学习是使用已知正确答案的示例来训练网络。已知数据和其一一对应的标签，训练一个预测模型，将输入数据映射到标签的过程。</p>
<p>​	常见应用场景：监督式学习的常见应用场景如分类问题和回归问题。</p>
<p>​	算法举例：常见的有监督机器学习算法包括支持向量机(Support Vector Machine, SVM)，朴素贝叶斯(Naive Bayes)，逻辑回归(Logistic Regression)，K近邻(K-Nearest Neighborhood, KNN)，决策树(Decision Tree)，随机森林(Random Forest)，AdaBoost以及线性判别分析(Linear Discriminant Analysis, LDA)等。深度学习(Deep Learning)也是大多数以监督学习的方式呈现。</p>
<h3 id="2-2-2-非监督式学习">2.2.2 非监督式学习</h3>
<p>​	定义：在非监督式学习中，数据并不被特别标识，适用于你具有数据集但无标签的情况。学习模型是为了推断出数据的一些内在结构。</p>
<p>​	常见应用场景：常见的应用场景包括关联规则的学习以及聚类等。</p>
<p>​	算法举例：常见算法包括Apriori算法以及k-Means算法。</p>
<h3 id="2-2-3-半监督式学习">2.2.3 半监督式学习</h3>
<p>​	特点：在此学习方式下，输入数据部分被标记，部分没有被标记，这种学习模型可以用来进行预测。</p>
<p>​	常见应用场景：应用场景包括分类和回归，算法包括一些对常用监督式学习算法的延伸，通过对已标记数据建模，在此基础上，对未标记数据进行预测。</p>
<p>​	算法举例：常见算法如图论推理算法（Graph Inference）或者拉普拉斯支持向量机（Laplacian SVM）等。</p>
<h3 id="2-2-4-弱监督学习">2.2.4 弱监督学习</h3>
<p>​	特点：弱监督学习可以看做是有多个标记的数据集合，次集合可以是空集，单个元素，或包含多种情况（没有标记，有一个标记，和有多个标记）的多个元素。 数据集的标签是不可靠的，这里的不可靠可以是标记不正确，多种标记，标记不充分，局部标记等。已知数据和其一一对应的弱标签，训练一个智能算法，将输入数据映射到一组更强的标签的过程。标签的强弱指的是标签蕴含的信息量的多少，比如相对于分割的标签来说，分类的标签就是弱标签。</p>
<p>​	算法举例：举例，给出一张包含气球的图片，需要得出气球在图片中的位置及气球和背景的分割线，这就是已知弱标签学习强标签的问题。</p>
<p>​	在企业数据应用的场景下， 人们最常用的可能就是监督式学习和非监督式学习的模型。 在图像识别等领域，由于存在大量的非标识的数据和少量的可标识数据， 目前半监督式学习是一个很热的话题。</p>
<h3 id="2-2-5-监督学习有哪些步骤">2.2.5 监督学习有哪些步骤</h3>
<p>​	监督学习是使用已知正确答案的示例来训练网络，每组训练数据有一个明确的标识或结果。想象一下，我们可以训练一个网络，让其从照片库中（其中包含气球的照片）识别出气球的照片。以下就是我们在这个假设场景中所要采取的步骤。</p>
<p><strong>步骤1：数据集的创建和分类</strong><br>
​	首先，浏览你的照片（数据集），确定所有包含气球的照片，并对其进行标注。然后，将所有照片分为训练集和验证集。目标就是在深度网络中找一函数，这个函数输入是任意一张照片，当照片中包含气球时，输出1，否则输出0。</p>
<p><strong>步骤2：数据增强（Data Augmentation）</strong><br>
​	当原始数据搜集和标注完毕，一般搜集的数据并不一定包含目标在各种扰动下的信息。数据的好坏对于机器学习模型的预测能力至关重要，因此一般会进行数据增强。对于图像数据来说，数据增强一般包括，图像旋转，平移，颜色变换，裁剪，仿射变换等。</p>
<p><strong>步骤3：特征工程（Feature Engineering）</strong><br>
​	一般来讲，特征工程包含特征提取和特征选择。常见的手工特征(Hand-Crafted Feature)有尺度不变特征变换(Scale-Invariant Feature Transform, SIFT)，方向梯度直方图(Histogram of Oriented Gradient, HOG)等。由于手工特征是启发式的，其算法设计背后的出发点不同，将这些特征组合在一起的时候有可能会产生冲突，如何将组合特征的效能发挥出来，使原始数据在特征空间中的判别性最大化，就需要用到特征选择的方法。在深度学习方法大获成功之后，人们很大一部分不再关注特征工程本身。因为，最常用到的卷积神经网络(Convolutional Neural Networks, CNNs)本身就是一种特征提取和选择的引擎。研究者提出的不同的网络结构、正则化、归一化方法实际上就是深度学习背景下的特征工程。</p>
<p><strong>步骤4：构建预测模型和损失</strong><br>
​	将原始数据映射到特征空间之后，也就意味着我们得到了比较合理的输入。下一步就是构建合适的预测模型得到对应输入的输出。而如何保证模型的输出和输入标签的一致性，就需要构建模型预测和标签之间的损失函数，常见的损失函数(Loss Function)有交叉熵、均方差等。通过优化方法不断迭代，使模型从最初的初始化状态一步步变化为有预测能力的模型的过程，实际上就是学习的过程。</p>
<p><strong>步骤5：训练</strong><br>
​	选择合适的模型和超参数进行初始化，其中超参数比如支持向量机中核函数、误差项惩罚权重等。当模型初始化参数设定好后，将制作好的特征数据输入到模型，通过合适的优化方法不断缩小输出与标签之间的差距，当迭代过程到了截止条件，就可以得到训练好的模型。优化方法最常见的就是梯度下降法及其变种，使用梯度下降法的前提是优化目标函数对于模型是可导的。</p>
<p><strong>步骤6：验证和模型选择</strong><br>
​	训练完训练集图片后，需要进行模型测试。利用验证集来验证模型是否可以准确地挑选出含有气球在内的照片。<br>
​	在此过程中，通常会通过调整和模型相关的各种事物（超参数）来重复步骤2和3，诸如里面有多少个节点，有多少层，使用怎样的激活函数和损失函数，如何在反向传播阶段积极有效地训练权值等等。</p>
<p><strong>步骤7：测试及应用</strong><br>
​	当有了一个准确的模型，就可以将该模型部署到你的应用程序中。你可以将预测功能发布为API（Application Programming Interface, 应用程序编程接口）调用，并且你可以从软件中调用该API，从而进行推理并给出相应的结果。</p>
<h2 id="2-8-分类算法">2.8 分类算法</h2>
<p>​	分类算法和回归算法是对真实世界不同建模的方法。分类模型是认为模型的输出是离散的，例如大自然的生物被划分为不同的种类，是离散的。回归模型的输出是连续的，例如人的身高变化过程是一个连续过程，而不是离散的。</p>
<p>​	因此，在实际建模过程时，采用分类模型还是回归模型，取决于你对任务（真实世界）的分析和理解。</p>
<h3 id="2-8-1-常用分类算法的优缺点？">2.8.1 常用分类算法的优缺点？</h3>
<p>​	接下来我们介绍常用分类算法的优缺点，如表2-1所示。</p>
<p>​									表2-1 常用分类算法的优缺点</p>
<table>
<thead>
<tr>
<th style="text-align:left">算法</th>
<th style="text-align:left">优点</th>
<th style="text-align:left">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Bayes 贝叶斯分类法</td>
<td style="text-align:left">1）所需估计的参数少，对于缺失数据不敏感。<br>2）有着坚实的数学基础，以及稳定的分类效率。</td>
<td style="text-align:left">1）需要假设属性之间相互独立，这往往并不成立。（喜欢吃番茄、鸡蛋，却不喜欢吃番茄炒蛋）。<br>2）需要知道先验概率。<br>3）分类决策存在错误率。</td>
</tr>
<tr>
<td style="text-align:left">Decision Tree决策树</td>
<td style="text-align:left">1）不需要任何领域知识或参数假设。<br>2）适合高维数据。<br>3）简单易于理解。<br>4）短时间内处理大量数据，得到可行且效果较好的结果。<br>5）能够同时处理数据型和常规性属性。</td>
<td style="text-align:left">1）对于各类别样本数量不一致数据，信息增益偏向于那些具有更多数值的特征。<br>2）易于过拟合。<br>3）忽略属性之间的相关性。<br>4）不支持在线学习。</td>
</tr>
<tr>
<td style="text-align:left">SVM支持向量机</td>
<td style="text-align:left">1）可以解决小样本下机器学习的问题。<br>2）提高泛化性能。<br>3）可以解决高维、非线性问题。超高维文本分类仍受欢迎。<br>4）避免神经网络结构选择和局部极小的问题。</td>
<td style="text-align:left">1）对缺失数据敏感。<br>2）内存消耗大，难以解释。<br>3）运行和调参略烦人。</td>
</tr>
<tr>
<td style="text-align:left">KNN K近邻</td>
<td style="text-align:left">1）思想简单，理论成熟，既可以用来做分类也可以用来做回归； <br>2）可用于非线性分类；<br> 3）训练时间复杂度为O(n)； <br>4）准确度高，对数据没有假设，对outlier不敏感；</td>
<td style="text-align:left">1）计算量太大。<br>2）对于样本分类不均衡的问题，会产生误判。<br>3）需要大量的内存。<br>4）输出的可解释性不强。</td>
</tr>
<tr>
<td style="text-align:left">Logistic Regression逻辑回归</td>
<td style="text-align:left">1）速度快。<br>2）简单易于理解，直接看到各个特征的权重。<br>3）能容易地更新模型吸收新的数据。<br>4）如果想要一个概率框架，动态调整分类阀值。</td>
<td style="text-align:left">特征处理复杂。需要归一化和较多的特征工程。</td>
</tr>
<tr>
<td style="text-align:left">Neural Network 神经网络</td>
<td style="text-align:left">1）分类准确率高。<br>2）并行处理能力强。<br>3）分布式存储和学习能力强。<br>4）鲁棒性较强，不易受噪声影响。</td>
<td style="text-align:left">1）需要大量参数（网络拓扑、阀值、阈值）。<br>2）结果难以解释。<br>3）训练时间过长。</td>
</tr>
<tr>
<td style="text-align:left">Adaboosting</td>
<td style="text-align:left">1）adaboost是一种有很高精度的分类器。<br>2）可以使用各种方法构建子分类器，Adaboost算法提供的是框架。<br>3）当使用简单分类器时，计算出的结果是可以理解的。而且弱分类器构造极其简单。<br>4）简单，不用做特征筛选。<br>5）不用担心overfitting。</td>
<td style="text-align:left">对outlier比较敏感</td>
</tr>
</tbody>
</table>
<h3 id="2-8-2-分类算法的评估方法">2.8.2 分类算法的评估方法</h3>
<p>​	分类评估方法主要功能是用来评估分类算法的好坏，而评估一个分类器算法的好坏又包括许多项指标。了解各种评估方法，在实际应用中选择正确的评估方法是十分重要的。</p>
<ul>
<li>
<p><strong>几个常用术语</strong><br>
​	这里首先介绍几个常见的模型评价术语，现在假设我们的分类目标只有两类，计为正例（positive）和负例（negative）分别是：</p>
<ol>
<li>True positives(TP):  被正确地划分为正例的个数，即实际为正例且被分类器划分为正例的实例数；</li>
<li>False positives(FP): 被错误地划分为正例的个数，即实际为负例但被分类器划分为正例的实例数；</li>
<li>False negatives(FN):被错误地划分为负例的个数，即实际为正例但被分类器划分为负例的实例数；</li>
<li>True negatives(TN): 被正确地划分为负例的个数，即实际为负例且被分类器划分为负例的实例数。</li>
</ol>
<p>​									表2-2 四个术语的混淆矩阵</p>
</li>
</ul>
<p><img src="2.9/1.png" alt="图2-3 术语的混淆矩阵"></p>
<p>表2-2是这四个术语的混淆矩阵，做以下说明：<br>
1）P=TP+FN表示实际为正例的样本个数。<br>
2）True、False描述的是分类器是否判断正确。<br>
3）Positive、Negative是分类器的分类结果，如果正例计为1、负例计为-1，即positive=1、negative=-1。用1表示True，-1表示False，那么实际的类标=TF*PN，TF为true或false，PN为positive或negative。<br>
4）例如True positives(TP)的实际类标=1*1=1为正例，False positives(FP)的实际类标=(-1)*1=-1为负例，False negatives(FN)的实际类标=(-1)*(-1)=1为正例，True negatives(TN)的实际类标=1*(-1)=-1为负例。</p>
<ul>
<li>
<p><strong>评价指标</strong></p>
<ol>
<li>
<p>正确率（accuracy）<br>
正确率是我们最常见的评价指标，accuracy = (TP+TN)/(P+N)，正确率是被分对的样本数在所有样本数中的占比，通常来说，正确率越高，分类器越好。</p>
</li>
<li>
<p>错误率（error rate)<br>
错误率则与正确率相反，描述被分类器错分的比例，error rate = (FP+FN)/(P+N)，对某一个实例来说，分对与分错是互斥事件，所以accuracy =1 -  error rate。</p>
</li>
<li>
<p>灵敏度（sensitivity）<br>
sensitivity = TP/P，表示的是所有正例中被分对的比例，衡量了分类器对正例的识别能力。</p>
</li>
<li>
<p>特异性（specificity)<br>
specificity = TN/N，表示的是所有负例中被分对的比例，衡量了分类器对负例的识别能力。</p>
</li>
<li>
<p>精度（precision）<br>
precision=TP/(TP+FP)，精度是精确性的度量，表示被分为正例的示例中实际为正例的比例。</p>
</li>
<li>
<p>召回率（recall）<br>
召回率是覆盖面的度量，度量有多个正例被分为正例，recall=TP/(TP+FN)=TP/P=sensitivity，可以看到召回率与灵敏度是一样的。</p>
</li>
<li>
<p>其他评价指标<br>
计算速度：分类器训练和预测需要的时间；<br>
鲁棒性：处理缺失值和异常值的能力；<br>
可扩展性：处理大数据集的能力；<br>
可解释性：分类器的预测标准的可理解性，像决策树产生的规则就是很容易理解的，而神经网络的一堆参数就不好理解，我们只好把它看成一个黑盒子。</p>
</li>
<li>
<p>精度和召回率反映了分类器分类性能的两个方面。如果综合考虑查准率与查全率，可以得到新的评价指标F1-score，也称为综合分类率： $F1=\frac{2 \times precision \times recall}{precision + recall}​$ 。</p>
<p>为了综合多个类别的分类情况，评测系统整体性能，经常采用的还有微平均F1（micro-averaging）和宏平均F1（macro-averaging ）两种指标。</p>
<p>（1）宏平均F1与微平均F1是以两种不同的平均方式求的全局F1指标。</p>
<p>（2）宏平均F1的计算方法先对每个类别单独计算F1值，再取这些F1值的算术平均值作为全局指标。</p>
<p>（3）微平均F1的计算方法是先累加计算各个类别的a、b、c、d的值，再由这些值求出F1值。</p>
<p>（4）由两种平均F1的计算方式不难看出，宏平均F1平等对待每一个类别，所以它的值主要受到稀有类别的影响，而微平均F1平等考虑文档集中的每一个文档，所以它的值受到常见类别的影响比较大。</p>
</li>
</ol>
</li>
<li>
<p><strong>ROC曲线和PR曲线</strong></p>
<pre><code>  如图2-3，ROC曲线是（Receiver Operating Characteristic Curve，受试者工作特征曲线）的简称，是以灵敏度（真阳性率）为纵坐标，以1减去特异性（假阳性率）为横坐标绘制的性能评价曲线。可以将不同模型对同一数据集的ROC曲线绘制在同一笛卡尔坐标系中，ROC曲线越靠近左上角，说明其对应模型越可靠。也可以通过ROC曲线下面的面积（Area Under Curve, AUC）来评价模型，AUC越大，模型越可靠。
</code></pre>
</li>
</ul>
<p><img src="2.7.3.png" alt></p>
<p>​	                                                                         图2-3 ROC曲线</p>
<p>​	PR曲线是Precision Recall Curve的简称，描述的是precision和recall之间的关系，以recall为横坐标，precision为纵坐标绘制的曲线。该曲线的所对应的面积AUC实际上是目标检测中常用的评价指标平均精度（Average Precision, AP）。AP越高，说明模型性能越好。</p>
<h3 id="2-8-3-正确率能很好的评估分类算法吗">2.8.3 正确率能很好的评估分类算法吗</h3>
<p>​	不同算法有不同特点，在不同数据集上有不同的表现效果，根据特定的任务选择不同的算法。如何评价分类算法的好坏，要做具体任务具体分析。对于决策树，主要用正确率去评估，但是其他算法，只用正确率能很好的评估吗？<br>
​	答案是否定的。<br>
​	正确率确实是一个很直观很好的评价指标，但是有时候正确率高并不能完全代表一个算法就好。比如对某个地区进行地震预测，地震分类属性分为0：不发生地震、1发生地震。我们都知道，不发生的概率是极大的，对于分类器而言，如果分类器不加思考，对每一个测试样例的类别都划分为0，达到99%的正确率，但是，问题来了，如果真的发生地震时，这个分类器毫无察觉，那带来的后果将是巨大的。很显然，99%正确率的分类器并不是我们想要的。出现这种现象的原因主要是数据分布不均衡，类别为1的数据太少，错分了类别1但达到了很高的正确率缺忽视了研究者本身最为关注的情况。</p>
<h3 id="2-8-4-什么样的分类器是最好的">2.8.4 什么样的分类器是最好的</h3>
<p>​	对某一个任务，某个具体的分类器不可能同时满足或提高所有上面介绍的指标。<br>
​	如果一个分类器能正确分对所有的实例，那么各项指标都已经达到最优，但这样的分类器往往不存在。比如之前说的地震预测，既然不能百分百预测地震的发生，但实际情况中能容忍一定程度的误报。假设在1000次预测中，共有5次预测发生了地震，真实情况中有一次发生了地震，其他4次则为误报。正确率由原来的999/1000=99.9下降为996/1000=99.6。召回率由0/1=0%上升为1/1=100%。对此解释为，虽然预测失误了4次，但真的地震发生前，分类器能预测对，没有错过，这样的分类器实际意义更为重大，正是我们想要的。在这种情况下，在一定正确率前提下，要求分类器的召回率尽量高。</p>
<h2 id="2-9-逻辑回归">2.9 逻辑回归</h2>
<h3 id="2-9-1-回归划分">2.9.1 回归划分</h3>
<p>广义线性模型家族里，依据因变量不同，可以有如下划分：</p>
<p>（1）如果是连续的，就是多重线性回归。</p>
<p>（2）如果是二项分布，就是逻辑回归。</p>
<p>（3）如果是泊松（Poisson）分布，就是泊松回归。</p>
<p>（4）如果是负二项分布，就是负二项回归。</p>
<p>（5）逻辑回归的因变量可以是二分类的，也可以是多分类的，但是二分类的更为常用，也更加容易解释。所以实际中最常用的就是二分类的逻辑回归。</p>
<h3 id="2-9-2-逻辑回归适用性">2.9.2 逻辑回归适用性</h3>
<p>逻辑回归可用于以下几个方面：</p>
<p>（1）用于概率预测。用于可能性预测时，得到的结果有可比性。比如根据模型进而预测在不同的自变量情况下，发生某病或某种情况的概率有多大。</p>
<p>（2）用于分类。实际上跟预测有些类似，也是根据模型，判断某人属于某病或属于某种情况的概率有多大，也就是看一下这个人有多大的可能性是属于某病。进行分类时，仅需要设定一个阈值即可，可能性高于阈值是一类，低于阈值是另一类。</p>
<p>（3）寻找危险因素。寻找某一疾病的危险因素等。</p>
<p>（4）仅能用于线性问题。只有当目标和特征是线性关系时，才能用逻辑回归。在应用逻辑回归时注意两点：一是当知道模型是非线性时，不适用逻辑回归；二是当使用逻辑回归时，应注意选择和目标为线性关系的特征。</p>
<p>（5）各特征之间不需要满足条件独立假设，但各个特征的贡献独立计算。</p>
<h3 id="2-9-3-生成模型和判别模型的区别">2.9.3 生成模型和判别模型的区别</h3>
<p>生成模型：由数据学习联合概率密度分布P(X,Y)，然后求出条件概率分布P(Y|X)作为预测的模型，即生成模型：P(Y|X)= P(X,Y)/ P(X)（贝叶斯概率）。基本思想是首先建立样本的联合概率概率密度模型P(X,Y)，然后再得到后验概率P(Y|X)，再利用它进行分类。典型的生成模型有朴素贝叶斯，隐马尔科夫模型等</p>
<p>判别模型：由数据直接学习决策函数Y=f(X)或者条件概率分布P(Y|X)作为预测的模型，即判别模型。基本思想是有限样本条件下建立判别函数，不考虑样本的产生模型，直接研究预测模型。典型的判别模型包括k近邻，感知级，决策树，支持向量机等。这些模型的特点都是输入属性X可以直接得到后验概率P(Y|X)，输出条件概率最大的作为最终的类别（对于二分类任务来说，实际得到一个score，当score大于threshold时则为正类，否则为负类）。</p>
<p>举例：</p>
<p>判别式模型举例：要确定一个羊是山羊还是绵羊，用判别模型的方法是从历史数据中学习到模型，然后通过提取这只羊的特征来预测出这只羊是山羊的概率，是绵羊的概率。</p>
<p>生成式模型举例：利用生成模型是根据山羊的特征首先学习出一个山羊的模型，然后根据绵羊的特征学习出一个绵羊的模型，然后从这只羊中提取特征，放到山羊模型中看概率是多少，在放到绵羊模型中看概率是多少，哪个大就是哪个。</p>
<p>联系和区别：</p>
<pre><code>生成方法的特点：上面说到，生成方法学习联合概率密度分布P(X,Y)，所以就可以从统计的角度表示数据的分布情况，能够反映同类数据本身的相似度。但它不关心到底划分各类的那个分类边界在哪。生成方法可以还原出联合概率分布P(Y,X)，而判别方法不能。生成方法的学习收敛速度更快，即当样本容量增加的时候，学到的模型可以更快的收敛于真实模型，当存在隐变量时，仍可以用生成方法学习。此时判别方法就不能用。

判别方法的特点：判别方法直接学习的是决策函数Y=f(X)或者条件概率分布P(Y|X)。不能反映训练数据本身的特性。但它寻找不同类别之间的最优分类面，反映的是异类数据之间的差异。直接面对预测，往往学习的准确率更高。由于直接学习P(Y|X)或P(X)，可以对数据进行各种程度上的抽象、定义特征并使用特征，因此可以简化学习问题。
</code></pre>
<p>​	最后，由生成模型可以得到判别模型，但由判别模型得不到生成模型。</p>
<h3 id="2-9-4-逻辑回归与朴素贝叶斯有什么区别">2.9.4 逻辑回归与朴素贝叶斯有什么区别</h3>
<p>逻辑回归与朴素贝叶斯区别有以下几个方面：</p>
<p>（1）逻辑回归是判别模型， 朴素贝叶斯是生成模型，所以生成和判别的所有区别它们都有。</p>
<p>（2）朴素贝叶斯属于贝叶斯，逻辑回归是最大似然，两种概率哲学间的区别。</p>
<p>（3）朴素贝叶斯需要条件独立假设。</p>
<p>（4）逻辑回归需要求特征参数间是线性的。</p>
<h3 id="2-9-5-线性回归与逻辑回归的区别">2.9.5 线性回归与逻辑回归的区别</h3>
<p>线性回归与逻辑回归的区别如下描述：</p>
<p>（1）线性回归的样本的输出，都是连续值， $ y\in (-\infty ,+\infty )$ ，而逻辑回归中 $y\in (0,1)$ ，只能取0和1。</p>
<p>（2）对于拟合函数也有本质上的差别：</p>
<p>​	线性回归： $f(x)=\theta ^{T}x=\theta _{1}x _{1}+\theta _{2}x _{2}+...+\theta _{n}x _{n}$</p>
<p>​	逻辑回归： $f(x)=P(y=1|x;\theta )=g(\theta ^{T}x)$ ，其中， $g(z)=\frac{1}{1+e^{-z}}$</p>
<p>​	可以看出，线性回归的拟合函数，是对f(x)的输出变量y的拟合，而逻辑回归的拟合函数是对为1类样本的概率的拟合。</p>
<p>​	那么，为什么要以1类样本的概率进行拟合呢，为什么可以这样拟合呢？</p>
<p>​	 $\theta ^{T}x=0$ 就相当于是1类和0类的决策边界：</p>
<p>​	当 $\theta ^{T}x>0$ ，则y&gt;0.5；若 $\theta ^{T}x\rightarrow +\infty $ ，则 $y \rightarrow  1 $ ，即y为1类;</p>
<p>​	当 $\theta ^{T}x<0$ 0 ，则y&lt;0.5；若 $\theta ^{t}x\rightarrow -\infty $ ，则 $y \rightarrow ，即y为0类;< p>
<p>这个时候就能看出区别，在线性回归中 $\theta ^{T}x$ 为预测值的拟合函数；而在逻辑回归中 $\theta ^{T}x$ 为决策边界。下表2-3为线性回归和逻辑回归的区别。</p>
<p>​									表2-3 线性回归和逻辑回归的区别</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">线性回归</th>
<th style="text-align:center">逻辑回归</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">目的</td>
<td style="text-align:center">预测</td>
<td style="text-align:center">分类</td>
</tr>
<tr>
<td style="text-align:center">$y^{(i)}$</td>
<td style="text-align:center">未知</td>
<td style="text-align:center">（0,1）</td>
</tr>
<tr>
<td style="text-align:center">函数</td>
<td style="text-align:center">拟合函数</td>
<td style="text-align:center">预测函数</td>
</tr>
<tr>
<td style="text-align:center">参数计算方式</td>
<td style="text-align:center">最小二乘法</td>
<td style="text-align:center">极大似然估计</td>
</tr>
</tbody>
</table>
<p>下面具体解释一下：</p>
<ol>
<li>拟合函数和预测函数什么关系呢？简单来说就是将拟合函数做了一个逻辑函数的转换，转换后使得 $y^{(i)} \in (0,1)$ ;</li>
<li>最小二乘和最大似然估计可以相互替代吗？回答当然是不行了。我们来看看两者依仗的原理：最大似然估计是计算使得数据出现的可能性最大的参数，依仗的自然是Probability。而最小二乘是计算误差损失。</li>
</ol>
<h2 id="2-10-代价函数">2.10 代价函数</h2>
<h3 id="2-10-1-为什么需要代价函数">2.10.1 为什么需要代价函数</h3>
<ol>
<li>为了得到训练逻辑回归模型的参数，需要一个代价函数，通过训练代价函数来得到参数。</li>
<li>用于找到最优解的目的函数。</li>
</ol>
<h3 id="2-10-2-代价函数作用原理">2.10.2 代价函数作用原理</h3>
<p>​	在回归问题中，通过代价函数来求解最优解，常用的是平方误差代价函数。假设函数图像如图2-4所示，当参数发生变化时，假设函数状态也会随着变化。</p>
<p><img src="2.16/1.jpg" alt></p>
<p>​										图2-4   $h(x) = A + Bx$ 函数示意图</p>
<p>​	想要拟合图中的离散点，我们需要尽可能找到最优的 $A$ 和 $B$ 来使这条直线更能代表所有数据。如何找到最优解呢，这就需要使用代价函数来求解，以平方误差代价函数为例，假设函数为 $h(x)=\theta_0x$ 。<br>
​	<strong>平方误差代价函数的主要思想</strong>就是将实际数据给出的值与拟合出的线的对应值做差，求出拟合出的直线与实际的差距。在实际应用中，为了避免因个别极端数据产生的影响，采用类似方差再取二分之一的方式来减小个别数据的影响。因此，引出代价函数：</p>
 $$
J(\theta_0, \theta_1) = \frac{1}{m}\sum_{i=1}^m(h(x^{(i)})-y^{(i)})^2
$$ 
<p>​	<strong>最优解即为代价函数的最小值</strong> $\min J(\theta_0, \theta_1)$ 。如果是1个参数，代价函数一般通过二维曲线便可直观看出。如果是2个参数，代价函数通过三维图像可看出效果，参数越多，越复杂。<br>
当参数为2个时，代价函数是三维图像，如下图2-5所示。</p>
<p><img src="2.16/2.jpg" alt></p>
<p>​										图2-5  代价函数三维图像</p>
<h3 id="2-10-3-为什么代价函数要非负">2.10.3 为什么代价函数要非负</h3>
<p>​	目标函数存在一个下界，在优化过程当中，如果优化算法能够使目标函数不断减小，根据单调有界准则，这个优化算法就能证明是收敛有效的。<br>
​	只要设计的目标函数有下界，基本上都可以，代价函数非负更为方便。</p>
<h3 id="2-10-4-常见代价函数">2.10.4 常见代价函数</h3>
<p>（1）<strong>二次代价函数（quadratic cost）</strong>：</p>
 $$
J = \frac{1}{2n}\sum_x\Vert y(x)-a^L(x)\Vert^2
$$ 
<p>​	其中， $J$ 表示代价函数， $x$ 表示样本， $y$ 表示实际值， $a$ 表示输出值， $n$ 表示样本的总数。使用一个样本为例简单说明，此时二次代价函数为：</p>
 $$
J = \frac{(y-a)^2}{2}
$$ 
<p>​	假如使用梯度下降法（Gradient descent）来调整权值参数的大小，权值 $w$ 和偏置 $b$ 的梯度推导如下：</p>
 $$
\frac{\partial J}{\partial w}=(y-a)\sigma'(z)x\;,
\frac{\partial J}{\partial b}=(y-a)\sigma'(z)
$$ 
<p>其中， $z​$ 表示神经元的输入， $\sigma​$ 表示激活函数。权值 $w​$ 和偏置 $b​$ 的梯度跟激活函数的梯度成正比，激活函数的梯度越大，权值 $w​$ 和偏置 $b​$ 的大小调整得越快，训练收敛得就越快。</p>
<p><em>注</em>：神经网络常用的激活函数为sigmoid函数，该函数的曲线如下图2-6所示：</p>
<p><img src="2.18/1.jpg" alt></p>
<p>​												图2-6 sigmoid函数曲线</p>
<p>如上图所示，对0.88和0.98两个点进行比较：<br>
​	假设目标是收敛到1.0。0.88离目标1.0比较远，梯度比较大，权值调整比较大。0.98离目标1.0比较近，梯度比较小，权值调整比较小。调整方案合理。<br>
​	假如目标是收敛到0。0.88离目标0比较近，梯度比较大，权值调整比较大。0.98离目标0比较远，梯度比较小，权值调整比较小。调整方案不合理。<br>
​	原因：在使用sigmoid函数的情况下, 初始的代价（误差）越大，导致训练越慢。</p>
<p>（2）<strong>交叉熵代价函数（cross-entropy）</strong>：</p>
 $$
J = -\frac{1}{n}\sum_x[y\ln a + (1-y)\ln{(1-a)}]
$$ 
<p>其中， $J$ 表示代价函数， $x$ 表示样本， $y$ 表示实际值， $a$ 表示输出值， $n$ 表示样本的总数。<br>
权值 $w$ 和偏置 $b​$ 的梯度推导如下：</p>
 $$
\frac{\partial J}{\partial w_j}=\frac{1}{n}\sum_{x}x_j(\sigma{(z)}-y)\;，
\frac{\partial J}{\partial b}=\frac{1}{n}\sum_{x}(\sigma{(z)}-y)
$$ 
<p>当误差越大时，梯度就越大，权值 $w$ 和偏置 $b$ 调整就越快，训练的速度也就越快。<br>
<strong>二次代价函数适合输出神经元是线性的情况，交叉熵代价函数适合输出神经元是S型函数的情况。</strong></p>
<p>（3）<strong>对数似然代价函数（log-likelihood cost）</strong>：<br>
对数似然函数常用来作为softmax回归的代价函数。深度学习中普遍的做法是将softmax作为最后一层，此时常用的代价函数是对数似然代价函数。<br>
对数似然代价函数与softmax的组合和交叉熵与sigmoid函数的组合非常相似。对数似然代价函数在二分类时可以化简为交叉熵代价函数的形式。<br>
在tensorflow中：<br>
与sigmoid搭配使用的交叉熵函数：<code>tf.nn.sigmoid_cross_entropy_with_logits()</code>。<br>
与softmax搭配使用的交叉熵函数：<code>tf.nn.softmax_cross_entropy_with_logits()</code>。<br>
在pytorch中：<br>
与sigmoid搭配使用的交叉熵函数：<code>torch.nn.BCEWithLogitsLoss()</code>。<br>
与softmax搭配使用的交叉熵函数：<code>torch.nn.CrossEntropyLoss()</code>。</p>
<p>对数似然函数：</p>
<p>​	我们将似然函数作为机器学习模型的损失函数，并且用在分类问题中。这时似然函数是直接作用于模型的输出的（损失函数就是为了衡量当前参数下model的预测值predict距离真实值label的大小，所以似然函数用作损失函数时当然也是为了完成该任务），所以对于似然函数来说，这里的样本集就成了label集（而不是机器学习意义上的样本集X了），这里的参数也不是机器学习model 的参数，而是predict值。</p>
<p>其实作为损失函数的似然函数并不关心你当前的机器学习model的参数是怎样的，毕竟它此时所接收的输入只有两部分：<strong>1、predict。2、label 。3、分布模型（predict服从的分布）</strong>。</p>
<p>显然这里的label就是似然函数的观测值，即样本集。<strong>而它眼里的模型，当然就是predict这个随机变量所服从的概率分布模型。它的目的，就是衡量predict背后的模型对于当前观测值的解释程度。而每个样本的predict值，恰恰就是它所服从的分布模型的参数。</strong></p>
<p>比如此时我们的机器学习任务是一个4个类别的分类任务，机器学习model的输出就是当前样本X下的每个类别的概率，如predict=[0.1, 0.1, 0.7, 0.1]，而该样本的标签是类别3，表示成向量就是label=[0, 0, 1, 0]。那么label=[0, 0, 1, 0]就是似然函数眼里的样本，然后我们可以假设predict这个随机变量背后的模型是<strong>单次观测下的多项式分布</strong>，（<strong>因为softmax本身是基于多项式分布的</strong>）。</p>
<p>回顾：</p>
<p>伯努利分布，也叫做（0，1）分布，贝努利分布可以看成是将一枚硬币（只有正反两个面，代表两个类别）向上扔出，出现某个面（类别）的概率情况，因此其概率密度函数为：</p>
 $$
f(x)=p^x(1-p)^{1-x}=
\begin{cases}
p,& x=1\\
q,& x=0
\end{cases}
$$ 
<p>这是理解似然函数做损失函数的关键！另外，贝努利分布的模型参数就是其中一个类别的发生概率。</p>
<p>而二项分布呢，就是将贝努利实验重复n次（各次实验之间是相互独立的）。</p>
<p>而多项式分布呢，就是将二项分布推广到多个面（类别）。</p>
<p><strong>所以，单次观测下的多项式分布就是贝努利分布的多类推广！即：</strong></p>
 $$
f_{mulit}(x;p)=\prod_{i=1}^C p_{i}^{xi}
$$ 
<p>其中，C代表类别数。p代表向量形式的模型参数，即各个类别的发生概率，如p=[0.1, 0.1, 0.7, 0.1]，则p1=0.1, p3=0.7等。即，<strong>多项式分布的模型参数就是各个类别的发生概率！<strong>x代表</strong>one-hot形式</strong>的观测值，如x=类别3，则x=[0, 0, 1, 0]。xi代表x的第i个元素，比如x=类别3时，x1=0，x2=0，x3=1，x4=0。</p>
<p>想一下，机器学习model对某个样本的输出，就代表各个类别发生的概率。但是，对于当前<strong>这一个</strong>样本而言，它肯定只能有<strong>一个类别</strong>，所以这一个样本就可以看成是一次实验（观察），而这次实验（观察）的结果要服从上述各个类别发生的概率，那不就是服从多项式分布嘛！而且是单次观察！各个类别发生的概率predict当然就是这个多项式分布的参数。</p>
<p><strong>总结一下，对于多类分类问题，似然函数就是衡量当前这个以predict为参数的单次观测下的多项式分布模型与样本值label之间的似然度。</strong></p>
<p>所以，根据似然函数的定义，单个样本的似然函数即：</p>
 $$
L = f_{mulit}(label;predict)
$$ 
<p>所以，整个样本集（或者一个batch）的似然函数即：</p>
 $$
L=\prod_{X}f_{multi}(label;predict)= \prod_{X}\prod_{i=1}^{C}predict(i)^{label(i)}
$$ 
<p>所以在累乘号前面加上log函数后，就成了所谓的对数似然函数：</p>
 $$
L=\sum_{X}\sum_{i=1}^{C}label(i)log(predict(i))
$$ 
<p>而最大化对数似然函数就等效于最小化负对数似然函数，所以前面加个负号就和交叉熵的形式相同的了。</p>
<p>交叉熵定义：对于某种分布的随机变量X~p(x), 有一个模型q(x)用于近似p(x)的概率分布，则分布X与模型q之间的交叉熵即：</p>
 $$
H(X,q)=-\sum_{x}p(x)logq(x)
$$ 
<p>这里X的分布模型即样本集label的真实分布模型，这里模型q(x)即想要模拟真实分布模型的机器学习模型。可以说交叉熵是直接衡量两个分布，或者说两个model之间的差异。而似然函数则是解释以model的输出为参数的某分布模型对样本集的解释程度。因此，可以说这两者是“同貌不同源”，但是“殊途同归”啦。</p>
<p>tips：</p>
<p>最大似然估计：</p>
<p>给定一堆数据，假如我们知道它是从某一种分布中随机取出来的，可是我们并不知道这个分布具体的参，即“模型已定，参数未知”。例如，我们知道这个分布是正态分布，但是不知道均值和方差；或者是二项分布，但是不知道均值。最大似然估计（MLE，Maximum Likelihood Estimation）就可以用来估计模型的参数。<strong>MLE的目标是找出一组参数，使得模型产生出观测数据的概率最大。</strong></p>
<h3 id="2-10-5-为什么用交叉熵代替二次代价函数">2.10.5 为什么用交叉熵代替二次代价函数</h3>
<p>（1）<strong>为什么不用二次方代价函数</strong><br>
由上一节可知，权值 $w$ 和偏置 $b$ 的偏导数为 $\frac{\partial J}{\partial w}=(a-y)\sigma'(z)x$ ， $\frac{\partial J}{\partial b}=(a-y)\sigma'(z)$ ， 偏导数受激活函数的导数影响，sigmoid函数导数在输出接近0和1时非常小，会导致一些实例在刚开始训练时学习得非常慢。</p>
<p>（2）<strong>为什么要用交叉熵</strong><br>
交叉熵函数权值 $w$ 和偏置 $b$ 的梯度推导为：</p>
 $$
\frac{\partial J}{\partial w_j}=\frac{1}{n}\sum_{x}x_j(\sigma{(z)}-y)\;，
\frac{\partial J}{\partial b}=\frac{1}{n}\sum_{x}(\sigma{(z)}-y)
$$ 
<p>由以上公式可知，权重学习的速度受到 $\sigma{(z)}-y$ 影响，更大的误差，就有更快的学习速度，避免了二次代价函数方程中因 $\sigma'{(z)}$ 导致的学习缓慢的情况。</p>
<h2 id="2-11-损失函数">2.11 损失函数</h2>
<h3 id="2-11-1-什么是损失函数">2.11.1 什么是损失函数</h3>
<p>​	损失函数（Loss Function）又叫做误差函数，用来衡量算法的运行情况，估量模型的预测值与真实值的不一致程度，是一个非负实值函数，通常使用 $
L(Y, f(x))​$ 来表示。损失函数越小，模型的鲁棒性就越好。损失函数是经验风险函数的核心部分，也是结构风险函数重要组成部分。</p>
<h3 id="2-11-2-常见的损失函数">2.11.2 常见的损失函数</h3>
<p>​	机器学习通过对算法中的目标函数进行不断求解优化，得到最终想要的结果。分类和回归问题中，通常使用损失函数或代价函数作为目标函数。<br>
​	损失函数用来评价预测值和真实值不一样的程度。通常损失函数越好，模型的性能也越好。<br>
​	损失函数可分为经验风险损失函数和结构风险损失函数。经验风险损失函数指预测结果和实际结果的差别，结构风险损失函数是在经验风险损失函数上加上正则项。<br>
​	下面介绍常用的损失函数：</p>
<p>（1）<strong>0-1损失函数</strong><br>
如果预测值和目标值相等，值为0，如果不相等，值为1。</p>
 $$
L(Y, f(x)) =
\begin{cases}
1,& Y\ne f(x)\\
0,& Y = f(x)
\end{cases}
$$ 
<p>一般的在实际使用中，相等的条件过于严格，可适当放宽条件：</p>
 $$
L(Y, f(x)) =
\begin{cases}
1,& |Y-f(x)|\geqslant T\\
0,& |Y-f(x)|< T
\end{cases}
$$ 
<p>（2）<strong>绝对值损失函数</strong><br>
和0-1损失函数相似，绝对值损失函数表示为：</p>
 $$
L(Y, f(x)) = |Y-f(x)|​
$$ 
<p>（3）<strong>平方损失函数</strong></p>
 $$
L(Y, f(x)) = \sum_N{(Y-f(x))}^2
$$ 
<p>这点可从最小二乘法和欧几里得距离角度理解。最小二乘法的原理是，最优拟合曲线应该使所有点到回归直线的距离和最小。</p>
<p>（4）<strong>对数损失函数</strong></p>
 $$
L(Y, P(Y|X)) = -\log{P(Y|X)}=-\frac{1}{N}\sum_{i=1}^N\sum_{j=1}^M y_{ij}log(p_{ij})
$$ 
<p>​	其中, Y 为输出变量, X为输入变量, L 为损失函数. N为输入样本量, M为可能的类别数,  $y_{ij}$  是一个二值指标, 表示类别 j 是否是输入实例 xi 的真实类别.  $p_{ij}$  为模型或分类器预测输入实例 xi 属于类别 j 的概率.</p>
<p>常见的逻辑回归使用的就是对数损失函数，有很多人认为逻辑回归的损失函数是平方损失，其实不然。逻辑回归它假设样本服从伯努利分布（0-1分布），进而求得满足该分布的似然函数，接着取对数求极值等。逻辑回归推导出的经验风险函数是最小化负的似然函数，从损失函数的角度看，就是对数损失函数。形式上等价于二分类的交叉熵损失函数。</p>
<p>（6）<strong>指数损失函数</strong><br>
指数损失函数的标准形式为：</p>
 $$
L(Y, f(x)) = \exp(-Yf(x))
$$ 
<p>例如AdaBoost就是以指数损失函数为损失函数。</p>
<p>（7）<strong>Hinge损失函数</strong><br>
Hinge损失函数的标准形式如下：</p>
 $$
L(y) = \max{(0, 1-ty)}
$$ 
<p>统一的形式：</p>
 $$
L(Y, f(x)) = \max{(0, Yf(x))}
$$ 
<p>其中y是预测值，范围为(-1,1)，t为目标值，其为-1或1。</p>
<p>在线性支持向量机中，最优化问题可等价于</p>
 $$
\underset{\min}{w,b}\sum_{i=1}^N (1-y_i(wx_i+b))+\lambda\Vert w\Vert ^2
$$ 
<p>上式相似于下式</p>
 $$
\frac{1}{m}\sum_{i=1}^{N}l(wx_i+by_i) + \Vert w\Vert ^2
$$ 
<p>其中 $l(wx_i+by_i)$ 是Hinge损失函数， $\Vert w\Vert ^2$ 可看做为正则化项。</p>
<h3 id="2-11-3-逻辑回归为什么使用对数损失函数">2.11.3 逻辑回归为什么使用对数损失函数</h3>
<p>假设逻辑回归模型</p>
 $$
P(y=1|x;\theta)=\frac{1}{1+e^{-\theta^{T}x}}
$$ 
<p>假设逻辑回归模型的概率分布是伯努利分布，其概率质量函数为：</p>
 $$
P(X=n)=
\begin{cases}
1-p, n=0\\
 p,n=1
\end{cases}
$$ 
<p>其似然函数为：</p>
 $$
L(\theta)=\prod_{i=1}^{m}
P(y=1|x_i)^{y_i}P(y=0|x_i)^{1-y_i}
$$ 
<p>对数似然函数为：</p>
 $$
\ln L(\theta)=\sum_{i=1}^{m}[y_i\ln{P(y=1|x_i)}+(1-y_i)\ln{P(y=0|x_i)}]\\
  =\sum_{i=1}^m[y_i\ln{P(y=1|x_i)}+(1-y_i)\ln(1-P(y=1|x_i))]
$$ 
<p>对数函数在单个数据点上的定义为：</p>
 $$
cost(y,p(y|x))=-y\ln{p(y|x)-(1-y)\ln(1-p(y|x))}
$$ 
<p>则全局样本损失函数为：</p>
 $$
cost(y,p(y|x)) = -\sum_{i=1}^m[y_i\ln p(y_i|x_i)+(1-y_i)\ln(1-p(y_i|x_i))]
$$ 
<p>由此可看出，对数损失函数与极大似然估计的对数似然函数本质上是相同的。所以逻辑回归直接采用对数损失函数。</p>
<h3 id="2-11-4-对数损失函数是如何度量损失的">2.11.4 对数损失函数是如何度量损失的</h3>
<p>​	例如，在高斯分布中，我们需要确定均值和标准差。<br>
​	如何确定这两个参数？最大似然估计是比较常用的方法。最大似然的目标是找到一些参数值，这些参数值对应的分布可以最大化观测到数据的概率。<br>
​	因为需要计算观测到所有数据的全概率，即所有观测到的数据点的联合概率。现考虑如下简化情况：</p>
<p>（1）假设观测到每个数据点的概率和其他数据点的概率是独立的。</p>
<p>（2）取自然对数。<br>
假设观测到单个数据点 $x_i(i=1,2,...n)$ 的概率为：</p>
 $$
P(x_i;\mu,\sigma)=\frac{1}{\sigma \sqrt{2\pi}}\exp 
		\left( - \frac{(x_i-\mu)^2}{2\sigma^2} \right)
$$ 
<p>（3）其联合概率为：</p>
 $$
P(x_1,x_2,...,x_n;\mu,\sigma)=\frac{1}{\sigma \sqrt{2\pi}}\exp 
		\left( - \frac{(x_1-\mu)^2}{2\sigma^2} \right) \\ \times
		 \frac{1}{\sigma \sqrt{2\pi}}\exp 
		\left( - \frac{(x_2-\mu)^2}{2\sigma^2} \right) \times ... \times
		\frac{1}{\sigma \sqrt{2\pi}}\exp 
		\left( - \frac{(x_n-\mu)^2}{2\sigma^2} \right)
$$ 
<p>​	对上式取自然对数，可得：</p>
 $$
 \ln(P(x_1,x_2,...x_n;\mu,\sigma))=
 		\ln \left(\frac{1}{\sigma \sqrt{2\pi}} \right) 
 		 - \frac{(x_1-\mu)^2}{2\sigma^2}  \\ +
 		 \ln \left( \frac{1}{\sigma \sqrt{2\pi}} \right) 
 		 - \frac{(x_2-\mu)^2}{2\sigma^2} +...+
 		 \ln \left( \frac{1}{\sigma \sqrt{2\pi}} \right) 
 		 - \frac{(x_n-\mu)^2}{2\sigma^2}
$$ 
<p>根据对数定律，上式可以化简为：</p>
 $$
\ln(P(x_1,x_2,...x_n;\mu,\sigma))=-n\ln(\sigma)-\frac{n}{2} \ln(2\pi)\\
     	-\frac{1}{2\sigma^2}[(x_1-\mu)^2+(x_2-\mu)^2+...+(x_n-\mu)^2]
$$ 
<p>然后求导为：</p>
 $$
\frac{\partial\ln(P(x_1,x_2,...,x_n;\mu,\sigma))}{\partial\mu}=
     			\frac{n}{\sigma^2}[\mu - (x_1+x_2+...+x_n)]
$$ 
<p>​     上式左半部分为对数损失函数。损失函数越小越好，因此我们令等式左半的对数损失函数为0，可得：</p>
 $$
\mu=\frac{x_1+x_2+...+x_n}{n}
$$ 
<p>同理，可计算 $\sigma ​$ 。</p>
<h2 id="2-12-梯度下降">2.12 梯度下降</h2>
<h3 id="2-12-1-机器学习中为什么需要梯度下降">2.12.1 机器学习中为什么需要梯度下降</h3>
<p>梯度下降是机器学习中常见优化算法之一，梯度下降法有以下几个作用：</p>
<p>（1）梯度下降是迭代法的一种，可以用于求解最小二乘问题。</p>
<p>（2）在求解机器学习算法的模型参数，即无约束优化问题时，主要有梯度下降法（Gradient Descent）和最小二乘法。</p>
<p>（3）在求解损失函数的最小值时，可以通过梯度下降法来一步步的迭代求解，得到最小化的损失函数和模型参数值。</p>
<p>（4）如果我们需要求解损失函数的最大值，可通过梯度上升法来迭代。梯度下降法和梯度上升法可相互转换。</p>
<p>（5）在机器学习中，梯度下降法主要有随机梯度下降法和批量梯度下降法。</p>
<h3 id="2-12-2-梯度下降法缺点">2.12.2 梯度下降法缺点</h3>
<p>梯度下降法缺点有以下几点：</p>
<p>（1）靠近极小值时收敛速度减慢。</p>
<p>（2）直线搜索时可能会产生一些问题。</p>
<p>（3）可能会“之字形”地下降。</p>
<p>梯度概念也有需注意的地方：</p>
<p>（1）梯度是一个向量，即有方向有大小。</p>
<p>（2）梯度的方向是最大方向导数的方向。</p>
<p>（3）梯度的值是最大方向导数的值。</p>
<h3 id="2-12-3-梯度下降法直观理解">2.12.3 梯度下降法直观理解</h3>
<p>梯度下降法经典图示如下图2.7所示：</p>
<p><img src="2.25/1.png" alt></p>
<p>​									图2.7 梯度下降法经典图示</p>
<p>​	形象化举例，由上图2.7所示，假如最开始，我们在一座大山上的某处位置，因为到处都是陌生的，不知道下山的路，所以只能摸索着根据直觉，走一步算一步，在此过程中，每走到一个位置的时候，都会求解当前位置的梯度，沿着梯度的负方向，也就是当前最陡峭的位置向下走一步，然后继续求解当前位置梯度，向这一步所在位置沿着最陡峭最易下山的位置走一步。不断循环求梯度，就这样一步步地走下去，一直走到我们觉得已经到了山脚。当然这样走下去，有可能我们不能走到山脚，而是到了某一个局部的山势低处。<br>
​	由此，从上面的解释可以看出，梯度下降不一定能够找到全局的最优解，有可能是一个局部的最优解。当然，如果损失函数是凸函数，梯度下降法得到的解就一定是全局最优解。</p>
<p><strong>核心思想归纳</strong>：</p>
<p>（1）初始化参数，随机选取取值范围内的任意数；</p>
<p>（2）迭代操作：<br>
a）计算当前梯度；<br>
b）修改新的变量；<br>
c）计算朝最陡的下坡方向走一步；<br>
d）判断是否需要终止，如否，返回a）；</p>
<p>（3）得到全局最优解或者接近全局最优解。</p>
<h3 id="2-12-4-梯度下降法算法描述">2.12.4 梯度下降法算法描述</h3>
<p>梯度下降法算法步骤如下：</p>
<p>（1）确定优化模型的假设函数及损失函数。<br>
​	举例，对于线性回归，假设函数为：</p>
 $$
  h_\theta(x_1,x_2,...,x_n)=\theta_0+\theta_1x_1+...+\theta_nx_n
$$ 
<p>其中， $\theta_i,x_i(i=0,1,2,...,n)$ 分别为模型参数、每个样本的特征值。<br>
对于假设函数，损失函数为：</p>
 $$
  J(\theta_0,\theta_1,...,\theta_n)=\frac{1}{2m}\sum^{m}_{j=0}(h_\theta (x^{(j)}_0
  	,x^{(j)}_1,...,x^{(j)}_n)-y_j)^2
$$ 
<p>（2）相关参数初始化。<br>
​	主要初始化 ${\theta}_i$ 、算法迭代步长 ${\alpha} $ 、终止距离 ${\zeta} $ 。初始化时可以根据经验初始化，即 ${\theta} $ 初始化为0，步长 ${\alpha} $ 初始化为1。当前步长记为 ${\varphi}_i $ 。当然，也可随机初始化。</p>
<p>（3）迭代计算。</p>
<p>​	1）计算当前位置时损失函数的梯度，对 ${\theta}_i $ ，其梯度表示为：</p>
 $$
\frac{\partial}{\partial \theta_i}J({\theta}_0,{\theta}_1,...,{\theta}_n)=\frac{1}{2m}\sum^{m}_{j=0}(h_\theta (x^{(j)}_0
	,x^{(j)}_1,...,x^{(j)}_n)-y_j)^2
$$ 
<p>​	2）计算当前位置下降的距离。</p>
 $$
{\varphi}_i={\alpha} \frac{\partial}{\partial \theta_i}J({\theta}_0,{\theta}_1,...,{\theta}_n)
$$ 
<p>​	3）判断是否终止。<br>
​	确定是否所有 ${\theta}_i$ 梯度下降的距离 ${\varphi}_i$ 都小于终止距离 ${\zeta}$ ，如果都小于 ${\zeta}$ ，则算法终止，当然的值即为最终结果，否则进入下一步。<br>
​	4）更新所有的 ${\theta}_i$ ，更新后的表达式为：</p>
 $$
{\theta}_i={\theta}_i-\alpha \frac{\partial}{\partial \theta_i}J({\theta}_0,{\theta}_1,...,{\theta}_n)
$$ 
 $$
\theta_i=\theta_i - \alpha \frac{1}{m} \sum^{m}_{j=0}(h_\theta (x^{(j)}_0
	,x^{(j)}_1,...,x^{(j)}_n)-y_j)x^{(j)}_i
$$ 
<p>​	5）令上式 $x^{(j)}_0=1$ ，更新完毕后转入1)。<br>
​	由此，可看出，当前位置的梯度方向由所有样本决定，上式中  $\frac{1}{m}​$ 、 $\alpha \frac{1}{m}​$  的目的是为了便于理解。</p>
<h3 id="2-12-5-如何对梯度下降法进行调优">2.12.5 如何对梯度下降法进行调优</h3>
<p>实际使用梯度下降法时，各项参数指标不能一步就达到理想状态，对梯度下降法调优主要体现在以下几个方面：</p>
<p>（1）<strong>算法迭代步长 $\alpha$ 选择。</strong><br>
在算法参数初始化时，有时根据经验将步长初始化为1。实际取值取决于数据样本。可以从大到小，多取一些值，分别运行算法看迭代效果，如果损失函数在变小，则取值有效。如果取值无效，说明要增大步长。但步长太大，有时会导致迭代速度过快，错过最优解。步长太小，迭代速度慢，算法运行时间长。</p>
<p>（2）<strong>参数的初始值选择。</strong><br>
初始值不同，获得的最小值也有可能不同，梯度下降有可能得到的是局部最小值。如果损失函数是凸函数，则一定是最优解。由于有局部最优解的风险，需要多次用不同初始值运行算法，关键损失函数的最小值，选择损失函数最小化的初值。</p>
<p>（3）<strong>标准化处理。</strong><br>
由于样本不同，特征取值范围也不同，导致迭代速度慢。为了减少特征取值的影响，可对特征数据标准化，使新期望为0，新方差为1，可节省算法运行时间。</p>
<h3 id="2-12-6-随机梯度和批量梯度区别">2.12.6 随机梯度和批量梯度区别</h3>
<p>​	随机梯度下降（SGD）和批量梯度下降（BGD）是两种主要梯度下降法，其目的是增加某些限制来加速运算求解。<br>
下面通过介绍两种梯度下降法的求解思路，对其进行比较。<br>
假设函数为：</p>
 $$
h_\theta (x_0,x_1,...,x_3) = \theta_0 x_0 + \theta_1 x_1 + ... + \theta_n x_n
$$ 
<p>损失函数为：</p>
 $$
J(\theta_0, \theta_1, ... , \theta_n) = 
			\frac{1}{2m} \sum^{m}_{j=0}(h_\theta (x^{j}_0
	,x^{j}_1,...,x^{j}_n)-y^j)^2
$$ 
<p>其中， $m​$ 为样本个数， $j​$ 为参数个数。</p>
<p>1、 <strong>批量梯度下降的求解思路如下：</strong><br>
a) 得到每个 $ \theta ​$ 对应的梯度：</p>
 $$
\frac{\partial}{\partial \theta_i}J({\theta}_0,{\theta}_1,...,{\theta}_n)=\frac{1}{m}\sum^{m}_{j=0}(h_\theta (x^{j}_0
	,x^{j}_1,...,x^{j}_n)-y^j)x^{j}_i
$$ 
<p>b) 由于是求最小化风险函数，所以按每个参数  $ \theta ​$  的梯度负方向更新  $ \theta_i ​$  ：</p>
 $$
\theta_i=\theta_i - \frac{1}{m} \sum^{m}_{j=0}(h_\theta (x^{j}_0
	,x^{j}_1,...,x^{j}_n)-y^j)x^{j}_i
$$ 
<p>c) 从上式可以注意到，它得到的虽然是一个全局最优解，但每迭代一步，都要用到训练集所有的数据，如果样本数据很大，这种方法迭代速度就很慢。<br>
相比而言，随机梯度下降可避免这种问题。</p>
<p>2、<strong>随机梯度下降的求解思路如下：</strong><br>
a) 相比批量梯度下降对应所有的训练样本，随机梯度下降法中损失函数对应的是训练集中每个样本的粒度。<br>
损失函数可以写成如下这种形式，</p>
 $$
J(\theta_0, \theta_1, ... , \theta_n) = 
			\frac{1}{m} \sum^{m}_{j=0}(y^j - h_\theta (x^{j}_0
			,x^{j}_1,...,x^{j}_n))^2 = 
			\frac{1}{m} \sum^{m}_{j=0} cost(\theta,(x^j,y^j))
$$ 
<p>b）对每个参数  $ \theta​$  按梯度方向更新  $ \theta​$ ：</p>
 $$
\theta_i = \theta_i + (y^j - h_\theta (x^{j}_0, x^{j}_1, ... ,x^{j}_n))
$$ 
<p>c) 随机梯度下降是通过每个样本来迭代更新一次。<br>
随机梯度下降伴随的一个问题是噪音较批量梯度下降要多，使得随机梯度下降并不是每次迭代都向着整体最优化方向。</p>
<p><strong>小结：</strong><br>
随机梯度下降法、批量梯度下降法相对来说都比较极端，简单对比如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:left">特点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">批量梯度下降</td>
<td style="text-align:left">a）采用所有数据来梯度下降。<br>b）批量梯度下降法在样本量很大的时候，训练速度慢。</td>
</tr>
<tr>
<td style="text-align:center">随机梯度下降</td>
<td style="text-align:left">a）随机梯度下降用一个样本来梯度下降。<br>b）训练速度很快。<br>c）随机梯度下降法仅仅用一个样本决定梯度方向，导致解有可能不是全局最优。<br>d）收敛速度来说，随机梯度下降法一次迭代一个样本，导致迭代方向变化很大，不能很快的收敛到局部最优解。</td>
</tr>
</tbody>
</table>
<p>下面介绍能结合两种方法优点的小批量梯度下降法。</p>
<p>3、 <strong>小批量（Mini-Batch）梯度下降的求解思路如下</strong><br>
对于总数为 $m$ 个样本的数据，根据样本的数据，选取其中的 $n(1< n< m)$ 个子样本来迭代。其参数 $\theta$ 按梯度方向更新 $\theta_i$ 公式如下：</p>
 $$
\theta_i = \theta_i - \alpha \sum^{t+n-1}_{j=t}
		( h_\theta (x^{j}_{0}, x^{j}_{1}, ... , x^{j}_{n} ) - y^j ) x^{j}_{i}
$$ 
<h3 id="2-12-7-各种梯度下降法性能比较">2.12.7 各种梯度下降法性能比较</h3>
<p>​	下表简单对比随机梯度下降（SGD）、批量梯度下降（BGD）、小批量梯度下降（Mini-batch GD）、和Online GD的区别：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">BGD</th>
<th style="text-align:center">SGD</th>
<th style="text-align:center">Mini-batch GD</th>
<th style="text-align:center">Online GD</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">训练集</td>
<td style="text-align:center">固定</td>
<td style="text-align:center">固定</td>
<td style="text-align:center">固定</td>
<td style="text-align:center">实时更新</td>
</tr>
<tr>
<td style="text-align:center">单次迭代样本数</td>
<td style="text-align:center">整个训练集</td>
<td style="text-align:center">单个样本</td>
<td style="text-align:center">训练集的子集</td>
<td style="text-align:center">根据具体算法定</td>
</tr>
<tr>
<td style="text-align:center">算法复杂度</td>
<td style="text-align:center">高</td>
<td style="text-align:center">低</td>
<td style="text-align:center">一般</td>
<td style="text-align:center">低</td>
</tr>
<tr>
<td style="text-align:center">时效性</td>
<td style="text-align:center">低</td>
<td style="text-align:center">一般</td>
<td style="text-align:center">一般</td>
<td style="text-align:center">高</td>
</tr>
<tr>
<td style="text-align:center">收敛性</td>
<td style="text-align:center">稳定</td>
<td style="text-align:center">不稳定</td>
<td style="text-align:center">较稳定</td>
<td style="text-align:center">不稳定</td>
</tr>
</tbody>
</table>
<p>BGD、SGD、Mini-batch GD，前面均已讨论过，这里介绍一下Online GD。</p>
<p>​	Online GD于Mini-batch GD/SGD的区别在于，所有训练数据只用一次，然后丢弃。这样做的优点在于可预测最终模型的变化趋势。</p>
<p>​	Online GD在互联网领域用的较多，比如搜索广告的点击率（CTR）预估模型，网民的点击行为会随着时间改变。用普通的BGD算法（每天更新一次）一方面耗时较长（需要对所有历史数据重新训练）；另一方面，无法及时反馈用户的点击行为迁移。而Online GD算法可以实时的依据网民的点击行为进行迁移。</p>
<h2 id="2-13-自然梯度法">2.13 自然梯度法</h2>
<p><strong>（贡献者：郜泉凯－华南理工大学）</strong></p>
<h3 id="2-13-1-为什么我们需要自然梯度">2.13.1 为什么我们需要自然梯度</h3>
<p>传统的梯度下降方法是在欧氏空间进行、并与时序过程结合的优化方法，但这样的更新过程无法度量由于参数变化引起的概率属性的变化（这一点也可以认为是传统梯度下降方法的缺点）。在如强化学习等很多应用领域关注模型输出的概率分布，优化过程常常需要在一定概率属性的约束下完成，这就需要自然梯度。</p>
<h3 id="2-12-2-如何定义自然梯度">2.12.2 如何定义自然梯度</h3>
<p>若度量模型参数变化引起的概率分布变化，常用的“距离”度量是KL散度（Kullback-Leibler divergence）。设模型概率分布为 $p(x;\theta)$ ，其与参数变动后的概率分布间的KL散度为：</p>
 $$
D_{KL}(p(x;\theta)||p(x;\theta+\delta\theta))=\int p(x;\theta)log\frac {p(x;\theta)}{p(x;\theta+\delta\theta)}dx
$$ 
<p>我们令 $f(\theta+\delta\theta)=log p(x;\theta+\delta\theta)$ ，做泰勒展开取二阶近似（忽略高阶余项）得到：</p>
 $$
f(\theta+\delta\theta)\approx f(\theta)+\delta\theta^T\frac{\partial f(\theta)}{\partial\theta}+\frac{1}{2}\delta\theta^T\frac{\partial f(\theta)}{\partial\theta}\frac{\partial f(\theta)^T}{\partial\theta}\delta\theta
$$ 
<p>带入到 $D_{KL}(p(x;\theta)||p(x;\theta+\delta\theta))$ 中可得到：</p>
 $$
\begin{eqnarray}
D_{KL}(p(x;\theta)||p(x;\theta+\delta\theta))&=&\int p(x;\theta)(f(\theta)-f(\theta+\delta\theta))dx\\
&=&-\int p(x;\theta)(\delta\theta^T\frac{\partial f(\theta)}{\partial\theta}+\frac{1}{2}\delta\theta^T\frac{\partial f(\theta)}{\partial\theta}\frac{\partial f(\theta)^T}{\partial\theta}\delta\theta)dx\\
&=&-\delta\theta^T\int p(x;\theta)\frac{\partial logp(x;\theta)}{\partial\theta}dx\\
&-&\frac{1}{2}\delta\theta^T\int p(x;\theta)\frac{\partial f(\theta)}{\partial\theta}\frac{\partial f(\theta)^T}{\partial\theta}dx\delta\theta\\
&=&-\delta\theta^T\int p(x;\theta)\frac{\frac{\partial p(x;\theta)}{\partial\theta}}{p(x;\theta)}dx-\frac{1}{2}\delta\theta^TG\delta\theta\\
&=&-\frac{1}{2}\delta\theta^TG\delta\theta
\end{eqnarray}
$$ 
<p>我们记在KL散度意义下的参数增量为 $\delta\theta_G$ ，接下来我们寻求在 $||\delta\theta_G||^2=\epsilon$ 约束下 $\delta\theta_G$ 的方向，使得目标函数 $J(\theta)$ 下降最快,即 $J(\theta+\delta\theta)-J(\theta)$ 最大。应用拉格朗日乘子法：</p>
 $$
\max_{\delta\theta}J(\theta+\delta\theta)-J(\theta)-\lambda(||\delta\theta_G||^2-\epsilon)
$$ 
<p>应用一阶泰勒展开等价于:</p>
 $$
\max_{\delta\theta}\nabla \delta\theta^T J(\theta)-\frac{1}{2}\lambda\delta\theta^TG\delta\theta
$$ 
<p>对 $\delta\theta$ 求导得 $\nabla J(\theta)-\lambda G\delta\theta=0$ ，即 $\delta\theta=\frac{1}{\lambda}G^{-1}\nabla J(\theta)$ ，其中 $G^{-1}\nabla J(\theta)$ 称为自然梯度，相应的自然梯度下降公式为 $\theta_{k+1}=\theta_k-\alpha_kG^{-1}(\theta_k)\nabla J(\theta_K)$ 。</p>
<h3 id="2-12-3-Fisher信息矩阵的意义">2.12.3 Fisher信息矩阵的意义</h3>
<p>首先我们对一个模型进行建模，成为以 $\theta$ 为参数的概率分布 $p(x;\theta)$ 。为求出一个合理的 $\theta$ 我们需要一个评分函数（score function）： $s(\theta)=\nabla_{\theta}logp(x;\theta)$ ，意为对数似然的梯度，当分数为0时（对数似然梯度为0），对数似然达到极值。对评分函数求关于 $p(x;\theta)$ 数学期望 $p_E$ 不难发现期望为0。接下来求估计误差的界，我们用评分函数的方差来确定，即 $E_{p(x;\theta)}[(s(\theta)-p_E)(s(\theta-p_E)^T)]$ 。带入评分函数的数学表达形式则等价于Fisher信息矩阵 $G(\theta)=\int p(x;\theta)\frac{\partial f(\theta)}{\partial\theta}\frac{\partial f(\theta)^T}{\partial\theta}dx$ 。特别地，Fisher信息矩阵与评分函数 $\nabla_{\theta}logp(x;\theta)$ 的Hessian似然的负数等价。</p>
<p>证明：首先求出评分函数的Hessian矩阵，由梯度的Jacobian决定</p>
 $$
\begin{eqnarray}
H_{logp(x;\theta)}&=&J(\frac{\nabla p(x;\theta)}{p(x;\theta)})\\
&=&\frac{\frac{\partial\nabla p(x;\theta)}{\partial\theta}p(x;\theta)-\nabla p(x;\theta)\nabla p(x;\theta)^T}{p(x;\theta)p(x;\theta)}\\
&=&\frac{H_{p(x;\theta)}p(x;\theta)}{p(x;\theta)p(x;\theta)}-\frac{\nabla p(x;\theta)\nabla p(x;\theta)^T}{p(x;\theta)p(x;\theta)}\\
\end{eqnarray}
$$ 
<p>等式两边同时求关于 $p(x;\theta)$ 的数学期望：</p>
 $$
\begin{eqnarray}
E_{p(x;\theta)}[H_{logp(x;\theta)}] &=& E_{p(x;\theta)}(\frac{H_{p(x;\theta)}p(x;\theta)}{p(x;\theta)p(x;\theta)})-G\\
&=&\int\frac{H_{p(x;\theta)}}{p(x;\theta)}p(x;\theta)dx-G\\
&=&\nabla^2\int p(x;\theta)dx-G\\
&=&-G
\end{eqnarray}
$$ 
<p>而Hessian矩阵刻画着对数似然函数的曲率，所以本质上自然梯度下降法是在一个消除了不同概率分布的曲率后，在同一个“平坦”曲面上进行迭代更新，步长等于原概率分布空间的步长按照曲率折合到新的“平坦曲面”的大小。</p>
<p>值得注意的一点是，一般来说似然函数获取很难，在实际问题中，我们可以用采样的方法从数据集中采样数据，将Fisher信息矩阵原始表达式的积分变为求和来近似估计，这样的方式得到的Fisher信息矩阵称为经验Fisher。</p>
<h2 id="2-14-线性判别分析（LDA）">2.14 线性判别分析（LDA）</h2>
<h3 id="2-14-1-LDA思想总结">2.14.1 LDA思想总结</h3>
<p>​	线性判别分析（Linear Discriminant Analysis，LDA）是一种经典的降维方法。和主成分分析PCA不考虑样本类别输出的无监督降维技术不同，LDA是一种监督学习的降维技术，数据集的每个样本有类别输出。</p>
<p>LDA分类思想简单总结如下：</p>
<ol>
<li>多维空间中，数据处理分类问题较为复杂，LDA算法将多维空间中的数据投影到一条直线上，将d维数据转化成1维数据进行处理。</li>
<li>对于训练数据，设法将多维数据投影到一条直线上，同类数据的投影点尽可能接近，异类数据点尽可能远离。</li>
<li>对数据进行分类时，将其投影到同样的这条直线上，再根据投影点的位置来确定样本的类别。</li>
</ol>
<p>如果用一句话概括LDA思想，即“投影后类内方差最小，类间方差最大”。</p>
<h3 id="2-14-2-图解LDA核心思想">2.14.2 图解LDA核心思想</h3>
<p>​	假设有红、蓝两类数据，这些数据特征均为二维，如下图所示。我们的目标是将这些数据投影到一维，让每一类相近的数据的投影点尽可能接近，不同类别数据尽可能远，即图中红色和蓝色数据中心之间的距离尽可能大。</p>
<p><img src="2.29/1.png" alt></p>
<p>左图和右图是两种不同的投影方式。</p>
<p>​	左图思路：让不同类别的平均点距离最远的投影方式。</p>
<p>​	右图思路：让同类别的数据挨得最近的投影方式。</p>
<p>​	从上图直观看出，右图红色数据和蓝色数据在各自的区域来说相对集中，根据数据分布直方图也可看出，所以右图的投影效果好于左图，左图中间直方图部分有明显交集。</p>
<p>​	以上例子是基于数据是二维的，分类后的投影是一条直线。如果原始数据是多维的，则投影后的分类面是一低维的超平面。</p>
<h3 id="2-14-3-二类LDA算法原理">2.14.3 二类LDA算法原理</h3>
<p>​	输入：数据集  $D=\{(\boldsymbol x_1,\boldsymbol y_1),(\boldsymbol x_2,\boldsymbol y_2),...,(\boldsymbol x_m,\boldsymbol y_m)\}​$ ，其中样本  $\boldsymbol x_i ​$  是n维向量， $\boldsymbol y_i  \epsilon \{0, 1\}​$ ，降维后的目标维度  $d​$ 。定义</p>
<p>​	 $N_j(j=0,1)$  为第  $j$  类样本个数；</p>
<p>​	 $X_j(j=0,1)$  为第  $j$  类样本的集合；</p>
<p>​	 $u_j(j=0,1)​$  为第  $j​$  类样本的均值向量；</p>
<p>​	 $\sum_j(j=0,1)$  为第  $j$  类样本的协方差矩阵。</p>
<p>​	其中</p>
 $$
u_j = \frac{1}{N_j} \sum_{\boldsymbol x\epsilon X_j}\boldsymbol x(j=0,1)， 
\sum_j = \sum_{\boldsymbol x\epsilon X_j}(\boldsymbol x-u_j)(\boldsymbol x-u_j)^T(j=0,1)
$$ 
<p>​	假设投影直线是向量  $\boldsymbol w$ ，对任意样本  $\boldsymbol x_i$ ，它在直线  $w$ 上的投影为  $\boldsymbol w^Tx_i$ ，两个类别的中心点  $u_0$ ,  $u_1 $ 在直线  $w$  的投影分别为  $\boldsymbol w^Tu_0$  、 $\boldsymbol w^Tu_1$ 。</p>
<p>​	LDA的目标是让两类别的数据中心间的距离  $\| \boldsymbol w^Tu_0 - \boldsymbol w^Tu_1 \|^2_2$  尽量大，与此同时，希望同类样本投影点的协方差 $\boldsymbol w^T \sum_0 \boldsymbol w$ 、 $\boldsymbol w^T \sum_1 \boldsymbol w$  尽量小，最小化  $\boldsymbol w^T \sum_0 \boldsymbol w + \boldsymbol w^T \sum_1 \boldsymbol w​$  。<br>
​	定义<br>
​	类内散度矩阵</p>
 $$
S_w = \sum_0 + \sum_1 = 
	\sum_{\boldsymbol x\epsilon X_0}(\boldsymbol x-u_0)(\boldsymbol x-u_0)^T + 
	\sum_{\boldsymbol x\epsilon X_1}(\boldsymbol x-u_1)(\boldsymbol x-u_1)^T
$$ 
<p>​	类间散度矩阵  $S_b = (u_0 - u_1)(u_0 - u_1)^T$</p>
<p>​	据上分析，优化目标为</p>
 $$
\mathop{\arg\max}_\boldsymbol w J(\boldsymbol w) = \frac{\| \boldsymbol w^Tu_0 - \boldsymbol w^Tu_1 \|^2_2}{\boldsymbol w^T \sum_0\boldsymbol w + \boldsymbol w^T \sum_1\boldsymbol w} = 
\frac{\boldsymbol w^T(u_0-u_1)(u_0-u_1)^T\boldsymbol w}{\boldsymbol w^T(\sum_0 + \sum_1)\boldsymbol w} =
\frac{\boldsymbol w^TS_b\boldsymbol w}{\boldsymbol w^TS_w\boldsymbol w}
$$ 
<p>​	根据广义瑞利商的性质，矩阵  $S^{-1}_{w} S_b$  的最大特征值为  $J(\boldsymbol w)$  的最大值，矩阵  $S^{-1}_{w} S_b$  的最大特征值对应的特征向量即为  $\boldsymbol w$ 。</p>
<h3 id="2-14-4-LDA算法流程总结">2.14.4 LDA算法流程总结</h3>
<p>LDA算法降维流程如下：</p>
<p>​	输入：数据集  $D = \{ (x_1,y_1),(x_2,y_2), ... ,(x_m,y_m) \}$ ，其中样本  $x_i $  是n维向量， $y_i  \epsilon \{C_1, C_2, ..., C_k\}$ ，降维后的目标维度  $d$  。</p>
<p>​	输出：降维后的数据集  $\overline{D} $  。</p>
<p>步骤：</p>
<ol>
<li>计算类内散度矩阵  $S_w$ 。</li>
<li>计算类间散度矩阵  $S_b​$  。</li>
<li>计算矩阵  $S^{-1}_wS_b​$  。</li>
<li>计算矩阵  $S^{-1}_wS_b$  的最大的 d 个特征值。</li>
<li>计算 d 个特征值对应的 d 个特征向量，记投影矩阵为 W 。</li>
<li>转化样本集的每个样本，得到新样本  $P_i = W^Tx_i​$  。</li>
<li>输出新样本集  $\overline{D} = \{ (p_1,y_1),(p_2,y_2),...,(p_m,y_m) \}​$</li>
</ol>
<h3 id="2-14-5-LDA和PCA区别">2.14.5 LDA和PCA区别</h3>
<table>
<thead>
<tr>
<th style="text-align:center">异同点</th>
<th style="text-align:left">LDA</th>
<th style="text-align:left">PCA</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">相同点</td>
<td style="text-align:left">1. 两者均可以对数据进行降维；<br>2. 两者在降维时均使用了矩阵特征分解的思想；<br>3. 两者都假设数据符合高斯分布；</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">不同点</td>
<td style="text-align:left">有监督的降维方法；</td>
<td style="text-align:left">无监督的降维方法；</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left">降维最多降到k-1维；</td>
<td style="text-align:left">降维多少没有限制；</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left">可以用于降维，还可以用于分类；</td>
<td style="text-align:left">只用于降维；</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left">选择分类性能最好的投影方向；</td>
<td style="text-align:left">选择样本点投影具有最大方差的方向；</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left">更明确，更能反映样本间差异；</td>
<td style="text-align:left">目的较为模糊；</td>
</tr>
</tbody>
</table>
<h3 id="2-14-6-LDA优缺点">2.14.6 LDA优缺点</h3>
<table>
<thead>
<tr>
<th style="text-align:center">优缺点</th>
<th style="text-align:left">简要说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">优点</td>
<td style="text-align:left">1. 可以使用类别的先验知识；<br>2. 以标签、类别衡量差异性的有监督降维方式，相对于PCA的模糊性，其目的更明确，更能反映样本间的差异；</td>
</tr>
<tr>
<td style="text-align:center">缺点</td>
<td style="text-align:left">1. LDA不适合对非高斯分布样本进行降维；<br>2. LDA降维最多降到分类数k-1维；<br>3. LDA在样本分类信息依赖方差而不是均值时，降维效果不好；<br>4. LDA可能过度拟合数据。</td>
</tr>
</tbody>
</table>
<h2 id="2-15-主成分分析（PCA）">2.15  主成分分析（PCA）</h2>
<h3 id="2-15-1-主成分分析（PCA）思想总结">2.15.1 主成分分析（PCA）思想总结</h3>
<ol>
<li>PCA就是将高维的数据通过线性变换投影到低维空间上去。</li>
<li>投影思想：找出最能够代表原始数据的投影方法。被PCA降掉的那些维度只能是那些噪声或是冗余的数据。</li>
<li>去冗余：去除可以被其他向量代表的线性相关向量，这部分信息量是多余的。</li>
<li>去噪声，去除较小特征值对应的特征向量，特征值的大小反映了变换后在特征向量方向上变换的幅度，幅度越大，说明这个方向上的元素差异也越大，要保留。</li>
<li>对角化矩阵，寻找极大线性无关组，保留较大的特征值，去除较小特征值，组成一个投影矩阵，对原始样本矩阵进行投影，得到降维后的新样本矩阵。</li>
<li>完成PCA的关键是——协方差矩阵。协方差矩阵，能同时表现不同维度间的相关性以及各个维度上的方差。协方差矩阵度量的是维度与维度之间的关系，而非样本与样本之间。</li>
<li>之所以对角化，因为对角化之后非对角上的元素都是0，达到去噪声的目的。对角化后的协方差矩阵，对角线上较小的新方差对应的就是那些该去掉的维度。所以我们只取那些含有较大能量(特征值)的维度，其余的就舍掉，即去冗余。</li>
</ol>
<h3 id="2-15-2-图解PCA核心思想">2.15.2 图解PCA核心思想</h3>
<p>​	PCA可解决训练数据中存在数据特征过多或特征累赘的问题。核心思想是将m维特征映射到n维（n &lt; m），这n维形成主元，是重构出来最能代表原始数据的正交特征。</p>
<p>​	假设数据集是m个n维， $(\boldsymbol x^{(1)}, \boldsymbol x^{(2)}, \cdots, \boldsymbol x^{(m)})$ 。如果 $n=2$ ，需要降维到 $n'=1$ ，现在想找到某一维度方向代表这两个维度的数据。下图有 $u_1, u_2$ 两个向量方向，但是哪个向量才是我们所想要的，可以更好代表原始数据集的呢？</p>
<p><img src="2.34/1.png" alt></p>
<p>从图可看出， $u_1$ 比 $u_2$ 好，为什么呢？有以下两个主要评价指标：</p>
<ol>
<li>样本点到这个直线的距离足够近。</li>
<li>样本点在这个直线上的投影能尽可能的分开。</li>
</ol>
<p>如果我们需要降维的目标维数是其他任意维，则：</p>
<ol>
<li>样本点到这个超平面的距离足够近。</li>
<li>样本点在这个超平面上的投影能尽可能的分开。</li>
</ol>
<h3 id="2-15-3-PCA算法推理">2.15.3 PCA算法推理</h3>
<p>下面以基于最小投影距离为评价指标推理：</p>
<p>​	假设数据集是m个n维， $(x^{(1)}, x^{(2)},...,x^{(m)})$ ，且数据进行了中心化。经过投影变换得到新坐标为  ${w_1,w_2,...,w_n}$ ，其中  $w$  是标准正交基，即  $\| w \|_2 = 1$ ， $w^T_iw_j = 0$ 。</p>
<p>​	经过降维后，新坐标为  $\{ w_1,w_2,...,w_n \}$ ，其中  $n'$  是降维后的目标维数。样本点  $x^{(i)}$  在新坐标系下的投影为  $z^{(i)} = \left(z^{(i)}_1, z^{(i)}_2, ..., z^{(i)}_{n'}   \right)$ ，其中  $z^{(i)}_j = w^T_j x^{(i)}$  是  $x^{(i)} ​$  在低维坐标系里第 j 维的坐标。</p>
<p>​	如果用  $z^{(i)} $  去恢复  $x^{(i)} $  ，则得到的恢复数据为  $\widehat{x}^{(i)} = \sum^{n'}_{j=1} x^{(i)}_j w_j = Wz^{(i)}$ ，其中  $W$ 为标准正交基组成的矩阵。</p>
<p>​	考虑到整个样本集，样本点到这个超平面的距离足够近，目标变为最小化  $\sum^m_{i=1} \| \hat{x}^{(i)} - x^{(i)} \|^2_2$  。对此式进行推理，可得：</p>
 $$
\sum^m_{i=1} \| \hat{x}^{(i)} - x^{(i)} \|^2_2 = 
	\sum^m_{i=1} \| Wz^{(i)} - x^{(i)} \|^2_2 \\
	= \sum^m_{i=1} \left( Wz^{(i)} \right)^T \left( Wz^{(i)} \right)
	- 2\sum^m_{i=1} \left( Wz^{(i)} \right)^T x^{(i)}
	+ \sum^m_{i=1} \left( x^{(i)} \right)^T x^{(i)} \\
	= \sum^m_{i=1} \left( z^{(i)} \right)^T \left( z^{(i)} \right)
	- 2\sum^m_{i=1} \left( z^{(i)} \right)^T x^{(i)}
	+ \sum^m_{i=1} \left( x^{(i)} \right)^T x^{(i)} \\
	= - \sum^m_{i=1} \left( z^{(i)} \right)^T \left( z^{(i)} \right)
	+ \sum^m_{i=1} \left( x^{(i)} \right)^T x^{(i)} \\
	= -tr \left( W^T \left( \sum^m_{i=1} x^{(i)} \left( x^{(i)} \right)^T \right)W \right)
	+ \sum^m_{i=1} \left( x^{(i)} \right)^T x^{(i)} \\
	= -tr \left( W^TXX^TW \right)
	+ \sum^m_{i=1} \left( x^{(i)} \right)^T x^{(i)}
$$ 
<p>​	在推导过程中，分别用到了  $\overline{x}^{(i)} = Wz^{(i)}$  ，矩阵转置公式  $(AB)^T = B^TA^T$ ， $W^TW = I$ ， $z^{(i)} = W^Tx^{(i)}$  以及矩阵的迹，最后两步是将代数和转为矩阵形式。<br>
​	由于  $W$  的每一个向量  $w_j$  是标准正交基， $\sum^m_{i=1} x^{(i)} \left(  x^{(i)} \right)^T$  是数据集的协方差矩阵， $\sum^m_{i=1} \left(  x^{(i)} \right)^T x^{(i)} $  是一个常量。最小化  $\sum^m_{i=1} \| \hat{x}^{(i)} - x^{(i)} \|^2_2$  又可等价于</p>
 $$
\underbrace{\arg \min}_W - tr \left( W^TXX^TW \right) s.t.W^TW = I
$$ 
<p>利用拉格朗日函数可得到</p>
 $$
J(W) = -tr(W^TXX^TW) + \lambda(W^TW - I)
$$ 
<p>​	对  $W$  求导，可得  $-XX^TW + \lambda W = 0 $  ，也即  $ XX^TW = \lambda W $  。  $ XX^T $  是  $ n' $  个特征向量组成的矩阵， $\lambda$  为 $ XX^T $  的特征值。 $W$  即为我们想要的矩阵。<br>
​	对于原始数据，只需要  $z^{(i)} = W^TX^{(i)}$  ，就可把原始数据集降维到最小投影距离的  $n'$  维数据集。</p>
<p>​	基于最大投影方差的推导，这里就不再赘述，有兴趣的同仁可自行查阅资料。</p>
<h3 id="2-15-4-PCA算法流程总结">2.15.4 PCA算法流程总结</h3>
<p>输入： $n​$  维样本集  $D = \left( x^{(1)},x^{(2)},...,x^{(m)} \right)​$  ，目标降维的维数  $n'​$  。</p>
<p>输出：降维后的新样本集  $D'  = \left( z^{(1)},z^{(2)},...,z^{(m)} \right)$  。</p>
<p>主要步骤如下：</p>
<ol>
<li>对所有的样本进行中心化， $ x^{(i)} = x^{(i)} - \frac{1}{m} \sum^m_{j=1} x^{(j)} $  。</li>
<li>计算样本的协方差矩阵  $XX^T​$  。</li>
<li>对协方差矩阵  $XX^T$  进行特征值分解。</li>
<li>取出最大的  $n' $  个特征值对应的特征向量  $\{ w_1,w_2,...,w_{n'} \}$  。</li>
<li>标准化特征向量，得到特征向量矩阵  $W$  。</li>
<li>转化样本集中的每个样本  $z^{(i)} = W^T x^{(i)}$  。</li>
<li>得到输出矩阵  $D' = \left( z^{(1)},z^{(2)},...,z^{(n)} \right)​$  。<br>
<em>注</em>：在降维时，有时不明确目标维数，而是指定降维到的主成分比重阈值  $k(k \epsilon(0,1])​$  。假设  $n​$  个特征值为  $\lambda_1 \geqslant \lambda_2 \geqslant ... \geqslant \lambda_n​$  ，则  $n'​$  可从  $\sum^{n'}_{i=1} \lambda_i \geqslant k \times \sum^n_{i=1} \lambda_i ​$  得到。</li>
</ol>
<h3 id="2-15-5-PCA算法主要优缺点">2.15.5 PCA算法主要优缺点</h3>
<table>
<thead>
<tr>
<th style="text-align:center">优缺点</th>
<th style="text-align:left">简要说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">优点</td>
<td style="text-align:left">1. 仅仅需要以方差衡量信息量，不受数据集以外的因素影响。　2.各主成分之间正交，可消除原始数据成分间的相互影响的因素。3. 计算方法简单，主要运算是特征值分解，易于实现。</td>
</tr>
<tr>
<td style="text-align:center">缺点</td>
<td style="text-align:left">1.主成分各个特征维度的含义具有一定的模糊性，不如原始样本特征的解释性强。2. 方差小的非主成分也可能含有对样本差异的重要信息，因降维丢弃可能对后续数据处理有影响。</td>
</tr>
</tbody>
</table>
<h3 id="2-15-6-降维的必要性及目的">2.15.6 降维的必要性及目的</h3>
<p><strong>降维的必要性</strong>：</p>
<ol>
<li>多重共线性和预测变量之间相互关联。多重共线性会导致解空间的不稳定，从而可能导致结果的不连贯。</li>
<li>高维空间本身具有稀疏性。一维正态分布有68%的值落于正负标准差之间，而在十维空间上只有2%。</li>
<li>过多的变量，对查找规律造成冗余麻烦。</li>
<li>仅在变量层面上分析可能会忽略变量之间的潜在联系。例如几个预测变量可能落入仅反映数据某一方面特征的一个组内。</li>
</ol>
<p><strong>降维的目的</strong>：</p>
<ol>
<li>减少预测变量的个数。</li>
<li>确保这些变量是相互独立的。</li>
<li>提供一个框架来解释结果。相关特征，特别是重要特征更能在数据中明确的显示出来；如果只有两维或者三维的话，更便于可视化展示。</li>
<li>数据在低维下更容易处理、更容易使用。</li>
<li>去除数据噪声。</li>
<li>降低算法运算开销。</li>
</ol>
<h3 id="2-15-7-KPCA与PCA的区别">2.15.7 KPCA与PCA的区别</h3>
<p>​	应用PCA算法前提是假设存在一个线性超平面，进而投影。那如果数据不是线性的呢？该怎么办？这时候就需要KPCA，数据集从  $n$  维映射到线性可分的高维  $N >n$ ，然后再从  $N$  维降维到一个低维度  $n'(n'<n<N)$ 。< p>
<p>​	KPCA用到了核函数思想，使用了核函数的主成分分析一般称为核主成分分析(Kernelized PCA, 简称KPCA）。</p>
<p>假设高维空间数据由  $n​$  维空间的数据通过映射  $\phi​$  产生。</p>
<p>​	 $n$  维空间的特征分解为：</p>
 $$
\sum^m_{i=1} x^{(i)} \left( x^{(i)} \right)^T W = \lambda W
$$ 
<p>​	其映射为</p>
 $$
\sum^m_{i=1} \phi \left( x^{(i)} \right) \phi \left( x^{(i)} \right)^T W = \lambda W
$$ 
<p>​	通过在高维空间进行协方差矩阵的特征值分解，然后用和PCA一样的方法进行降维。由于KPCA需要核函数的运算，因此它的计算量要比PCA大很多。</p>
<h2 id="2-16-模型评估">2.16 模型评估</h2>
<h3 id="2-16-1-模型评估常用方法？">2.16.1 模型评估常用方法？</h3>
<p>​	一般情况来说，单一评分标准无法完全评估一个机器学习模型。只用good和bad偏离真实场景去评估某个模型，都是一种欠妥的评估方式。下面介绍常用的分类模型和回归模型评估方法。</p>
<p><strong>分类模型常用评估方法：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">指标</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Accuracy</td>
<td style="text-align:center">准确率</td>
</tr>
<tr>
<td style="text-align:center">Precision</td>
<td style="text-align:center">精准度/查准率</td>
</tr>
<tr>
<td style="text-align:center">Recall</td>
<td style="text-align:center">召回率/查全率</td>
</tr>
<tr>
<td style="text-align:center">P-R曲线</td>
<td style="text-align:center">查准率为纵轴，查全率为横轴，作图</td>
</tr>
<tr>
<td style="text-align:center">F1</td>
<td style="text-align:center">F1值</td>
</tr>
<tr>
<td style="text-align:center">Confusion Matrix</td>
<td style="text-align:center">混淆矩阵</td>
</tr>
<tr>
<td style="text-align:center">ROC</td>
<td style="text-align:center">ROC曲线</td>
</tr>
<tr>
<td style="text-align:center">AUC</td>
<td style="text-align:center">ROC曲线下的面积</td>
</tr>
</tbody>
</table>
<p><strong>回归模型常用评估方法：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">指标</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Mean Square Error (MSE, RMSE)</td>
<td style="text-align:center">平均方差</td>
</tr>
<tr>
<td style="text-align:center">Absolute Error (MAE, RAE)</td>
<td style="text-align:center">绝对误差</td>
</tr>
<tr>
<td style="text-align:center">R-Squared</td>
<td style="text-align:center">R平方值</td>
</tr>
</tbody>
</table>
<h3 id="2-16-2-误差、偏差和方差有什么区别和联系">2.16.2 误差、偏差和方差有什么区别和联系</h3>
<p>在机器学习中，Bias(偏差)，Error(误差)，和Variance(方差)存在以下区别和联系：</p>
<p>**对于Error **：</p>
<ul>
<li>
<p>误差（error）：一般地，我们把学习器的实际预测输出与样本的真是输出之间的差异称为“误差”。</p>
</li>
<li>
<p>Error = Bias + Variance + Noise，Error反映的是整个模型的准确度。</p>
</li>
</ul>
<p><strong>对于Noise:</strong></p>
<p>噪声：描述了在当前任务上任何学习算法所能达到的期望泛化误差的下界，即刻画了学习问题本身的难度。</p>
<p><strong>对于Bias：</strong></p>
<ul>
<li>Bias衡量模型拟合训练数据的能力（训练数据不一定是整个 training dataset，而是只用于训练它的那一部分数据，例如：mini-batch），Bias反映的是模型在样本上的输出与真实值之间的误差，即模型本身的精准度。</li>
<li>Bias 越小，拟合能力越高（可能产生overfitting）；反之，拟合能力越低（可能产生underfitting）。</li>
<li>偏差越大，越偏离真实数据，如下图第二行所示。</li>
</ul>
<p><strong>对于Variance：</strong></p>
<ul>
<li>
<p>方差公式： $S_{N}^{2}=\frac{1}{N}\sum_{i=1}^{N}(x_{i}-\bar{x})^{2}$</p>
</li>
<li>
<p>Variance描述的是预测值的变化范围，离散程度，也就是离其期望值的距离。方差越大，数据的分布越分散，模型的稳定程度越差。</p>
</li>
<li>
<p>Variance反映的是模型每一次输出结果与模型输出期望之间的误差，即模型的稳定性。</p>
</li>
<li>
<p>Variance越小，模型的泛化的能力越高；反之，模型的泛化的能力越低。</p>
</li>
<li>
<p>如果模型在训练集上拟合效果比较优秀，但是在测试集上拟合效果比较差劣，则方差较大，说明模型的稳定程度较差，出现这种现象可能是由于模型对训练集过拟合造成的。 如下图右列所示。</p>
</li>
</ul>
<blockquote>
<p><img src="2.16.20.1.png" alt></p>
</blockquote>
<h3 id="2-16-3-经验误差与泛化误差">2.16.3 经验误差与泛化误差</h3>
<p>经验误差（empirical error）：也叫训练误差（training error），模型在训练集上的误差。</p>
<p>泛化误差（generalization error）：模型在新样本集（测试集）上的误差称为“泛化误差”。</p>
<h3 id="2-16-4-图解欠拟合、过拟合">2.16.4 图解欠拟合、过拟合</h3>
<p>根据不同的坐标方式，欠拟合与过拟合图解不同。</p>
<ol>
<li><strong>横轴为训练样本数量，纵轴为误差</strong></li>
</ol>
<p><img src="2.16.4.1.jpg" alt></p>
<p>如上图所示，我们可以直观看出欠拟合和过拟合的区别：</p>
<p>​	模型欠拟合：在训练集以及测试集上同时具有较高的误差，此时模型的偏差较大；</p>
<p>​	模型过拟合：在训练集上具有较低的误差，在测试集上具有较高的误差，此时模型的方差较大。</p>
<p>​	模型正常：在训练集以及测试集上，同时具有相对较低的偏差以及方差。</p>
<ol start="2">
<li><strong>横轴为模型复杂程度，纵轴为误差</strong></li>
</ol>
<p><img src="2.16.4.2.png" alt></p>
<p>​					红线为测试集上的Error,蓝线为训练集上的Error</p>
<p>​	模型欠拟合：模型在点A处，在训练集以及测试集上同时具有较高的误差，此时模型的偏差较大。</p>
<p>​	模型过拟合：模型在点C处，在训练集上具有较低的误差，在测试集上具有较高的误差，此时模型的方差较大。</p>
<p>​	模型正常：模型复杂程度控制在点B处为最优。</p>
<ol start="3">
<li><strong>横轴为正则项系数，纵轴为误差</strong></li>
</ol>
<p><img src="2.16.4.3.png" alt></p>
<p>​                                             红线为测试集上的Error,蓝线为训练集上的Error</p>
<p>​	模型欠拟合：模型在点C处，在训练集以及测试集上同时具有较高的误差，此时模型的偏差较大。</p>
<p>​	模型过拟合：模型在点A处，在训练集上具有较低的误差，在测试集上具有较高的误差，此时模型的方差较大。 它通常发生在模型过于复杂的情况下，如参数过多等，会使得模型的预测性能变弱，并且增加数据的波动性。虽然模型在训练时的效果可以表现的很完美，基本上记住了数据的全部特点，但这种模型在未知数据的表现能力会大减折扣，因为简单的模型泛化能力通常都是很弱的。</p>
<p>​	模型正常：模型复杂程度控制在点B处为最优。</p>
<h3 id="2-16-5-如何解决过拟合与欠拟合">2.16.5 如何解决过拟合与欠拟合</h3>
<p><strong>如何解决欠拟合：</strong></p>
<ol>
<li>添加其他特征项。组合、泛化、相关性、上下文特征、平台特征等特征是特征添加的重要手段，有时候特征项不够会导致模型欠拟合。</li>
<li>添加多项式特征。例如将线性模型添加二次项或三次项使模型泛化能力更强。例如，FM（Factorization Machine）模型、FFM（Field-aware Factorization Machine）模型，其实就是线性模型，增加了二阶多项式，保证了模型一定的拟合程度。</li>
<li>可以增加模型的复杂程度。</li>
<li>减小正则化系数。正则化的目的是用来防止过拟合的，但是现在模型出现了欠拟合，则需要减少正则化参数。</li>
</ol>
<p><strong>如何解决过拟合：</strong></p>
<ol>
<li>重新清洗数据，数据不纯会导致过拟合，此类情况需要重新清洗数据。</li>
<li>增加训练样本数量。</li>
<li>降低模型复杂程度。</li>
<li>增大正则项系数。</li>
<li>采用dropout方法，dropout方法，通俗的讲就是在训练的时候让神经元以一定的概率不工作。</li>
<li>early stopping。</li>
<li>减少迭代次数。</li>
<li>增大学习率。</li>
<li>添加噪声数据。</li>
<li>树结构中，可以对树进行剪枝。</li>
<li>减少特征项。</li>
</ol>
<p>欠拟合和过拟合这些方法，需要根据实际问题，实际模型，进行选择。</p>
<h3 id="2-16-6-交叉验证的主要作用">2.16.6 交叉验证的主要作用</h3>
<p>​	为了得到更为稳健可靠的模型，对模型的泛化误差进行评估，得到模型泛化误差的近似值。当有多个模型可以选择时，我们通常选择“泛化误差”最小的模型。</p>
<p>​	交叉验证的方法有许多种，但是最常用的是：留一交叉验证、k折交叉验证。</p>
<h3 id="2-16-7-理解k折交叉验证">2.16.7 理解k折交叉验证</h3>
<ol>
<li>将含有N个样本的数据集，分成K份，每份含有N/K个样本。选择其中1份作为测试集，另外K-1份作为训练集，测试集就有K种情况。</li>
<li>在每种情况中，用训练集训练模型，用测试集测试模型，计算模型的泛化误差。</li>
<li>交叉验证重复K次，每份验证一次，平均K次的结果或者使用其它结合方式，最终得到一个单一估测，得到模型最终的泛化误差。</li>
<li>将K种情况下，模型的泛化误差取均值，得到模型最终的泛化误差。</li>
<li>一般 $2\leqslant K \leqslant10$ 。 k折交叉验证的优势在于，同时重复运用随机产生的子样本进行训练和验证，每次的结果验证一次，10折交叉验证是最常用的。</li>
<li>训练集中样本数量要足够多，一般至少大于总样本数的50%。</li>
<li>训练集和测试集必须从完整的数据集中均匀取样。均匀取样的目的是希望减少训练集、测试集与原数据集之间的偏差。当样本数量足够多时，通过随机取样，便可以实现均匀取样的效果。</li>
</ol>
<h3 id="2-16-8-混淆矩阵">2.16.8 混淆矩阵</h3>
<p>第一种混淆矩阵:</p>
<table>
<thead>
<tr>
<th style="text-align:center">真实情况T or F</th>
<th style="text-align:left">预测为正例1，P</th>
<th style="text-align:left">预测为负例0，N</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">本来label标记为1，预测结果真为T、假为F</td>
<td style="text-align:left">TP(预测为1，实际为1)</td>
<td style="text-align:left">FN(预测为0，实际为1)</td>
</tr>
<tr>
<td style="text-align:center">本来label标记为0，预测结果真为T、假为F</td>
<td style="text-align:left">FP(预测为1，实际为0)</td>
<td style="text-align:left">TN(预测为0，实际也为0)</td>
</tr>
</tbody>
</table>
<p>第二种混淆矩阵:</p>
<table>
<thead>
<tr>
<th style="text-align:center">预测情况P or N</th>
<th style="text-align:left">实际label为1,预测对了为T</th>
<th style="text-align:left">实际label为0,预测对了为T</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">预测为正例1，P</td>
<td style="text-align:left">TP(预测为1，实际为1)</td>
<td style="text-align:left">FP(预测为1，实际为0)</td>
</tr>
<tr>
<td style="text-align:center">预测为负例0，N</td>
<td style="text-align:left">FN(预测为0，实际为1)</td>
<td style="text-align:left">TN(预测为0，实际也为0)</td>
</tr>
</tbody>
</table>
<h3 id="2-16-9-错误率及精度">2.16.9 错误率及精度</h3>
<ol>
<li>错误率（Error Rate）：分类错误的样本数占样本总数的比例。</li>
<li>精度（accuracy）：分类正确的样本数占样本总数的比例。</li>
</ol>
<h3 id="2-16-10-查准率与查全率">2.16.10 查准率与查全率</h3>
<p>将算法预测的结果分成四种情况：</p>
<ol>
<li>正确肯定（True Positive,TP）：预测为真，实际为真</li>
<li>正确否定（True Negative,TN）：预测为假，实际为假</li>
<li>错误肯定（False Positive,FP）：预测为真，实际为假</li>
<li>错误否定（False Negative,FN）：预测为假，实际为真</li>
</ol>
<p>则：</p>
<p>查准率（Precision）=TP/（TP+FP）</p>
<p><strong>理解</strong>：预测出为阳性的样本中，正确的有多少。区别准确率（正确预测出的样本，包括正确预测为阳性、阴性，占总样本比例）。<br>
例，在所有我们预测有恶性肿瘤的病人中，实际上有恶性肿瘤的病人的百分比，越高越好。</p>
<p>查全率（Recall）=TP/（TP+FN）</p>
<p><strong>理解</strong>：正确预测为阳性的数量占总样本中阳性数量的比例。<br>
例，在所有实际上有恶性肿瘤的病人中，成功预测有恶性肿瘤的病人的百分比，越高越好。</p>
<h3 id="2-16-11-ROC与AUC">2.16.11 ROC与AUC</h3>
<p>​	ROC全称是“受试者工作特征”（Receiver Operating Characteristic）。</p>
<p>​	ROC曲线的面积就是AUC（Area Under Curve）。</p>
<p>​	AUC用于衡量“二分类问题”机器学习算法性能（泛化能力）。</p>
<p>​	ROC曲线，通过将连续变量设定出多个不同的临界值，从而计算出一系列真正率和假正率，再以假正率为横坐标、真正率为纵坐标绘制成曲线，曲线下面积越大，推断准确性越高。在ROC曲线上，最靠近坐标图左上方的点为假正率和真正率均较高的临界值。</p>
<p>​	对于分类器，或者说分类算法，评价指标主要有Precision，Recall，F-score。下图是一个ROC曲线的示例。</p>
<p><img src="2.40.10/1.png" alt></p>
<p>ROC曲线的横坐标为False Positive Rate（FPR），纵坐标为True Positive Rate（TPR）。其中</p>
 $$
TPR = \frac{TP}{TP+FN} ,FPR = \frac{FP}{FP+TN}
$$ 
<p>​	下面着重介绍ROC曲线图中的四个点和一条线。<br>
​	第一个点(0,1)，即FPR=0, TPR=1，这意味着FN（False Negative）=0，并且FP（False Positive）=0。意味着这是一个完美的分类器，它将所有的样本都正确分类。<br>
​	第二个点(1,0)，即FPR=1，TPR=0，意味着这是一个最糟糕的分类器，因为它成功避开了所有的正确答案。<br>
​	第三个点(0,0)，即FPR=TPR=0，即FP（False Positive）=TP（True Positive）=0，可以发现该分类器预测所有的样本都为负样本（Negative）。<br>
​	第四个点(1,1)，即FPR=TPR=1，分类器实际上预测所有的样本都为正样本。<br>
​	经过以上分析，ROC曲线越接近左上角，该分类器的性能越好。</p>
<p>​	ROC曲线所覆盖的面积称为AUC（Area Under Curve），可以更直观的判断学习器的性能，AUC越大则性能越好。</p>
<h3 id="2-16-12-如何画ROC曲线">2.16.12 如何画ROC曲线</h3>
<p>​	下图是一个示例，图中共有20个测试样本，“Class”一栏表示每个测试样本真正的标签（p表示正样本，n表示负样本），“Score”表示每个测试样本属于正样本的概率。</p>
<p>步骤：<br>
1、假设已经得出一系列样本被划分为正类的概率，按照大小排序。<br>
2、从高到低，依次将“Score”值作为阈值threshold，当测试样本属于正样本的概率大于或等于这个threshold时，我们认为它为正样本，否则为负样本。举例来说，对于图中的第4个样本，其“Score”值为0.6，那么样本1，2，3，4都被认为是正样本，因为它们的“Score”值都大于等于0.6，而其他样本则都认为是负样本。<br>
3、每次选取一个不同的threshold，得到一组FPR和TPR，即ROC曲线上的一点。以此共得到20组FPR和TPR的值。<br>
4、根据3、中的每个坐标点，画图。</p>
<p><img src="2.40.11/1.jpg" alt></p>
<h3 id="2-16-13-如何计算TPR，FPR">2.16.13 如何计算TPR，FPR</h3>
<p>1、分析数据<br>
y_true = [0, 0, 1, 1]；scores = [0.1, 0.4, 0.35, 0.8]；<br>
2、列表</p>
<table>
<thead>
<tr>
<th>样本</th>
<th>预测属于P的概率(score)</th>
<th>真实类别</th>
</tr>
</thead>
<tbody>
<tr>
<td>y[0]</td>
<td>0.1</td>
<td>N</td>
</tr>
<tr>
<td>y[1]</td>
<td>0.4</td>
<td>N</td>
</tr>
<tr>
<td>y[2]</td>
<td>0.35</td>
<td>P</td>
</tr>
<tr>
<td>y[3]</td>
<td>0.8</td>
<td>P</td>
</tr>
</tbody>
</table>
<p>3、将截断点依次取为score值，计算TPR和FPR。<br>
当截断点为0.1时：<br>
说明只要score&gt;=0.1，它的预测类别就是正例。 因为4个样本的score都大于等于0.1，所以，所有样本的预测类别都为P。<br>
scores = [0.1, 0.4, 0.35, 0.8]；y_true = [0, 0, 1, 1]；y_pred = [1, 1, 1, 1]；<br>
正例与反例信息如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>正例</th>
<th>反例</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>正例</strong></td>
<td>TP=2</td>
<td>FN=0</td>
</tr>
<tr>
<td><strong>反例</strong></td>
<td>FP=2</td>
<td>TN=0</td>
</tr>
</tbody>
</table>
<p>由此可得：<br>
TPR = TP/(TP+FN) = 1； FPR = FP/(TN+FP) = 1；</p>
<p>当截断点为0.35时：<br>
scores = [0.1, 0.4, 0.35, 0.8]；y_true = [0, 0, 1, 1]；y_pred = [0, 1, 1, 1];<br>
正例与反例信息如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>正例</th>
<th>反例</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>正例</strong></td>
<td>TP=2</td>
<td>FN=0</td>
</tr>
<tr>
<td><strong>反例</strong></td>
<td>FP=1</td>
<td>TN=1</td>
</tr>
</tbody>
</table>
<p>由此可得：<br>
TPR = TP/(TP+FN) = 1； FPR = FP/(TN+FP) = 0.5；</p>
<p>当截断点为0.4时：<br>
scores = [0.1, 0.4, 0.35, 0.8]；y_true = [0, 0, 1, 1]；y_pred = [0, 1, 0, 1]；<br>
正例与反例信息如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>正例</th>
<th>反例</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>正例</strong></td>
<td>TP=1</td>
<td>FN=1</td>
</tr>
<tr>
<td><strong>反例</strong></td>
<td>FP=1</td>
<td>TN=1</td>
</tr>
</tbody>
</table>
<p>由此可得：<br>
TPR = TP/(TP+FN) = 0.5； FPR = FP/(TN+FP) = 0.5；</p>
<p>当截断点为0.8时：<br>
scores = [0.1, 0.4, 0.35, 0.8]；y_true = [0, 0, 1, 1]；y_pred = [0, 0, 0, 1]；</p>
<p>正例与反例信息如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>正例</th>
<th>反例</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>正例</strong></td>
<td>TP=1</td>
<td>FN=1</td>
</tr>
<tr>
<td><strong>反例</strong></td>
<td>FP=0</td>
<td>TN=2</td>
</tr>
</tbody>
</table>
<p>由此可得：<br>
TPR = TP/(TP+FN) = 0.5； FPR = FP/(TN+FP) = 0；</p>
<p>4、根据TPR、FPR值，以FPR为横轴，TPR为纵轴画图。</p>
<h3 id="2-16-14-如何计算AUC">2.16.14 如何计算AUC</h3>
<ul>
<li>将坐标点按照横坐标FPR排序 。</li>
<li>计算第 $i$ 个坐标点和第 $i+1$ 个坐标点的间距 $dx$  。</li>
<li>获取第 $i$ 或者 $i+1$ 个坐标点的纵坐标y。</li>
<li>计算面积微元 $ds=ydx$ 。</li>
<li>对面积微元进行累加，得到AUC。</li>
</ul>
<h3 id="2-16-15-为什么使用Roc和Auc评价分类器">2.16.15 为什么使用Roc和Auc评价分类器</h3>
<p>​	模型有很多评估方法，为什么还要使用ROC和AUC呢？<br>
​	因为ROC曲线有个很好的特性：当测试集中的正负样本的分布变换的时候，ROC曲线能够保持不变。在实际的数据集中经常会出现样本类不平衡，即正负样本比例差距较大，而且测试数据中的正负样本也可能随着时间变化。</p>
<h3 id="2-16-16-直观理解AUC">2.16.16 直观理解AUC</h3>
<p>​	下图展现了三种AUC的值：</p>
<p><img src="2.40.15/1.png" alt></p>
<p>​	AUC是衡量二分类模型优劣的一种评价指标，表示正例排在负例前面的概率。其他评价指标有精确度、准确率、召回率，而AUC比这三者更为常用。<br>
​	一般在分类模型中，预测结果都是以概率的形式表现，如果要计算准确率，通常都会手动设置一个阈值来将对应的概率转化成类别，这个阈值也就很大程度上影响了模型准确率的计算。<br>
​	举例：<br>
​	现在假设有一个训练好的二分类器对10个正负样本（正例5个，负例5个）预测，得分按高到低排序得到的最好预测结果为[1, 1, 1, 1, 1, 0, 0, 0, 0, 0]，即5个正例均排在5个负例前面，正例排在负例前面的概率为100%。然后绘制其ROC曲线，由于是10个样本，除去原点我们需要描10个点，如下：</p>
<p><img src="2.16.17-1.png" alt></p>
<p>​	描点方式按照样本预测结果的得分高低从左至右开始遍历。从原点开始，每遇到1便向y轴正方向移动y轴最小步长1个单位，这里是1/5=0.2；每遇到0则向x轴正方向移动x轴最小步长1个单位，这里也是0.2。不难看出，上图的AUC等于1，印证了正例排在负例前面的概率的确为100%。</p>
<p>​	假设预测结果序列为[1, 1, 1, 1, 0, 1, 0, 0, 0, 0]。</p>
<p><img src="2.16.17-2.png" alt></p>
<p>​	计算上图的AUC为0.96与计算正例与排在负例前面的概率0.8 × 1 + 0.2 × 0.8 = 0.96相等，而左上角阴影部分的面积则是负例排在正例前面的概率0.2 × 0.2 = 0.04。</p>
<p>​	假设预测结果序列为[1, 1, 1, 0, 1, 0, 1, 0, 0, 0]。</p>
<p><img src="2.16.17-3.png" alt></p>
<p>​	计算上图的AUC为0.88与计算正例与排在负例前面的概率0.6 × 1 + 0.2 × 0.8 + 0.2 × 0.6 = 0.88相等，左上角阴影部分的面积是负例排在正例前面的概率0.2 × 0.2 × 3 = 0.12。</p>
<h3 id="2-16-17-代价敏感错误率与代价曲线">2.16.17 代价敏感错误率与代价曲线</h3>
<p>不同的错误会产生不同代价。以二分法为例，设置代价矩阵如下：</p>
<p><img src="2-1.png" alt></p>
<p>当判断正确的时候，值为0，不正确的时候，分别为 $Cost_{01}​$ 和 $Cost_{10}​$  。</p>
 $Cost_{10}$ :表示实际为反例但预测成正例的代价。
 $Cost_{01}$ :表示实际为正例但是预测为反例的代价。
<p><strong>代价敏感错误率</strong>=样本中由模型得到的错误值与代价乘积之和 / 总样本。<br>
其数学表达式为：</p>
 $$
E(f;D;cost)=\frac{1}{m}\left( \sum_{x_{i} \in D^{+}}({f(x_i)\neq y_i})\times Cost_{01}+ \sum_{x_{i} \in D^{-}}({f(x_i)\neq y_i})\times Cost_{10}\right)
$$ 
 $D^{+}、D^{-}​$ 分别代表样例集的正例子集和反例子集，x是预测值，y是真实值。
<p><strong>代价曲线</strong>：<br>
在均等代价时，ROC曲线不能直接反应出模型的期望总体代价，而代价曲线可以。<br>
代价曲线横轴为[0,1]的正例函数代价：</p>
 $$
P(+)Cost=\frac{p*Cost_{01}}{p*Cost_{01}+(1-p)*Cost_{10}}
$$ 
<p>其中p是样本为正例的概率。</p>
<p>代价曲线纵轴维[0,1]的归一化代价：</p>
 $$
Cost_{norm}=\frac{FNR*p*Cost_{01}+FNR*(1-p)*Cost_{10}}{p*Cost_{01}+(1-p)*Cost_{10}}
$$ 
<p>其中FPR为假阳率，FNR=1-TPR为假阴率。</p>
<p>注：ROC每个点，对应代价平面上一条线。</p>
<p>例如，ROC上(TPR,FPR),计算出FNR=1-TPR，在代价平面上绘制一条从(0,FPR)到(1,FNR)的线段，面积则为该条件下期望的总体代价。所有线段下界面积，所有条件下学习器的期望总体代价。</p>
<p><img src="2.16.18.1.png" alt></p>
<h3 id="2-16-18-模型有哪些比较检验方法">2.16.18 模型有哪些比较检验方法</h3>
<p>正确性分析：模型稳定性分析，稳健性分析，收敛性分析，变化趋势分析，极值分析等。<br>
有效性分析：误差分析，参数敏感性分析，模型对比检验等。<br>
有用性分析：关键数据求解，极值点，拐点，变化趋势分析，用数据验证动态模拟等。<br>
高效性分析：时空复杂度分析与现有进行比较等。</p>
<h3 id="2-16-19-为什么使用标准差">2.16.19 为什么使用标准差</h3>
<p>方差公式为： $S^2_{N}=\frac{1}{N}\sum_{i=1}^{N}(x_{i}-\bar{x})^{2}​$</p>
<p>标准差公式为： $S_{N}=\sqrt{\frac{1}{N}\sum_{i=1}^{N}(x_{i}-\bar{x})^{2}}​$</p>
<p>样本标准差公式为： $S_{N}=\sqrt{\frac{1}{N-1}\sum_{i=1}^{N}(x_{i}-\bar{x})^{2}}​$</p>
<p>与方差相比，使用标准差来表示数据点的离散程度有3个好处：<br>
1、表示离散程度的数字与样本数据点的数量级一致，更适合对数据样本形成感性认知。</p>
<p>2、表示离散程度的数字单位与样本数据的单位一致，更方便做后续的分析运算。</p>
<p>3、在样本数据大致符合正态分布的情况下，标准差具有方便估算的特性：68%的数据点落在平均值前后1个标准差的范围内、95%的数据点落在平均值前后2个标准差的范围内，而99%的数据点将会落在平均值前后3个标准差的范围内。</p>
<h3 id="2-16-20-类别不平衡产生原因">2.16.20 类别不平衡产生原因</h3>
<p>​	类别不平衡（class-imbalance）是指分类任务中不同类别的训练样例数目差别很大的情况。</p>
<p>产生原因：</p>
<p>​	分类学习算法通常都会假设不同类别的训练样例数目基本相同。如果不同类别的训练样例数目差别很大，则会影响学习结果，测试结果变差。例如二分类问题中有998个反例，正例有2个，那学习方法只需返回一个永远将新样本预测为反例的分类器，就能达到99.8%的精度；然而这样的分类器没有价值。</p>
<h3 id="2-16-21-常见的类别不平衡问题解决方法">2.16.21 常见的类别不平衡问题解决方法</h3>
<p>防止类别不平衡对学习造成的影响，在构建分类模型之前，需要对分类不平衡性问题进行处理。主要解决方法有：</p>
<p>1、扩大数据集</p>
<p>​	增加包含小类样本数据的数据，更多的数据能得到更多的分布信息。</p>
<p>2、对大类数据欠采样</p>
<p>​	减少大类数据样本个数，使与小样本个数接近。<br>
​	缺点：欠采样操作时若随机丢弃大类样本，可能会丢失重要信息。<br>
​	代表算法：EasyEnsemble。其思想是利用集成学习机制，将大类划分为若干个集合供不同的学习器使用。相当于对每个学习器都进行欠采样，但对于全局则不会丢失重要信息。</p>
<p>3、对小类数据过采样</p>
<p>​	过采样：对小类的数据样本进行采样来增加小类的数据样本个数。</p>
<p>​	代表算法：SMOTE和ADASYN。</p>
<p>​	SMOTE：通过对训练集中的小类数据进行插值来产生额外的小类样本数据。</p>
<p>​	新的少数类样本产生的策略：对每个少数类样本a，在a的最近邻中随机选一个样本b，然后在a、b之间的连线上随机选一点作为新合成的少数类样本。 	<br>
​	ADASYN：根据学习难度的不同，对不同的少数类别的样本使用加权分布，对于难以学习的少数类的样本，产生更多的综合数据。 通过减少类不平衡引入的偏差和将分类决策边界自适应地转移到困难的样本两种手段，改善了数据分布。</p>
<p>4、使用新评价指标</p>
<p>​	如果当前评价指标不适用，则应寻找其他具有说服力的评价指标。比如准确度这个评价指标在类别不均衡的分类任务中并不适用，甚至进行误导。因此在类别不均衡分类任务中，需要使用更有说服力的评价指标来对分类器进行评价。</p>
<p>5、选择新算法</p>
<p>​	不同的算法适用于不同的任务与数据，应该使用不同的算法进行比较。</p>
<p>6、数据代价加权</p>
<p>​	例如当分类任务是识别小类，那么可以对分类器的小类样本数据增加权值，降低大类样本的权值，从而使得分类器将重点集中在小类样本身上。</p>
<p>7、转化问题思考角度</p>
<p>​	例如在分类问题时，把小类的样本作为异常点，将问题转化为异常点检测或变化趋势检测问题。 异常点检测即是对那些罕见事件进行识别。变化趋势检测区别于异常点检测在于其通过检测不寻常的变化趋势来识别。</p>
<p>8、将问题细化分析</p>
<p>​	对问题进行分析与挖掘，将问题划分成多个更小的问题，看这些小问题是否更容易解决。</p>
<h2 id="2-17-决策树">2.17 决策树</h2>
<h3 id="2-17-1-决策树的基本原理">2.17.1 决策树的基本原理</h3>
<p>​	决策树（Decision Tree）是一种分而治之的决策过程。一个困难的预测问题，通过树的分支节点，被划分成两个或多个较为简单的子集，从结构上划分为不同的子问题。将依规则分割数据集的过程不断递归下去（Recursive Partitioning）。随着树的深度不断增加，分支节点的子集越来越小，所需要提的问题数也逐渐简化。当分支节点的深度或者问题的简单程度满足一定的停止规则（Stopping Rule）时, 该分支节点会停止分裂，此为自上而下的停止阈值（Cutoff Threshold）法；有些决策树也使用自下而上的剪枝（Pruning）法。</p>
<h3 id="2-17-2-决策树的三要素？">2.17.2 决策树的三要素？</h3>
<p>​	一棵决策树的生成过程主要分为下3个部分：</p>
<p>​	1、特征选择：从训练数据中众多的特征中选择一个特征作为当前节点的分裂标准，如何选择特征有着很多不同量化评估标准，从而衍生出不同的决策树算法。</p>
<p>​	2、决策树生成：根据选择的特征评估标准，从上至下递归地生成子节点，直到数据集不可分则决策树停止生长。树结构来说，递归结构是最容易理解的方式。</p>
<p>​	3、剪枝：决策树容易过拟合，一般来需要剪枝，缩小树结构规模、缓解过拟合。剪枝技术有预剪枝和后剪枝两种。</p>
<h3 id="2-17-3-决策树学习基本算法">2.17.3 决策树学习基本算法</h3>
<p><img src="2-5.png" alt></p>
<h3 id="2-17-4-决策树算法优缺点">2.17.4 决策树算法优缺点</h3>
<p><strong>决策树算法的优点</strong>：</p>
<p>1、决策树算法易理解，机理解释起来简单。</p>
<p>2、决策树算法可以用于小数据集。</p>
<p>3、决策树算法的时间复杂度较小，为用于训练决策树的数据点的对数。</p>
<p>4、相比于其他算法智能分析一种类型变量，决策树算法可处理数字和数据的类别。</p>
<p>5、能够处理多输出的问题。</p>
<p>6、对缺失值不敏感。</p>
<p>7、可以处理不相关特征数据。</p>
<p>8、效率高，决策树只需要一次构建，反复使用，每一次预测的最大计算次数不超过决策树的深度。</p>
<p><strong>决策树算法的缺点</strong>：</p>
<p>1、对连续性的字段比较难预测。</p>
<p>2、容易出现过拟合。</p>
<p>3、当类别太多时，错误可能就会增加的比较快。</p>
<p>4、在处理特征关联性比较强的数据时表现得不是太好。</p>
<p>5、对于各类别样本数量不一致的数据，在决策树当中，信息增益的结果偏向于那些具有更多数值的特征。</p>
<h3 id="2-17-5-熵的概念以及理解">2.17.5 熵的概念以及理解</h3>
<p>​	熵：度量随机变量的不确定性。<br>
​	定义：假设随机变量X的可能取值有 $x_{1},x_{2},...,x_{n}$ ，对于每一个可能的取值 $x_{i}$ ，其概率为 $P(X=x_{i})=p_{i},i=1,2...,n$ 。随机变量的熵为：</p>
 $$
H(X)=-\sum_{i=1}^{n}p_{i}log_{2}p_{i}
$$ 
<p>​       对于样本集合，假设样本有k个类别，每个类别的概率为 $\frac{|C_{k}|}{|D|}$ ，其中  ${|C_{k}|}{|D|}$ 为类别为k的样本个数， $|D|​$ 为样本总数。样本集合D的熵为：</p>
 $$
H(D)=-\sum_{k=1}^{k}\frac{|C_{k}|}{|D|}log_{2}\frac{|C_{k}|}{|D|}
$$ 
<h3 id="2-17-6-信息增益的理解">2.17.6 信息增益的理解</h3>
<p>​	定义：以某特征划分数据集前后的熵的差值。<br>
​	熵可以表示样本集合的不确定性，熵越大，样本的不确定性就越大。因此可以使用划分前后集合熵的差值来衡量使用当前特征对于样本集合D划分效果的好坏。  ​	假设划分前样本集合D的熵为H(D)。使用某个特征A划分数据集D，计算划分后的数据子集的熵为H(D|A)。<br>
​	则信息增益为：</p>
 $$
g(D,A)=H(D)-H(D|A)
$$ 
<p>​	*注：*在决策树构建的过程中我们总是希望集合往最快到达纯度更高的子集合方向发展，因此我们总是选择使得信息增益最大的特征来划分当前数据集D。<br>
​	思想：计算所有特征划分数据集D，得到多个特征划分数据集D的信息增益，从这些信息增益中选择最大的，因而当前结点的划分特征便是使信息增益最大的划分所使用的特征。<br>
​	另外这里提一下信息增益比相关知识：<br>
​	 $信息增益比=惩罚参数\times信息增益$<br>
​	信息增益比本质：在信息增益的基础之上乘上一个惩罚参数。特征个数较多时，惩罚参数较小；特征个数较少时，惩罚参数较大。<br>
​	惩罚参数：数据集D以特征A作为随机变量的熵的倒数。</p>
<h3 id="2-17-7-剪枝处理的作用及策略">2.17.7 剪枝处理的作用及策略</h3>
<p>​	剪枝处理是决策树学习算法用来解决过拟合问题的一种办法。</p>
<p>​	在决策树算法中，为了尽可能正确分类训练样本， 节点划分过程不断重复， 有时候会造成决策树分支过多，以至于将训练样本集自身特点当作泛化特点， 而导致过拟合。 因此可以采用剪枝处理来去掉一些分支来降低过拟合的风险。</p>
<p>​	剪枝的基本策略有预剪枝（pre-pruning）和后剪枝（post-pruning）。</p>
<p>​	预剪枝：在决策树生成过程中，在每个节点划分前先估计其划分后的泛化性能， 如果不能提升，则停止划分，将当前节点标记为叶结点。</p>
<p>​	后剪枝：生成决策树以后，再自下而上对非叶结点进行考察， 若将此节点标记为叶结点可以带来泛化性能提升，则修改之。</p>
<h2 id="2-18-支持向量机">2.18 支持向量机</h2>
<h3 id="2-18-1-什么是支持向量机">2.18.1 什么是支持向量机</h3>
<p>​	支持向量：在求解的过程中，会发现只根据部分数据就可以确定分类器，这些数据称为支持向量。</p>
<p>​	支持向量机（Support Vector Machine，SVM）：其含义是通过支持向量运算的分类器。</p>
<p>​	在一个二维环境中，其中点R，S，G点和其它靠近中间黑线的点可以看作为支持向量，它们可以决定分类器，即黑线的具体参数。</p>
<p><img src="2-6.png" alt></p>
<p>​	支持向量机是一种二分类模型，它的目的是寻找一个超平面来对样本进行分割，分割的原则是边界最大化，最终转化为一个凸二次规划问题来求解。由简至繁的模型包括：</p>
<p>​	当训练样本线性可分时，通过硬边界（hard margin）最大化，学习一个线性可分支持向量机；</p>
<p>​	当训练样本近似线性可分时，通过软边界（soft margin）最大化，学习一个线性支持向量机；</p>
<p>​	当训练样本线性不可分时，通过核技巧和软边界最大化，学习一个非线性支持向量机；</p>
<h3 id="2-18-2-支持向量机能解决哪些问题">2.18.2 支持向量机能解决哪些问题</h3>
<p><strong>线性分类</strong></p>
<p>​	在训练数据中，每个数据都有n个的属性和一个二分类类别标志，我们可以认为这些数据在一个n维空间里。我们的目标是找到一个n-1维的超平面，这个超平面可以将数据分成两部分，每部分数据都属于同一个类别。</p>
<p>​	这样的超平面有很多，假如我们要找到一个最佳的超平面。此时，增加一个约束条件：要求这个超平面到每边最近数据点的距离是最大的，成为最大边距超平面。这个分类器即为最大边距分类器。</p>
<p><strong>非线性分类</strong></p>
<p>​	SVM的一个优势是支持非线性分类。它结合使用拉格朗日乘子法（Lagrange Multiplier）和KKT（Karush Kuhn Tucker）条件，以及核函数可以生成非线性分类器。</p>
<h3 id="2-18-3-核函数特点及其作用">2.18.3 核函数特点及其作用</h3>
<p>​	引入核函数目的：把原坐标系里线性不可分的数据用核函数Kernel投影到另一个空间，尽量使得数据在新的空间里线性可分。<br>
​	核函数方法的广泛应用，与其特点是分不开的：</p>
<p>1）核函数的引入避免了“维数灾难”，大大减小了计算量。而输入空间的维数n对核函数矩阵无影响。因此，核函数方法可以有效处理高维输入。</p>
<p>2）无需知道非线性变换函数Φ的形式和参数。</p>
<p>3）核函数的形式和参数的变化会隐式地改变从输入空间到特征空间的映射，进而对特征空间的性质产生影响，最终改变各种核函数方法的性能。</p>
<p>4）核函数方法可以和不同的算法相结合，形成多种不同的基于核函数技术的方法，且这两部分的设计可以单独进行，并可以为不同的应用选择不同的核函数和算法。</p>
<h3 id="2-18-4-SVM为什么引入对偶问题">2.18.4 SVM为什么引入对偶问题</h3>
<p>1，对偶问题将原始问题中的约束转为了对偶问题中的等式约束，对偶问题往往更加容易求解。</p>
<p>2，可以很自然的引用核函数（拉格朗日表达式里面有内积，而核函数也是通过内积进行映射的）。</p>
<p>3，在优化理论中，目标函数 f(x) 会有多种形式：如果目标函数和约束条件都为变量 x 的线性函数，称该问题为线性规划；如果目标函数为二次函数，约束条件为线性函数，称该最优化问题为二次规划；如果目标函数或者约束条件均为非线性函数，称该最优化问题为非线性规划。每个线性规划问题都有一个与之对应的对偶问题，对偶问题有非常良好的性质，以下列举几个：</p>
<p>​	a, 对偶问题的对偶是原问题；</p>
<p>​	b, 无论原始问题是否是凸的，对偶问题都是凸优化问题；</p>
<p>​	c, 对偶问题可以给出原始问题一个下界；</p>
<p>​	d, 当满足一定条件时，原始问题与对偶问题的解是完全等价的。</p>
<h3 id="2-18-5-如何理解SVM中的对偶问题">2.18.5 如何理解SVM中的对偶问题</h3>
<p>在硬边界支持向量机中，问题的求解可以转化为凸二次规划问题。</p>
<p>​	假设优化目标为</p>
 $$
\begin{align}
&\min_{\boldsymbol w, b}\frac{1}{2}||\boldsymbol w||^2\\
&s.t. y_i(\boldsymbol w^T\boldsymbol x_i+b)\geqslant 1, i=1,2,\cdots,m.\\
\end{align}  \tag{1}
$$ 
<p><strong>step 1</strong>. 转化问题：</p>
 $$
\min_{\boldsymbol w, b} \max_{\alpha_i \geqslant 0}  \left\{\frac{1}{2}||\boldsymbol w||^2 + \sum_{i=1}^m\alpha_i(1 - y_i(\boldsymbol w^T\boldsymbol x_i+b))\right\}  \tag{2}
$$ 
<p>上式等价于原问题，因为若满足(1)中不等式约束，则(2)式求max时, $\alpha_i(1 - y_i(\boldsymbol w^T\boldsymbol x_i+b))$ 必须取0，与(1)等价；若不满足(1)中不等式约束，(2)中求max会得到无穷大。 交换min和max获得其对偶问题:</p>
 $$
\max_{\alpha_i \geqslant 0} \min_{\boldsymbol w, b}  \left\{\frac{1}{2}||\boldsymbol w||^2 + \sum_{i=1}^m\alpha_i(1 - y_i(\boldsymbol w^T\boldsymbol x_i+b))\right\}
$$ 
<p>交换之后的对偶问题和原问题并不相等，上式的解小于等于原问题的解。</p>
<p><strong>step 2</strong>.现在的问题是如何找到问题(1) 的最优值的一个最好的下界?</p>
 $$
\frac{1}{2}||\boldsymbol w||^2 < v\\
1 - y_i(\boldsymbol w^T\boldsymbol x_i+b) \leqslant 0\tag{3}
$$ 
<p>若方程组(3)无解， 则v是问题(1)的一个下界。若(3)有解， 则</p>
 $$
\forall \boldsymbol \alpha >  0 , \ \min_{\boldsymbol w, b}  \left\{\frac{1}{2}||\boldsymbol w||^2 + \sum_{i=1}^m\alpha_i(1 - y_i(\boldsymbol w^T\boldsymbol x_i+b))\right\} < v
$$ 
<p>由逆否命题得：若</p>
 $$
\exists \boldsymbol \alpha >  0 , \ \min_{\boldsymbol w, b}  \left\{\frac{1}{2}||\boldsymbol w||^2 + \sum_{i=1}^m\alpha_i(1 - y_i(\boldsymbol w^T\boldsymbol x_i+b))\right\} \geqslant v
$$ 
<p>则(3)无解。</p>
<p>那么v是问题</p>
<p>(1)的一个下界。<br>
要求得一个好的下界，取最大值即可</p>
 $$
\max_{\alpha_i \geqslant 0}  \min_{\boldsymbol w, b} \left\{\frac{1}{2}||\boldsymbol w||^2 + \sum_{i=1}^m\alpha_i(1 - y_i(\boldsymbol w^T\boldsymbol x_i+b))\right\}
$$ 
<p><strong>step 3</strong>. 令</p>
 $$
L(\boldsymbol w, b,\boldsymbol a) =   \frac{1}{2}||\boldsymbol w||^2 + \sum_{i=1}^m\alpha_i(1 - y_i(\boldsymbol w^T\boldsymbol x_i+b))
$$ 
 $p^*$ 为原问题的最小值，对应的 $w,b$ 分别为 $w^*,b^*$ ,则对于任意的 $a>0$ :
 $$
p^* = \frac{1}{2}||\boldsymbol w^*||^2 \geqslant  L(\boldsymbol w^*, b,\boldsymbol a) \geqslant \min_{\boldsymbol w, b} L(\boldsymbol w, b,\boldsymbol a)
$$ 
<p>则  $\min_{\boldsymbol w, b} L(\boldsymbol w, b,\boldsymbol a)$ 是问题（1）的一个下界。</p>
<p>此时，取最大值即可求得好的下界，即</p>
 $$
\max_{\alpha_i \geqslant 0} \min_{\boldsymbol w, b} L(\boldsymbol w, b,\boldsymbol a)
$$ 
<h3 id="2-18-7-常见的核函数有哪些">2.18.7 常见的核函数有哪些</h3>
<table>
<thead>
<tr>
<th>核函数</th>
<th>表达式</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>Linear Kernel线性核</td>
<td>$k(x,y)=x^{t}y+c$</td>
<td></td>
</tr>
<tr>
<td>Polynomial Kernel多项式核</td>
<td>$k(x,y)=(ax^{t}y+c)^{d}$</td>
<td>$d\geqslant1$ 为多项式的次数</td>
</tr>
<tr>
<td>Exponential Kernel指数核</td>
<td>$k(x,y)=exp(-\frac{\left \|x-y \right \|}{2\sigma ^{2}})$</td>
<td>$\sigma>0$</td>
</tr>
<tr>
<td>Gaussian Kernel高斯核</td>
<td>$k(x,y)=exp(-\frac{\left \|x-y \right \|^{2}}{2\sigma ^{2}})$</td>
<td>$\sigma$ 为高斯核的带宽， $\sigma>0$ ,</td>
</tr>
<tr>
<td>Laplacian Kernel拉普拉斯核</td>
<td>$k(x,y)=exp(-\frac{\left \|x-y \right \|}{\sigma})$</td>
<td>$\sigma>0$</td>
</tr>
<tr>
<td>ANOVA Kernel</td>
<td>$k(x,y)=exp(-\sigma(x^{k}-y^{k})^{2})^{d}$</td>
<td></td>
</tr>
<tr>
<td>Sigmoid Kernel</td>
<td>$k(x,y)=tanh(ax^{t}y+c)$</td>
<td>$tanh$ 为双曲正切函数， $a>0,c<0$< td>
</0$<></td></tr>
</tbody>
</table>
<h3 id="2-18-9-SVM主要特点">2.18.9 SVM主要特点</h3>
<p>特点：</p>
<p>(1)  SVM方法的理论基础是非线性映射，SVM利用内积核函数代替向高维空间的非线性映射。<br>
(2)  SVM的目标是对特征空间划分得到最优超平面，SVM方法核心是最大化分类边界。<br>
(3)  支持向量是SVM的训练结果，在SVM分类决策中起决定作用的是支持向量。<br>
(4)  SVM是一种有坚实理论基础的新颖的适用小样本学习方法。它基本上不涉及概率测度及大数定律等，也简化了通常的分类和回归等问题。<br>
(5)  SVM的最终决策函数只由少数的支持向量所确定，计算的复杂性取决于支持向量的数目，而不是样本空间的维数，这在某种意义上避免了“维数灾难”。<br>
(6)  少数支持向量决定了最终结果，这不但可以帮助我们抓住关键样本、“剔除”大量冗余样本,而且注定了该方法不但算法简单，而且具有较好的“鲁棒性”。这种鲁棒性主要体现在：<br>
​        ①增、删非支持向量样本对模型没有影响;<br>
​        ②支持向量样本集具有一定的鲁棒性;<br>
​        ③有些成功的应用中，SVM方法对核的选取不敏感<br>
(7)  SVM学习问题可以表示为凸优化问题，因此可以利用已知的有效算法发现目标函数的全局最小值。而其他分类方法（如基于规则的分类器和人工神经网络）都采用一种基于贪心学习的策略来搜索假设空间，这种方法一般只能获得局部最优解。<br>
(8)  SVM通过最大化决策边界的边缘来控制模型的能力。尽管如此，用户必须提供其他参数，如使用核函数类型和引入松弛变量等。<br>
(9)  SVM在小样本训练集上能够得到比其它算法好很多的结果。SVM优化目标是结构化风险最小，而不是经验风险最小，避免了过拟合问题，通过margin的概念，得到对数据分布的结构化描述，减低了对数据规模和数据分布的要求，有优秀的泛化能力。<br>
(10)  它是一个凸优化问题，因此局部最优解一定是全局最优解的优点。</p>
<h3 id="2-18-10-SVM主要缺点">2.18.10 SVM主要缺点</h3>
<p>(1) SVM算法对大规模训练样本难以实施<br>
​        SVM的空间消耗主要是存储训练样本和核矩阵，由于SVM是借助二次规划来求解支持向量，而求解二次规划将涉及m阶矩阵的计算（m为样本的个数），当m数目很大时该矩阵的存储和计算将耗费大量的机器内存和运算时间。<br>
​        如果数据量很大，SVM的训练时间就会比较长，如垃圾邮件的分类检测，没有使用SVM分类器，而是使用简单的朴素贝叶斯分类器，或者是使用逻辑回归模型分类。</p>
<p>(2) 用SVM解决多分类问题存在困难</p>
<p>​        经典的支持向量机算法只给出了二类分类的算法，而在实际应用中，一般要解决多类的分类问题。可以通过多个二类支持向量机的组合来解决。主要有一对多组合模式、一对一组合模式和SVM决策树；再就是通过构造多个分类器的组合来解决。主要原理是克服SVM固有的缺点，结合其他算法的优势，解决多类问题的分类精度。如：与粗糙集理论结合，形成一种优势互补的多类问题的组合分类器。</p>
<p>(3) 对缺失数据敏感，对参数和核函数的选择敏感</p>
<p>​        支持向量机性能的优劣主要取决于核函数的选取，所以对于一个实际问题而言，如何根据实际的数据模型选择合适的核函数从而构造SVM算法。目前比较成熟的核函数及其参数的选择都是人为的，根据经验来选取的，带有一定的随意性。在不同的问题领域，核函数应当具有不同的形式和参数，所以在选取时候应该将领域知识引入进来，但是目前还没有好的方法来解决核函数的选取问题。</p>
<h3 id="2-18-11-逻辑回归与SVM的异同">2.18.11 逻辑回归与SVM的异同</h3>
<p>相同点：</p>
<ul>
<li>LR和SVM都是<strong>分类</strong>算法。</li>
<li>LR和SVM都是<strong>监督学习</strong>算法。</li>
<li>LR和SVM都是<strong>判别模型</strong>。</li>
<li>如果不考虑核函数，LR和SVM都是<strong>线性分类</strong>算法，也就是说他们的分类决策面都是线性的。<br>
说明：LR也是可以用核函数的.但LR通常不采用核函数的方法。（<strong>计算量太大</strong>）</li>
</ul>
<p>不同点：</p>
<p><strong>1、LR采用log损失，SVM采用合页(hinge)损失。</strong><br>
逻辑回归的损失函数：</p>
 $$
J(\theta)=-\frac{1}{m}\sum^m_{i=1}\left[y^{i}logh_{\theta}(x^{i})+ (1-y^{i})log(1-h_{\theta}(x^{i}))\right]
$$ 
<p>支持向量机的目标函数:</p>
 $$
L(w,n,a)=\frac{1}{2}||w||^2-\sum^n_{i=1}\alpha_i \left( y_i(w^Tx_i+b)-1\right)
$$ 
<p>​	逻辑回归方法基于概率理论，假设样本为1的概率可以用sigmoid函数来表示，然后通过<strong>极大似然估计</strong>的方法估计出参数的值。<br>
​	支持向量机基于几何<strong>边界最大化</strong>原理，认为存在最大几何边界的分类面为最优分类面。</p>
<p>2、<strong>LR对异常值敏感，SVM对异常值不敏感</strong>。</p>
<p>​	支持向量机只考虑局部的边界线附近的点，而逻辑回归考虑全局。LR模型找到的那个超平面，是尽量让所有点都远离他，而SVM寻找的那个超平面，是只让最靠近中间分割线的那些点尽量远离，即只用到那些支持向量的样本。<br>
​	支持向量机改变非支持向量样本并不会引起决策面的变化。<br>
​	逻辑回归中改变任何样本都会引起决策面的变化。</p>
<p>3、<strong>计算复杂度不同。对于海量数据，SVM的效率较低，LR效率比较高</strong></p>
<p>​	当样本较少，特征维数较低时，SVM和LR的运行时间均比较短，SVM较短一些。准确率的话，LR明显比SVM要高。当样本稍微增加些时，SVM运行时间开始增长，但是准确率赶超了LR。SVM时间虽长，但在可接受范围内。当数据量增长到20000时，特征维数增长到200时，SVM的运行时间剧烈增加，远远超过了LR的运行时间。但是准确率却和LR相差无几。(这其中主要原因是大量非支持向量参与计算，造成SVM的二次规划问题)</p>
<p>4、<strong>对非线性问题的处理方式不同</strong></p>
<p>​	LR主要靠特征构造，必须组合交叉特征，特征离散化。SVM也可以这样，还可以通过核函数kernel（因为只有支持向量参与核计算，计算复杂度不高）。由于可以利用核函数，SVM则可以通过对偶求解高效处理。LR则在特征空间维度很高时，表现较差。</p>
<p>5、<strong>SVM的损失函数就自带正则</strong>。<br>
​	损失函数中的1/2||w||^2项，这就是为什么SVM是结构风险最小化算法的原因！！！而LR必须另外在损失函数上添加正则项！！！**</p>
<p>6、SVM自带<strong>结构风险最小化</strong>，LR则是<strong>经验风险最小化</strong>。</p>
<p>7、SVM会用核函数而LR一般不用核函数。</p>
<h2 id="2-19-贝叶斯分类器">2.19 贝叶斯分类器</h2>
<h3 id="2-19-1-图解极大似然估计">2.19.1 图解极大似然估计</h3>
<p>极大似然估计的原理，用一张图片来说明，如下图所示：</p>
<p><img src="2.19.1.1.png" alt></p>
<p>​	例：有两个外形完全相同的箱子，1号箱有99只白球，1只黑球；2号箱有1只白球，99只黑球。在一次实验中，取出的是黑球，请问是从哪个箱子中取出的？</p>
<p>​	一般的根据经验想法，会猜测这只黑球最像是从2号箱取出，此时描述的“最像”就有“最大似然”的意思，这种想法常称为“最大似然原理”。</p>
<h3 id="2-19-2-极大似然估计原理">2.19.2 极大似然估计原理</h3>
<p>​	总结起来，最大似然估计的目的就是：利用已知的样本结果，反推最有可能（最大概率）导致这样结果的参数值。</p>
<p>​	极大似然估计是建立在极大似然原理的基础上的一个统计方法。极大似然估计提供了一种给定观察数据来评估模型参数的方法，即：“模型已定，参数未知”。通过若干次试验，观察其结果，利用试验结果得到某个参数值能够使样本出现的概率为最大，则称为极大似然估计。</p>
<p>​	由于样本集中的样本都是独立同分布，可以只考虑一类样本集 $D$ ，来估计参数向量 $\vec\theta$ 。记已知的样本集为：</p>
 $$
D=\vec x_{1},\vec x_{2},...,\vec x_{n}
$$ 
<p>似然函数（likelihood function）：联合概率密度函数 $p(D|\vec\theta )$ 称为相对于 $\vec x_{1},\vec x_{2},...,\vec x_{n}$ 的 $\vec\theta$ 的似然函数。</p>
 $$
l(\vec\theta )=p(D|\vec\theta ) =p(\vec x_{1},\vec x_{2},...,\vec x_{n}|\vec\theta )=\prod_{i=1}^{n}p(\vec x_{i}|\vec \theta )
$$ 
<p>如果 $\hat{\vec\theta}$ 是参数空间中能使似然函数 $l(\vec\theta)$ 最大的 $\vec\theta$ 值，则 $\hat{\vec\theta}$ 应该是“最可能”的参数值，那么 $\hat{\vec\theta}​$ 就是 $\theta$ 的极大似然估计量。它是样本集的函数，记作：</p>
 $$
\hat{\vec\theta}=d(D)= \mathop {\arg \max}_{\vec\theta} l(\vec\theta )
$$ 
 $\hat{\vec\theta}(\vec x_{1},\vec x_{2},...,\vec x_{n})$ 称为极大似然函数估计值。
<h3 id="2-19-3-贝叶斯分类器基本原理">2.19.3 贝叶斯分类器基本原理</h3>
<p>​	贝叶斯决策论通过<strong>相关概率已知</strong>的情况下利用<strong>误判损失</strong>来选择最优的类别分类。<br>
假设有 $N$ 种可能的分类标记，记为 $Y=\{c_1,c_2,...,c_N\}$ ，那对于样本 $\boldsymbol{x}$ ，它属于哪一类呢？</p>
<p>计算步骤如下：</p>
<p>step 1. 算出样本 $\boldsymbol{x}$ 属于第i个类的概率，即 $P(c_i|x)​$ ；</p>
<p>step 2. 通过比较所有的 $P(c_i|\boldsymbol{x})$ ，得到样本 $\boldsymbol{x}$ 所属的最佳类别。</p>
<p>step 3. 将类别 $c_i$ 和样本 $\boldsymbol{x}$ 代入到贝叶斯公式中，得到：</p>
 $$
P(c_i|\boldsymbol{x})=\frac{P(\boldsymbol{x}|c_i)P(c_i)}{P(\boldsymbol{x})}.
$$ 
<p>​	一般来说， $P(c_i)$ 为先验概率， $P(\boldsymbol{x}|c_i)$ 为条件概率， $P(\boldsymbol{x})$ 是用于归一化的证据因子。对于 $P(c_i)$ 可以通过训练样本中类别为 $c_i$ 的样本所占的比例进行估计；此外，由于只需要找出最大的 $P(\boldsymbol{x}|c_i)$ ，因此我们并不需要计算 $P(\boldsymbol{x})$ 。<br>
​	为了求解条件概率，基于不同假设提出了不同的方法，以下将介绍朴素贝叶斯分类器和半朴素贝叶斯分类器。</p>
<h3 id="2-19-4-朴素贝叶斯分类器">2.19.4 朴素贝叶斯分类器</h3>
<p>​	假设样本 $\boldsymbol{x}$ 包含 $d$ 个属性，即 $\boldsymbol{x}=\{ x_1,x_2,...,x_d\}$ 。于是有：</p>
 $$
P(\boldsymbol{x}|c_i)=P(x_1,x_2,\cdots,x_d|c_i)
$$ 
<p>这个联合概率难以从有限的训练样本中直接估计得到。于是，朴素贝叶斯（Naive Bayesian，简称NB）采用了“属性条件独立性假设”：对已知类别，假设所有属性相互独立。于是有：</p>
 $$
P(x_1,x_2,\cdots,x_d|c_i)=\prod_{j=1}^d P(x_j|c_i)
$$ 
<p>这样的话，我们就可以很容易地推出相应的判定准则了：</p>
 $$
h_{nb}(\boldsymbol{x})=\mathop{\arg \max}_{c_i\in Y} P(c_i)\prod_{j=1}^dP(x_j|c_i)
$$ 
<p><strong>条件概率 $P(x_j|c_i)​$ 的求解</strong></p>
<p>如果 $x_j$ 是标签属性，那么我们可以通过计数的方法估计 $P(x_j|c_i)$</p>
 $$
P(x_j|c_i)=\frac{P(x_j,c_i)}{P(c_i)}\approx\frac{\#(x_j,c_i)}{\#(c_i)}
$$ 
<p>其中， $\#(x_j,c_i)$ 表示在训练样本中 $x_j$ 与 $c_{i}$ 共同出现的次数。</p>
<p>如果 $x_j​$ 是数值属性，通常我们假设类别中 $c_{i}​$ 的所有样本第 $j​$ 个属性的值服从正态分布。我们首先估计这个分布的均值 $μ​$ 和方差 $σ​$ ，然后计算 $x_j​$ 在这个分布中的概率密度 $P(x_j|c_i)​$ 。</p>
<h3 id="2-19-5-举例理解朴素贝叶斯分类器">2.19.5 举例理解朴素贝叶斯分类器</h3>
<p>使用经典的西瓜训练集如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">编号</th>
<th style="text-align:center">色泽</th>
<th style="text-align:center">根蒂</th>
<th style="text-align:center">敲声</th>
<th style="text-align:center">纹理</th>
<th style="text-align:center">脐部</th>
<th style="text-align:center">触感</th>
<th style="text-align:center">密度</th>
<th style="text-align:center">含糖率</th>
<th style="text-align:center">好瓜</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">青绿</td>
<td style="text-align:center">蜷缩</td>
<td style="text-align:center">浊响</td>
<td style="text-align:center">清晰</td>
<td style="text-align:center">凹陷</td>
<td style="text-align:center">硬滑</td>
<td style="text-align:center">0.697</td>
<td style="text-align:center">0.460</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">乌黑</td>
<td style="text-align:center">蜷缩</td>
<td style="text-align:center">沉闷</td>
<td style="text-align:center">清晰</td>
<td style="text-align:center">凹陷</td>
<td style="text-align:center">硬滑</td>
<td style="text-align:center">0.774</td>
<td style="text-align:center">0.376</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">乌黑</td>
<td style="text-align:center">蜷缩</td>
<td style="text-align:center">浊响</td>
<td style="text-align:center">清晰</td>
<td style="text-align:center">凹陷</td>
<td style="text-align:center">硬滑</td>
<td style="text-align:center">0.634</td>
<td style="text-align:center">0.264</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">青绿</td>
<td style="text-align:center">蜷缩</td>
<td style="text-align:center">沉闷</td>
<td style="text-align:center">清晰</td>
<td style="text-align:center">凹陷</td>
<td style="text-align:center">硬滑</td>
<td style="text-align:center">0.608</td>
<td style="text-align:center">0.318</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">浅白</td>
<td style="text-align:center">蜷缩</td>
<td style="text-align:center">浊响</td>
<td style="text-align:center">清晰</td>
<td style="text-align:center">凹陷</td>
<td style="text-align:center">硬滑</td>
<td style="text-align:center">0.556</td>
<td style="text-align:center">0.215</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">青绿</td>
<td style="text-align:center">稍蜷</td>
<td style="text-align:center">浊响</td>
<td style="text-align:center">清晰</td>
<td style="text-align:center">稍凹</td>
<td style="text-align:center">软粘</td>
<td style="text-align:center">0.403</td>
<td style="text-align:center">0.237</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">乌黑</td>
<td style="text-align:center">稍蜷</td>
<td style="text-align:center">浊响</td>
<td style="text-align:center">稍糊</td>
<td style="text-align:center">稍凹</td>
<td style="text-align:center">软粘</td>
<td style="text-align:center">0.481</td>
<td style="text-align:center">0.149</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">乌黑</td>
<td style="text-align:center">稍蜷</td>
<td style="text-align:center">浊响</td>
<td style="text-align:center">清晰</td>
<td style="text-align:center">稍凹</td>
<td style="text-align:center">硬滑</td>
<td style="text-align:center">0.437</td>
<td style="text-align:center">0.211</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">乌黑</td>
<td style="text-align:center">稍蜷</td>
<td style="text-align:center">沉闷</td>
<td style="text-align:center">稍糊</td>
<td style="text-align:center">稍凹</td>
<td style="text-align:center">硬滑</td>
<td style="text-align:center">0.666</td>
<td style="text-align:center">0.091</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">青绿</td>
<td style="text-align:center">硬挺</td>
<td style="text-align:center">清脆</td>
<td style="text-align:center">清晰</td>
<td style="text-align:center">平坦</td>
<td style="text-align:center">软粘</td>
<td style="text-align:center">0.243</td>
<td style="text-align:center">0.267</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center">浅白</td>
<td style="text-align:center">硬挺</td>
<td style="text-align:center">清脆</td>
<td style="text-align:center">模糊</td>
<td style="text-align:center">平坦</td>
<td style="text-align:center">硬滑</td>
<td style="text-align:center">0.245</td>
<td style="text-align:center">0.057</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center">浅白</td>
<td style="text-align:center">蜷缩</td>
<td style="text-align:center">浊响</td>
<td style="text-align:center">模糊</td>
<td style="text-align:center">平坦</td>
<td style="text-align:center">软粘</td>
<td style="text-align:center">0.343</td>
<td style="text-align:center">0.099</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">13</td>
<td style="text-align:center">青绿</td>
<td style="text-align:center">稍蜷</td>
<td style="text-align:center">浊响</td>
<td style="text-align:center">稍糊</td>
<td style="text-align:center">凹陷</td>
<td style="text-align:center">硬滑</td>
<td style="text-align:center">0.639</td>
<td style="text-align:center">0.161</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">14</td>
<td style="text-align:center">浅白</td>
<td style="text-align:center">稍蜷</td>
<td style="text-align:center">沉闷</td>
<td style="text-align:center">稍糊</td>
<td style="text-align:center">凹陷</td>
<td style="text-align:center">硬滑</td>
<td style="text-align:center">0.657</td>
<td style="text-align:center">0.198</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">15</td>
<td style="text-align:center">乌黑</td>
<td style="text-align:center">稍蜷</td>
<td style="text-align:center">浊响</td>
<td style="text-align:center">清晰</td>
<td style="text-align:center">稍凹</td>
<td style="text-align:center">软粘</td>
<td style="text-align:center">0.360</td>
<td style="text-align:center">0.370</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">16</td>
<td style="text-align:center">浅白</td>
<td style="text-align:center">蜷缩</td>
<td style="text-align:center">浊响</td>
<td style="text-align:center">模糊</td>
<td style="text-align:center">平坦</td>
<td style="text-align:center">硬滑</td>
<td style="text-align:center">0.593</td>
<td style="text-align:center">0.042</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">17</td>
<td style="text-align:center">青绿</td>
<td style="text-align:center">蜷缩</td>
<td style="text-align:center">沉闷</td>
<td style="text-align:center">稍糊</td>
<td style="text-align:center">稍凹</td>
<td style="text-align:center">硬滑</td>
<td style="text-align:center">0.719</td>
<td style="text-align:center">0.103</td>
<td style="text-align:center">否</td>
</tr>
</tbody>
</table>
<p>对下面的测试例“测1”进行 分类：</p>
<table>
<thead>
<tr>
<th style="text-align:center">编号</th>
<th style="text-align:center">色泽</th>
<th style="text-align:center">根蒂</th>
<th style="text-align:center">敲声</th>
<th style="text-align:center">纹理</th>
<th style="text-align:center">脐部</th>
<th style="text-align:center">触感</th>
<th style="text-align:center">密度</th>
<th style="text-align:center">含糖率</th>
<th style="text-align:center">好瓜</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">测1</td>
<td style="text-align:center">青绿</td>
<td style="text-align:center">蜷缩</td>
<td style="text-align:center">浊响</td>
<td style="text-align:center">清晰</td>
<td style="text-align:center">凹陷</td>
<td style="text-align:center">硬滑</td>
<td style="text-align:center">0.697</td>
<td style="text-align:center">0.460</td>
<td style="text-align:center">？</td>
</tr>
</tbody>
</table>
<p>首先，估计类先验概率 $P(c_j)$ ，有</p>
 $$
\begin{align} 
&P(好瓜=是)=\frac{8}{17}=0.471 \newline 
&P(好瓜=否)=\frac{9}{17}=0.529 
\end{align}
$$ 
<p>然后，为每个属性估计条件概率（这里，对于连续属性，假定它们服从正态分布）</p>
 $$
P_{青绿|是}=P（色泽=青绿|好瓜=是）=\frac{3}{8}=0.375
$$ 
 $$
P_{青绿|否}=P（色泽=青绿|好瓜=否）=\frac{3}{9}\approx0.333
$$ 
 $$
P_{蜷缩|是}=P（根蒂=蜷缩|好瓜=是）=\frac{5}{8}=0.625
$$ 
 $$
P_{蜷缩|否}=P（根蒂=蜷缩|好瓜=否）=\frac{3}{9}=0.333
$$ 
 $$
P_{浊响|是}=P（敲声=浊响|好瓜=是）=\frac{6}{8}=0.750
$$ 
 $$
P_{浊响|否}=P（敲声=浊响|好瓜=否）=\frac{4}{9}\approx 0.444
$$ 
 $$
P_{清晰|是}=P（纹理=清晰|好瓜=是）=\frac{7}{8}= 0.875
$$ 
 $$
P_{清晰|否}=P（纹理=清晰|好瓜=否）=\frac{2}{9}\approx 0.222
$$ 
 $$
P_{凹陷|是}=P（脐部=凹陷|好瓜=是）=\frac{6}{8}= 0.750
$$ 
 $$
P_{凹陷|否}=P（脐部=凹陷|好瓜=否）=\frac{2}{9} \approx 0.222
$$ 
 $$
P_{硬滑|是}=P（触感=硬滑|好瓜=是）=\frac{6}{8}= 0.750
$$ 
 $$
P_{硬滑|否}=P（触感=硬滑|好瓜=否）=\frac{6}{9} \approx 0.667
$$ 
 $$
\begin{aligned}
\rho_{密度：0.697|是}&=\rho（密度=0.697|好瓜=是）\\&=\frac{1}{\sqrt{2 \pi}\times0.129}exp\left( -\frac{(0.697-0.574)^2}{2\times0.129^2}\right) \approx 1.959
\end{aligned}
$$ 
 $$
\begin{aligned}
\rho_{密度：0.697|否}&=\rho（密度=0.697|好瓜=否）\\&=\frac{1}{\sqrt{2 \pi}\times0.195}exp\left( -\frac{(0.697-0.496)^2}{2\times0.195^2}\right) \approx 1.203
\end{aligned}
$$ 
 $$
\begin{aligned}
\rho_{含糖：0.460|是}&=\rho（密度=0.460|好瓜=是）\\&=\frac{1}{\sqrt{2 \pi}\times0.101}exp\left( -\frac{(0.460-0.279)^2}{2\times0.101^2}\right) \approx 0.788
\end{aligned}
$$ 
 $$
\begin{aligned}
\rho_{含糖：0.460|否}&=\rho（密度=0.460|好瓜=是）\\&=\frac{1}{\sqrt{2 \pi}\times0.108}exp\left( -\frac{(0.460-0.154)^2}{2\times0.108^2}\right) \approx 0.066
\end{aligned}
$$ 
<p>于是有</p>
 $$
\begin{align} 
P(&好瓜=是)\times P_{青绿|是} \times P_{蜷缩|是} \times P_{浊响|是} \times P_{清晰|是} \times P_{凹陷|是}\newline 
&\times P_{硬滑|是} \times p_{密度：0.697|是} \times p_{含糖：0.460|是} \approx 0.063 \newline\newline 
P(&好瓜=否)\times P_{青绿|否} \times P_{蜷缩|否} \times P_{浊响|否} \times P_{清晰|否} \times P_{凹陷|否}\newline 
&\times P_{硬滑|否} \times p_{密度：0.697|否} \times p_{含糖：0.460|否} \approx 6.80\times 10^{-5} 
\end{align}
$$ 
<p>由于 $0.063>6.80\times 10^{-5}$ ，因此，朴素贝叶斯分类器将测试样本“测1”判别为“好瓜”。</p>
<h3 id="2-19-6-半朴素贝叶斯分类器">2.19.6 半朴素贝叶斯分类器</h3>
<p>​	朴素贝叶斯采用了“属性条件独立性假设”，半朴素贝叶斯分类器的基本想法是适当考虑一部分属性间的相互依赖信息。<strong>独依赖估计</strong>（One-Dependence Estimator，简称ODE）是半朴素贝叶斯分类器最常用的一种策略。顾名思义，独依赖是假设每个属性在类别之外最多依赖一个其他属性，即：</p>
 $$
P(\boldsymbol{x}|c_i)=\prod_{j=1}^d P(x_j|c_i,{\rm pa}_j)
$$ 
<p>其中 $pa_j$ 为属性 $x_i$ 所依赖的属性，成为 $x_i$ 的父属性。假设父属性 $pa_j$ 已知，那么可以使用下面的公式估计 $P(x_j|c_i,{\rm pa}_j)$</p>
 $$
P(x_j|c_i,{\rm pa}_j)=\frac{P(x_j,c_i,{\rm pa}_j)}{P(c_i,{\rm pa}_j)}
$$ 
<h2 id="2-20-EM算法">2.20 EM算法</h2>
<h3 id="2-20-1-EM算法基本思想">2.20.1 EM算法基本思想</h3>
<p>​	最大期望算法（Expectation-Maximization algorithm, EM），是一类通过迭代进行极大似然估计的优化算法，通常作为牛顿迭代法的替代，用于对包含隐变量或缺失数据的概率模型进行参数估计。</p>
<p>​	最大期望算法基本思想是经过两个步骤交替进行计算：</p>
<p>​	第一步是计算期望（E），利用对隐藏变量的现有估计值，计算其最大似然估计值**；**</p>
<p>​	第二步是最大化（M），最大化在E步上求得的最大似然值来计算参数的值。</p>
<p>​	M步上找到的参数估计值被用于下一个E步计算中，这个过程不断交替进行。</p>
<h3 id="2-20-2-EM算法推导">2.20.2 EM算法推导</h3>
<p>​	对于 $m$ 个样本观察数据 $x=(x^{1},x^{2},...,x^{m})$ ，现在想找出样本的模型参数 $\theta$ ，其极大化模型分布的对数似然函数为：</p>
 $$
\theta = \mathop{\arg\max}_\theta\sum\limits_{i=1}^m logP(x^{(i)};\theta)
$$ 
<p>如果得到的观察数据有未观察到的隐含数据 $z=(z^{(1)},z^{(2)},...z^{(m)})$ ，极大化模型分布的对数似然函数则为：</p>
 $$
\theta =\mathop{\arg\max}_\theta\sum\limits_{i=1}^m logP(x^{(i)};\theta) = \mathop{\arg\max}_\theta\sum\limits_{i=1}^m log\sum\limits_{z^{(i)}}P(x^{(i)}, z^{(i)};\theta)  \tag{a}
$$ 
<p>由于上式不能直接求出 $\theta$ ，采用缩放技巧：</p>
 $$
\begin{align} \sum\limits_{i=1}^m log\sum\limits_{z^{(i)}}P(x^{(i)}, z^{(i)};\theta)   & = \sum\limits_{i=1}^m log\sum\limits_{z^{(i)}}Q_i(z^{(i)})\frac{P(x^{(i)}, z^{(i)};\theta)}{Q_i(z^{(i)})} \\ & \geqslant  \sum\limits_{i=1}^m \sum\limits_{z^{(i)}}Q_i(z^{(i)})log\frac{P(x^{(i)}, z^{(i)};\theta)}{Q_i(z^{(i)})} \end{align}   \tag{1}
$$ 
<p>上式用到了Jensen不等式：</p>
 $$
log\sum\limits_j\lambda_jy_j \geqslant \sum\limits_j\lambda_jlogy_j\;\;,  \lambda_j \geqslant 0, \sum\limits_j\lambda_j =1
$$ 
<p>并且引入了一个未知的新分布 $Q_i(z^{(i)})$ 。</p>
<p>此时，如果需要满足Jensen不等式中的等号，所以有：</p>
 $$
\frac{P(x^{(i)}, z^{(i)};\theta)}{Q_i(z^{(i)})} =c, c为常数
$$ 
<p>由于 $Q_i(z^{(i)})$ 是一个分布，所以满足</p>
 $$
\sum\limits_{z}Q_i(z^{(i)}) =1
$$ 
<p>综上，可得：</p>
 $$
Q_i(z^{(i)})  = \frac{P(x^{(i)}， z^{(i)};\theta)}{\sum\limits_{z}P(x^{(i)}, z^{(i)};\theta)} =  \frac{P(x^{(i)}, z^{(i)};\theta)}{P(x^{(i)};\theta)} = P( z^{(i)}|x^{(i)};\theta)
$$ 
<p>如果 $Q_i(z^{(i)}) = P( z^{(i)}|x^{(i)};\theta)$  ，则第(1)式是我们的包含隐藏数据的对数似然的一个下界。如果我们能极大化这个下界，则也在尝试极大化我们的对数似然。即我们需要最大化下式：</p>
 $$
\mathop{\arg\max}_\theta \sum\limits_{i=1}^m \sum\limits_{z^{(i)}}Q_i(z^{(i)})log\frac{P(x^{(i)}， z^{(i)};\theta)}{Q_i(z^{(i)})}
$$ 
<p>简化得：</p>
 $$
\mathop{\arg\max}_\theta \sum\limits_{i=1}^m \sum\limits_{z^{(i)}}Q_i(z^{(i)})log{P(x^{(i)}, z^{(i)};\theta)}
$$ 
<p>以上即为EM算法的M步， $\sum\limits_{z^{(i)}}Q_i(z^{(i)})log{P(x^{(i)}, z^{(i)};\theta)}​$ 可理解为 $logP(x^{(i)}, z^{(i)};\theta) $ 基于条件概率分布 $Q_i(z^{(i)}) $ 的期望。以上即为EM算法中E步和M步的具体数学含义。</p>
<h3 id="2-20-3-图解EM算法">2.20.3 图解EM算法</h3>
<p>​	考虑上一节中的（a）式，表达式中存在隐变量，直接找到参数估计比较困难，通过EM算法迭代求解下界的最大值到收敛为止。</p>
<p><img src="2.20.1.jpg" alt></p>
<p>​	图片中的紫色部分是我们的目标模型 $p(x|\theta)$ ，该模型复杂，难以求解析解，为了消除隐变量 $z^{(i)}$ 的影响，我们可以选择一个不包含 $z^{(i)}$ 的模型 $r(x|\theta)$ ，使其满足条件 $r(x|\theta) \leqslant p(x|\theta) $ 。</p>
<p>求解步骤如下：</p>
<p>（1）选取 $\theta_1$ ，使得 $r(x|\theta_1) = p(x|\theta_1)$ ，然后对此时的 $r$ 求取最大值，得到极值点 $\theta_2$ ，实现参数的更新。</p>
<p>（2）重复以上过程到收敛为止，在更新过程中始终满足 $r \leqslant p $ .</p>
<h3 id="2-20-4-EM算法流程">2.20.4 EM算法流程</h3>
<p>输入：观察数据 $x=(x^{(1)},x^{(2)},...x^{(m)})$ ，联合分布 $p(x,z ;\theta)$ ，条件分布 $p(z|x; \theta)$ ，最大迭代次数 $J$</p>
<p>1）随机初始化模型参数 $\theta$ 的初值 $\theta^0$ 。</p>
<p>2） $for \ j  \ from \ 1  \ to  \ j$ ：</p>
<p>​	a） E步。计算联合分布的条件概率期望：</p>
 $$
Q_i(z^{(i)}) = P( z^{(i)}|x^{(i)}, \theta^{j})
$$ 
 $$
L(\theta, \theta^{j}) = \sum\limits_{i=1}^m\sum\limits_{z^{(i)}}P( z^{(i)}|x^{(i)}, \theta^{j})log{P(x^{(i)}, z^{(i)};\theta)}
$$ 
<p>​	b） M步。极大化 $L(\theta, \theta^{j})$ ，得到 $\theta^{j+1}$ :</p>
 $$
\theta^{j+1} = \mathop{\arg\max}_\theta L(\theta, \theta^{j})
$$ 
<p>​	c） 如果 $\theta^{j+1}$ 收敛，则算法结束。否则继续回到步骤a）进行E步迭代。</p>
<p>输出：模型参数 $\theta​$ 。</p>
<h2 id="2-21-降维和聚类">2.21 降维和聚类</h2>
<h3 id="2-21-1-图解为什么会产生维数灾难">2.21.1 图解为什么会产生维数灾难</h3>
<p>​	假如数据集包含10张照片，照片中包含三角形和圆两种形状。现在来设计一个分类器进行训练，让这个分类器对其他的照片进行正确分类（假设三角形和圆的总数是无限大），简单的，我们用一个特征进行分类：</p>
<p><img src="2.21.1.1.png" alt></p>
<p>​											图2.21.1.a</p>
<p>​	从上图可看到，如果仅仅只有一个特征进行分类，三角形和圆几乎是均匀分布在这条线段上，很难将10张照片线性分类。那么，增加一个特征后的情况会怎么样：</p>
<p><img src="2.21.1.2.png" alt></p>
<p>​											图2.21.1.b</p>
<p>增加一个特征后，我们发现仍然无法找到一条直线将猫和狗分开。所以，考虑需要再增加一个特征：</p>
<p><img src="2.21.1.3.png" alt></p>
<p>​											图2.21.1.c</p>
<p><img src="2.21.1.4.png" alt></p>
<p>​											图2.21.1.d</p>
<p>​	此时，可以找到一个平面将三角形和圆分开。</p>
<p>​	现在计算一下不同特征数是样本的密度：</p>
<p>​	（1）一个特征时，假设特征空间时长度为5的线段，则样本密度为 $10 \div 5 = 2$ 。</p>
<p>​	（2）两个特征时，特征空间大小为 $ 5\times5 = 25$ ，样本密度为 $10 \div 25 = 0.4$ 。</p>
<p>​	（3）三个特征时，特征空间大小是 $ 5\times5\times5 = 125$ ，样本密度为 $10 \div 125 = 0.08$ 。</p>
<p>​	以此类推，如果继续增加特征数量，样本密度会越来越稀疏，此时，更容易找到一个超平面将训练样本分开。当特征数量增长至无限大时，样本密度就变得非常稀疏。</p>
<p>​	下面看一下将高维空间的分类结果映射到低维空间时，会出现什么情况？</p>
<p><img src="2.21.1.5.png" alt></p>
<p>​										图2.21.1.e</p>
<p>​	上图是将三维特征空间映射到二维特征空间后的结果。尽管在高维特征空间时训练样本线性可分，但是映射到低维空间后，结果正好相反。事实上，增加特征数量使得高维空间线性可分，相当于在低维空间内训练一个复杂的非线性分类器。不过，这个非线性分类器太过“聪明”，仅仅学到了一些特例。如果将其用来辨别那些未曾出现在训练样本中的测试样本时，通常结果不太理想，会造成过拟合问题。</p>
<p><img src="2.21.1.6a.png" alt></p>
<p>​										图2.21.1.f</p>
<p>​	上图所示的只采用2个特征的线性分类器分错了一些训练样本，准确率似乎没有图2.21.1.e的高，但是，采用2个特征的线性分类器的泛化能力比采用3个特征的线性分类器要强。因为，采用2个特征的线性分类器学习到的不只是特例，而是一个整体趋势，对于那些未曾出现过的样本也可以比较好地辨别开来。换句话说，通过减少特征数量，可以避免出现过拟合问题，从而避免“维数灾难”。</p>
<p><img src="2.21.1.6.png" alt></p>
<p>​	上图从另一个角度诠释了“维数灾难”。假设只有一个特征时，特征的值域是0到1，每一个三角形和圆的特征值都是唯一的。如果我们希望训练样本覆盖特征值值域的20%，那么就需要三角形和圆总数的20%。我们增加一个特征后，为了继续覆盖特征值值域的20%就需要三角形和圆总数的45%( $0.452^2\approx0.2$ )。继续增加一个特征后，需要三角形和圆总数的58%( $0.583^3\approx0.2$ )。随着特征数量的增加，为了覆盖特征值值域的20%，就需要更多的训练样本。如果没有足够的训练样本，就可能会出现过拟合问题。</p>
<p>​	通过上述例子，我们可以看到特征数量越多，训练样本就会越稀疏，分类器的参数估计就会越不准确，更加容易出现过拟合问题。“维数灾难”的另一个影响是训练样本的稀疏性并不是均匀分布的。处于中心位置的训练样本比四周的训练样本更加稀疏。</p>
<p><img src="2.21.1.7.png" alt></p>
<p>​	假设有一个二维特征空间，如上图所示的矩形，在矩形内部有一个内切的圆形。由于越接近圆心的样本越稀疏，因此，相比于圆形内的样本，那些位于矩形四角的样本更加难以分类。当维数变大时，特征超空间的容量不变，但单位圆的容量会趋于0，在高维空间中，大多数训练数据驻留在特征超空间的角落。散落在角落的数据要比处于中心的数据难于分类。</p>
<h3 id="2-21-2-怎样避免维数灾难">2.21.2 怎样避免维数灾难</h3>
<p><strong>有待完善！！！</strong></p>
<p>解决维度灾难问题：</p>
<p>主成分分析法PCA，线性判别法LDA</p>
<p>奇异值分解简化数据、拉普拉斯特征映射</p>
<p>Lassio缩减系数法、小波分析法、</p>
<h3 id="2-21-3-聚类和降维有什么区别与联系">2.21.3 聚类和降维有什么区别与联系</h3>
<p>​	聚类用于找寻数据内在的分布结构，既可以作为一个单独的过程，比如异常检测等等。也可作为分类等其他学习任务的前驱过程。聚类是标准的无监督学习。</p>
<p>​	1）在一些推荐系统中需确定新用户的类型，但定义“用户类型”却可能不太容易，此时往往可先对原有的用户数据进行聚类，根据聚类结果将每个簇定义为一个类,然后再基于这些类训练分类模型,用于判别新用户的类型。</p>
<p><img src="2.21.3.1.png" alt></p>
<p>​	2）而降维则是为了缓解维数灾难的一个重要方法，就是通过某种数学变换将原始高维属性空间转变为一个低维“子空间”。其基于的假设就是，虽然人们平时观测到的数据样本虽然是高维的，但是实际上真正与学习任务相关的是个低维度的分布。从而通过最主要的几个特征维度就可以实现对数据的描述，对于后续的分类很有帮助。比如对于Kaggle（数据分析竞赛平台之一）上的泰坦尼克号生还问题。通过给定一个乘客的许多特征如年龄、姓名、性别、票价等，来判断其是否能在海难中生还。这就需要首先进行特征筛选，从而能够找出主要的特征，让学习到的模型有更好的泛化性。</p>
<p>​	聚类和降维都可以作为分类等问题的预处理步骤。</p>
<p><img src="2-19.jpg" alt></p>
<p>​	但是他们虽然都能实现对数据的约减。但是二者适用的对象不同，聚类针对的是数据点，而降维则是对于数据的特征。另外它们有着很多种实现方法。聚类中常用的有K-means、层次聚类、基于密度的聚类等；降维中常用的则PCA、Isomap、LLE等。</p>
<h3 id="2-21-4-有哪些聚类算法优劣衡量标准">2.21.4 有哪些聚类算法优劣衡量标准</h3>
<p>不同聚类算法有不同的优劣和不同的适用条件。可从以下方面进行衡量判断：<br>
1、算法的处理能力：处理大的数据集的能力，即算法复杂度；处理数据噪声的能力；处理任意形状，包括有间隙的嵌套的数据的能力；<br>
2、算法是否需要预设条件：是否需要预先知道聚类个数，是否需要用户给出领域知识；</p>
<p>​    3、算法的数据输入属性：算法处理的结果与数据输入的顺序是否相关，也就是说算法是否独立于数据输入顺序；算法处理有很多属性数据的能力，也就是对数据维数是否敏感，对数据的类型有无要求。</p>
<h3 id="2-21-5-聚类和分类有什么区别">2.21.5 聚类和分类有什么区别</h3>
<p>**聚类（Clustering） **<br>
聚类，简单地说就是把相似的东西分到一组，聚类的时候，我们并不关心某一类是什么，我们需要实现的目标只是把相似的东西聚到一起。一个聚类算法通常只需要知道如何计算相似度就可以开始工作了，因此聚类通常并不需要使用训练数据进行学习，在机器学习中属于无监督学习。</p>
<p>**分类（Classification） **</p>
<p>​     分类，对于一个分类器，通常需要你告诉它“这个东西被分为某某类”。一般情况下，一个分类器会从它得到的训练集中进行学习，从而具备对未知数据进行分类的能力，在机器学习中属于监督学习。</p>
<h3 id="2-21-6-不同聚类算法特点性能比较">2.21.6 不同聚类算法特点性能比较</h3>
<table>
<thead>
<tr>
<th style="text-align:center">算法名称</th>
<th style="text-align:center">可伸缩性</th>
<th style="text-align:center">适合的数据类型</th>
<th style="text-align:center">高维性</th>
<th style="text-align:center">异常数据抗干扰性</th>
<th style="text-align:center">聚类形状</th>
<th style="text-align:center">算法效率</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">WAVECLUSTER</td>
<td style="text-align:center">很高</td>
<td style="text-align:center">数值型</td>
<td style="text-align:center">很高</td>
<td style="text-align:center">较高</td>
<td style="text-align:center">任意形状</td>
<td style="text-align:center">很高</td>
</tr>
<tr>
<td style="text-align:center">ROCK</td>
<td style="text-align:center">很高</td>
<td style="text-align:center">混合型</td>
<td style="text-align:center">很高</td>
<td style="text-align:center">很高</td>
<td style="text-align:center">任意形状</td>
<td style="text-align:center">一般</td>
</tr>
<tr>
<td style="text-align:center">BIRCH</td>
<td style="text-align:center">较高</td>
<td style="text-align:center">数值型</td>
<td style="text-align:center">较低</td>
<td style="text-align:center">较低</td>
<td style="text-align:center">球形</td>
<td style="text-align:center">很高</td>
</tr>
<tr>
<td style="text-align:center">CURE</td>
<td style="text-align:center">较高</td>
<td style="text-align:center">数值型</td>
<td style="text-align:center">一般</td>
<td style="text-align:center">很高</td>
<td style="text-align:center">任意形状</td>
<td style="text-align:center">较高</td>
</tr>
<tr>
<td style="text-align:center">K-PROTOTYPES</td>
<td style="text-align:center">一般</td>
<td style="text-align:center">混合型</td>
<td style="text-align:center">较低</td>
<td style="text-align:center">较低</td>
<td style="text-align:center">任意形状</td>
<td style="text-align:center">一般</td>
</tr>
<tr>
<td style="text-align:center">DENCLUE</td>
<td style="text-align:center">较低</td>
<td style="text-align:center">数值型</td>
<td style="text-align:center">较高</td>
<td style="text-align:center">一般</td>
<td style="text-align:center">任意形状</td>
<td style="text-align:center">较高</td>
</tr>
<tr>
<td style="text-align:center">OPTIGRID</td>
<td style="text-align:center">一般</td>
<td style="text-align:center">数值型</td>
<td style="text-align:center">较高</td>
<td style="text-align:center">一般</td>
<td style="text-align:center">任意形状</td>
<td style="text-align:center">一般</td>
</tr>
<tr>
<td style="text-align:center">CLIQUE</td>
<td style="text-align:center">较高</td>
<td style="text-align:center">数值型</td>
<td style="text-align:center">较高</td>
<td style="text-align:center">较高</td>
<td style="text-align:center">任意形状</td>
<td style="text-align:center">较低</td>
</tr>
<tr>
<td style="text-align:center">DBSCAN</td>
<td style="text-align:center">一般</td>
<td style="text-align:center">数值型</td>
<td style="text-align:center">较低</td>
<td style="text-align:center">较高</td>
<td style="text-align:center">任意形状</td>
<td style="text-align:center">一般</td>
</tr>
<tr>
<td style="text-align:center">CLARANS</td>
<td style="text-align:center">较低</td>
<td style="text-align:center">数值型</td>
<td style="text-align:center">较低</td>
<td style="text-align:center">较高</td>
<td style="text-align:center">球形</td>
<td style="text-align:center">较低</td>
</tr>
</tbody>
</table>
<h3 id="2-21-7-四种常用聚类方法之比较">2.21.7 四种常用聚类方法之比较</h3>
<p>​	聚类就是按照某个特定标准把一个数据集分割成不同的类或簇，使得同一个簇内的数据对象的相似性尽可能大，同时不在同一个簇中的数据对象的差异性也尽可能地大。即聚类后同一类的数据尽可能聚集到一起，不同类数据尽量分离。<br>
​	主要的聚类算法可以划分为如下几类：划分方法、层次方法、基于密度的方法、基于网格的方法以及基于模型的方法。下面主要对k-means聚类算法、凝聚型层次聚类算法、神经网络聚类算法之SOM,以及模糊聚类的FCM算法通过通用测试数据集进行聚类效果的比较和分析。</p>
<h3 id="2-21-8-k-means聚类算法">2.21.8 k-means聚类算法</h3>
<p>k-means是划分方法中较经典的聚类算法之一。由于该算法的效率高，所以在对大规模数据进行聚类时被广泛应用。目前，许多算法均围绕着该算法进行扩展和改进。<br>
k-means算法以k为参数，把n个对象分成k个簇，使簇内具有较高的相似度，而簇间的相似度较低。k-means算法的处理过程如下：首先，随机地 选择k个对象，每个对象初始地代表了一个簇的平均值或中心;对剩余的每个对象，根据其与各簇中心的距离，将它赋给最近的簇;然后重新计算每个簇的平均值。 这个过程不断重复，直到准则函数收敛。通常，采用平方误差准则，其定义如下：</p>
 $$
E=\sum_{i=1}^{k}\sum_{p\in C_i}\left\|p-m_i\right\|^2
$$ 
<p>这里E是数据中所有对象的平方误差的总和，p是空间中的点， $m_i$ 是簇 $C_i$ 的平均值[9]。该目标函数使生成的簇尽可能紧凑独立，使用的距离度量是欧几里得距离，当然也可以用其他距离度量。</p>
<p><strong>算法流程</strong>：<br>
​    输入：包含n个对象的数据和簇的数目k；<br>
​    输出：n个对象到k个簇，使平方误差准则最小。<br>
​    步骤：<br>
　　(1) 任意选择k个对象作为初始的簇中心；<br>
　　(2) 根据簇中对象的平均值，将每个对象(重新)赋予最类似的簇；<br>
　　(3) 更新簇的平均值，即计算每个簇中对象的平均值；<br>
　　(4) 重复步骤(2)、(3)直到簇中心不再变化；</p>
<h3 id="2-21-9-层次聚类算法">2.21.9 层次聚类算法</h3>
<p>​    根据层次分解的顺序是自底向上的还是自上向下的，层次聚类算法分为凝聚的层次聚类算法和分裂的层次聚类算法。<br>
　凝聚型层次聚类的策略是先将每个对象作为一个簇，然后合并这些原子簇为越来越大的簇，直到所有对象都在一个簇中，或者某个终结条件被满足。绝大多数层次聚类属于凝聚型层次聚类，它们只是在簇间相似度的定义上有所不同。</p>
<p><strong>算法流程</strong>：</p>
<p>注：以采用最小距离的凝聚层次聚类算法为例：</p>
<p>(1) 将每个对象看作一类，计算两两之间的最小距离；<br>
　(2) 将距离最小的两个类合并成一个新类；<br>
　(3) 重新计算新类与所有类之间的距离；<br>
　(4) 重复(2)、(3)，直到所有类最后合并成一类。</p>
<h3 id="2-21-10-SOM聚类算法">2.21.10 SOM聚类算法</h3>
<p>​	SOM神经网络[11]是由芬兰神经网络专家Kohonen教授提出的，该算法假设在输入对象中存在一些拓扑结构或顺序，可以实现从输入空间(n维)到输出平面(2维)的降维映射，其映射具有拓扑特征保持性质,与实际的大脑处理有很强的理论联系。</p>
<p>​	SOM网络包含输入层和输出层。输入层对应一个高维的输入向量，输出层由一系列组织在2维网格上的有序节点构成，输入节点与输出节点通过权重向量连接。 学习过程中，找到与之距离最短的输出层单元，即获胜单元，对其更新。同时，将邻近区域的权值更新，使输出节点保持输入向量的拓扑特征。</p>
<p><strong>算法流程</strong>：</p>
<p>​	(1) 网络初始化，对输出层每个节点权重赋初值；<br>
​	(2) 从输入样本中随机选取输入向量并且归一化，找到与输入向量距离最小的权重向量；<br>
​	(3) 定义获胜单元，在获胜单元的邻近区域调整权重使其向输入向量靠拢；<br>
​	(4) 提供新样本、进行训练；<br>
​	(5) 收缩邻域半径、减小学习率、重复，直到小于允许值，输出聚类结果。</p>
<h3 id="2-21-11-FCM聚类算法">2.21.11 FCM聚类算法</h3>
<p>​	1965年美国加州大学柏克莱分校的扎德教授第一次提出了‘集合’的概念。经过十多年的发展，模糊集合理论渐渐被应用到各个实际应用方面。为克服非此即彼的分类缺点，出现了以模糊集合论为数学基础的聚类分析。用模糊数学的方法进行聚类分析，就是模糊聚类分析[12]。<br>
​	FCM算法是一种以隶属度来确定每个数据点属于某个聚类程度的算法。该聚类算法是传统硬聚类算法的一种改进。<br>
​	设数据集 $X={x_1,x_2,...,x_n}$ ,它的模糊 $c$ 划分可用模糊矩阵 $U=[u_{ij}]$ 表示，矩阵 $U$ 的元素 $u_{ij}$ 表示第 $j(j=1,2,...,n)$ 个数据点属于第 $i(i=1,2,...,c)$ 类的隶属度， $u_{ij}$ 满足如下条件：</p>
 $$
\begin{equation}
\left\{
\begin{array}{lr}
\sum_{i=1}^c u_{ij}=1 \quad\forall~j
\\u_{ij}\in[0,1] \quad\forall ~i,j
\\\sum_{j=1}^c u_{ij}>0 \quad\forall ~i
\end{array}
\right.
\end{equation}
$$ 
<p>目前被广泛使用的聚类准则是取类内加权误差平方和的极小值。即：</p>
 $$
(min)J_m(U,V)=\sum^n_{j=1}\sum^c_{i=1}u^m_{ij}d^2_{ij}(x_j,v_i)
$$ 
<p>其中 $V$ 为聚类中心， $m$ 为加权指数， $d_{ij}(x_j,v_i)=||v_i-x_j||$ 。</p>
<p><strong>算法流程</strong>：</p>
<p>(1) 标准化数据矩阵；<br>
　(2) 建立模糊相似矩阵，初始化隶属矩阵；<br>
　(3) 算法开始迭代，直到目标函数收敛到极小值；<br>
　(4) 根据迭代结果，由最后的隶属矩阵确定数据所属的类，显示最后的聚类结果。</p>
<h3 id="2-21-12-四种聚类算法试验">2.21.12 四种聚类算法试验</h3>
<p>​	选取专门用于测试分类、聚类算法的国际通用的UCI数据库中的IRIS数据集，IRIS数据集包含150个样本数据，分别取自三种不同 的莺尾属植物setosa、versicolor和virginica的花朵样本,每个数据含有4个属性，即萼片长度、萼片宽度、花瓣长度、花瓣宽度，单位为cm。 在数据集上执行不同的聚类算法，可以得到不同精度的聚类结果。基于前面描述的各算法原理及流程，可初步得如下聚类结果。</p>
<table>
<thead>
<tr>
<th>聚类方法</th>
<th>聚错样本数</th>
<th>运行时间/s</th>
<th>平均准确率/（%）</th>
</tr>
</thead>
<tbody>
<tr>
<td>K-means</td>
<td>17</td>
<td>0.146001</td>
<td>89</td>
</tr>
<tr>
<td>层次聚类</td>
<td>51</td>
<td>0.128744</td>
<td>66</td>
</tr>
<tr>
<td>SOM</td>
<td>22</td>
<td>5.267283</td>
<td>86</td>
</tr>
<tr>
<td>FCM</td>
<td>12</td>
<td>0.470417</td>
<td>92</td>
</tr>
</tbody>
</table>
<p><strong>注</strong>：</p>
<p>(1) 聚错样本数：总的聚错的样本数，即各类中聚错的样本数的和；<br>
(2) 运行时间：即聚类整个过程所耗费的时间，单位为s；<br>
(3) 平均准确度：设原数据集有k个类,用 $c_i$ 表示第i类， $n_i$ 为 $c_i$ 中样本的个数， $m_i$ 为聚类正确的个数,则 $m_i/n_i$ 为 第i类中的精度，则平均精度为： $avg=\frac{1}{k}\sum_{i=1}^{k}\frac{m_{i}}{n_{i}}$ 。</p>
<h2 id="参考文献">参考文献</h2>
<p>[1]   Goodfellow I, Bengio Y, Courville A. Deep learning[M]. MIT press, 2016.<br>
[2]   周志华. 机器学习[M].清华大学出版社, 2016.<br>
[3]   Michael A. Nielsen. “Neural Networks and Deep Learning”, Determination Press, 2015.<br>
[4]   Suryansh S. Gradient Descent: All You Need to Know, 2018.<br>
[5]   刘建平. 梯度下降小结,EM算法的推导, 2018<br>
[6]   杨小兵．聚类分析中若干关键技术的研究[D]． 杭州：浙江大学, 2005.<br>
[7]   XU Rui, Donald Wunsch 1 1． survey of clustering algorithm[J]．IEEE．Transactions on Neural Networks, 2005, 16(3)：645-67 8.<br>
[8]   YI Hong, SAM K． Learning assignment order of instances for the constrained k-means clustering algorithm[J]．IEEE Transactions on Systems, Man, and Cybernetics, Part B：Cybernetics,2009,39 (2)：568-574.<br>
[9]   贺玲, 吴玲达, 蔡益朝．数据挖掘中的聚类算法综述[J]．计算机应用研究, 2007, 24(1):10-13．<br>
[10]  孙吉贵, 刘杰, 赵连宇．聚类算法研究[J]．软件学报, 2008, 19(1)：48-61．<br>
[11]  孔英会, 苑津莎, 张铁峰等．基于数据流管理技术的配变负荷分类方法研究．中国国际供电会议, CICED2006．<br>
[12]  马晓艳, 唐雁．层次聚类算法研究[J]．计算机科学, 2008, 34(7)：34-36．<br>
[13]  FISHER R A． Iris Plants Database <a href="https://www.ics.uci.edu/vmlearn/MLRepository.html">https://www.ics.uci.edu/vmlearn/MLRepository.html</a>, Authorized license．<br>
[14]  Quinlan J R. Induction of decision trees[J]. Machine learning, 1986, 1(1): 81-106.<br>
[15]  Breiman L. Random forests[J]. Machine learning, 2001, 45(1): 5-32.</p>
</n<N)$></p></0$></p>]]></content>
      <categories>
        <category>算法面试</category>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>刷八股</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习基础面试题</title>
    <url>/2024/03/19/deep_learning/ch3/</url>
    <content><![CDATA[<h1>深度学习基础</h1>
<h2 id="3-1-基本概念">3.1 基本概念</h2>
<h3 id="3-1-1-神经网络组成？">3.1.1 神经网络组成？</h3>
<p>神经网络类型众多，其中最为重要的是多层感知机。为了详细地描述神经网络，我们先从最简单的神经网络说起。</p>
<p><strong>感知机</strong></p>
<p>多层感知机中的特征神经元模型称为感知机，由<em>Frank Rosenblatt</em>于1957年发明。</p>
<p>简单的感知机如下图所示：</p>
<p><img src="3-1.png" alt></p>
<p>其中 $x_1$ ， $x_2$ ， $x_3$ 为感知机的输入，其输出为：</p>
 $$
output = \left\{
\begin{aligned}
0, \quad if \ \ \sum_i w_i x_i \leqslant threshold \\
1, \quad if \ \ \sum_i w_i x_i > threshold
\end{aligned}
\right.
$$ 
<p>假如把感知机想象成一个加权投票机制，比如 3 位评委给一个歌手打分，打分分别为 $ 4 $ 分、 $1$  分、 $-3 $ 分，这 $ 3$  位评分的权重分别是  $1、3、2$ ，则该歌手最终得分为  $4 \times 1 + 1 \times 3 + (-3) \times 2 = 1$  。按照比赛规则，选取的  $threshold$  为  $3$ ，说明只有歌手的综合评分大于 $ 3$  时，才可顺利晋级。对照感知机，该选手被淘汰，因为：</p>
 $$
\sum_i w_i x_i < threshold=3, output = 0
$$ 
<p>用  $-b$   代替  $threshold$ ，输出变为：</p>
 $$
output = \left\{
\begin{aligned}
0, \quad if \ \ \boldsymbol{w} \cdot \boldsymbol{x} + b \leqslant 0 \\
1, \quad if \ \ \boldsymbol{w} \cdot \boldsymbol{x} + b > 0
\end{aligned}
\right.
$$ 
<p>设置合适的   $\boldsymbol{x}$   和   $b$  ，一个简单的感知机单元的与非门表示如下：</p>
<p><img src="3-2.png" alt></p>
<p>当输入为  $0$ ， $1$  时，感知机输出为  $ 0 \times (-2) + 1 \times (-2) + 3 = 1$ 。</p>
<p>复杂一些的感知机由简单的感知机单元组合而成：</p>
<p><img src="3-3.png" alt></p>
<p><strong>多层感知机</strong></p>
<p>多层感知机由感知机推广而来，最主要的特点是有多个神经元层，因此也叫深度神经网络。相比于单独的感知机，多层感知机的第  $ i $  层的每个神经元和第  $ i-1 $  层的每个神经元都有连接。</p>
<p><img src="3.1.1.5.png" alt></p>
<p>输出层可以不止有 $ 1$  个神经元。隐藏层可以只有 $ 1$  层，也可以有多层。输出层为多个神经元的神经网络例如下图所示：</p>
<p><img src="3.1.1.6.png" alt></p>
<h3 id="3-1-2-神经网络有哪些常用模型结构？">3.1.2 神经网络有哪些常用模型结构？</h3>
<p>下图包含了大部分常用的模型：</p>
<p><img src="3-7.jpg" alt></p>
<h3 id="3-1-3-如何选择深度学习开发平台？">3.1.3 如何选择深度学习开发平台？</h3>
<p>​	现有的深度学习开源平台主要有 Caffe, PyTorch, MXNet, CNTK, Theano, TensorFlow, Keras, fastai等。那如何选择一个适合自己的平台呢，下面列出一些衡量做参考。</p>
<p><strong>参考1：与现有编程平台、技能整合的难易程度</strong></p>
<p>​	主要是前期积累的开发经验和资源，比如编程语言，前期数据集存储格式等。</p>
<p><strong>参考2: 与相关机器学习、数据处理生态整合的紧密程度</strong></p>
<p>​	深度学习研究离不开各种数据处理、可视化、统计推断等软件包。考虑建模之前，是否具有方便的数据预处理工具？建模之后，是否具有方便的工具进行可视化、统计推断、数据分析。</p>
<p><strong>参考3：对数据量及硬件的要求和支持</strong></p>
<p>​	深度学习在不同应用场景的数据量是不一样的，这也就导致我们可能需要考虑分布式计算、多GPU计算的问题。例如，对计算机图像处理研究的人员往往需要将图像文件和计算任务分部到多台计算机节点上进行执行。当下每个深度学习平台都在快速发展，每个平台对分布式计算等场景的支持也在不断演进。</p>
<p><strong>参考4：深度学习平台的成熟程度</strong></p>
<p>​	成熟程度的考量是一个比较主观的考量因素，这些因素可包括：社区的活跃程度；是否容易和开发人员进行交流；当前应用的势头。</p>
<p><strong>参考5：平台利用是否多样性？</strong></p>
<p>​	有些平台是专门为深度学习研究和应用进行开发的，有些平台对分布式计算、GPU 等构架都有强大的优化，能否用这些平台/软件做其他事情？比如有些深度学习软件是可以用来求解二次型优化；有些深度学习平台很容易被扩展，被运用在强化学习的应用中。</p>
<h3 id="3-1-4-为什么使用深层表示">3.1.4 为什么使用深层表示?</h3>
<ol>
<li>深度神经网络是一种特征递进式的学习算法，浅层的神经元直接从输入数据中学习一些低层次的简单特征，例如边缘、纹理等。而深层的特征则基于已学习到的浅层特征继续学习更高级的特征，从计算机的角度学习深层的语义信息。</li>
<li>深层的网络隐藏单元数量相对较少，隐藏层数目较多，如果浅层的网络想要达到同样的计算结果则需要指数级增长的单元数量才能达到。</li>
</ol>
<h3 id="3-1-5-为什么深层神经网络难以训练？">3.1.5 为什么深层神经网络难以训练？</h3>
<ol>
<li>
<p>梯度消失<br>
梯度消失是指通过隐藏层从后向前看，梯度会变的越来越小，说明前面层的学习会显著慢于后面层的学习，所以学习会卡住，除非梯度变大。</p>
<p>​	梯度消失的原因受到多种因素影响，例如学习率的大小，网络参数的初始化，激活函数的边缘效应等。在深层神经网络中，每一个神经元计算得到的梯度都会传递给前一层，较浅层的神经元接收到的梯度受到之前所有层梯度的影响。如果计算得到的梯度值非常小，随着层数增多，求出的梯度更新信息将会以指数形式衰减，就会发生梯度消失。下图是不同隐含层的学习速率：</p>
</li>
</ol>
<p><img src="3-8.png" alt></p>
<ol start="2">
<li>
<p>梯度爆炸<br>
在深度网络或循环神经网络（Recurrent Neural Network, RNN）等网络结构中，梯度可在网络更新的过程中不断累积，变成非常大的梯度，导致网络权重值的大幅更新，使得网络不稳定；在极端情况下，权重值甚至会溢出，变为 $NaN$ 值，再也无法更新。</p>
</li>
<li>
<p>权重矩阵的退化导致模型的有效自由度减少。</p>
<p>​	参数空间中学习的退化速度减慢，导致减少了模型的有效维数，网络的可用自由度对学习中梯度范数的贡献不均衡，随着相乘矩阵的数量（即网络深度）的增加，矩阵的乘积变得越来越退化。在有硬饱和边界的非线性网络中（例如 ReLU 网络），随着深度增加，退化过程会变得越来越快。Duvenaud等人2014年的论文里展示了关于该退化过程的可视化：</p>
</li>
</ol>
<p><img src="3-9.jpg" alt></p>
<p>随着深度的增加，输入空间（左上角所示）会在输入空间中的每个点处被扭曲成越来越细的单丝，只有一个与细丝正交的方向影响网络的响应。沿着这个方向，网络实际上对变化变得非常敏感。</p>
<h3 id="3-1-6-深度学习和机器学习有什么不同？">3.1.6 深度学习和机器学习有什么不同？</h3>
<p>​	<strong>机器学习</strong>：利用计算机、概率论、统计学等知识，输入数据，让计算机学会新知识。机器学习的过程，就是训练数据去优化目标函数。</p>
<p>​	<strong>深度学习</strong>：是一种特殊的机器学习，具有强大的能力和灵活性。它通过学习将世界表示为嵌套的层次结构，每个表示都与更简单的特征相关，而抽象的表示则用于计算更抽象的表示。</p>
<p>​	传统的机器学习需要定义一些手工特征，从而有目的的去提取目标信息， 非常依赖任务的特异性以及设计特征的专家经验。而深度学习可以从大数据中先学习简单的特征，并从其逐渐学习到更为复杂抽象的深层特征，不依赖人工的特征工程，这也是深度学习在大数据时代受欢迎的一大原因。</p>
<p><img src="3.1.6.1.png" alt></p>
<p><img src="3-11.jpg" alt></p>
<h2 id="3-2-网络操作与计算">3.2 网络操作与计算</h2>
<h3 id="3-2-1-前向传播与反向传播？">3.2.1 前向传播与反向传播？</h3>
<p>神经网络的计算主要有两种：前向传播（foward propagation, FP）作用于每一层的输入，通过逐层计算得到输出结果；反向传播（backward propagation, BP）作用于网络的输出，通过计算梯度由深到浅更新网络参数。</p>
<p><strong>前向传播</strong></p>
<p><img src="3.2.1.1.png" alt></p>
<p>假设上一层结点  $ i,j,k,... $  等一些结点与本层的结点  $ w $  有连接，那么结点  $ w $  的值怎么算呢？就是通过上一层的  $ i,j,k,... $  等结点以及对应的连接权值进行加权和运算，最终结果再加上一个偏置项（图中为了简单省略了），最后在通过一个非线性函数（即激活函数），如  $ReLu$ ， $sigmoid$  等函数，最后得到的结果就是本层结点  $ w $  的输出。</p>
<p>最终不断的通过这种方法一层层的运算，得到输出层结果。</p>
<p><strong>反向传播</strong></p>
<p><img src="3.2.1.2.png" alt></p>
<p>由于我们前向传播最终得到的结果，以分类为例，最终总是有误差的，那么怎么减少误差呢，当前应用广泛的一个算法就是梯度下降算法，但是求梯度就要求偏导数，下面以图中字母为例讲解一下：</p>
<p>设最终误差为  $ E $ 且输出层的激活函数为线性激活函数，对于输出那么  $ E $  对于输出节点  $ y_l $  的偏导数是  $ y_l - t_l $ ，其中  $ t_l $  是真实值， $ \frac{\partial y_l}{\partial z_l} $  是指上面提到的激活函数， $ z_l $  是上面提到的加权和，那么这一层的  $ E $  对于  $ z_l $  的偏导数为  $ \frac{\partial E}{\partial z_l} = \frac{\partial E}{\partial y_l} \frac{\partial y_l}{\partial z_l} $ 。同理，下一层也是这么计算，只不过  $ \frac{\partial E}{\partial y_k} $  计算方法变了，一直反向传播到输入层，最后有  $ \frac{\partial E}{\partial x_i} = \frac{\partial E}{\partial y_j} \frac{\partial y_j}{\partial z_j} $ ，且  $ \frac{\partial z_j}{\partial x_i} = w_i j $ 。然后调整这些过程中的权值，再不断进行前向传播和反向传播的过程，最终得到一个比较好的结果。</p>
<h3 id="3-2-2-如何计算神经网络的输出？">3.2.2 如何计算神经网络的输出？</h3>
<p><img src="3.2.2.1.png" alt></p>
<p>如上图，输入层有三个节点，我们将其依次编号为 1、2、3；隐藏层的 4 个节点，编号依次为 4、5、6、7；最后输出层的两个节点编号为 8、9。比如，隐藏层的节点 4，它和输入层的三个节点 1、2、3 之间都有连接，其连接上的权重分别为是  $ w_{41}, w_{42}, w_{43} $ 。</p>
<p>为了计算节点 4 的输出值，我们必须先得到其所有上游节点（也就是节点 1、2、3）的输出值。节点 1、2、3 是输入层的节点，所以，他们的输出值就是输入向量本身。按照上图画出的对应关系，可以看到节点 1、2、3 的输出值分别是  $ x_1, x_2, x_3 $ 。</p>
 $$
a_4 = \sigma(w^T \cdot a) = \sigma(w_{41}x_4 + w_{42}x_2 + w_{43}a_3 + w_{4b})
$$ 
<p>其中  $ w_{4b} $  是节点 4 的偏置项。</p>
<p>同样，我们可以继续计算出节点 5、6、7 的输出值  $ a_5, a_6, a_7 $ 。</p>
<p>计算输出层的节点 8 的输出值  $ y_1 $ ：</p>
 $$
y_1 = \sigma(w^T \cdot a) = \sigma(w_{84}a_4 + w_{85}a_5 + w_{86}a_6 + w_{87}a_7 + w_{8b})
$$ 
<p>其中  $ w_{8b} $  是节点 8 的偏置项。</p>
<p>同理，我们还可以计算出  $ y_2 $ 。这样输出层所有节点的输出值计算完毕，我们就得到了在输入向量  $ x_1, x_2, x_3, x_4 $  时，神经网络的输出向量  $ y_1, y_2 $  。这里我们也看到，输出向量的维度和输出层神经元个数相同。</p>
<h3 id="3-2-3-如何计算卷积神经网络输出值？">3.2.3 如何计算卷积神经网络输出值？</h3>
<p>假设有一个 5*5 的图像，使用一个 3*3 的 filter 进行卷积，想得到一个 3*3 的 Feature Map，如下所示：</p>
<p><img src="3.2.3.1.png" alt></p>
 $ x_{i,j} $  表示图像第   $ i $  行第  $ j $  列元素。 $ w_{m,n} $  表示 filter​ 第  $ m $  行第  $ n $  列权重。  $ w_b $  表示  $filter$  的偏置项。 表 $a_i,_j$ 示 feature map 第  $ i$  行第  $ j $  列元素。  $f$  表示激活函数，这里以 $ ReLU$  函数为例。
<p>卷积计算公式如下：</p>
 $$
a_{i,j} = f(\sum_{m=0}^2 \sum_{n=0}^2 w_{m,n} x_{i+m, j+n} + w_b )
$$ 
<p>当步长为  $1$  时，计算 feature map 元素  $ a_{0,0} $  如下：</p>
 $$
a_{0,0} = f(\sum_{m=0}^2 \sum_{n=0}^2 w_{m,n} x_{0+m, 0+n} + w_b )

= relu(w_{0,0} x_{0,0} + w_{0,1} x_{0,1} + w_{0,2} x_{0,2} + w_{1,0} x_{1,0} + \\w_{1,1} x_{1,1} + w_{1,2} x_{1,2} + w_{2,0} x_{2,0} + w_{2,1} x_{2,1} + w_{2,2} x_{2,2}) \\

= 1 + 0 + 1 + 0 + 1 + 0 + 0 + 0 + 1 \\

= 4
$$ 
<p>其计算过程图示如下：</p>
<p><img src="3.2.3.2.png" alt></p>
<p>以此类推，计算出全部的Feature Map。</p>
<p><img src="3.2.3.4.png" alt></p>
<p>当步幅为 2 时，Feature Map计算如下</p>
<p><img src="3.2.3.5.png" alt></p>
<p>注：图像大小、步幅和卷积后的Feature Map大小是有关系的。它们满足下面的关系：</p>
 $$
W_2 = (W_1 - F + 2P)/S + 1\\
H_2 = (H_1 - F + 2P)/S + 1
$$ 
<p>​	其中  $ W_2 $ ， 是卷积后 Feature Map 的宽度； $ W_1 $  是卷积前图像的宽度； $ F $  是 filter 的宽度； $ P $  是 Zero Padding 数量，Zero Padding 是指在原始图像周围补几圈  $0$ ，如果  $P$  的值是  $1$ ，那么就补  $1$  圈  $0$ ； $S$  是步幅； $ H_2 $  卷积后 Feature Map 的高度； $ H_1 $  是卷积前图像的宽度。</p>
<p>​	举例：假设图像宽度  $ W_1 = 5 $ ，filter 宽度  $ F=3 $ ，Zero Padding  $ P=0 $ ，步幅  $ S=2 $ ， $ Z $  则</p>
 $$
W_2 = (W_1 - F + 2P)/S + 1

= (5-3+0)/2 + 1

= 2
$$ 
<p>​	说明 Feature Map 宽度是2。同样，我们也可以计算出 Feature Map 高度也是 2。</p>
<p>如果卷积前的图像深度为  $ D $ ，那么相应的 filter 的深度也必须为  $ D $ 。深度大于 1 的卷积计算公式：</p>
 $$
a_{i,j} = f(\sum_{d=0}^{D-1} \sum_{m=0}^{F-1} \sum_{n=0}^{F-1} w_{d,m,n} x_{d,i+m,j+n} + w_b)
$$ 
<p>​	其中， $ D $  是深度； $ F $  是 filter 的大小； $ w_{d,m,n} $  表示 filter 的第  $ d $  层第  $ m $  行第  $ n $  列权重； $ a_{d,i,j} $  表示 feature map 的第  $ d $  层第  $ i $  行第  $ j $  列像素；其它的符号含义前面相同，不再赘述。</p>
<p>​	每个卷积层可以有多个 filter。每个 filter 和原始图像进行卷积后，都可以得到一个 Feature Map。卷积后 Feature Map 的深度(个数)和卷积层的 filter 个数相同。下面的图示显示了包含两个 filter 的卷积层的计算。 $7*7*3$  输入，经过两个  $3*3*3$  filter 的卷积(步幅为  $2$ )，得到了  $3*3*2$  的输出。图中的 Zero padding 是  $1$ ，也就是在输入元素的周围补了一圈  $0$ 。</p>
<p><img src="3.2.3.6.png" alt></p>
<p>​	以上就是卷积层的计算方法。这里面体现了局部连接和权值共享：每层神经元只和上一层部分神经元相连(卷积计算规则)，且 filter 的权值对于上一层所有神经元都是一样的。对于包含两个  $ 3 * 3 * 3 $  的 fitler 的卷积层来说，其参数数量仅有  $ (3 * 3 * 3+1) * 2 = 56 $  个，且参数数量与上一层神经元个数无关。与全连接神经网络相比，其参数数量大大减少了。</p>
<h3 id="3-2-4-如何计算-Pooling-层输出值输出值？">3.2.4 如何计算 Pooling 层输出值输出值？</h3>
<p>​	Pooling 层主要的作用是下采样，通过去掉 Feature Map 中不重要的样本，进一步减少参数数量。Pooling 的方法很多，最常用的是 Max Pooling。Max Pooling 实际上就是在 n*n 的样本中取最大值，作为采样后的样本值。下图是 2*2 max pooling：</p>
<p><img src="3.2.4.1.png" alt></p>
<p>​	除了 Max Pooing 之外，常用的还有 Average Pooling ——取各样本的平均值。<br>
​	对于深度为  $ D $  的 Feature Map，各层独立做 Pooling，因此 Pooling 后的深度仍然为  $ D $ 。</p>
<h3 id="3-2-5-实例理解反向传播">3.2.5 实例理解反向传播</h3>
<p>​	一个典型的三层神经网络如下所示：</p>
<p><img src="3.2.5.1.png" alt></p>
<p>​	其中 Layer  $ L_1 $  是输入层，Layer  $ L_2 $  是隐含层，Layer  $ L_3 $  是输出层。</p>
<p>​	假设输入数据集为  $ D={x_1, x_2, ..., x_n} $ ，输出数据集为  $ y_1, y_2, ..., y_n $ 。</p>
<p>​	如果输入和输出是一样，即为自编码模型。如果原始数据经过映射，会得到不同于输入的输出。</p>
<p>假设有如下的网络层：</p>
<p><img src="3.2.5.2.png" alt></p>
<p>​	输入层包含神经元  $ i_1, i_2 $ ，偏置  $ b_1 $ ；隐含层包含神经元  $ h_1, h_2 $ ，偏置  $ b_2 $ ，输出层为   $ o_1, o_2 $ ， $ w_i $  为层与层之间连接的权重，激活函数为  $sigmoid$  函数。对以上参数取初始值，如下图所示：</p>
<p><img src="3.2.5.3.png" alt></p>
<p>其中：</p>
<ul>
<li>输入数据  $ i1=0.05, i2 = 0.10 $</li>
<li>输出数据  $ o1=0.01, o2=0.99 $ ;</li>
<li>初始权重  $ w1=0.15, w2=0.20, w3=0.25,w4=0.30, w5=0.40, w6=0.45, w7=0.50, w8=0.55 $</li>
<li>目标：给出输入数据  $ i1,i2 $  (  $0.05$ 和 $0.10$  )，使输出尽可能与原始输出  $ o1,o2 $ ，(  $0.01$ 和 $0.99$ )接近。</li>
</ul>
<p><strong>前向传播</strong></p>
<ol>
<li>输入层 --&gt; 输出层</li>
</ol>
<p>计算神经元  $ h1 $  的输入加权和：</p>
 $$
net_{h1} = w_1 * i_1 + w_2 * i_2 + b_1 * 1\\

net_{h1} = 0.15 * 0.05 + 0.2 * 0.1 + 0.35 * 1 = 0.3775
$$ 
<p>神经元  $ h1 $  的输出  $ o1 $  ：（此处用到激活函数为 sigmoid 函数）：</p>
 $$
out_{h1} = \frac{1}{1 + e^{-net_{h1}}} = \frac{1}{1 + e^{-0.3775}} = 0.593269992
$$ 
<p>同理，可计算出神经元  $ h2 $  的输出  $ o1 $ ：</p>
 $$
out_{h2} = 0.596884378
$$ 
<ol start="2">
<li>隐含层–&gt;输出层：</li>
</ol>
<p>计算输出层神经元  $ o1 $  和  $ o2 $  的值：</p>
 $$
net_{o1} = w_5 * out_{h1} + w_6 * out_{h2} + b_2 * 1
$$ 
 $$
net_{o1} = 0.4 * 0.593269992 + 0.45 * 0.596884378 + 0.6 * 1 = 1.105905967
$$ 
 $$
out_{o1} = \frac{1}{1 + e^{-net_{o1}}} = \frac{1}{1 + e^{1.105905967}} = 0.75136079
$$ 
<p>这样前向传播的过程就结束了，我们得到输出值为  $ [0.75136079 ,  0.772928465] $ ，与实际值  $ [0.01 , 0.99] $  相差还很远，现在我们对误差进行反向传播，更新权值，重新计算输出。</p>
<p>**反向传播 **</p>
<p>​	1.计算总误差</p>
<p>总误差：(这里使用Square Error)</p>
 $$
E_{total} = \sum \frac{1}{2}(target - output)^2
$$ 
<p>但是有两个输出，所以分别计算  $ o1 $  和  $ o2 $  的误差，总误差为两者之和：</p>
 $E_{o1} = \frac{1}{2}(target_{o1} - out_{o1})^2 
= \frac{1}{2}(0.01 - 0.75136507)^2 = 0.274811083$ .
 $E_{o2} = 0.023560026$ .
 $E_{total} = E_{o1} + E_{o2} = 0.274811083 + 0.023560026 = 0.298371109$ .
<p>​	2.隐含层 --&gt; 输出层的权值更新：</p>
<p>以权重参数  $ w5 $  为例，如果我们想知道  $ w5 $  对整体误差产生了多少影响，可以用整体误差对  $ w5 $  求偏导求出：（链式法则）</p>
 $$
\frac{\partial E_{total}}{\partial w5} = \frac{\partial E_{total}}{\partial out_{o1}} * \frac{\partial out_{o1}}{\partial net_{o1}} * \frac{\partial net_{o1}}{\partial w5}
$$ 
<p>下面的图可以更直观的看清楚误差是怎样反向传播的：</p>
<p><img src="3.2.5.4.png" alt></p>
<h3 id="3-2-6-神经网络更“深”有什么意义？">3.2.6 神经网络更“深”有什么意义？</h3>
<p>前提：在一定范围内。</p>
<ul>
<li>在神经元数量相同的情况下，深层网络结构具有更大容量，分层组合带来的是指数级的表达空间，能够组合成更多不同类型的子结构，这样可以更容易地学习和表示各种特征。</li>
<li>隐藏层增加则意味着由激活函数带来的非线性变换的嵌套层数更多，就能构造更复杂的映射关系。</li>
</ul>
<h2 id="3-3-超参数">3.3 超参数</h2>
<h3 id="3-3-1-什么是超参数？">3.3.1 什么是超参数？</h3>
<p>​	<strong>超参数</strong> : 在机器学习的上下文中，超参数是在开始学习过程之前设置值的参数，而不是通过训练得到的参数数据。通常情况下，需要对超参数进行优化，给学习机选择一组最优超参数，以提高学习的性能和效果。</p>
<p>​	超参数通常存在于：</p>
<pre><code>1.  定义关于模型的更高层次的概念，如复杂性或学习能力。
2.  不能直接从标准模型培训过程中的数据中学习，需要预先定义。
3.  可以通过设置不同的值，训练不同的模型和选择更好的测试值来决定
</code></pre>
<p>​	超参数具体来讲比如算法中的学习率（learning rate）、梯度下降法迭代的数量（iterations）、隐藏层数目（hidden layers）、隐藏层单元数目、激活函数（ activation function）都需要根据实际情况来设置，这些数字实际上控制了最后的参数和的值，所以它们被称作超参数。</p>
<h3 id="3-3-2-如何寻找超参数的最优值？">3.3.2 如何寻找超参数的最优值？</h3>
<p>​	在使用机器学习算法时，总有一些难调的超参数。例如权重衰减大小，高斯核宽度等等。这些参数需要人为设置，设置的值对结果产生较大影响。常见设置超参数的方法有：</p>
<ol>
<li>
<p>猜测和检查：根据经验或直觉，选择参数，一直迭代。</p>
</li>
<li>
<p>网格搜索：让计算机尝试在一定范围内均匀分布的一组值。</p>
</li>
<li>
<p>随机搜索：让计算机随机挑选一组值。</p>
</li>
<li>
<p>贝叶斯优化：使用贝叶斯优化超参数，会遇到贝叶斯优化算法本身就需要很多的参数的困难。</p>
</li>
<li>
<p>MITIE方法，好初始猜测的前提下进行局部优化。它使用BOBYQA算法，并有一个精心选择的起始点。由于BOBYQA只寻找最近的局部最优解，所以这个方法是否成功很大程度上取决于是否有一个好的起点。在MITIE的情况下，我们知道一个好的起点，但这不是一个普遍的解决方案，因为通常你不会知道好的起点在哪里。从好的方面来说，这种方法非常适合寻找局部最优解。稍后我会再讨论这一点。</p>
</li>
<li>
<p>最新提出的LIPO的全局优化方法。这个方法没有参数，而且经验证比随机搜索方法好。</p>
</li>
</ol>
<h3 id="3-3-3-超参数搜索一般过程？">3.3.3 超参数搜索一般过程？</h3>
<p>超参数搜索一般过程：</p>
<ol>
<li>将数据集划分成训练集、验证集及测试集。</li>
<li>在训练集上根据模型的性能指标对模型参数进行优化。</li>
<li>在验证集上根据模型的性能指标对模型的超参数进行搜索。</li>
<li>步骤 2 和步骤 3 交替迭代，最终确定模型的参数和超参数，在测试集中验证评价模型的优劣。</li>
</ol>
<p>其中，搜索过程需要搜索算法，一般有：网格搜索、随机搜过、启发式智能搜索、贝叶斯搜索。</p>
<h2 id="3-4-激活函数">3.4 激活函数</h2>
<h3 id="3-4-1-为什么需要非线性激活函数？">3.4.1 为什么需要非线性激活函数？</h3>
<p><strong>为什么需要激活函数？</strong></p>
<ol>
<li>激活函数对模型学习、理解非常复杂和非线性的函数具有重要作用。</li>
<li>激活函数可以引入非线性因素。如果不使用激活函数，则输出信号仅是一个简单的线性函数。线性函数一个一级多项式，线性方程的复杂度有限，从数据中学习复杂函数映射的能力很小。没有激活函数，神经网络将无法学习和模拟其他复杂类型的数据，例如图像、视频、音频、语音等。</li>
<li>激活函数可以把当前特征空间通过一定的线性映射转换到另一个空间，让数据能够更好的被分类。</li>
</ol>
<p><strong>为什么激活函数需要非线性函数？</strong></p>
<ol>
<li>假若网络中全部是线性部件，那么线性的组合还是线性，与单独一个线性分类器无异。这样就做不到用非线性来逼近任意函数。</li>
<li>使用非线性激活函数 ，以便使网络更加强大，增加它的能力，使它可以学习复杂的事物，复杂的表单数据，以及表示输入输出之间非线性的复杂的任意函数映射。使用非线性激活函数，能够从输入输出之间生成非线性映射。</li>
</ol>
<h3 id="3-4-2-常见的激活函数及图像">3.4.2 常见的激活函数及图像</h3>
<ol>
<li>
<p>sigmoid 激活函数</p>
<p>函数的定义为： $ f(x) = \frac{1}{1 + e^{-x}} $ ，其值域为  $ (0,1) $ 。</p>
<p>函数图像如下：</p>
</li>
</ol>
<p><img src="3-26.png" alt></p>
<ol start="2">
<li>
<p>tanh激活函数</p>
<p>函数的定义为： $ f(x) = tanh(x) = \frac{e^x - e^{-x}}{e^x + e^{-x}} $ ，值域为  $ (-1,1) $ 。</p>
<p>函数图像如下：</p>
</li>
</ol>
<p><img src="3-27.png" alt></p>
<ol start="3">
<li>
<p>Relu激活函数</p>
<p>函数的定义为： $ f(x) = max(0, x) $   ，值域为  $ [0,+∞) $ ；</p>
<p>函数图像如下：</p>
</li>
</ol>
<p><img src="3-28.png" alt></p>
<ol start="4">
<li>
<p>Leak Relu 激活函数</p>
<p>函数定义为：  $ f(x) =  \left\{
   \begin{aligned}
   ax, \quad x<0 \\ x, \quad x>0
   \end{aligned}
   \right. $ ，值域为  $ (-∞,+∞) $ 。</0></p>
<p>图像如下（ $ a = 0.5 $ ）：</p>
</li>
</ol>
<p><img src="3-29.png" alt></p>
<ol start="5">
<li>
<p>SoftPlus 激活函数</p>
<p>函数的定义为： $ f(x) = ln( 1 + e^x) $ ，值域为  $ (0,+∞) $ 。</p>
<p>函数图像如下:</p>
</li>
</ol>
<p><img src="3-30.png" alt></p>
<ol start="6">
<li>
<p>softmax 函数</p>
<p>函数定义为：  $ \sigma(z)_j = \frac{e^{z_j}}{\sum_{k=1}^K e^{z_k}} $ 。</p>
<p>Softmax 多用于多分类神经网络输出。</p>
</li>
</ol>
<h3 id="3-4-3-常见激活函数的导数计算？">3.4.3 常见激活函数的导数计算？</h3>
<p>对常见激活函数，导数计算如下：</p>
<table>
<thead>
<tr>
<th>原函数</th>
<th>函数表达式</th>
<th>导数</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>Sigmoid激活函数</td>
<td>$f(x)=\frac{1}{1+e^{-x}}$</td>
<td>$f^{'}(x)=\frac{1}{1+e^{-x}}\left( 1- \frac{1}{1+e^{-x}} \right)=f(x)(1-f(x))$</td>
<td>当 $x=10$ ,或 $x=-10​$ ， $f^{'}(x) \approx0​$ ,当 $x=0​ {% raw%}$$f^{'}(x) =0.25​${% endraw %}</td>
</tr>
<tr>
<td>Tanh激活函数</td>
<td>{% raw%}$f(x)=tanh(x)=\frac{e^x-e^{-x}}{e^x+e^{-x}}${% endraw %}</td>
<td>{% raw%}$f^{'}(x)=-(tanh(x))^2${% endraw %}</td>
<td>当 {% raw%}$x=10${% endraw %} ,或 {% raw%}$x=-10${% endraw %} ， {% raw%}$f^{'}(x) \approx0${% endraw %} ,当 {% raw%}$x=0$${% endraw %} f^{`}(x) =1$</td>
</tr>
<tr>
<td>Relu激活函数</td>
<td>$f(x)=max(0,x)$</td>
<td>$c(u)=\begin{cases} 0,x<0 \\ 1,x>0 \\ undefined,x=0\end{cases}$</0></td>
<td>通常 $x=0$ 时，给定其导数为1和0</td>
</tr>
</tbody>
</table>
<h3 id="3-4-4-激活函数有哪些性质？">3.4.4 激活函数有哪些性质？</h3>
<ol>
<li>非线性： 当激活函数是非线性的，一个两层的神经网络就可以基本上逼近所有的函数。但如果激活函数是恒等激活函数的时候，即  $ f(x)=x $ ，就不满足这个性质，而且如果 MLP 使用的是恒等激活函数，那么其实整个网络跟单层神经网络是等价的；</li>
<li>可微性： 当优化方法是基于梯度的时候，就体现了该性质；</li>
<li>单调性： 当激活函数是单调的时候，单层网络能够保证是凸函数；</li>
<li>
$ f(x)≈x $ ： 当激活函数满足这个性质的时候，如果参数的初始化是随机的较小值，那么神经网络的训练将会很高效；如果不满足这个性质，那么就需要详细地去设置初始值；
</li>
<li>输出值的范围： 当激活函数输出值是有限的时候，基于梯度的优化方法会更加稳定，因为特征的表示受有限权值的影响更显著；当激活函数的输出是无限的时候，模型的训练会更加高效，不过在这种情况小，一般需要更小的 Learning Rate。</li>
</ol>
<h3 id="3-4-5-如何选择激活函数？">3.4.5 如何选择激活函数？</h3>
<p>​	选择一个适合的激活函数并不容易，需要考虑很多因素，通常的做法是，如果不确定哪一个激活函数效果更好，可以把它们都试试，然后在验证集或者测试集上进行评价。然后看哪一种表现的更好，就去使用它。</p>
<p>以下是常见的选择情况：</p>
<ol>
<li>如果输出是 0、1 值（二分类问题），则输出层选择 sigmoid 函数，然后其它的所有单元都选择 Relu 函数。</li>
<li>如果在隐藏层上不确定使用哪个激活函数，那么通常会使用 Relu 激活函数。有时，也会使用 tanh 激活函数，但 Relu 的一个优点是：当是负值的时候，导数等于 0。</li>
<li>sigmoid 激活函数：除了输出层是一个二分类问题基本不会用它。</li>
<li>tanh 激活函数：tanh 是非常优秀的，几乎适合所有场合。</li>
<li>ReLu 激活函数：最常用的默认函数，如果不确定用哪个激活函数，就使用 ReLu 或者 Leaky ReLu，再去尝试其他的激活函数。</li>
<li>如果遇到了一些死的神经元，我们可以使用 Leaky ReLU 函数。</li>
</ol>
<h3 id="3-4-6-使用-ReLu-激活函数的优点？">3.4.6 使用 ReLu 激活函数的优点？</h3>
<ol>
<li>在区间变动很大的情况下，ReLu 激活函数的导数或者激活函数的斜率都会远大于 0，在程序实现就是一个 if-else 语句，而 sigmoid 函数需要进行浮点四则运算，在实践中，使用 ReLu 激活函数神经网络通常会比使用 sigmoid 或者 tanh 激活函数学习的更快。</li>
<li>sigmoid 和 tanh 函数的导数在正负饱和区的梯度都会接近于 0，这会造成梯度弥散，而 Relu 和Leaky ReLu 函数大于 0 部分都为常数，不会产生梯度弥散现象。</li>
<li>需注意，Relu 进入负半区的时候，梯度为 0，神经元此时不会训练，产生所谓的稀疏性，而 Leaky ReLu 不会产生这个问题。</li>
</ol>
<h3 id="3-4-7-什么时候可以用线性激活函数？">3.4.7 什么时候可以用线性激活函数？</h3>
<ol>
<li>输出层，大多使用线性激活函数。</li>
<li>在隐含层可能会使用一些线性激活函数。</li>
<li>一般用到的线性激活函数很少。</li>
</ol>
<h3 id="3-4-8-怎样理解-Relu（-0-时）是非线性激活函数？">3.4.8 怎样理解 Relu（&lt; 0 时）是非线性激活函数？</h3>
<p>Relu 激活函数图像如下：</p>
<p><img src="3-32.png" alt></p>
<p>根据图像可看出具有如下特点：</p>
<ol>
<li>
<p>单侧抑制；</p>
</li>
<li>
<p>相对宽阔的兴奋边界；</p>
</li>
<li>
<p>稀疏激活性；</p>
<p>ReLU 函数从图像上看，是一个分段线性函数，把所有的负值都变为 0，而正值不变，这样就成为单侧抑制。</p>
<p>因为有了这单侧抑制，才使得神经网络中的神经元也具有了稀疏激活性。</p>
<p><strong>稀疏激活性</strong>：从信号方面来看，即神经元同时只对输入信号的少部分选择性响应，大量信号被刻意的屏蔽了，这样可以提高学习的精度，更好更快地提取稀疏特征。当  $ x<0 $ 时，relu 硬饱和，而当 x>0 $  时，则不存在饱和问题。ReLU 能够在  $ x>0 $  时保持梯度不衰减，从而缓解梯度消失问题。</0></p>
</li>
</ol>
<h3 id="3-4-9-Softmax-定义及作用">3.4.9 Softmax 定义及作用</h3>
<p>Softmax 是一种形如下式的函数：</p>
 $$
P(i) = \frac{exp(\theta_i^T x)}{\sum_{k=1}^{K} exp(\theta_i^T x)}
$$ 
<p>​	其中， $ \theta_i $  和  $ x $  是列向量， $ \theta_i^T x $  可能被换成函数关于  $ x $  的函数  $ f_i(x) $</p>
<p>​	通过 softmax 函数，可以使得  $ P(i) $  的范围在  $ [0,1] $  之间。在回归和分类问题中，通常  $ \theta $  是待求参数，通过寻找使得  $ P(i) $  最大的  $ \theta_i $  作为最佳参数。</p>
<p>​	但是，使得范围在  $ [0,1] $   之间的方法有很多，为啥要在前面加上以  $ e $  的幂函数的形式呢？参考 logistic 函数：</p>
 $$
P(i) = \frac{1}{1+exp(-\theta_i^T x)}
$$ 
<p>​	这个函数的作用就是使得  $ P(i) $  在负无穷到 0 的区间趋向于 0， 在 0 到正无穷的区间趋向 1,。同样 softmax 函数加入了  $ e $  的幂函数正是为了两极化：正样本的结果将趋近于 1，而负样本的结果趋近于 0。这样为多类别提供了方便（可以把  $ P(i) $  看做是样本属于类别的概率）。可以说，Softmax 函数是 logistic 函数的一种泛化。</p>
<p>​	softmax 函数可以把它的输入，通常被称为 logits 或者 logit scores，处理成 0 到 1 之间，并且能够把输出归一化到和为 1。这意味着 softmax 函数与分类的概率分布等价。它是一个网络预测多酚类问题的最佳输出激活函数。</p>
<h3 id="3-4-10-Softmax-函数如何应用于多分类？">3.4.10 Softmax 函数如何应用于多分类？</h3>
<p>​	softmax 用于多分类过程中，它将多个神经元的输出，映射到  $ (0,1) $  区间内，可以看成概率来理解，从而来进行多分类！</p>
<p>​	假设我们有一个数组， $ V_i $  表示  $ V $   中的第  $ i $  个元素，那么这个元素的 softmax 值就是</p>
 $$
S_i = \frac{e^{V_i}}{\sum_j e^{V_j}}
$$ 
<p>​	从下图看，神经网络中包含了输入层，然后通过两个特征层处理，最后通过 softmax 分析器就能得到不同条件下的概率，这里需要分成三个类别，最终会得到  $ y=0, y=1, y=2 $  的概率值。</p>
<p><img src="3.4.9.1.png" alt></p>
<p>继续看下面的图，三个输入通过 softmax 后得到一个数组  $ [0.05 , 0.10 , 0.85] $ ，这就是 soft 的功能。</p>
<p><img src="3.4.9.2.png" alt></p>
<p>更形象的映射过程如下图所示：</p>
<p><img src="3.4.9.3.png" alt="****"></p>
<p>​	softmax 直白来说就是将原来输出是  $ 3,1,-3 $  通过 softmax 函数一作用，就映射成为  $ (0,1) $  的值，而这些值的累和为  $ 1 $ （满足概率的性质），那么我们就可以将它理解成概率，在最后选取输出结点的时候，我们就可以选取概率最大（也就是值对应最大的）结点，作为我们的预测目标！</p>
<h3 id="3-4-11-交叉熵代价函数定义及其求导推导">3.4.11 交叉熵代价函数定义及其求导推导</h3>
<p>(<strong>贡献者：黄钦建－华南理工大学</strong>)</p>
<p>​	神经元的输出就是 a = σ(z)，其中 $z=\sum w_{j}i_{j}+b$ 是输⼊的带权和。</p>
 $C=-\frac{1}{n}\sum[ylna+(1-y)ln(1-a)]$ 
<p>​	其中 n 是训练数据的总数，求和是在所有的训练输⼊ x 上进⾏的， y 是对应的⽬标输出。</p>
<p>​	表达式是否解决学习缓慢的问题并不明显。实际上，甚⾄将这个定义看做是代价函数也不是显⽽易⻅的！在解决学习缓慢前，我们来看看交叉熵为何能够解释成⼀个代价函数。</p>
<p>​	将交叉熵看做是代价函数有两点原因。</p>
<p>​	第⼀，它是⾮负的， C &gt; 0。可以看出：式子中的求和中的所有独⽴的项都是负数的，因为对数函数的定义域是 (0，1)，并且求和前⾯有⼀个负号，所以结果是非负。</p>
<p>​	第⼆，如果对于所有的训练输⼊ x，神经元实际的输出接近⽬标值，那么交叉熵将接近 0。</p>
<p>​	假设在这个例⼦中， y = 0 ⽽ a ≈ 0。这是我们想到得到的结果。我们看到公式中第⼀个项就消去了，因为 y = 0，⽽第⼆项实际上就是 − ln(1 − a) ≈ 0。反之， y = 1 ⽽ a ≈ 1。所以在实际输出和⽬标输出之间的差距越⼩，最终的交叉熵的值就越低了。（这里假设输出结果不是0，就是1，实际分类也是这样的）</p>
<p>​	综上所述，交叉熵是⾮负的，在神经元达到很好的正确率的时候会接近 0。这些其实就是我们想要的代价函数的特性。其实这些特性也是⼆次代价函数具备的。所以，交叉熵就是很好的选择了。但是交叉熵代价函数有⼀个⽐⼆次代价函数更好的特性就是它避免了学习速度下降的问题。为了弄清楚这个情况，我们来算算交叉熵函数关于权重的偏导数。我们将 $a={\varsigma}(z)$ 代⼊到 公式中应⽤两次链式法则，得到：</p>
 $\begin{eqnarray}\frac{\partial C}{\partial w_{j}}&=&-\frac{1}{n}\sum \frac{\partial }{\partial w_{j}}[ylna+(1-y)ln(1-a)]\\&=&-\frac{1}{n}\sum \frac{\partial }{\partial a}[ylna+(1-y)ln(1-a)]*\frac{\partial a}{\partial w_{j}}\\&=&-\frac{1}{n}\sum (\frac{y}{a}-\frac{1-y}{1-a})*\frac{\partial a}{\partial w_{j}}\\&=&-\frac{1}{n}\sum (\frac{y}{\varsigma(z)}-\frac{1-y}{1-\varsigma(z)})\frac{\partial \varsigma(z)}{\partial w_{j}}\\&=&-\frac{1}{n}\sum (\frac{y}{\varsigma(z)}-\frac{1-y}{1-\varsigma(z)}){\varsigma}'(z)x_{j}\end{eqnarray}$ 
<p>​	根据 $\varsigma(z)=\frac{1}{1+e^{-z}}$  的定义，和⼀些运算，我们可以得到  ${\varsigma}'(z)=\varsigma(z)(1-\varsigma(z))$ 。化简后可得：</p>
 $\frac{\partial C}{\partial w_{j}}=\frac{1}{n}\sum x_{j}({\varsigma}(z)-y)$ 
<p>​	这是⼀个优美的公式。它告诉我们权重学习的速度受到 $\varsigma(z)-y$ ，也就是输出中的误差的控制。更⼤的误差，更快的学习速度。这是我们直觉上期待的结果。特别地，这个代价函数还避免了像在⼆次代价函数中类似⽅程中 ${\varsigma}'(z)$ 导致的学习缓慢。当我们使⽤交叉熵的时候， ${\varsigma}'(z)$ 被约掉了，所以我们不再需要关⼼它是不是变得很⼩。这种约除就是交叉熵带来的特效。实际上，这也并不是⾮常奇迹的事情。我们在后⾯可以看到，交叉熵其实只是满⾜这种特性的⼀种选择罢了。</p>
<p>​	根据类似的⽅法，我们可以计算出关于偏置的偏导数。我这⾥不再给出详细的过程，你可以轻易验证得到：</p>
 $\frac{\partial C}{\partial b}=\frac{1}{n}\sum ({\varsigma}(z)-y)$ 
<p>​	再⼀次, 这避免了⼆次代价函数中类似 ${\varsigma}'(z)$ 项导致的学习缓慢。</p>
<h3 id="3-4-12-为什么Tanh收敛速度比Sigmoid快？">3.4.12 为什么Tanh收敛速度比Sigmoid快？</h3>
<p><strong>（贡献者：黄钦建－华南理工大学）</strong></p>
<p>首先看如下两个函数的求导：</p>
 $tanh^{,}(x)=1-tanh(x)^{2}\in (0,1)$ 
 $s^{,}(x)=s(x)*(1-s(x))\in (0,\frac{1}{4}]$ 
<p>由上面两个公式可知tanh(x)梯度消失的问题比sigmoid轻，所以Tanh收敛速度比Sigmoid快。</p>
<p><strong>（贡献者：郜泉凯 - 华南理工大学）</strong></p>
<p>注：梯度消失（gradient vanishing）或者爆炸（gradient explosion）是激活函数<strong>以及当前权重</strong>耦合产生的综合结果：<br>
​   设任意激活函数为 $\sigma(\cdot)$ ，k+1层网络输出为 $f_{k+1}=\sigma(Wf_k)$ ，求导得到 $\frac {\partial h_{t+1}}{\partial h_t}=diag(\sigma'(Wh_t))W$ 。可见求导结果同时会受到权重 $W$ 和激活函数的导数 $\sigma'(\cdot)$ 的影响，以sigmoid函数 $\sigma(X)=\frac {1}{1+e^{-x}}$ 为例，其导数为 $\sigma'(x)=\frac{1}{1+e^{-x}}(1-\frac{1}{1+e^{-x}})$ ，其值恒大于零小于1，用链式法则求梯度回传时连续相乘使得结果趋于0，但是如果权重 $W$ 是较大的数值，使得 $\frac {\partial f_{t+1}}{\partial f_t}$ 相乘结果大于1，则梯度回传时连续相乘则不会发生梯度消失。<br>
综上，在讨论激活函数收敛速度或与梯度消失或者爆炸相关时，应同时考虑当前权重 $W$ 数值的影响。</p>
<p>3.4.13</p>
<h3 id="3-4-12-内聚外斥-Center-Loss">3.4.12 内聚外斥 - Center Loss</h3>
<p><strong>（贡献者：李世轩－加州大学伯克利分校）</strong></p>
<p>在计算机视觉任务中, 由于其简易性, 良好的表现, 与对分类任务的概率性理解, Cross Entropy Loss (交叉熵代价) + Softmax 组合被广泛应用于以分类任务为代表的任务中. 在此应用下, 我们可将其学习过程进一步理解为: 更相似(同类/同物体)的图像在特征域中拥有“更近的距离”, 相反则”距离更远“. 换而言之, 我们可以进一步理解为其学习了一种低类内距离(Intra-class Distance)与高类间距离(Inter-class Distance)的特征判别模型. 在此Center Loss则可以高效的计算出这种具判别性的特征. 不同于传统的Softmax Loss, Center Loss通过学习“特征中心”从而最小化其类内距离. 其表达形式如下:</p>
 $L_{C} = \frac{1}{2}\sum^{m}_{i=1}||x_{i}-c_{y_{i}}||^{2}_{2}$ 
<p>其中 $x_{i}$ 表示FCN(全连接层)之前的特征,  $c_{y_{i}}$ 表示第 $y_{i} $ 个类别的特征中心,  $m$ 表示mini-batch的大小. 我们很清楚的看到 $L_{C}$ 的终极目标为最小化每个特征与其特征中心的方差, 即最小化类内距离. 其迭代公式为:</p>
 $\frac{\partial L_{C}}{\partial x_{i}}=x_{i}-c_{y_{i}}$ 
 $\Delta{c_{j}} = \frac{\sum^{m}_{i=1}\delta(y_{i}=j)\cdot(c_{j}-x_{i})}{1+\sum^{m}_{i=1}\delta(y_{i}=j)}$ 
<p>其中 $ \delta(condition)=\left\{
\begin{array}{rcl}
1       &      & {condition\ is\ True}\\
0     &      & {otherwise}\\ \end{array} \right.$</p>
<p>结合Softmax, 我们可以搭配二者使用, 适当平衡这两种监督信号. 在Softmax拉开类间距离的同时, 利用Center Loss最小化类内距离. 例如:</p>
 $\begin{eqnarray}L & = & L_{S} + \lambda L_{C} \\ &=& -\sum^{m}_{i=1}log\frac{e^{W_{y}^{T}x_{i}+b_{y_{i}}}}{\sum^{m}_{i=1}e^{W^{T}_{j}x_{i}+b_{j}}} + \frac{\lambda}{2}\sum^{m}_{i=1}||x_{i}-c_{y_{i}}||^{2}_{2}\\ \end{eqnarray}$ 
<p>即便如此, Center Loss仍有它的不足之处: 其特征中心为存储在网络模型之外的额外参数, 不能与模型参数一同优化. 这些额外参数将与记录每一步特征变化的自动回归均值估计(autoregressive mean estimator)进行更迭. 当需要学习的类别数量较大时, mini-batch可能无力提供足够的样本进行均值估计. 若此Center Loss将需要平衡两种监督损失来以确定更迭, 其过程需要一个对平衡超参数的搜索过程, 使得其择值消耗昂贵.</p>
<h2 id="3-5-Batch-Size">3.5 Batch_Size</h2>
<h3 id="3-5-1-为什么需要-Batch-Size？">3.5.1 为什么需要 Batch_Size？</h3>
<p>Batch的选择，首先决定的是下降的方向。</p>
<p>如果数据集比较小，可采用全数据集的形式，好处是：</p>
<ol>
<li>由全数据集确定的方向能够更好地代表样本总体，从而更准确地朝向极值所在的方向。</li>
<li>由于不同权重的梯度值差别巨大，因此选取一个全局的学习率很困难。 Full Batch Learning 可以使用 Rprop 只基于梯度符号并且针对性单独更新各权值。</li>
</ol>
<p>对于更大的数据集，假如采用全数据集的形式，坏处是：</p>
<ol>
<li>随着数据集的海量增长和内存限制，一次性载入所有的数据进来变得越来越不可行。</li>
<li>以 Rprop 的方式迭代，会由于各个 Batch 之间的采样差异性，各次梯度修正值相互抵消，无法修正。这才有了后来 RMSProp 的妥协方案。</li>
</ol>
<h3 id="3-5-2-Batch-Size-值的选择">3.5.2 Batch_Size 值的选择</h3>
<p>​	假如每次只训练一个样本，即 Batch_Size = 1。线性神经元在均方误差代价函数的错误面是一个抛物面，横截面是椭圆。对于多层神经元、非线性网络，在局部依然近似是抛物面。此时，每次修正方向以各自样本的梯度方向修正，横冲直撞各自为政，难以达到收敛。</p>
<p>​	既然 Batch_Size 为全数据集或者Batch_Size = 1都有各自缺点，可不可以选择一个适中的Batch_Size值呢？</p>
<p>​	此时，可采用批梯度下降法（Mini-batches Learning）。因为如果数据集足够充分，那么用一半（甚至少得多）的数据训练算出来的梯度与用全部数据训练出来的梯度是几乎一样的。</p>
<h3 id="3-5-3-在合理范围内，增大Batch-Size有何好处？">3.5.3 在合理范围内，增大Batch_Size有何好处？</h3>
<ol>
<li>内存利用率提高了，大矩阵乘法的并行化效率提高。</li>
<li>跑完一次 epoch（全数据集）所需的迭代次数减少，对于相同数据量的处理速度进一步加快。</li>
<li>在一定范围内，一般来说 Batch_Size 越大，其确定的下降方向越准，引起训练震荡越小。</li>
</ol>
<h3 id="3-5-4-盲目增大-Batch-Size-有何坏处？">3.5.4 盲目增大 Batch_Size 有何坏处？</h3>
<ol>
<li>内存利用率提高了，但是内存容量可能撑不住了。</li>
<li>跑完一次 epoch（全数据集）所需的迭代次数减少，要想达到相同的精度，其所花费的时间大大增加了，从而对参数的修正也就显得更加缓慢。</li>
<li>Batch_Size 增大到一定程度，其确定的下降方向已经基本不再变化。</li>
</ol>
<h3 id="3-5-5-调节-Batch-Size-对训练效果影响到底如何？">3.5.5 调节 Batch_Size 对训练效果影响到底如何？</h3>
<ol>
<li>Batch_Size 太小，模型表现效果极其糟糕(error飙升)。</li>
<li>随着 Batch_Size 增大，处理相同数据量的速度越快。</li>
<li>随着 Batch_Size 增大，达到相同精度所需要的 epoch 数量越来越多。</li>
<li>由于上述两种因素的矛盾， Batch_Size 增大到某个时候，达到时间上的最优。</li>
<li>由于最终收敛精度会陷入不同的局部极值，因此 Batch_Size 增大到某些时候，达到最终收敛精度上的最优。</li>
</ol>
<h2 id="3-6-归一化">3.6 归一化</h2>
<h3 id="3-6-1-归一化含义？">3.6.1 归一化含义？</h3>
<ol>
<li>
<p>归纳统一样本的统计分布性。归一化在  $ 0-1$  之间是统计的概率分布，归一化在 $ -1--+1$  之间是统计的坐标分布。</p>
</li>
<li>
<p>无论是为了建模还是为了计算，首先基本度量单位要同一，神经网络是以样本在事件中的统计分别几率来进行训练（概率计算）和预测，且 sigmoid 函数的取值是 0 到 1 之间的，网络最后一个节点的输出也是如此，所以经常要对样本的输出归一化处理。</p>
</li>
<li>
<p>归一化是统一在  $ 0-1 $  之间的统计概率分布，当所有样本的输入信号都为正值时，与第一隐含层神经元相连的权值只能同时增加或减小，从而导致学习速度很慢。</p>
</li>
<li>
<p>另外在数据中常存在奇异样本数据，奇异样本数据存在所引起的网络训练时间增加，并可能引起网络无法收敛。为了避免出现这种情况及后面数据处理的方便，加快网络学习速度，可以对输入信号进行归一化，使得所有样本的输入信号其均值接近于 0 或与其均方差相比很小。</p>
</li>
</ol>
<h3 id="3-6-2-为什么要归一化？">3.6.2 为什么要归一化？</h3>
<ol>
<li>为了后面数据处理的方便，归一化的确可以避免一些不必要的数值问题。</li>
<li>为了程序运行时收敛加快。</li>
<li>同一量纲。样本数据的评价标准不一样，需要对其量纲化，统一评价标准。这算是应用层面的需求。</li>
<li>避免神经元饱和。啥意思？就是当神经元的激活在接近 0 或者 1 时会饱和，在这些区域，梯度几乎为 0，这样，在反向传播过程中，局部梯度就会接近 0，这会有效地“杀死”梯度。</li>
<li>保证输出数据中数值小的不被吞食。</li>
</ol>
<h3 id="3-6-3-为什么归一化能提高求解最优解速度？">3.6.3 为什么归一化能提高求解最优解速度？</h3>
<p><img src="3.6.3.1.png" alt></p>
<p>​	上图是代表数据是否均一化的最优解寻解过程（圆圈可以理解为等高线）。左图表示未经归一化操作的寻解过程，右图表示经过归一化后的寻解过程。</p>
<p>​	当使用梯度下降法寻求最优解时，很有可能走“之字型”路线（垂直等高线走），从而导致需要迭代很多次才能收敛；而右图对两个原始特征进行了归一化，其对应的等高线显得很圆，在梯度下降进行求解时能较快的收敛。</p>
<p>​	因此如果机器学习模型使用梯度下降法求最优解时，归一化往往非常有必要，否则很难收敛甚至不能收敛。</p>
<h3 id="3-6-4-3D-图解未归一化">3.6.4 3D 图解未归一化</h3>
<p>例子：</p>
<p>​	假设  $ w1 $  的范围在  $ [-10, 10] $ ，而  $ w2 $  的范围在  $ [-100, 100] $ ，梯度每次都前进 1 单位，那么在  $ w1 $  方向上每次相当于前进了  $ 1/20 $ ，而在  $ w2 $  上只相当于  $ 1/200 $ ！某种意义上来说，在  $ w2 $  上前进的步长更小一些,而  $ w1 $  在搜索过程中会比  $ w2 $  “走”得更快。</p>
<p>​	这样会导致，在搜索过程中更偏向于  $ w1 $  的方向。走出了“L”形状，或者成为“之”字形。</p>
<p><img src="3-37.png" alt></p>
<h3 id="3-6-5-归一化有哪些类型？">3.6.5 归一化有哪些类型？</h3>
<ol>
<li>线性归一化</li>
</ol>
 $$
x^{\prime} = \frac{x-min(x)}{max(x) - min(x)}
$$ 
<p>​	适用范围：比较适用在数值比较集中的情况。</p>
<p>​	缺点：如果 max 和 min 不稳定，很容易使得归一化结果不稳定，使得后续使用效果也不稳定。</p>
<ol start="2">
<li>标准差标准化</li>
</ol>
 $$
x^{\prime} = \frac{x-\mu}{\sigma}
$$ 
<p>​	含义：经过处理的数据符合标准正态分布，即均值为 0，标准差为 1 其中  $ \mu $  为所有样本数据的均值， $ \sigma $  为所有样本数据的标准差。</p>
<ol start="3">
<li>
<p>非线性归一化</p>
<p>适用范围：经常用在数据分化比较大的场景，有些数值很大，有些很小。通过一些数学函数，将原始值进行映射。该方法包括  $ log $ 、指数，正切等。</p>
</li>
</ol>
<h3 id="3-6-6-局部响应归一化作用">3.6.6 局部响应归一化作用</h3>
<p>​	LRN 是一种提高深度学习准确度的技术方法。LRN 一般是在激活、池化函数后的一种方法。</p>
<p>​	在 ALexNet 中，提出了 LRN 层，对局部神经元的活动创建竞争机制，使其中响应比较大对值变得相对更大，并抑制其他反馈较小的神经元，增强了模型的泛化能力。</p>
<h3 id="3-6-7-理解局部响应归一化">3.6.7 理解局部响应归一化</h3>
<p>​	局部响应归一化原理是仿造生物学上活跃的神经元对相邻神经元的抑制现象（侧抑制），其公式如下：</p>
 $$
b_{x,y}^i = a_{x,y}^i / (k + \alpha \sum_{j=max(0, i-n/2)}^{min(N-1, i+n/2)}(a_{x,y}^j)^2 )^\beta
$$ 
<p>其中，</p>
<ol>
<li>
$ a $ ：表示卷积层（包括卷积操作和池化操作）后的输出结果，是一个四维数组[batch,height,width,channel]。
</li>
</ol>
<ul>
<li>batch：批次数(每一批为一张图片)。</li>
<li>height：图片高度。</li>
<li>width：图片宽度。</li>
<li>channel：通道数。可以理解成一批图片中的某一个图片经过卷积操作后输出的神经元个数，或理解为处理后的图片深度。</li>
</ul>
<ol start="2">
<li>
$ a_{x,y}^i $  表示在这个输出结构中的一个位置  $ [a,b,c,d] $ ，可以理解成在某一张图中的某一个通道下的某个高度和某个宽度位置的点，即第  $ a $  张图的第  $ d $  个通道下的高度为b宽度为c的点。
</li>
<li>
$ N $ ：论文公式中的  $ N $  表示通道数 (channel)。
</li>
<li>
$ a $ ， $ n/2 $ ，  $ k $  分别表示函数中的 input,depth_radius,bias。参数  $ k, n, \alpha, \beta $  都是超参数，一般设置  $ k=2, n=5, \alpha=1*e-4, \beta=0.75 $ 
</li>
<li>
$ \sum $ ： $ \sum $  叠加的方向是沿着通道方向的，即每个点值的平方和是沿着  $ a $  中的第 3 维 channel 方向的，也就是一个点同方向的前面  $ n/2 $  个通道（最小为第  $ 0 $  个通道）和后  $ n/2 $  个通道（最大为第  $ d-1 $  个通道）的点的平方和(共  $ n+1 $  个点)。而函数的英文注解中也说明了把 input 当成是  $ d $  个 3 维的矩阵，说白了就是把 input 的通道数当作 3 维矩阵的个数，叠加的方向也是在通道方向。 
</li>
</ol>
<p>简单的示意图如下：</p>
<p><img src="3.6.7.1.png" alt></p>
<h3 id="3-6-8-什么是批归一化（Batch-Normalization）">3.6.8 什么是批归一化（Batch Normalization）</h3>
<p>​	以前在神经网络训练中，只是对输入层数据进行归一化处理，却没有在中间层进行归一化处理。要知道，虽然我们对输入数据进行了归一化处理，但是输入数据经过  $ \sigma(WX+b) $  这样的矩阵乘法以及非线性运算之后，其数据分布很可能被改变，而随着深度网络的多层运算之后，数据分布的变化将越来越大。如果我们能在网络的中间也进行归一化处理，是否对网络的训练起到改进作用呢？答案是肯定的。</p>
<p>​	这种在神经网络中间层也进行归一化处理，使训练效果更好的方法，就是批归一化Batch Normalization（BN）。</p>
<h3 id="3-6-9-批归一化（BN）算法的优点">3.6.9 批归一化（BN）算法的优点</h3>
<p>下面我们来说一下BN算法的优点：</p>
<ol>
<li>减少了人为选择参数。在某些情况下可以取消 dropout 和 L2 正则项参数,或者采取更小的 L2 正则项约束参数；</li>
<li>减少了对学习率的要求。现在我们可以使用初始很大的学习率或者选择了较小的学习率，算法也能够快速训练收敛；</li>
<li>可以不再使用局部响应归一化。BN 本身就是归一化网络(局部响应归一化在 AlexNet 网络中存在)</li>
<li>破坏原来的数据分布，一定程度上缓解过拟合（防止每批训练中某一个样本经常被挑选到，文献说这个可以提高 1% 的精度）。</li>
<li>减少梯度消失，加快收敛速度，提高训练精度。</li>
</ol>
<h3 id="3-6-10-批归一化（BN）算法流程">3.6.10 批归一化（BN）算法流程</h3>
<p>下面给出 BN 算法在训练时的过程</p>
<p>输入：上一层输出结果  $ X = {x_1, x_2, ..., x_m} $ ，学习参数  $ \gamma, \beta $</p>
<p>算法流程：</p>
<ol>
<li>计算上一层输出数据的均值</li>
</ol>
 $$
\mu_{\beta} = \frac{1}{m} \sum_{i=1}^m(x_i)
$$ 
<p>其中， $ m $  是此次训练样本 batch 的大小。</p>
<ol start="2">
<li>计算上一层输出数据的标准差</li>
</ol>
 $$
\sigma_{\beta}^2 = \frac{1}{m} \sum_{i=1}^m (x_i - \mu_{\beta})^2
$$ 
<ol start="3">
<li>归一化处理，得到</li>
</ol>
 $$
\hat x_i = \frac{x_i + \mu_{\beta}}{\sqrt{\sigma_{\beta}^2} + \epsilon}
$$ 
<p>其中  $ \epsilon $  是为了避免分母为 0 而加进去的接近于 0 的很小值</p>
<ol start="4">
<li>重构，对经过上面归一化处理得到的数据进行重构，得到</li>
</ol>
 $$
y_i = \gamma \hat x_i + \beta
$$ 
<p>其中， $ \gamma, \beta $  为可学习参数。</p>
<p>注：上述是 BN 训练时的过程，但是当在投入使用时，往往只是输入一个样本，没有所谓的均值  $ \mu_{\beta} $  和标准差  $ \sigma_{\beta}^2 $ 。此时，均值  $ \mu_{\beta} $  是计算所有 batch  $ \mu_{\beta} $  值的平均值得到，标准差  $ \sigma_{\beta}^2 $  采用每个batch  $ \sigma_{\beta}^2 $   的无偏估计得到。</p>
<h3 id="3-6-11-批归一化和群组归一化比较">3.6.11 批归一化和群组归一化比较</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th style="text-align:left">特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>批量归一化（Batch Normalization，以下简称 BN）</td>
<td style="text-align:left">可让各种网络并行训练。但是，批量维度进行归一化会带来一些问题——批量统计估算不准确导致批量变小时，BN 的误差会迅速增加。在训练大型网络和将特征转移到计算机视觉任务中（包括检测、分割和视频），内存消耗限制了只能使用小批量的 BN。</td>
</tr>
<tr>
<td>群组归一化 Group Normalization (简称 GN)</td>
<td style="text-align:left">GN 将通道分成组，并在每组内计算归一化的均值和方差。GN 的计算与批量大小无关，并且其准确度在各种批量大小下都很稳定。</td>
</tr>
<tr>
<td>比较</td>
<td style="text-align:left">在 ImageNet 上训练的 ResNet-50上，GN 使用批量大小为 2 时的错误率比 BN 的错误率低 10.6％ ;当使用典型的批量时，GN 与 BN 相当，并且优于其他标归一化变体。而且，GN 可以自然地从预训练迁移到微调。在进行 COCO 中的目标检测和分割以及 Kinetics 中的视频分类比赛中，GN 可以胜过其竞争对手，表明 GN 可以在各种任务中有效地取代强大的 BN。</td>
</tr>
</tbody>
</table>
<h3 id="3-6-12-Weight-Normalization和Batch-Normalization比较">3.6.12 Weight Normalization和Batch Normalization比较</h3>
<p>​	Weight Normalization 和 Batch Normalization 都属于参数重写（Reparameterization）的方法，只是采用的方式不同。</p>
<p>​	Weight Normalization 是对网络权值 $  W $  进行 normalization，因此也称为 Weight Normalization；</p>
<p>​	Batch Normalization 是对网络某一层输入数据进行 normalization。</p>
<p>​	Weight Normalization相比Batch Normalization有以下三点优势：</p>
<ol>
<li>
<p>Weight Normalization 通过重写深度学习网络的权重W的方式来加速深度学习网络参数收敛，没有引入 minbatch 的依赖，适用于 RNN（LSTM）网络（Batch Normalization 不能直接用于RNN，进行 normalization 操作，原因在于：1) RNN 处理的 Sequence 是变长的；2) RNN 是基于 time step 计算，如果直接使用 Batch Normalization 处理，需要保存每个 time step 下，mini btach 的均值和方差，效率低且占内存）。</p>
</li>
<li>
<p>Batch Normalization 基于一个 mini batch 的数据计算均值和方差，而不是基于整个 Training set 来做，相当于进行梯度计算式引入噪声。因此，Batch Normalization 不适用于对噪声敏感的强化学习、生成模型（Generative model：GAN，VAE）使用。相反，Weight Normalization 对通过标量  $ g $  和向量  $ v $  对权重  $ W $  进行重写，重写向量  $ v $  是固定的，因此，基于 Weight Normalization 的 Normalization 可以看做比 Batch Normalization 引入更少的噪声。</p>
</li>
<li>
<p>不需要额外的存储空间来保存 mini batch 的均值和方差，同时实现 Weight Normalization 时，对深度学习网络进行正向信号传播和反向梯度计算带来的额外计算开销也很小。因此，要比采用 Batch Normalization 进行 normalization 操作时，速度快。  但是 Weight Normalization 不具备 Batch Normalization 把网络每一层的输出 Y 固定在一个变化范围的作用。因此，采用 Weight Normalization 进行 Normalization 时需要特别注意参数初始值的选择。</p>
</li>
</ol>
<h3 id="3-6-13-Batch-Normalization在什么时候用比较合适？">3.6.13 Batch Normalization在什么时候用比较合适？</h3>
<p><strong>（贡献者：黄钦建－华南理工大学）</strong></p>
<p>​	在CNN中，BN应作用在非线性映射前。在神经网络训练时遇到收敛速度很慢，或梯度爆炸等无法训练的状况时可以尝试BN来解决。另外，在一般使用情况下也可以加入BN来加快训练速度，提高模型精度。</p>
<p>​	BN比较适用的场景是：每个mini-batch比较大，数据分布比较接近。在进行训练之前，要做好充分的shuffle，否则效果会差很多。另外，由于BN需要在运行过程中统计每个mini-batch的一阶统计量和二阶统计量，因此不适用于动态的网络结构和RNN网络。</p>
<h2 id="3-7-预训练与微调-fine-tuning">3.7 预训练与微调(fine tuning)</h2>
<h3 id="3-7-1-为什么无监督预训练可以帮助深度学习？">3.7.1 为什么无监督预训练可以帮助深度学习？</h3>
<p>深度网络存在问题:</p>
<ol>
<li>
<p>网络越深，需要的训练样本数越多。若用监督则需大量标注样本，不然小规模样本容易造成过拟合。深层网络特征比较多，会出现的多特征问题主要有多样本问题、规则化问题、特征选择问题。</p>
</li>
<li>
<p>多层神经网络参数优化是个高阶非凸优化问题，经常得到收敛较差的局部解；</p>
</li>
<li>
<p>梯度扩散问题，BP算法计算出的梯度随着深度向前而显著下降，导致前面网络参数贡献很小，更新速度慢。</p>
</li>
</ol>
<p><strong>解决方法：</strong></p>
<p>​	逐层贪婪训练，无监督预训练（unsupervised pre-training）即训练网络的第一个隐藏层，再训练第二个…最后用这些训练好的网络参数值作为整体网络参数的初始值。</p>
<p>经过预训练最终能得到比较好的局部最优解。</p>
<h3 id="3-7-2-什么是模型微调fine-tuning">3.7.2 什么是模型微调fine tuning</h3>
<p>​	用别人的参数、修改后的网络和自己的数据进行训练，使得参数适应自己的数据，这样一个过程，通常称之为微调（fine tuning).</p>
<p><strong>模型的微调举例说明：</strong></p>
<p>​	我们知道，CNN 在图像识别这一领域取得了巨大的进步。如果想将 CNN 应用到我们自己的数据集上，这时通常就会面临一个问题：通常我们的 dataset 都不会特别大，一般不会超过 1 万张，甚至更少，每一类图片只有几十或者十几张。这时候，直接应用这些数据训练一个网络的想法就不可行了，因为深度学习成功的一个关键性因素就是大量带标签数据组成的训练集。如果只利用手头上这点数据，即使我们利用非常好的网络结构，也达不到很高的 performance。这时候，fine-tuning 的思想就可以很好解决我们的问题：我们通过对 ImageNet 上训练出来的模型（如CaffeNet,VGGNet,ResNet) 进行微调，然后应用到我们自己的数据集上。</p>
<h3 id="3-7-3-微调时候网络参数是否更新？">3.7.3 微调时候网络参数是否更新？</h3>
<p>答案：会更新。</p>
<ol>
<li>finetune 的过程相当于继续训练，跟直接训练的区别是初始化的时候。</li>
<li>直接训练是按照网络定义指定的方式初始化。</li>
<li>finetune是用你已经有的参数文件来初始化。</li>
</ol>
<h3 id="3-7-4-fine-tuning-模型的三种状态">3.7.4 fine-tuning 模型的三种状态</h3>
<ol>
<li>
<p>状态一：只预测，不训练。<br>
特点：相对快、简单，针对那些已经训练好，现在要实际对未知数据进行标注的项目，非常高效；</p>
</li>
<li>
<p>状态二：训练，但只训练最后分类层。<br>
特点：fine-tuning的模型最终的分类以及符合要求，现在只是在他们的基础上进行类别降维。</p>
</li>
<li>
<p>状态三：完全训练，分类层+之前卷积层都训练<br>
特点：跟状态二的差异很小，当然状态三比较耗时和需要训练GPU资源，不过非常适合fine-tuning到自己想要的模型里面，预测精度相比状态二也提高不少。</p>
</li>
</ol>
<h2 id="3-8-权重偏差初始化">3.8 权重偏差初始化</h2>
<h3 id="3-8-1-全都初始化为-0">3.8.1 全都初始化为 0</h3>
<p><strong>偏差初始化陷阱</strong>： 都初始化为 0。</p>
<p><strong>产生陷阱原因</strong>：因为并不知道在训练神经网络中每一个权重最后的值，但是如果进行了恰当的数据归一化后，我们可以有理由认为有一半的权重是正的，另一半是负的。令所有权重都初始化为 0，如果神经网络计算出来的输出值是一样的，神经网络在进行反向传播算法计算出来的梯度值也一样，并且参数更新值也一样。更一般地说，如果权重初始化为同一个值，网络就是对称的。</p>
<p><strong>形象化理解</strong>：在神经网络中考虑梯度下降的时候，设想你在爬山，但身处直线形的山谷中，两边是对称的山峰。由于对称性，你所在之处的梯度只能沿着山谷的方向，不会指向山峰；你走了一步之后，情况依然不变。结果就是你只能收敛到山谷中的一个极大值，而走不到山峰上去。</p>
<h3 id="3-8-2-全都初始化为同样的值">3.8.2 全都初始化为同样的值</h3>
<p>​	偏差初始化陷阱： 都初始化为一样的值。<br>
​	以一个三层网络为例：<br>
首先看下结构</p>
<p><img src="3.8.2.1.png" alt></p>
<p>它的表达式为：</p>
 $$
a_1^{(2)} = f(W_{11}^{(1)} x_1 + W_{12}^{(1)} x_2 + W_{13}^{(1)} x_3 + b_1^{(1)})
$$ 
 $$
a_2^{(2)} = f(W_{21}^{(1)} x_1 + W_{22}^{(1)} x_2 + W_{23}^{(1)} x_3 + b_2^{(1)})
$$ 
 $$
a_3^{(2)} = f(W_{31}^{(1)} x_1 + W_{32}^{(1)} x_2 + W_{33}^{(1)} x_3 + b_3^{(1)})
$$ 
 $$
h_{W,b}(x) = a_1^{(3)} = f(W_{11}^{(2)} a_1^{(2)} + W_{12}^{(2)} a_2^{(2)} + W_{13}^{(2)} a_3^{(2)} + b_1^{(2)})
$$ 
 $$
xa_1^{(2)} = f(W_{11}^{(1)} x_1 + W_{12}^{(1)} x_2 + W_{13}^{(1)} x_3 + b_1^{(1)})a_2^{(2)} = f(W_{21}^{(1)} x_1 + W_{22}^{(1)} x_2 + W_{23}^{(1)} x_3 + 
$$ 
<p>如果每个权重都一样，那么在多层网络中，从第二层开始，每一层的输入值都是相同的了也就是 $ a1=a2=a3=.... $ ，既然都一样，就相当于一个输入了，为啥呢？？</p>
<p>如果是反向传递算法（如果这里不明白请看上面的连接），其中的偏置项和权重项的迭代的偏导数计算公式如下</p>
 $$
\frac{\partial}{\partial W_{ij}^{(l)}} J(W,b;x,y) = a_j^{(l)} \delta_i^{(l+1)}

\frac{\partial}{\partial b_{i}^{(l)}} J(W,b;x,y) = \delta_i^{(l+1)}
$$ 
 $ \delta $  的计算公式
 $$
\delta_i^{(l)} = (\sum_{j=1}^{s_{t+1}} W_{ji}^{(l)} \delta_j^{(l+1)} ) f^{\prime}(z_i^{(l)})
$$ 
<p>如果用的是 sigmoid 函数</p>
 $$
f^{\prime}(z_i^{(l)}) = a_i^{(l)}(1-a_i^{(l)})
$$ 
<p>把后两个公式代入，可以看出所得到的梯度下降法的偏导相同，不停的迭代，不停的相同，不停的迭代，不停的相同…，最后就得到了相同的值（权重和截距）。</p>
<h3 id="3-8-3-初始化为小的随机数">3.8.3 初始化为小的随机数</h3>
<p>​	将权重初始化为很小的数字是一个普遍的打破网络对称性的解决办法。这个想法是，神经元在一开始都是随机的、独一无二的，所以它们会计算出不同的更新，并将自己整合到整个网络的各个部分。一个权重矩阵的实现可能看起来像  $ W=0.01∗np.random.randn(D,H) $ ，其中 randn 是从均值为 0 的单位标准高斯分布进行取样。通过这个公式(函数)，每个神经元的权重向量初始化为一个从多维高斯分布取样的随机向量，所以神经元在输入空间中指向随机的方向(so the neurons point in random direction in the input space). 应该是指输入空间对于随机方向有影响)。其实也可以从均匀分布中来随机选取小数，但是在实际操作中看起来似乎对最后的表现并没有太大的影响。</p>
<p>​	备注：并不是数字越小就会表现的越好。比如，如果一个神经网络层的权重非常小，那么在反向传播算法就会计算出很小的梯度(因为梯度 gradient 是与权重成正比的)。在网络不断的反向传播过程中将极大地减少“梯度信号”，并可能成为深层网络的一个需要注意的问题。</p>
<h3 id="3-8-4-用-swig￼331-校准方差">3.8.4 用  $ 1/\sqrt n $  校准方差</h3>
<p>​	上述建议的一个问题是，随机初始化神经元的输出的分布有一个随输入量增加而变化的方差。结果证明，我们可以通过将其权重向量按其输入的平方根(即输入的数量)进行缩放，从而将每个神经元的输出的方差标准化到 1。也就是说推荐的启发式方法 (heuristic) 是将每个神经元的权重向量按下面的方法进行初始化:  $ w=np.random.randn(n)/\sqrt n $ ，其中 n 表示输入的数量。这保证了网络中所有的神经元最初的输出分布大致相同，并在经验上提高了收敛速度。</p>
<h3 id="3-8-5-稀疏初始化-Sparse-Initialazation">3.8.5 稀疏初始化(Sparse Initialazation)</h3>
<p>​	另一种解决未校准方差问题的方法是把所有的权重矩阵都设为零，但是为了打破对称性，每个神经元都是随机连接地(从如上面所介绍的一个小的高斯分布中抽取权重)到它下面的一个固定数量的神经元。一个典型的神经元连接的数目可能是小到 10 个。</p>
<h3 id="3-8-6-初始化偏差">3.8.6 初始化偏差</h3>
<p>​	将偏差初始化为零是可能的，也是很常见的，因为非对称性破坏是由权重的小随机数导致的。因为 ReLU 具有非线性特点，所以有些人喜欢使用将所有的偏差设定为小的常数值如 0.01，因为这样可以确保所有的 ReLU 单元在最开始就激活触发(fire)并因此能够获得和传播一些梯度值。然而，这是否能够提供持续的改善还不太清楚(实际上一些结果表明这样做反而使得性能更加糟糕)，所以更通常的做法是简单地将偏差初始化为 0.</p>
<h2 id="3-9-学习率">3.9 学习率</h2>
<h3 id="3-9-1-学习率的作用">3.9.1 学习率的作用</h3>
<p>​	在机器学习中，监督式学习通过定义一个模型，并根据训练集上的数据估计最优参数。梯度下降法是一个广泛被用来最小化模型误差的参数优化算法。梯度下降法通过多次迭代，并在每一步中最小化成本函数（cost 来估计模型的参数。学习率 (learning rate)，在迭代过程中会控制模型的学习进度。</p>
<p>​	在梯度下降法中，都是给定的统一的学习率，整个优化过程中都以确定的步长进行更新， 在迭代优化的前期中，学习率较大，则前进的步长就会较长，这时便能以较快的速度进行梯度下降，而在迭代优化的后期，逐步减小学习率的值，减小步长，这样将有助于算法的收敛，更容易接近最优解。故而如何对学习率的更新成为了研究者的关注点。<br>
​	在模型优化中，常用到的几种学习率衰减方法有：分段常数衰减、多项式衰减、指数衰减、自然指数衰减、余弦衰减、线性余弦衰减、噪声线性余弦衰减</p>
<h3 id="3-9-2-学习率衰减常用参数有哪些">3.9.2 学习率衰减常用参数有哪些</h3>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>参数说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>learning_rate</td>
<td>初始学习率</td>
</tr>
<tr>
<td>global_step</td>
<td>用于衰减计算的全局步数，非负，用于逐步计算衰减指数</td>
</tr>
<tr>
<td>decay_steps</td>
<td>衰减步数，必须是正值，决定衰减周期</td>
</tr>
<tr>
<td>decay_rate</td>
<td>衰减率</td>
</tr>
<tr>
<td>end_learning_rate</td>
<td>最低的最终学习率</td>
</tr>
<tr>
<td>cycle</td>
<td>学习率下降后是否重新上升</td>
</tr>
<tr>
<td>alpha</td>
<td>最小学习率</td>
</tr>
<tr>
<td>num_periods</td>
<td>衰减余弦部分的周期数</td>
</tr>
<tr>
<td>initial_variance</td>
<td>噪声的初始方差</td>
</tr>
<tr>
<td>variance_decay</td>
<td>衰减噪声的方差</td>
</tr>
</tbody>
</table>
<h3 id="3-9-3-分段常数衰减">3.9.3 分段常数衰减</h3>
<p>​	分段常数衰减需要事先定义好的训练次数区间，在对应区间置不同的学习率的常数值，一般情况刚开始的学习率要大一些，之后要越来越小，要根据样本量的大小设置区间的间隔大小，样本量越大，区间间隔要小一点。下图即为分段常数衰减的学习率变化图，横坐标代表训练次数，纵坐标代表学习率。</p>
<p><img src="learnrate1.png" alt></p>
<h3 id="3-9-4-指数衰减">3.9.4 指数衰减</h3>
<p>​	以指数衰减方式进行学习率的更新，学习率的大小和训练次数指数相关，其更新规则为：</p>
 $$
decayed{\_}learning{\_}rate =learning{\_}rate*decay{\_}rate^{\frac{global{\_step}}{decay{\_}steps}}
$$ 
<p>​	这种衰减方式简单直接，收敛速度快，是最常用的学习率衰减方式，如下图所示，绿色的为学习率随<br>
训练次数的指数衰减方式，红色的即为分段常数衰减，它在一定的训练区间内保持学习率不变。</p>
<p><img src="learnrate2.png" alt></p>
<h3 id="3-9-5-自然指数衰减">3.9.5 自然指数衰减</h3>
<p>​	它与指数衰减方式相似，不同的在于它的衰减底数是 $e$ ，故而其收敛的速度更快，一般用于相对比较<br>
容易训练的网络，便于较快的收敛，其更新规则如下</p>
 $$
decayed{\_}learning{\_}rate =learning{\_}rate*e^{\frac{-decay{\_rate}}{global{\_}step}}
$$ 
<p>​	下图为为分段常数衰减、指数衰减、自然指数衰减三种方式的对比图，红色的即为分段常数衰减图，阶梯型曲线。蓝色线为指数衰减图，绿色即为自然指数衰减图，很明可以看到自然指数衰减方式下的学习率衰减程度要大于一般指数衰减方式，有助于更快的收敛。</p>
<p><img src="learnrate3.png" alt></p>
<h3 id="3-9-6-多项式衰减">3.9.6 多项式衰减</h3>
<p>​	应用多项式衰减的方式进行更新学习率，这里会给定初始学习率和最低学习率取值，然后将会按照<br>
给定的衰减方式将学习率从初始值衰减到最低值,其更新规则如下式所示。</p>
 $$
global{\_}step=min(global{\_}step,decay{\_}steps)
$$ 
 $$
decayed{\_}learning{\_}rate =(learning{\_}rate-end{\_}learning{\_}rate)* \left( 1-\frac{global{\_step}}{decay{\_}steps}\right)^{power} \\
 +end{\_}learning{\_}rate
$$ 
<p>​	需要注意的是，有两个机制，降到最低学习率后，到训练结束可以一直使用最低学习率进行更新，另一个是再次将学习率调高，使用 decay_steps 的倍数，取第一个大于 global_steps 的结果，如下式所示.它是用来防止神经网络在训练的后期由于学习率过小而导致的网络一直在某个局部最小值附近震荡，这样可以通过在后期增大学习率跳出局部极小值。</p>
 $$
decay{\_}steps = decay{\_}steps*ceil \left( \frac{global{\_}step}{decay{\_}steps}\right)
$$ 
<p>​	如下图所示，红色线代表学习率降低至最低后，一直保持学习率不变进行更新，绿色线代表学习率衰减到最低后，又会再次循环往复的升高降低。</p>
<p><img src="learnrate4.png" alt></p>
<h3 id="3-9-7-余弦衰减">3.9.7 余弦衰减</h3>
<p>​	余弦衰减就是采用余弦的相关方式进行学习率的衰减，衰减图和余弦函数相似。其更新机制如下式所示：</p>
 $$
global{\_}step=min(global{\_}step,decay{\_}steps)
$$ 
 $$
cosine{\_}decay=0.5*\left( 1+cos\left( \pi* \frac{global{\_}step}{decay{\_}steps}\right)\right)
$$ 
 $$
decayed=(1-\alpha)*cosine{\_}decay+\alpha
$$ 
 $$
decayed{\_}learning{\_}rate=learning{\_}rate*decayed
$$ 
<p>​	如下图所示，红色即为标准的余弦衰减曲线，学习率从初始值下降到最低学习率后保持不变。蓝色的线是线性余弦衰减方式曲线，它是学习率从初始学习率以线性的方式下降到最低学习率值。绿色噪声线性余弦衰减方式。</p>
<p><img src="learnrate5.png" alt></p>
<h2 id="3-12-Dropout-系列问题">3.12 Dropout 系列问题</h2>
<h3 id="3-12-1-为什么要正则化？">3.12.1 为什么要正则化？</h3>
<ol>
<li>深度学习可能存在过拟合问题——高方差，有两个解决方法，一个是正则化，另一个是准备更多的数据，这是非常可靠的方法，但你可能无法时时刻刻准备足够多的训练数据或者获取更多数据的成本很高，但正则化通常有助于避免过拟合或减少你的网络误差。</li>
<li>如果你怀疑神经网络过度拟合了数据，即存在高方差问题，那么最先想到的方法可能是正则化，另一个解决高方差的方法就是准备更多数据，这也是非常可靠的办法，但你可能无法时时准备足够多的训练数据，或者，获取更多数据的成本很高，但正则化有助于避免过度拟合，或者减少网络误差。</li>
</ol>
<h3 id="3-12-2-为什么正则化有利于预防过拟合？">3.12.2 为什么正则化有利于预防过拟合？</h3>
<p><img src="3.12.2.1.png" alt><br>
<img src="3.12.2.2.png" alt></p>
<p>左图是高偏差，右图是高方差，中间是Just Right，这几张图我们在前面课程中看到过。</p>
<h3 id="3-12-3-理解dropout正则化">3.12.3 理解dropout正则化</h3>
<p>​	Dropout可以随机删除网络中的神经单元，它为什么可以通过正则化发挥如此大的作用呢？</p>
<p>​	直观上理解：不要依赖于任何一个特征，因为该单元的输入可能随时被清除，因此该单元通过这种方式传播下去，并为单元的四个输入增加一点权重，通过传播所有权重，dropout将产生收缩权重的平方范数的效果，和之前讲的L2正则化类似；实施dropout的结果实它会压缩权重，并完成一些预防过拟合的外层正则化；L2对不同权重的衰减是不同的，它取决于激活函数倍增的大小。</p>
<h3 id="3-12-4-dropout率的选择">3.12.4 dropout率的选择</h3>
<ol>
<li>经过交叉验证，隐含节点 dropout 率等于 0.5 的时候效果最好，原因是 0.5 的时候 dropout 随机生成的网络结构最多。</li>
<li>dropout 也可以被用作一种添加噪声的方法，直接对 input 进行操作。输入层设为更接近 1 的数。使得输入变化不会太大（0.8）</li>
<li>对参数  $ w $  的训练进行球形限制 (max-normalization)，对 dropout 的训练非常有用。</li>
<li>球形半径  $ c $  是一个需要调整的参数，可以使用验证集进行参数调优。</li>
<li>dropout 自己虽然也很牛，但是 dropout、max-normalization、large decaying learning rates and high momentum 组合起来效果更好，比如 max-norm regularization 就可以防止大的learning rate 导致的参数 blow up。</li>
<li>使用 pretraining 方法也可以帮助 dropout 训练参数，在使用 dropout 时，要将所有参数都乘以  $ 1/p $ 。</li>
</ol>
<h3 id="3-12-5-dropout有什么缺点？">3.12.5 dropout有什么缺点？</h3>
<p>​	dropout一大缺点就是代价函数J不再被明确定义，每次迭代，都会随机移除一些节点，如果再三检查梯度下降的性能，实际上是很难进行复查的。定义明确的代价函数J每次迭代后都会下降，因为我们所优化的代价函数J实际上并没有明确定义，或者说在某种程度上很难计算，所以我们失去了调试工具来绘制这样的图片。我通常会关闭dropout函数，将keep-prob的值设为1，运行代码，确保J函数单调递减。然后打开dropout函数，希望在dropout过程中，代码并未引入bug。我觉得你也可以尝试其它方法，虽然我们并没有关于这些方法性能的数据统计，但你可以把它们与dropout方法一起使用。</p>
<h2 id="3-13-深度学习中常用的数据增强方法？">3.13 深度学习中常用的数据增强方法？</h2>
<p><strong>（贡献者：黄钦建－华南理工大学）</strong></p>
<ul>
<li>
<p>Color Jittering：对颜色的数据增强：图像亮度、饱和度、对比度变化（此处对色彩抖动的理解不知是否得当）；</p>
</li>
<li>
<p>PCA  Jittering：首先按照RGB三个颜色通道计算均值和标准差，再在整个训练集上计算协方差矩阵，进行特征分解，得到特征向量和特征值，用来做PCA Jittering；</p>
</li>
<li>
<p>Random Scale：尺度变换；</p>
</li>
<li>
<p>Random Crop：采用随机图像差值方式，对图像进行裁剪、缩放；包括Scale Jittering方法（VGG及ResNet模型使用）或者尺度和长宽比增强变换；</p>
</li>
<li>
<p>Horizontal/Vertical Flip：水平/垂直翻转；</p>
</li>
<li>
<p>Shift：平移变换；</p>
</li>
<li>
<p>Rotation/Reflection：旋转/仿射变换；</p>
</li>
<li>
<p>Noise：高斯噪声、模糊处理；</p>
</li>
<li>
<p>Label Shuffle：类别不平衡数据的增广；</p>
</li>
</ul>
<h2 id="3-14-如何理解-Internal-Covariate-Shift？">3.14 如何理解 Internal Covariate Shift？</h2>
<p><strong>（贡献者：黄钦建－华南理工大学）</strong></p>
<p>​	深度神经网络模型的训练为什么会很困难？其中一个重要的原因是，深度神经网络涉及到很多层的叠加，而每一层的参数更新会导致上层的输入数据分布发生变化，通过层层叠加，高层的输入分布变化会非常剧烈，这就使得高层需要不断去重新适应底层的参数更新。为了训好模型，我们需要非常谨慎地去设定学习率、初始化权重、以及尽可能细致的参数更新策略。</p>
<p>​	Google 将这一现象总结为 Internal Covariate Shift，简称 ICS。 什么是 ICS 呢？</p>
<p>​	大家都知道在统计机器学习中的一个经典假设是“源空间（source domain）和目标空间（target domain）的数据分布（distribution）是一致的”。如果不一致，那么就出现了新的机器学习问题，如 transfer learning / domain adaptation 等。而 covariate shift 就是分布不一致假设之下的一个分支问题，它是指源空间和目标空间的条件概率是一致的，但是其边缘概率不同。</p>
<p>​	大家细想便会发现，的确，对于神经网络的各层输出，由于它们经过了层内操作作用，其分布显然与各层对应的输入信号分布不同，而且差异会随着网络深度增大而增大，可是它们所能“指示”的样本标记（label）仍然是不变的，这便符合了covariate shift的定义。由于是对层间信号的分析，也即是“internal”的来由。</p>
<p><strong>那么ICS会导致什么问题？</strong></p>
<p>简而言之，每个神经元的输入数据不再是“独立同分布”。</p>
<p>其一，上层参数需要不断适应新的输入数据分布，降低学习速度。</p>
<p>其二，下层输入的变化可能趋向于变大或者变小，导致上层落入饱和区，使得学习过早停止。</p>
<p>其三，每层的更新都会影响到其它层，因此每层的参数更新策略需要尽可能的谨慎。</p>
<h2 id="参考文献">参考文献</h2>
<p>[1] Rosenblatt, F. The perceptron: A probabilistic model for information storage and organization in the brain.[J]. Psychological Review, 1958, 65(6):386-408.</p>
<p>[2] Duvenaud D , Rippel O , Adams R P , et al. Avoiding pathologies in very deep networks[J]. Eprint Arxiv, 2014:202-210.</p>
<p>[3] Rumelhart D E, Hinton G E, Williams R J. Learning representations by back-propagating errors[J]. Cognitive modeling, 1988, 5(3): 1.</p>
<p>[4] Hecht-Nielsen R. Theory of the backpropagation neural network[M]//Neural networks for perception. Academic Press, 1992: 65-93.</p>
<p>[5] Felice M. Which deep learning network is best for you?| CIO[J]. 2017.</p>
<p>[6] Conneau A, Schwenk H, Barrault L, et al. Very deep convolutional networks for natural language processing[J]. arXiv preprint arXiv:1606.01781, 2016, 2.</p>
<p>[7] Ba J, Caruana R. Do deep nets really need to be deep?[C]//Advances in neural information processing systems. 2014: 2654-2662.</p>
<p>[8] Nielsen M A. Neural networks and deep learning[M]. USA: Determination press, 2015.</p>
<p>[9] Goodfellow I, Bengio Y, Courville A. Deep learning[M]. MIT press, 2016.</p>
<p>[10] 周志华. 机器学习[M].清华大学出版社, 2016.</p>
<p>[11] Kim J, Kwon Lee J, Mu Lee K. Accurate image super-resolution using very deep convolutional networks[C]//Proceedings of the IEEE conference on computer vision and pattern recognition. 2016: 1646-1654.</p>
<p>[12] Chen Y, Lin Z, Zhao X, et al. Deep learning-based classification of hyperspectral data[J]. IEEE Journal of Selected topics in applied earth observations and remote sensing, 2014, 7(6): 2094-2107.</p>
<p>[13] Domhan T, Springenberg J T, Hutter F. Speeding up automatic hyperparameter optimization of deep neural networks by extrapolation of learning curves[C]//Twenty-Fourth International Joint Conference on Artificial Intelligence. 2015.</p>
<p>[14] Maclaurin D, Duvenaud D, Adams R. Gradient-based hyperparameter optimization through reversible learning[C]//International Conference on Machine Learning. 2015: 2113-2122.</p>
<p>[15] Srivastava R K, Greff K, Schmidhuber J. Training very deep networks[C]//Advances in neural information processing systems. 2015: 2377-2385.</p>
<p>[16] Bergstra J, Bengio Y. Random search for hyper-parameter optimization[J]. Journal of Machine Learning Research, 2012, 13(Feb): 281-305.</p>
<p>[17] Ngiam J, Khosla A, Kim M, et al. Multimodal deep learning[C]//Proceedings of the 28th international conference on machine learning (ICML-11). 2011: 689-696.</p>
<p>[18] Deng L, Yu D. Deep learning: methods and applications[J]. Foundations and Trends® in Signal Processing, 2014, 7(3–4): 197-387.</p>
<p>[19] Erhan D, Bengio Y, Courville A, et al. Why does unsupervised pre-training help deep learning?[J]. Journal of Machine Learning Research, 2010, 11(Feb): 625-660.</p>
<p>[20] Dong C, Loy C C, He K, et al. Learning a deep convolutional network for image super resolution[C]//European conference on computer vision. Springer, Cham, 2014: 184-199.</p>
<p>[21] 郑泽宇，梁博文，顾思宇.TensorFlow：实战Google深度学习框架（第2版）[M].电子工业出版社,2018.</p>
<p>[22] 焦李成. 深度学习优化与识别[M].清华大学出版社,2017.</p>
<p>[23] 吴岸城. 神经网络与深度学习[M].电子工业出版社,2016.</p>
<p>[24] Wei, W.G.H., Liu, T., Song, A., et al. (2018) An Adaptive Natural Gradient Method with Adaptive Step Size in Multilayer Perceptrons. Chinese Automation Congress, 1593-1597.</p>
<p>[25] Y Feng, Y <a href="http://Li.An">Li.An</a> Overview of Deep Learning Optimization Methods and Learning Rate Attenuation Methods[J].Hans Journal of Data Mining,2018,8(4),186-200.</p>
]]></content>
      <categories>
        <category>算法面试</category>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>刷八股</tag>
      </tags>
  </entry>
  <entry>
    <title>经典网络面试题</title>
    <url>/2024/03/19/deep_learning/ch4/</url>
    <content><![CDATA[<h1>经典网络解读</h1>
<h2 id="4-1-LeNet-5">4.1 LeNet-5</h2>
<h3 id="4-1-1-模型介绍">4.1.1 模型介绍</h3>
<p>​	LeNet-5是由 $LeCun$  提出的一种用于识别手写数字和机器印刷字符的卷积神经网络（Convolutional Neural Network，CNN） $^{[1]}$ ，其命名来源于作者 $LeCun$ 的名字，5则是其研究成果的代号，在LeNet-5之前还有LeNet-4和LeNet-1鲜为人知。LeNet-5阐述了图像中像素特征之间的相关性能够由参数共享的卷积操作所提取，同时使用卷积、下采样（池化）和非线性映射这样的组合结构，是当前流行的大多数深度图像识别网络的基础。</p>
<h3 id="4-1-2-模型结构">4.1.2 模型结构</h3>
<p><img src="image1.png" alt></p>
<p>​                                                                 图4.1 LeNet-5网络结构图</p>
<p>​	如图4.1所示，LeNet-5一共包含7层（输入层不作为网络结构），分别由2个卷积层、2个下采样层和3个连接层组成，网络的参数配置如表4.1所示，其中下采样层和全连接层的核尺寸分别代表采样范围和连接矩阵的尺寸（如卷积核尺寸中的 $“5\times5\times1/1,6”$ 表示核大小为 $5\times5\times1$ 、步长为 $1​$ 且核个数为6的卷积核）。</p>
<p>​                                                                 表4.1 LeNet-5网络参数配置</p>
<table>
<thead>
<tr>
<th style="text-align:center">网络层</th>
<th style="text-align:center">输入尺寸</th>
<th style="text-align:center">核尺寸</th>
<th style="text-align:center">输出尺寸</th>
<th style="text-align:center">可训练参数量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">卷积层 $C_1$</td>
<td style="text-align:center">$32\times32\times1$</td>
<td style="text-align:center">$5\times5\times1/1,6$</td>
<td style="text-align:center">$28\times28\times6$</td>
<td style="text-align:center">$(5\times5\times1+1)\times6$</td>
</tr>
<tr>
<td style="text-align:center">下采样层 $S_2$</td>
<td style="text-align:center">$28\times28\times6$</td>
<td style="text-align:center">$2\times2/2$</td>
<td style="text-align:center">$14\times14\times6$</td>
<td style="text-align:center">$(1+1)\times6$   $^*$</td>
</tr>
<tr>
<td style="text-align:center">卷积层 $C_3$</td>
<td style="text-align:center">$14\times14\times6$</td>
<td style="text-align:center">$5\times5\times6/1,16$</td>
<td style="text-align:center">$10\times10\times16$</td>
<td style="text-align:center">$1516^*$</td>
</tr>
<tr>
<td style="text-align:center">下采样层 $S_4$</td>
<td style="text-align:center">$10\times10\times16$</td>
<td style="text-align:center">$2\times2/2$</td>
<td style="text-align:center">$5\times5\times16$</td>
<td style="text-align:center">$(1+1)\times16$</td>
</tr>
<tr>
<td style="text-align:center">卷积层 $C_5 {% raw%}$$^*${% endraw %}</td>
<td style="text-align:center">{% raw%}$5\times5\times16${% endraw %}</td>
<td style="text-align:center">{% raw%}$5\times5\times16/1,120${% endraw %}</td>
<td style="text-align:center">{% raw%}$1\times1\times120${% endraw %}</td>
<td style="text-align:center">{% raw%}$(5\times5\times16+1)\times120${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">全连接层 {% raw%}$F_6${% endraw %}</td>
<td style="text-align:center">{% raw%}$1\times1\times120${% endraw %}</td>
<td style="text-align:center">{% raw%}$120\times84${% endraw %}</td>
<td style="text-align:center">{% raw%}$1\times1\times84${% endraw %}</td>
<td style="text-align:center">{% raw%}$(120+1)\times84${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">输出层</td>
<td style="text-align:center">{% raw%}$1\times1\times84${% endraw %}</td>
<td style="text-align:center">{% raw%}$84\times10${% endraw %}</td>
<td style="text-align:center">{% raw%}$1\times1\times10${% endraw %}</td>
<td style="text-align:center">{% raw%}$(84+1)\times10${% endraw %}</td>
</tr>
</tbody>
</table>
<blockquote>
<p>​	 {% raw%}$^*${% endraw %}  在LeNet中，下采样操作和池化操作类似，但是在得到采样结果后会乘以一个系数和加上一个偏置项，所以下采样的参数个数是 {% raw%}$(1+1)\times6​${% endraw %} 而不是零。</p>
<p>​	 {% raw%}$^*${% endraw %}   {% raw%}$C_3${% endraw %} 卷积层可训练参数并未直接连接 {% raw%}$S_2${% endraw %} 中所有的特征图（Feature Map），而是采用如图4.2所示的采样特征方式进行连接（稀疏连接），生成的16个通道特征图中分别按照相邻3个特征图、相邻4个特征图、非相邻4个特征图和全部6个特征图进行映射，得到的参数个数计算公式为 {% raw%}$6\times(25\times3+1)+6\times(25\times4+1)+3\times(25\times4+1)+1\times(25\times6+1)=1516${% endraw %} ，在原论文中解释了使用这种采样方式原因包含两点：限制了连接数不至于过大（当年的计算能力比较弱）;强制限定不同特征图的组合可以使映射得到的特征图学习到不同的特征模式。</p>
</blockquote>
<p><img src="featureMap.jpg" alt="FeatureMap"></p>
<p>​                                                                图4.2  {% raw%}$S_2${% endraw %} 与 {% raw%}$C_3${% endraw %} 之间的特征图稀疏连接</p>
<blockquote>
<p>​	 {% raw%}$^*${% endraw %}   {% raw%}$C_5${% endraw %} 卷积层在图4.1中显示为全连接层，原论文中解释这里实际采用的是卷积操作，只是刚好在 {% raw%}$5\times5${% endraw %} 卷积后尺寸被压缩为 {% raw%}$1\times1​${% endraw %} ，输出结果看起来和全连接很相似。</p>
</blockquote>
<h3 id="4-1-3-模型特性">4.1.3 模型特性</h3>
<ul>
<li>卷积网络使用一个3层的序列组合：卷积、下采样（池化）、非线性映射（LeNet-5最重要的特性，奠定了目前深层卷积网络的基础）</li>
<li>使用卷积提取空间特征</li>
<li>使用映射的空间均值进行下采样</li>
<li>使用 {% raw%}$tanh${% endraw %} 或 {% raw%}$sigmoid${% endraw %} 进行非线性映射</li>
<li>多层神经网络（MLP）作为最终的分类器</li>
<li>层间的稀疏连接矩阵以避免巨大的计算开销</li>
</ul>
<h2 id="4-2-AlexNet">4.2 AlexNet</h2>
<h3 id="4-2-1-模型介绍">4.2.1 模型介绍</h3>
<p>​	AlexNet是由 {% raw%}$Alex${% endraw %}   {% raw%}$Krizhevsky ${% endraw %} 提出的首个应用于图像分类的深层卷积神经网络，该网络在2012年ILSVRC（ImageNet Large Scale Visual Recognition Competition）图像分类竞赛中以15.3%的top-5测试错误率赢得第一名 {% raw%}$^{[2]}${% endraw %} 。AlexNet使用GPU代替CPU进行运算，使得在可接受的时间范围内模型结构能够更加复杂，它的出现证明了深层卷积神经网络在复杂模型下的有效性，使CNN在计算机视觉中流行开来，直接或间接地引发了深度学习的热潮。</p>
<h3 id="4-2-2-模型结构">4.2.2 模型结构</h3>
<p><img src="alexnet.png" alt></p>
<p>​                                                                         图4.3 AlexNet网络结构图</p>
<p>​	如图4.3所示，除去下采样（池化层）和局部响应规范化操作（Local Responsible Normalization, LRN），AlexNet一共包含8层，前5层由卷积层组成，而剩下的3层为全连接层。网络结构分为上下两层，分别对应两个GPU的操作过程，除了中间某些层（ {% raw%}$C_3${% endraw %} 卷积层和 {% raw%}$F_{6-8}${% endraw %} 全连接层会有GPU间的交互），其他层两个GPU分别计算结 果。最后一层全连接层的输出作为 {% raw%}$softmax${% endraw %} 的输入，得到1000个图像分类标签对应的概率值。除去GPU并行结构的设计，AlexNet网络结构与LeNet十分相似，其网络的参数配置如表4.2所示。</p>
<p>​									表4.2 AlexNet网络参数配置</p>
<table>
<thead>
<tr>
<th style="text-align:center">网络层</th>
<th style="text-align:center">输入尺寸</th>
<th style="text-align:center">核尺寸</th>
<th style="text-align:center">输出尺寸</th>
<th style="text-align:center">可训练参数量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">卷积层 {% raw%}$C_1${% endraw %}   {% raw%}$^*${% endraw %}</td>
<td style="text-align:center">{% raw%}$224\times224\times3${% endraw %}</td>
<td style="text-align:center">{% raw%}$11\times11\times3/4,48(\times2_{GPU})${% endraw %}</td>
<td style="text-align:center">{% raw%}$55\times55\times48(\times2_{GPU})${% endraw %}</td>
<td style="text-align:center">{% raw%}$(11\times11\times3+1)\times48\times2${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">下采样层 {% raw%}$S_{max}$${% endraw %} ^*$</td>
<td style="text-align:center">$55\times55\times48(\times2_{GPU})$</td>
<td style="text-align:center">$3\times3/2(\times2_{GPU})$</td>
<td style="text-align:center">$27\times27\times48(\times2_{GPU})$</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">卷积层 $C_2$</td>
<td style="text-align:center">$27\times27\times48(\times2_{GPU})$</td>
<td style="text-align:center">$5\times5\times48/1,128(\times2_{GPU})$</td>
<td style="text-align:center">$27\times27\times128(\times2_{GPU})$</td>
<td style="text-align:center">$(5\times5\times48+1)\times128\times2$</td>
</tr>
<tr>
<td style="text-align:center">下采样层 $S_{max}$</td>
<td style="text-align:center">$27\times27\times128(\times2_{GPU})$</td>
<td style="text-align:center">$3\times3/2(\times2_{GPU})$</td>
<td style="text-align:center">$13\times13\times128(\times2_{GPU})$</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">卷积层 $C_3$   $^*$</td>
<td style="text-align:center">$13\times13\times128\times2_{GPU}$</td>
<td style="text-align:center">$3\times3\times256/1,192(\times2_{GPU})$</td>
<td style="text-align:center">$13\times13\times192(\times2_{GPU})$</td>
<td style="text-align:center">$(3\times3\times256+1)\times192\times2$</td>
</tr>
<tr>
<td style="text-align:center">卷积层 $C_4$</td>
<td style="text-align:center">$13\times13\times192(\times2_{GPU})$</td>
<td style="text-align:center">$3\times3\times192/1,192(\times2_{GPU})$</td>
<td style="text-align:center">$13\times13\times192(\times2_{GPU})$</td>
<td style="text-align:center">$(3\times3\times192+1)\times192\times2$</td>
</tr>
<tr>
<td style="text-align:center">卷积层 $C_5$</td>
<td style="text-align:center">$13\times13\times192(\times2_{GPU})$</td>
<td style="text-align:center">$3\times3\times192/1,128(\times2_{GPU})$</td>
<td style="text-align:center">$13\times13\times128(\times2_{GPU})$</td>
<td style="text-align:center">$(3\times3\times192+1)\times128\times2$</td>
</tr>
<tr>
<td style="text-align:center">下采样层 $S_{max}$</td>
<td style="text-align:center">$13\times13\times128(\times2_{GPU})$</td>
<td style="text-align:center">$3\times3/2(\times2_{GPU})$</td>
<td style="text-align:center">$6\times6\times128(\times2_{GPU})$</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">全连接层 $F_6$    $^*$</td>
<td style="text-align:center">$6\times6\times128\times2_{GPU}$</td>
<td style="text-align:center">$9216\times2048(\times2_{GPU})$</td>
<td style="text-align:center">$1\times1\times2048(\times2_{GPU})$</td>
<td style="text-align:center">$(9216+1)\times2048\times2$</td>
</tr>
<tr>
<td style="text-align:center">全连接层 $F_7$</td>
<td style="text-align:center">$1\times1\times2048\times2_{GPU}$</td>
<td style="text-align:center">$4096\times2048(\times2_{GPU})$</td>
<td style="text-align:center">$1\times1\times2048(\times2_{GPU})$</td>
<td style="text-align:center">$(4096+1)\times2048\times2$</td>
</tr>
<tr>
<td style="text-align:center">全连接层 $F_8$</td>
<td style="text-align:center">$1\times1\times2048\times2_{GPU}$</td>
<td style="text-align:center">$4096\times1000$</td>
<td style="text-align:center">$1\times1\times1000$</td>
<td style="text-align:center">$(4096+1)\times1000\times2$</td>
</tr>
</tbody>
</table>
<blockquote>
<p>卷积层 $C_1$ 输入为 $224\times224\times3$ 的图片数据，分别在两个GPU中经过核为 $11\times11\times3$ 、步长（stride）为4的卷积卷积后，分别得到两条独立的 $55\times55\times48$ 的输出数据。</p>
<p>下采样层 $S_{max}$ 实际上是嵌套在卷积中的最大池化操作，但是为了区分没有采用最大池化的卷积层单独列出来。在 $C_{1-2}$ 卷积层中的池化操作之后（ReLU激活操作之前），还有一个LRN操作，用作对相邻特征点的归一化处理。</p>
<p>卷积层 $C_3$  的输入与其他卷积层不同， $13\times13\times192\times2_{GPU}$ 表示汇聚了上一层网络在两个GPU上的输出结果作为输入，所以在进行卷积操作时通道上的卷积核维度为384。</p>
<p>全连接层 $F_{6-8}$ 中输入数据尺寸也和 $C_3$ 类似，都是融合了两个GPU流向的输出结果作为输入。</p>
</blockquote>
<h3 id="4-2-3-模型特性">4.2.3 模型特性</h3>
<ul>
<li>所有卷积层都使用ReLU作为非线性映射函数，使模型收敛速度更快</li>
<li>在多个GPU上进行模型的训练，不但可以提高模型的训练速度，还能提升数据的使用规模</li>
<li>使用LRN对局部的特征进行归一化，结果作为ReLU激活函数的输入能有效降低错误率</li>
<li>重叠最大池化（overlapping max pooling），即池化范围z与步长s存在关系 $z>s$ （如 $S_{max}$ 中核尺度为 $3\times3/2$ ），避免平均池化（average pooling）的平均效应</li>
<li>使用随机丢弃技术（dropout）选择性地忽略训练中的单个神经元，避免模型的过拟合</li>
</ul>
<h2 id="4-3-ZFNet">4.3 ZFNet</h2>
<h3 id="4-3-1-模型介绍">4.3.1 模型介绍</h3>
<p>​	ZFNet是由 $Matthew$   $D. Zeiler$ 和 $Rob$   $Fergus$ 在AlexNet基础上提出的大型卷积网络，在2013年ILSVRC图像分类竞赛中以11.19%的错误率获得冠军（实际上原ZFNet所在的队伍并不是真正的冠军，原ZFNet以13.51%错误率排在第8，真正的冠军是 $Clarifai$ 这个队伍，而 $Clarifai$ 这个队伍所对应的一家初创公司的CEO又是 $Zeiler$ ，而且 $Clarifai$ 对ZFNet的改动比较小，所以通常认为是ZFNet获得了冠军） $^{[3-4]}​$ 。ZFNet实际上是微调（fine-tuning）了的AlexNet，并通过反卷积（Deconvolution）的方式可视化各层的输出特征图，进一步解释了卷积操作在大型网络中效果显著的原因。</p>
<h3 id="4-3-2-模型结构">4.3.2 模型结构</h3>
<p><img src="image21.png" alt></p>
<p><img src="image21.jpeg" alt></p>
<p>​						图4.4 ZFNet网络结构图（原始结构图与AlexNet风格结构图）</p>
<p>​	如图4.4所示，ZFNet与AlexNet类似，都是由8层网络组成的卷积神经网络，其中包含5层卷积层和3层全连接层。两个网络结构最大的不同在于，ZFNet第一层卷积采用了 $7\times7\times3/2$ 的卷积核替代了AlexNet中第一层卷积核 $11\times11\times3/4$ 的卷积核。图4.5中ZFNet相比于AlexNet在第一层输出的特征图中包含更多中间频率的信息，而AlexNet第一层输出的特征图大多是低频或高频的信息，对中间频率特征的缺失导致后续网络层次如图4.5（c）能够学习到的特征不够细致，而导致这个问题的根本原因在于AlexNet在第一层中采用的卷积核和步长过大。</p>
<p><img src="zfnet-layer1.png" alt></p>
<p><img src="zfnet-layer2.png" alt></p>
<p>​	图4.5 （a）ZFNet第一层输出的特征图（b）AlexNet第一层输出的特征图（c）AlexNet第二层输出的特征图（d）ZFNet第二层输出的特征图</p>
<p>​									表4.3 ZFNet网络参数配置</p>
<table>
<thead>
<tr>
<th style="text-align:center">网络层</th>
<th style="text-align:center">输入尺寸</th>
<th style="text-align:center">核尺寸</th>
<th style="text-align:center">输出尺寸</th>
<th style="text-align:center">可训练参数量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">卷积层 $C_1$   $^*$</td>
<td style="text-align:center">$224\times224\times3$</td>
<td style="text-align:center">$7\times7\times3/2,96$</td>
<td style="text-align:center">$110\times110\times96$</td>
<td style="text-align:center">$(7\times7\times3+1)\times96$</td>
</tr>
<tr>
<td style="text-align:center">下采样层 $S_{max}$</td>
<td style="text-align:center">$110\times110\times96$</td>
<td style="text-align:center">$3\times3/2$</td>
<td style="text-align:center">$55\times55\times96$</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">卷积层 $C_2$   $^*$</td>
<td style="text-align:center">$55\times55\times96$</td>
<td style="text-align:center">$5\times5\times96/2,256$</td>
<td style="text-align:center">$26\times26\times256$</td>
<td style="text-align:center">$(5\times5\times96+1)\times256$</td>
</tr>
<tr>
<td style="text-align:center">下采样层 $S_{max}$</td>
<td style="text-align:center">$26\times26\times256$</td>
<td style="text-align:center">$3\times3/2$</td>
<td style="text-align:center">$13\times13\times256$</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">卷积层 $C_3$</td>
<td style="text-align:center">$13\times13\times256$</td>
<td style="text-align:center">$3\times3\times256/1,384$</td>
<td style="text-align:center">$13\times13\times384$</td>
<td style="text-align:center">$(3\times3\times256+1)\times384$</td>
</tr>
<tr>
<td style="text-align:center">卷积层 $C_4$</td>
<td style="text-align:center">$13\times13\times384$</td>
<td style="text-align:center">$3\times3\times384/1,384$</td>
<td style="text-align:center">$13\times13\times384$</td>
<td style="text-align:center">$(3\times3\times384+1)\times384$</td>
</tr>
<tr>
<td style="text-align:center">卷积层 $C_5$</td>
<td style="text-align:center">$13\times13\times384$</td>
<td style="text-align:center">$3\times3\times384/1,256$</td>
<td style="text-align:center">$13\times13\times256$</td>
<td style="text-align:center">$(3\times3\times384+1)\times256$</td>
</tr>
<tr>
<td style="text-align:center">下采样层 $S_{max}$</td>
<td style="text-align:center">$13\times13\times256$</td>
<td style="text-align:center">$3\times3/2$</td>
<td style="text-align:center">$6\times6\times256$</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">全连接层 $F_6$</td>
<td style="text-align:center">$6\times6\times256$</td>
<td style="text-align:center">$9216\times4096$</td>
<td style="text-align:center">$1\times1\times4096$</td>
<td style="text-align:center">$(9216+1)\times4096$</td>
</tr>
<tr>
<td style="text-align:center">全连接层 $F_7$</td>
<td style="text-align:center">$1\times1\times4096$</td>
<td style="text-align:center">$4096\times4096$</td>
<td style="text-align:center">$1\times1\times4096$</td>
<td style="text-align:center">$(4096+1)\times4096$</td>
</tr>
<tr>
<td style="text-align:center">全连接层 $F_8$</td>
<td style="text-align:center">$1\times1\times4096$</td>
<td style="text-align:center">$4096\times1000$</td>
<td style="text-align:center">$1\times1\times1000$</td>
<td style="text-align:center">$(4096+1)\times1000$</td>
</tr>
</tbody>
</table>
<blockquote>
<p>卷积层 $C_1$ 与AlexNet中的 $C_1$ 有所不同，采用 $7\times7\times3/2$ 的卷积核代替 $11\times11\times3/4​$ ，使第一层卷积输出的结果可以包含更多的中频率特征，对后续网络层中多样化的特征组合提供更多选择，有利于捕捉更细致的特征。</p>
<p>卷积层 $C_2$ 采用了步长2的卷积核，区别于AlexNet中 $C_2$ 的卷积核步长，所以输出的维度有所差异。</p>
</blockquote>
<h3 id="4-3-3-模型特性">4.3.3 模型特性</h3>
<p>​	ZFNet与AlexNet在结构上几乎相同，此部分虽属于模型特性，但准确地说应该是ZFNet原论文中可视化技术的贡献。</p>
<ul>
<li>可视化技术揭露了激发模型中每层单独的特征图。</li>
<li>可视化技术允许观察在训练阶段特征的演变过程且诊断出模型的潜在问题。</li>
<li>可视化技术用到了多层解卷积网络，即由特征激活返回到输入像素空间。</li>
<li>可视化技术进行了分类器输出的敏感性分析，即通过阻止部分输入图像来揭示那部分对于分类是重要的。</li>
<li>可视化技术提供了一个非参数的不变性来展示来自训练集的哪一块激活哪个特征图，不仅需要裁剪输入图片，而且自上而下的投影来揭露来自每块的结构激活一个特征图。</li>
<li>可视化技术依赖于解卷积操作，即卷积操作的逆过程，将特征映射到像素上。</li>
</ul>
<h2 id="4-4-Network-in-Network">4.4 Network in Network</h2>
<h3 id="4-4-1-模型介绍">4.4.1 模型介绍</h3>
<p>​	Network In Network (NIN)是由 $Min Lin$ 等人提出，在CIFAR-10和CIFAR-100分类任务中达到当时的最好水平，因其网络结构是由三个多层感知机堆叠而被成为NIN $^{[5]}$ 。NIN以一种全新的角度审视了卷积神经网络中的卷积核设计，通过引入子网络结构代替纯卷积中的线性映射部分，这种形式的网络结构激发了更复杂的卷积神经网络的结构设计，其中下一节中介绍的GoogLeNet的Inception结构就是来源于这个思想。</p>
<h3 id="4-4-2-模型结构">4.4.2 模型结构</h3>
<p><img src="image23.png" alt><br>
​									图 4.6 NIN网络结构图</p>
<p>​	NIN由三层的多层感知卷积层（MLPConv Layer）构成，每一层多层感知卷积层内部由若干层的局部全连接层和非线性激活函数组成，代替了传统卷积层中采用的线性卷积核。在网络推理（inference）时，这个多层感知器会对输入特征图的局部特征进行划窗计算，并且每个划窗的局部特征图对应的乘积的权重是共享的，这两点是和传统卷积操作完全一致的，最大的不同在于多层感知器对局部特征进行了非线性的映射，而传统卷积的方式是线性的。NIN的网络参数配置表4.4所示（原论文并未给出网络参数，表中参数为编者结合网络结构图和CIFAR-100数据集以 $3\times3$ 卷积为例给出）。</p>
<p>​					表4.4 NIN网络参数配置（结合原论文NIN结构和CIFAR-100数据给出）</p>
<table>
<thead>
<tr>
<th style="text-align:center">网络层</th>
<th style="text-align:center">输入尺寸</th>
<th style="text-align:center">核尺寸</th>
<th style="text-align:center">输出尺寸</th>
<th style="text-align:center">参数个数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">局部全连接层 $L_{11}$   $^*$</td>
<td style="text-align:center">$32\times32\times3$</td>
<td style="text-align:center">$(3\times3)\times16/1$</td>
<td style="text-align:center">$30\times30\times16$</td>
<td style="text-align:center">$(3\times3\times3+1)\times16$</td>
</tr>
<tr>
<td style="text-align:center">全连接层 $L_{12}$   $^*$</td>
<td style="text-align:center">$30\times30\times16$</td>
<td style="text-align:center">$16\times16$</td>
<td style="text-align:center">$30\times30\times16$</td>
<td style="text-align:center">$((16+1)\times16)$</td>
</tr>
<tr>
<td style="text-align:center">局部全连接层 $L_{21}$</td>
<td style="text-align:center">$30\times30\times16$</td>
<td style="text-align:center">$(3\times3)\times64/1$</td>
<td style="text-align:center">$28\times28\times64$</td>
<td style="text-align:center">$(3\times3\times16+1)\times64$</td>
</tr>
<tr>
<td style="text-align:center">全连接层 $L_{22}$</td>
<td style="text-align:center">$28\times28\times64$</td>
<td style="text-align:center">$64\times64$</td>
<td style="text-align:center">$28\times28\times64$</td>
<td style="text-align:center">$((64+1)\times64)$</td>
</tr>
<tr>
<td style="text-align:center">局部全连接层 $L_{31}$</td>
<td style="text-align:center">$28\times28\times64$</td>
<td style="text-align:center">$(3\times3)\times100/1$</td>
<td style="text-align:center">$26\times26\times100$</td>
<td style="text-align:center">$(3\times3\times64+1)\times100$</td>
</tr>
<tr>
<td style="text-align:center">全连接层 $L_{32}$</td>
<td style="text-align:center">$26\times26\times100$</td>
<td style="text-align:center">$100\times100$</td>
<td style="text-align:center">$26\times26\times100$</td>
<td style="text-align:center">$((100+1)\times100)$</td>
</tr>
<tr>
<td style="text-align:center">全局平均采样 $GAP$   $^*$</td>
<td style="text-align:center">$26\times26\times100$</td>
<td style="text-align:center">$26\times26\times100/1$</td>
<td style="text-align:center">$1\times1\times100$</td>
<td style="text-align:center">$0$</td>
</tr>
</tbody>
</table>
<blockquote>
<p>局部全连接层 $L_{11}$ 实际上是对原始输入图像进行划窗式的全连接操作，因此划窗得到的输出特征尺寸为 $30\times30$ （ $\frac{32-3_k+1}{1_{stride}}=30$ ）<br>
全连接层 $L_{12}$ 是紧跟 $L_{11}$ 后的全连接操作，输入的特征是划窗后经过激活的局部响应特征，因此仅需连接 $L_{11}$ 和 $L_{12}$ 的节点即可，而每个局部全连接层和紧接的全连接层构成代替卷积操作的多层感知卷积层（MLPConv）。<br>
全局平均采样层或全局平均池化层 $GAP$ （Global Average Pooling）将 $L_{32}$ 输出的每一个特征图进行全局的平均池化操作，直接得到最后的类别数，可以有效地减少参数量。</p>
</blockquote>
<h3 id="4-4-3-模型特点">4.4.3 模型特点</h3>
<ul>
<li>使用多层感知机结构来代替卷积的滤波操作，不但有效减少卷积核数过多而导致的参数量暴涨问题，还能通过引入非线性的映射来提高模型对特征的抽象能力。</li>
<li>使用全局平均池化来代替最后一个全连接层，能够有效地减少参数量（没有可训练参数），同时池化用到了整个特征图的信息，对空间信息的转换更加鲁棒，最后得到的输出结果可直接作为对应类别的置信度。</li>
</ul>
<h2 id="4-5-VGGNet">4.5 VGGNet</h2>
<h3 id="4-5-1-模型介绍">4.5.1 模型介绍</h3>
<p>​	VGGNet是由牛津大学视觉几何小组（Visual Geometry Group, VGG）提出的一种深层卷积网络结构，他们以7.32%的错误率赢得了2014年ILSVRC分类任务的亚军（冠军由GoogLeNet以6.65%的错误率夺得）和25.32%的错误率夺得定位任务（Localization）的第一名（GoogLeNet错误率为26.44%） $^{[5]}$ ，网络名称VGGNet取自该小组名缩写。VGGNet是首批把图像分类的错误率降低到10%以内模型，同时该网络所采用的 $3\times3$ 卷积核的思想是后来许多模型的基础，该模型发表在2015年国际学习表征会议（International Conference On Learning Representations, ICLR）后至今被引用的次数已经超过1万4千余次。</p>
<h3 id="4-5-2-模型结构">4.5.2 模型结构</h3>
<p><img src="vgg16.png" alt></p>
<p>​								图 4.7 VGG16网络结构图</p>
<p>​	在原论文中的VGGNet包含了6个版本的演进，分别对应VGG11、VGG11-LRN、VGG13、VGG16-1、VGG16-3和VGG19，不同的后缀数值表示不同的网络层数（VGG11-LRN表示在第一层中采用了LRN的VGG11，VGG16-1表示后三组卷积块中最后一层卷积采用卷积核尺寸为 $1\times1$ ，相应的VGG16-3表示卷积核尺寸为 $3\times3$ ），本节介绍的VGG16为VGG16-3。图4.7中的VGG16体现了VGGNet的核心思路，使用 $3\times3$ 的卷积组合代替大尺寸的卷积（2个 $3\times3卷积即可与 {% raw%}$$5\times5${% endraw %} 卷积拥有相同的感受视野），网络参数设置如表4.5所示。</p>
<p>​								表4.5 VGG16网络参数配置</p>
<table>
<thead>
<tr>
<th style="text-align:center">网络层</th>
<th style="text-align:center">输入尺寸</th>
<th style="text-align:center">核尺寸</th>
<th style="text-align:center">输出尺寸</th>
<th style="text-align:center">参数个数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">卷积层 {% raw%}$C_{11}${% endraw %}</td>
<td style="text-align:center">{% raw%}$224\times224\times3${% endraw %}</td>
<td style="text-align:center">{% raw%}$3\times3\times64/1${% endraw %}</td>
<td style="text-align:center">{% raw%}$224\times224\times64${% endraw %}</td>
<td style="text-align:center">{% raw%}$(3\times3\times3+1)\times64${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">卷积层 {% raw%}$C_{12}${% endraw %}</td>
<td style="text-align:center">{% raw%}$224\times224\times64${% endraw %}</td>
<td style="text-align:center">{% raw%}$3\times3\times64/1${% endraw %}</td>
<td style="text-align:center">{% raw%}$224\times224\times64${% endraw %}</td>
<td style="text-align:center">{% raw%}$(3\times3\times64+1)\times64${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">下采样层 {% raw%}$S_{max1}${% endraw %}</td>
<td style="text-align:center">{% raw%}$224\times224\times64${% endraw %}</td>
<td style="text-align:center">{% raw%}$2\times2/2${% endraw %}</td>
<td style="text-align:center">{% raw%}$112\times112\times64${% endraw %}</td>
<td style="text-align:center">{% raw%}$0${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">卷积层 {% raw%}$C_{21}${% endraw %}</td>
<td style="text-align:center">{% raw%}$112\times112\times64${% endraw %}</td>
<td style="text-align:center">{% raw%}$3\times3\times128/1${% endraw %}</td>
<td style="text-align:center">{% raw%}$112\times112\times128${% endraw %}</td>
<td style="text-align:center">{% raw%}$(3\times3\times64+1)\times128${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">卷积层 {% raw%}$C_{22}${% endraw %}</td>
<td style="text-align:center">{% raw%}$112\times112\times128${% endraw %}</td>
<td style="text-align:center">{% raw%}$3\times3\times128/1${% endraw %}</td>
<td style="text-align:center">{% raw%}$112\times112\times128${% endraw %}</td>
<td style="text-align:center">{% raw%}$(3\times3\times128+1)\times128${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">下采样层 {% raw%}$S_{max2}${% endraw %}</td>
<td style="text-align:center">{% raw%}$112\times112\times128${% endraw %}</td>
<td style="text-align:center">{% raw%}$2\times2/2${% endraw %}</td>
<td style="text-align:center">{% raw%}$56\times56\times128${% endraw %}</td>
<td style="text-align:center">{% raw%}$0${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">卷积层 {% raw%}$C_{31}${% endraw %}</td>
<td style="text-align:center">{% raw%}$56\times56\times128${% endraw %}</td>
<td style="text-align:center">{% raw%}$3\times3\times256/1${% endraw %}</td>
<td style="text-align:center">{% raw%}$56\times56\times256${% endraw %}</td>
<td style="text-align:center">{% raw%}$(3\times3\times128+1)\times256${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">卷积层 {% raw%}$C_{32}${% endraw %}</td>
<td style="text-align:center">{% raw%}$56\times56\times256${% endraw %}</td>
<td style="text-align:center">{% raw%}$3\times3\times256/1${% endraw %}</td>
<td style="text-align:center">{% raw%}$56\times56\times256${% endraw %}</td>
<td style="text-align:center">{% raw%}$(3\times3\times256+1)\times256${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">卷积层 {% raw%}$C_{33}${% endraw %}</td>
<td style="text-align:center">{% raw%}$56\times56\times256${% endraw %}</td>
<td style="text-align:center">{% raw%}$3\times3\times256/1${% endraw %}</td>
<td style="text-align:center">{% raw%}$56\times56\times256${% endraw %}</td>
<td style="text-align:center">{% raw%}$(3\times3\times256+1)\times256${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">下采样层 {% raw%}$S_{max3}${% endraw %}</td>
<td style="text-align:center">{% raw%}$56\times56\times256${% endraw %}</td>
<td style="text-align:center">{% raw%}$2\times2/2${% endraw %}</td>
<td style="text-align:center">{% raw%}$28\times28\times256${% endraw %}</td>
<td style="text-align:center">{% raw%}$0${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">卷积层 {% raw%}$C_{41}${% endraw %}</td>
<td style="text-align:center">{% raw%}$28\times28\times256${% endraw %}</td>
<td style="text-align:center">{% raw%}$3\times3\times512/1${% endraw %}</td>
<td style="text-align:center">{% raw%}$28\times28\times512${% endraw %}</td>
<td style="text-align:center">{% raw%}$(3\times3\times256+1)\times512${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">卷积层 {% raw%}$C_{42}${% endraw %}</td>
<td style="text-align:center">{% raw%}$28\times28\times512${% endraw %}</td>
<td style="text-align:center">{% raw%}$3\times3\times512/1${% endraw %}</td>
<td style="text-align:center">{% raw%}$28\times28\times512${% endraw %}</td>
<td style="text-align:center">{% raw%}$(3\times3\times512+1)\times512${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">卷积层 {% raw%}$C_{43}${% endraw %}</td>
<td style="text-align:center">{% raw%}$28\times28\times512${% endraw %}</td>
<td style="text-align:center">{% raw%}$3\times3\times512/1${% endraw %}</td>
<td style="text-align:center">{% raw%}$28\times28\times512${% endraw %}</td>
<td style="text-align:center">{% raw%}$(3\times3\times512+1)\times512${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">下采样层 {% raw%}$S_{max4}${% endraw %}</td>
<td style="text-align:center">{% raw%}$28\times28\times512${% endraw %}</td>
<td style="text-align:center">{% raw%}$2\times2/2${% endraw %}</td>
<td style="text-align:center">{% raw%}$14\times14\times512${% endraw %}</td>
<td style="text-align:center">{% raw%}$0${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">卷积层 {% raw%}$C_{51}${% endraw %}</td>
<td style="text-align:center">{% raw%}$14\times14\times512${% endraw %}</td>
<td style="text-align:center">{% raw%}$3\times3\times512/1${% endraw %}</td>
<td style="text-align:center">{% raw%}$14\times14\times512${% endraw %}</td>
<td style="text-align:center">{% raw%}$(3\times3\times512+1)\times512${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">卷积层 {% raw%}$C_{52}${% endraw %}</td>
<td style="text-align:center">{% raw%}$14\times14\times512${% endraw %}</td>
<td style="text-align:center">{% raw%}$3\times3\times512/1${% endraw %}</td>
<td style="text-align:center">{% raw%}$14\times14\times512${% endraw %}</td>
<td style="text-align:center">{% raw%}$(3\times3\times512+1)\times512${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">卷积层 {% raw%}$C_{53}${% endraw %}</td>
<td style="text-align:center">{% raw%}$14\times14\times512${% endraw %}</td>
<td style="text-align:center">{% raw%}$3\times3\times512/1${% endraw %}</td>
<td style="text-align:center">{% raw%}$14\times14\times512${% endraw %}</td>
<td style="text-align:center">{% raw%}$(3\times3\times512+1)\times512${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">下采样层 {% raw%}$S_{max5}${% endraw %}</td>
<td style="text-align:center">{% raw%}$14\times14\times512${% endraw %}</td>
<td style="text-align:center">{% raw%}$2\times2/2${% endraw %}</td>
<td style="text-align:center">{% raw%}$7\times7\times512${% endraw %}</td>
<td style="text-align:center">{% raw%}$0${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">全连接层 {% raw%}$FC_{1}${% endraw %}</td>
<td style="text-align:center">{% raw%}$7\times7\times512${% endraw %}</td>
<td style="text-align:center">{% raw%}$(7\times7\times512)\times4096${% endraw %}</td>
<td style="text-align:center">{% raw%}$1\times4096${% endraw %}</td>
<td style="text-align:center">{% raw%}$(7\times7\times512+1)\times4096${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">全连接层 {% raw%}$FC_{2}${% endraw %}</td>
<td style="text-align:center">{% raw%}$1\times4096${% endraw %}</td>
<td style="text-align:center">{% raw%}$4096\times4096${% endraw %}</td>
<td style="text-align:center">{% raw%}$1\times4096${% endraw %}</td>
<td style="text-align:center">{% raw%}$(4096+1)\times4096${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">全连接层 {% raw%}$FC_{3}${% endraw %}</td>
<td style="text-align:center">{% raw%}$1\times4096${% endraw %}</td>
<td style="text-align:center">{% raw%}$4096\times1000${% endraw %}</td>
<td style="text-align:center">{% raw%}$1\times1000${% endraw %}</td>
<td style="text-align:center">{% raw%}$(4096+1)\times1000${% endraw %}</td>
</tr>
</tbody>
</table>
<h3 id="4-5-3-模型特性">4.5.3 模型特性</h3>
<ul>
<li>整个网络都使用了同样大小的卷积核尺寸 {% raw%}$3\times3${% endraw %} 和最大池化尺寸 {% raw%}$2\times2${% endraw %} 。</li>
<li>
{% raw%}$1\times1${% endraw %} 卷积的意义主要在于线性变换，而输入通道数和输出通道数不变，没有发生降维。
</li>
<li>两个 {% raw%}$3\times3${% endraw %} 的卷积层串联相当于1个 {% raw%}$5\times5${% endraw %} 的卷积层，感受野大小为 {% raw%}$5\times5${% endraw %} 。同样地，3个 {% raw%}$3\times3${% endraw %} 的卷积层串联的效果则相当于1个 {% raw%}$7\times7${% endraw %} 的卷积层。这样的连接方式使得网络参数量更小，而且多层的激活函数令网络对特征的学习能力更强。</li>
<li>VGGNet在训练时有一个小技巧，先训练浅层的的简单网络VGG11，再复用VGG11的权重来初始化VGG13，如此反复训练并初始化VGG19，能够使训练时收敛的速度更快。</li>
<li>在训练过程中使用多尺度的变换对原始数据做数据增强，使得模型不易过拟合。</li>
</ul>
<h2 id="4-6-GoogLeNet">4.6 GoogLeNet</h2>
<h3 id="4-6-1-模型介绍">4.6.1 模型介绍</h3>
<p>​	GoogLeNet作为2014年ILSVRC在分类任务上的冠军，以6.65%的错误率力压VGGNet等模型，在分类的准确率上面相比过去两届冠军ZFNet和AlexNet都有很大的提升。从名字<strong>GoogLe</strong>Net可以知道这是来自谷歌工程师所设计的网络结构，而名字中Goog<strong>LeNet</strong>更是致敬了LeNet {% raw%}$^{[0]}${% endraw %} 。GoogLeNet中最核心的部分是其内部子网络结构Inception，该结构灵感来源于NIN，至今已经经历了四次版本迭代（Inception {% raw%}$_{v1-4}${% endraw %} ）。</p>
<p><img src="img_inception_01.png" alt><br>
​					图 4.8 Inception性能比较图</p>
<h3 id="4-6-2-模型结构">4.6.2 模型结构</h3>
<p><img src="image25.jpeg" alt><br>
​					图 4.9 GoogLeNet网络结构图<br>
​	如图4.9中所示，GoogLeNet相比于以前的卷积神经网络结构，除了在深度上进行了延伸，还对网络的宽度进行了扩展，整个网络由许多块状子网络的堆叠而成，这个子网络构成了Inception结构。图4.9为Inception的四个版本： {% raw%}$Inception_{v1}​${% endraw %} 在同一层中采用不同的卷积核，并对卷积结果进行合并; {% raw%}$Inception_{v2}​${% endraw %} 组合不同卷积核的堆叠形式，并对卷积结果进行合并; {% raw%}$Inception_{v3}​${% endraw %} 则在 {% raw%}$v_2​${% endraw %} 基础上进行深度组合的尝试; {% raw%}$Inception_{v4}​${% endraw %} 结构相比于前面的版本更加复杂，子网络中嵌套着子网络。</p>
 {% raw%}$Inception_{v1}${% endraw %} 
<p><img src="image27.png" alt></p>
<p><img src="image28.png" alt></p>
 {% raw%}$Inception_{v2}${% endraw %} 
<p><img src="image34.png" alt></p>
<p><img src="image36.png" alt></p>
<p><img src="image38.png" alt></p>
 {% raw%}$Inception_{v3}${% endraw %} 
<p><img src="image37.png" alt></p>
 {% raw%}$Inception_{v4}${% endraw %} 
<p><img src="image46.png" alt></p>
<p><img src="image47.png" alt></p>
<p><img src="image63.png" alt></p>
<p>​					图 4.10 Inception {% raw%}$_{v1-4}${% endraw %} 结构图</p>
<p>​					表 4.6 GoogLeNet中Inception {% raw%}$_{v1}${% endraw %} 网络参数配置</p>
<table>
<thead>
<tr>
<th style="text-align:center">网络层</th>
<th style="text-align:center">输入尺寸</th>
<th style="text-align:center">核尺寸</th>
<th style="text-align:center">输出尺寸</th>
<th style="text-align:center">参数个数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">卷积层 {% raw%}$C_{11}${% endraw %}</td>
<td style="text-align:center">{% raw%}$H\times{W}\times{C_1}${% endraw %}</td>
<td style="text-align:center">{% raw%}$1\times1\times{C_2}/2${% endraw %}</td>
<td style="text-align:center">{% raw%}$\frac{H}{2}\times\frac{W}{2}\times{C_2}${% endraw %}</td>
<td style="text-align:center">{% raw%}$(1\times1\times{C_1}+1)\times{C_2}${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">卷积层 {% raw%}$C_{21}${% endraw %}</td>
<td style="text-align:center">{% raw%}$H\times{W}\times{C_2}${% endraw %}</td>
<td style="text-align:center">{% raw%}$1\times1\times{C_2}/2${% endraw %}</td>
<td style="text-align:center">{% raw%}$\frac{H}{2}\times\frac{W}{2}\times{C_2}${% endraw %}</td>
<td style="text-align:center">{% raw%}$(1\times1\times{C_2}+1)\times{C_2}${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">卷积层 {% raw%}$C_{22}${% endraw %}</td>
<td style="text-align:center">{% raw%}$H\times{W}\times{C_2}${% endraw %}</td>
<td style="text-align:center">{% raw%}$3\times3\times{C_2}/1${% endraw %}</td>
<td style="text-align:center">{% raw%}$H\times{W}\times{C_2}/1${% endraw %}</td>
<td style="text-align:center">{% raw%}$(3\times3\times{C_2}+1)\times{C_2}${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">卷积层 {% raw%}$C_{31}${% endraw %}</td>
<td style="text-align:center">{% raw%}$H\times{W}\times{C_1}${% endraw %}</td>
<td style="text-align:center">{% raw%}$1\times1\times{C_2}/2${% endraw %}</td>
<td style="text-align:center">{% raw%}$\frac{H}{2}\times\frac{W}{2}\times{C_2}${% endraw %}</td>
<td style="text-align:center">{% raw%}$(1\times1\times{C_1}+1)\times{C_2}${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">卷积层 {% raw%}$C_{32}${% endraw %}</td>
<td style="text-align:center">{% raw%}$H\times{W}\times{C_2}${% endraw %}</td>
<td style="text-align:center">{% raw%}$5\times5\times{C_2}/1${% endraw %}</td>
<td style="text-align:center">{% raw%}$H\times{W}\times{C_2}/1${% endraw %}</td>
<td style="text-align:center">{% raw%}$(5\times5\times{C_2}+1)\times{C_2}${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">下采样层 {% raw%}$S_{41}${% endraw %}</td>
<td style="text-align:center">{% raw%}$H\times{W}\times{C_1}${% endraw %}</td>
<td style="text-align:center">{% raw%}$3\times3/2${% endraw %}</td>
<td style="text-align:center">{% raw%}$\frac{H}{2}\times\frac{W}{2}\times{C_2}${% endraw %}</td>
<td style="text-align:center">{% raw%}$0${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">卷积层 {% raw%}$C_{42}${% endraw %}</td>
<td style="text-align:center">{% raw%}$\frac{H}{2}\times\frac{W}{2}\times{C_2}${% endraw %}</td>
<td style="text-align:center">{% raw%}$1\times1\times{C_2}/1${% endraw %}</td>
<td style="text-align:center">{% raw%}$\frac{H}{2}\times\frac{W}{2}\times{C_2}${% endraw %}</td>
<td style="text-align:center">{% raw%}$(3\times3\times{C_2}+1)\times{C_2}${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">合并层 {% raw%}$M${% endraw %}</td>
<td style="text-align:center">{% raw%}$\frac{H}{2}\times\frac{W}{2}\times{C_2}(\times4)${% endraw %}</td>
<td style="text-align:center">拼接</td>
<td style="text-align:center">{% raw%}$\frac{H}{2}\times\frac{W}{2}\times({C_2}\times4)${% endraw %}</td>
<td style="text-align:center">{% raw%}$0${% endraw %}</td>
</tr>
</tbody>
</table>
<h3 id="4-6-3-模型特性">4.6.3 模型特性</h3>
<ul>
<li>
<p>采用不同大小的卷积核意味着不同大小的感受野，最后拼接意味着不同尺度特征的融合；</p>
</li>
<li>
<p>之所以卷积核大小采用1、3和5，主要是为了方便对齐。设定卷积步长stride=1之后，只要分别设定pad=0、1、2，那么卷积之后便可以得到相同维度的特征，然后这些特征就可以直接拼接在一起了；</p>
</li>
<li>
<p>网络越到后面，特征越抽象，而且每个特征所涉及的感受野也更大了，因此随着层数的增加，3x3和5x5卷积的比例也要增加。但是，使用5x5的卷积核仍然会带来巨大的计算量。 为此，文章借鉴NIN2，采用1x1卷积核来进行降维。</p>
<h1></h1>
</li>
</ul>
<h2 id="Restnet">Restnet</h2>
<h2 id="Densenet">Densenet</h2>
<h2 id="4-7-为什么现在的CNN模型都是在GoogleNet、VGGNet或者AlexNet上调整的？">4.7 为什么现在的CNN模型都是在GoogleNet、VGGNet或者AlexNet上调整的？</h2>
<ul>
<li>评测对比：为了让自己的结果更有说服力，在发表自己成果的时候会同一个标准的baseline及在baseline上改进而进行比较，常见的比如各种检测分割的问题都会基于VGG或者Resnet101这样的基础网络。</li>
<li>时间和精力有限：在科研压力和工作压力中，时间和精力只允许大家在有限的范围探索。</li>
<li>模型创新难度大：进行基本模型的改进需要大量的实验和尝试，并且需要大量的实验积累和强大灵感，很有可能投入产出比比较小。</li>
<li>资源限制：创造一个新的模型需要大量的时间和计算资源，往往在学校和小型商业团队不可行。</li>
<li>在实际的应用场景中，其实是有大量的非标准模型的配置。</li>
</ul>
<h2 id="参考文献">参考文献</h2>
<p>[1] Y. LeCun, L. Bottou, Y. Bengio, and P. Haffner. Gradient-based learning applied to document recognition. <em>Proceedings of the IEEE</em>, november 1998.</p>
<p>[2] A. Krizhevsky, I. Sutskever and G. E. Hinton. ImageNet Classification with Deep Convolutional Neural Networks. <em>Advances in Neural Information Processing Systems 25</em>. Curran Associates, Inc. 1097–1105.</p>
<p>[3] LSVRC-2013. <a href="http://www.image-net.org/challenges/LSVRC/2013/results.php">http://www.image-net.org/challenges/LSVRC/2013/results.php</a></p>
<p>[4] M. D. Zeiler and R. Fergus. Visualizing and Understanding Convolutional Networks. <em>European Conference on Computer Vision</em>.</p>
<p>[5] M. Lin,  Q. Chen,  and S. Yan.   Network in network. <em>Computing Research Repository</em>, abs/1312.4400, 2013.</p>
<p>[6] K. Simonyan and A. Zisserman.  Very Deep Convolutional Networks for Large-Scale Image Recognition. <em>International Conference on Machine Learning</em>, 2015.</p>
<p>[7] Bharath Raj. <a href="https://towardsdatascience.com/a-simple-guide-to-the-versions-of-the-inception-network-7fc52b863202">a-simple-guide-to-the-versions-of-the-inception-network</a>, 2018.</p>
<p>[8] Christian Szegedy, Sergey Ioffe, Vincent Vanhoucke, Alex Alemi. <a href="https://arxiv.org/pdf/1602.07261.pdf">Inception-v4, Inception-ResNet and<br>
the Impact of Residual Connections on Learning</a>, 2016.</p>
<p>[9] Sik-Ho Tsang. <a href="https://towardsdatascience.com/review-inception-v4-evolved-from-googlenet-merged-with-resnet-idea-image-classification-5e8c339d18bc">review-inception-v4-evolved-from-googlenet-merged-with-resnet-idea-image-classification</a>, 2018.</p>
<p>[10] Zbigniew Wojna, Christian Szegedy, Vincent Vanhoucke, Sergey Ioffe, Jonathon Shlens. <a href="https://arxiv.org/pdf/1512.00567v3.pdf">Rethinking the Inception Architecture for Computer Vision</a>, 2015.</p>
<p>[11] Christian Szegedy, Wei Liu, Yangqing Jia, Pierre Sermanet, Scott Reed, Dragomir Anguelov, Dumitru Erhan, Vincent Vanhoucke, Andrew Rabinovich. <a href="https://arxiv.org/pdf/1409.4842v1.pdf">Going deeper with convolutions</a>, 2014.</p>
]]></content>
      <categories>
        <category>算法面试</category>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>刷八股</tag>
      </tags>
  </entry>
  <entry>
    <title>循环神经网络面试题</title>
    <url>/2024/03/19/deep_learning/ch6/</url>
    <content><![CDATA[<h1>循环神经网络(RNN)</h1>
<h2 id="6-1-为什么需要RNN？">6.1 为什么需要RNN？</h2>
<p>​	时间序列数据是指在不同时间点上收集到的数据，这类数据反映了某一事物、现象等随时间的变化状态或程度。一般的神经网络，在训练数据足够、算法模型优越的情况下，给定特定的x，就能得到期望y。其一般处理单个的输入，前一个输入和后一个输入完全无关，但实际应用中，某些任务需要能够更好的处理序列的信息，即前面的输入和后面的输入是有关系的。比如：</p>
<p>​	当我们在理解一句话意思时，孤立的理解这句话的每个词不足以理解整体意思，我们通常需要处理这些词连接起来的整个序列； 当我们处理视频的时候，我们也不能只单独的去分析每一帧，而要分析这些帧连接起来的整个序列。为了解决一些这样类似的问题，能够更好的处理序列的信息，RNN就由此诞生了。</p>
<h2 id="6-2-图解RNN基本结构">6.2 图解RNN基本结构</h2>
<h3 id="6-2-1-基本的单层网络结构">6.2.1 基本的单层网络结构</h3>
<p>​	在进一步了解RNN之前，先给出最基本的单层网络结构，输入是<code>$x$</code>，经过变换<code>Wx+b</code>和激活函数<code>f</code>得到输出<code>y</code>：</p>
<p><img src="6.1.jpg" alt></p>
<h3 id="6-2-2-图解经典RNN结构">6.2.2 图解经典RNN结构</h3>
<p>​	在实际应用中，我们还会遇到很多序列形的数据，如：</p>
<ul>
<li>
<p>自然语言处理问题。x1可以看做是第一个单词，x2可以看做是第二个单词，依次类推。</p>
</li>
<li>
<p>语音处理。此时，x1、x2、x3……是每帧的声音信号。</p>
</li>
<li>
<p>时间序列问题。例如每天的股票价格等等。</p>
<p>其单个序列如下图所示：</p>
<p><img src="6.2.jpg" alt></p>
<p>前面介绍了诸如此类的序列数据用原始的神经网络难以建模，基于此，RNN引入了隐状态 $h$ （hidden state）， $h​$ 可对序列数据提取特征，接着再转换为输出。</p>
<p>为了便于理解，先计算 $h_1​$ ：</p>
<p><img src="6.3.jpg" alt></p>
<p>注：图中的圆圈表示向量，箭头表示对向量做变换。</p>
<p>RNN中，每个步骤使用的参数<code>$U,W,b$</code>​相同，<code>$h_2$</code>的计算方式和<code>$h_1​$</code>类似，其计算结果如下：</p>
<p><img src="6.4.jpg" alt></p>
<p>计算 $h_3$ , $h_4​$ 也相似，可得：</p>
<p><img src="6.5.jpg" alt></p>
<p>接下来，计算RNN的输出 $y_1$ ，采用 $Softmax$ 作为激活函数，根据 $y_n=f(Wx+b)$ ，得 $y_1​$ :</p>
<p><img src="6.6.jpg" alt></p>
<p>使用和 $y_1​$ 相同的参数 $V,c​$ ，得到 $y_1,y_2,y_3,y_4​$ 的输出结构：</p>
<p><img src="6.7.jpg" alt></p>
<p>以上即为最经典的RNN结构，其输入为 $x_1,x_2,x_3,x_4$ ，输出为 $y_1,y_2,y_3,y_4$ ，当然实际中最大值为 $y_n$ ，这里为了便于理解和展示，只计算4个输入和输出。从以上结构可看出，RNN结构的输入和输出等长。</p>
</li>
</ul>
<h3 id="6-2-3-vector-to-sequence结构">6.2.3 vector-to-sequence结构</h3>
<p>​	有时我们要处理的问题输入是一个单独的值，输出是一个序列。此时，有两种主要建模方式：</p>
<p>​	方式一：可只在其中的某一个序列进行计算，比如序列第一个进行输入计算，其建模方式如下：</p>
<p><img src="6.9.jpg" alt></p>
<p>​	方式二：把输入信息X作为每个阶段的输入，其建模方式如下：</p>
<p><img src="6.10.jpg" alt></p>
<h3 id="6-2-4-sequence-to-vector结构">6.2.4 sequence-to-vector结构</h3>
<p>​	有时我们要处理的问题输入是一个序列，输出是一个单独的值，此时通常在最后的一个序列上进行输出变换，其建模如下所示：</p>
<p><img src="6.8.jpg" alt></p>
<h3 id="6-2-5-Encoder-Decoder结构">6.2.5 Encoder-Decoder结构</h3>
<p>​	原始的sequence-to-sequence结构的RNN要求序列等长，然而我们遇到的大部分问题序列都是不等长的，如机器翻译中，源语言和目标语言的句子往往并没有相同的长度。</p>
<p>​	其建模步骤如下：</p>
<p>​	<strong>步骤一</strong>：将输入数据编码成一个上下文向量 $c$ ，这部分称为Encoder，得到 $c$ 有多种方式，最简单的方法就是把Encoder的最后一个隐状态赋值给 $c$ ，还可以对最后的隐状态做一个变换得到 $c$ ，也可以对所有的隐状态做变换。其示意如下所示：</p>
<p><img src="6.12.jpg" alt></p>
<p>​	<strong>步骤二</strong>：用另一个RNN网络（我们将其称为Decoder）对其进行编码，方法一是将步骤一中的 $c​$ 作为初始状态输入到Decoder，示意图如下所示：</p>
<p><img src="6.13.jpg" alt></p>
<p>方法二是将 $c$ 作为Decoder的每一步输入，示意图如下所示：</p>
<p><img src="6.14.jpg" alt></p>
<h3 id="6-2-6-以上三种结构各有怎样的应用场景">6.2.6  以上三种结构各有怎样的应用场景</h3>
<table>
<thead>
<tr>
<th>网络结构</th>
<th style="text-align:center">结构图示</th>
<th>应用场景举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 vs N</td>
<td style="text-align:center"><img src="6.9.jpg" alt></td>
<td>1、从图像生成文字，输入为图像的特征，输出为一段句子<br>2、根据图像生成语音或音乐，输入为图像特征，输出为一段语音或音乐</td>
</tr>
<tr>
<td>N vs 1</td>
<td style="text-align:center"><img src="6.8.jpg" alt></td>
<td>1、输出一段文字，判断其所属类别<br>2、输入一个句子，判断其情感倾向<br>3、输入一段视频，判断其所属类别</td>
</tr>
<tr>
<td>N vs M</td>
<td style="text-align:center"><img src="6.13.jpg" alt></td>
<td>1、机器翻译，输入一种语言文本序列，输出另外一种语言的文本序列<br>2、文本摘要，输入文本序列，输出这段文本序列摘要<br>3、阅读理解，输入文章，输出问题答案<br>4、语音识别，输入语音序列信息，输出文字序列</td>
</tr>
</tbody>
</table>
<h3 id="6-2-7-图解RNN中的Attention机制">6.2.7 图解RNN中的Attention机制</h3>
<p>​	在上述通用的Encoder-Decoder结构中，Encoder把所有的输入序列都编码成一个统一的语义特征 $c​$ 再解码，因此， $c​$ 中必须包含原始序列中的所有信息，它的长度就成了限制模型性能的瓶颈。如机器翻译问题，当要翻译的句子较长时，一个 $c​$ 可能存不下那么多信息，就会造成翻译精度的下降。Attention机制通过在每个时间输入不同的 $c​$ 来解决此问题。</p>
<p>​	引入了Attention机制的Decoder中，有不同的 $c$ ，每个 $c​$ 会自动选择与当前输出最匹配的上下文信息，其示意图如下所示：</p>
<p><img src="6.15.jpg" alt></p>
<p>​	<strong>举例</strong>，比如输入序列是“我爱中国”，要将此输入翻译成英文：</p>
<p>​	假如用 $a_{ij}$ 衡量Encoder中第 $j$ 阶段的 $h_j$ 和解码时第 $i$ 阶段的相关性， $a_{ij}$ 从模型中学习得到，和Decoder的第 $i-1$ 阶段的隐状态、Encoder 第 $j$ 个阶段的隐状态有关，比如 $a_{3j}​$ 的计算示意如下所示：</p>
<p><img src="6.19.jpg" alt></p>
<p>最终Decoder中第 $i$ 阶段的输入的上下文信息  $c_i$ 来自于所有 $h_j$ 对 $a_{ij}$ 的加权和。</p>
<p>其示意图如下图所示：</p>
<p><img src="6.16.jpg" alt></p>
<p>​	在Encoder中， $h_1,h_2,h_3,h_4$ 分别代表“我”，“爱”，“中”，“国”所代表信息。翻译的过程中， $c_1$ 会选择和“我”最相关的上下午信息，如上图所示，会优先选择 $a_{11}$ ，以此类推， $c_2$ 会优先选择相关性较大的 $a_{22}$ ， $c_3$ 会优先选择相关性较大的 $a_{33}，a_{34}$ ，这就是attention机制。</p>
<h2 id="6-3-RNNs典型特点？">6.3 RNNs典型特点？</h2>
<ol>
<li>RNNs主要用于处理序列数据。对于传统神经网络模型，从输入层到隐含层再到输出层，层与层之间一般为全连接，每层之间神经元是无连接的。但是传统神经网络无法处理数据间的前后关联问题。例如，为了预测句子的下一个单词，一般需要该词之前的语义信息。这是因为一个句子中前后单词是存在语义联系的。</li>
<li>RNNs中当前单元的输出与之前步骤输出也有关，因此称之为循环神经网络。具体的表现形式为当前单元会对之前步骤信息进行储存并应用于当前输出的计算中。隐藏层之间的节点连接起来，隐藏层当前输出由当前时刻输入向量和之前时刻隐藏层状态共同决定。</li>
<li>标准的RNNs结构图，图中每个箭头代表做一次变换，也就是说箭头连接带有权值。</li>
<li>在标准的RNN结构中，隐层的神经元之间也是带有权值的，且权值共享。</li>
<li>理论上，RNNs能够对任何长度序列数据进行处理。但是在实践中，为了降低复杂度往往假设当前的状态只与之前某几个时刻状态相关，<strong>下图便是一个典型的RNNs</strong>：</li>
</ol>
<p><img src="figure_6.2_1.png" alt></p>
<p><img src="figure_6.2_2.jpg" alt></p>
<p>输入单元(Input units)：输入集 $\bigr\{x_0,x_1,...,x_t,x_{t+1},...\bigr\}$ ，</p>
<p>输出单元(Output units)：输出集 $\bigr\{y_0,y_1,...,y_t,y_{y+1},...\bigr\}$ ，</p>
<p>隐藏单元(Hidden units)：输出集 $\bigr\{s_0,s_1,...,s_t,s_{t+1},...\bigr\}$ 。</p>
<p><strong>图中信息传递特点：</strong></p>
<ol>
<li>一条单向流动的信息流是从输入单元到隐藏单元。</li>
<li>一条单向流动的信息流从隐藏单元到输出单元。</li>
<li>在某些情况下，RNNs会打破后者的限制，引导信息从输出单元返回隐藏单元，这些被称为“Back Projections”。</li>
<li>在某些情况下，隐藏层的输入还包括上一时刻隐藏层的状态，即隐藏层内的节点可以自连也可以互连。</li>
<li>当前单元（cell）输出是由当前时刻输入和上一时刻隐藏层状态共同决定。</li>
</ol>
<h2 id="6-4-CNN和RNN的区别-？">6.4 CNN和RNN的区别 ？</h2>
<table>
<thead>
<tr>
<th>类别</th>
<th>特点描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>相同点</td>
<td>1、传统神经网络的扩展。<br>2、前向计算产生结果，反向计算模型更新。<br>3、每层神经网络横向可以多个神经元共存,纵向可以有多层神经网络连接。</td>
</tr>
<tr>
<td>不同点</td>
<td>1、CNN空间扩展，神经元与特征卷积；RNN时间扩展，神经元与多个时间输出计算<br>2、RNN可以用于描述时间上连续状态的输出，有记忆功能，CNN用于静态输出</td>
</tr>
</tbody>
</table>
<h2 id="6-5-RNNs和FNNs有什么区别？">6.5 RNNs和FNNs有什么区别？</h2>
<ol>
<li>不同于传统的前馈神经网络(FNNs)，RNNs引入了定向循环，能够处理输入之间前后关联问题。</li>
<li>RNNs可以记忆之前步骤的训练信息。<br>
<strong>定向循环结构如下图所示</strong>：</li>
</ol>
<p><img src="figure_6.1_1.jpg" alt></p>
<h2 id="6-6-RNNs训练和传统ANN训练异同点？">6.6 RNNs训练和传统ANN训练异同点？</h2>
<p><strong>相同点</strong>：</p>
<ol>
<li>RNNs与传统ANN都使用BP（Back Propagation）误差反向传播算法。</li>
</ol>
<p><strong>不同点</strong>：</p>
<ol>
<li>RNNs网络参数W,U,V是共享的(具体在本章6.2节中已介绍)，而传统神经网络各层参数间没有直接联系。</li>
<li>对于RNNs，在使用梯度下降算法中，每一步的输出不仅依赖当前步的网络，还依赖于之前若干步的网络状态。</li>
</ol>
<h2 id="6-7-为什么RNN-训练的时候Loss波动很大">6.7 为什么RNN 训练的时候Loss波动很大</h2>
<p>​	由于RNN特有的memory会影响后期其他的RNN的特点，梯度时大时小，learning rate没法个性化的调整，导致RNN在train的过程中，Loss会震荡起伏，为了解决RNN的这个问题，在训练的时候，可以设置临界值，当梯度大于某个临界值，直接截断，用这个临界值作为梯度的大小，防止大幅震荡。</p>
<h2 id="6-8-标准RNN前向输出流程">6.8 标准RNN前向输出流程</h2>
<p>​	以 $x$ 表示输入， $h$ 是隐层单元， $o$ 是输出， $L$ 为损失函数， $y$ 为训练集标签。 $t$ 表示 $t$ 时刻的状态， $V,U,W$ 是权值，同一类型的连接权值相同。以下图为例进行说明标准RNN的前向传播算法：</p>
<p>​	<img src="rnnbp.png" alt></p>
<p>对于 $t$ 时刻：</p>
 $$
h^{(t)}=\phi(Ux^{(t)}+Wh^{(t-1)}+b)
$$ 
<p>其中 $\phi()$ 为激活函数，一般会选择tanh函数， $b$ 为偏置。</p>
 $t$ 时刻的输出为：
 $$
o^{(t)}=Vh^{(t)}+c
$$ 
<p>模型的预测输出为：</p>
 $$
\widehat{y}^{(t)}=\sigma(o^{(t)})
$$ 
<p>其中 $\sigma​$ 为激活函数，通常RNN用于分类，故这里一般用softmax函数。</p>
<h2 id="6-9-BPTT算法推导">6.9 BPTT算法推导</h2>
<p>​	BPTT（back-propagation through time）算法是常用的训练RNN的方法，其本质还是BP算法，只不过RNN处理时间序列数据，所以要基于时间反向传播，故叫随时间反向传播。BPTT的中心思想和BP算法相同，沿着需要优化的参数的负梯度方向不断寻找更优的点直至收敛。需要寻优的参数有三个，分别是U、V、W。与BP算法不同的是，其中W和U两个参数的寻优过程需要追溯之前的历史数据，参数V相对简单只需关注目前，那么我们就来先求解参数V的偏导数。</p>
 $$
\frac{\partial L^{(t)}}{\partial V}=\frac{\partial L^{(t)}}{\partial o^{(t)}}\cdot \frac{\partial o^{(t)}}{\partial V}
$$ 
<p>RNN的损失也是会随着时间累加的，所以不能只求t时刻的偏导。</p>
 $$
L=\sum_{t=1}^{n}L^{(t)}
$$ 
 $$
\frac{\partial L}{\partial V}=\sum_{t=1}^{n}\frac{\partial L^{(t)}}{\partial o^{(t)}}\cdot \frac{\partial o^{(t)}}{\partial V}
$$ 
<p>​	W和U的偏导的求解由于需要涉及到历史数据，其偏导求起来相对复杂。为了简化推导过程，我们假设只有三个时刻，那么在第三个时刻 L对W，L对U的偏导数分别为：</p>
 $$
\frac{\partial L^{(3)}}{\partial W}=\frac{\partial L^{(3)}}{\partial o^{(3)}}\frac{\partial o^{(3)}}{\partial h^{(3)}}\frac{\partial h^{(3)}}{\partial W}+\frac{\partial L^{(3)}}{\partial o^{(3)}}\frac{\partial o^{(3)}}{\partial h^{(3)}}\frac{\partial h^{(3)}}{\partial h^{(2)}}\frac{\partial h^{(2)}}{\partial W}+\frac{\partial L^{(3)}}{\partial o^{(3)}}\frac{\partial o^{(3)}}{\partial h^{(3)}}\frac{\partial h^{(3)}}{\partial h^{(2)}}\frac{\partial h^{(2)}}{\partial h^{(1)}}\frac{\partial h^{(1)}}{\partial W}
$$ 
 $$
\frac{\partial L^{(3)}}{\partial U}=\frac{\partial L^{(3)}}{\partial o^{(3)}}\frac{\partial o^{(3)}}{\partial h^{(3)}}\frac{\partial h^{(3)}}{\partial U}+\frac{\partial L^{(3)}}{\partial o^{(3)}}\frac{\partial o^{(3)}}{\partial h^{(3)}}\frac{\partial h^{(3)}}{\partial h^{(2)}}\frac{\partial h^{(2)}}{\partial U}+\frac{\partial L^{(3)}}{\partial o^{(3)}}\frac{\partial o^{(3)}}{\partial h^{(3)}}\frac{\partial h^{(3)}}{\partial h^{(2)}}\frac{\partial h^{(2)}}{\partial h^{(1)}}\frac{\partial h^{(1)}}{\partial U}
$$ 
<p>可以观察到，在某个时刻的对W或是U的偏导数，需要追溯这个时刻之前所有时刻的信息。根据上面两个式子得出L在t时刻对W和U偏导数的通式：</p>
 $$
\frac{\partial L^{(t)}}{\partial W}=\sum_{k=0}^{t}\frac{\partial L^{(t)}}{\partial o^{(t)}}\frac{\partial o^{(t)}}{\partial h^{(t)}}(\prod_{j=k+1}^{t}\frac{\partial h^{(j)}}{\partial h^{(j-1)}})\frac{\partial h^{(k)}}{\partial W}
$$ 
 $$
\frac{\partial L^{(t)}}{\partial U}=\sum_{k=0}^{t}\frac{\partial L^{(t)}}{\partial o^{(t)}}\frac{\partial o^{(t)}}{\partial h^{(t)}}(\prod_{j=k+1}^{t}\frac{\partial h^{(j)}}{\partial h^{(j-1)}})\frac{\partial h^{(k)}}{\partial U}
$$ 
<p>整体的偏导公式就是将其按时刻再一一加起来。</p>
<h2 id="6-9-RNN中为什么会出现梯度消失？">6.9 RNN中为什么会出现梯度消失？</h2>
<p>首先来看tanh函数的函数及导数图如下所示：</p>
<p><img src="tanh.jpg" alt></p>
<p>sigmoid函数的函数及导数图如下所示：</p>
<p><img src="sigmoid.jpg" alt></p>
<p>从上图观察可知，sigmoid函数的导数范围是(0,0.25]，tanh函数的导数范围是(0,1]，他们的导数最大都不大于1。</p>
<p>​	基于6.8中式（9-10）中的推导，RNN的激活函数是嵌套在里面的，如果选择激活函数为 $tanh$ 或 $sigmoid$ ，把激活函数放进去，拿出中间累乘的那部分可得：</p>
 $$
\prod_{j=k+1}^{t}{\frac{\partial{h^{j}}}{\partial{h^{j-1}}}} = \prod_{j=k+1}^{t}{tanh^{'}}\cdot W_{s}
$$ 
 $$
\prod_{j=k+1}^{t}{\frac{\partial{h^{j}}}{\partial{h^{j-1}}}} = \prod_{j=k+1}^{t}{sigmoid^{'}}\cdot W_{s}
$$ 
<p>​	<strong>梯度消失现象</strong>：基于上式，会发现累乘会导致激活函数导数的累乘，如果取tanh或sigmoid函数作为激活函数的话，那么必然是一堆小数在做乘法，结果就是越乘越小。随着时间序列的不断深入，小数的累乘就会导致梯度越来越小直到接近于0，这就是“梯度消失“现象。</p>
<p>​	实际使用中，会优先选择tanh函数，原因是tanh函数相对于sigmoid函数来说梯度较大，收敛速度更快且引起梯度消失更慢。</p>
<h2 id="6-10-如何解决RNN中的梯度消失问题？">6.10 如何解决RNN中的梯度消失问题？</h2>
<p>​	上节描述的梯度消失是在无限的利用历史数据而造成，但是RNN的特点本来就是能利用历史数据获取更多的可利用信息，解决RNN中的梯度消失方法主要有：</p>
<p>​	1、选取更好的激活函数，如Relu激活函数。ReLU函数的左侧导数为0，右侧导数恒为1，这就避免了“梯度消失“的发生。但恒为1的导数容易导致“梯度爆炸“，但设定合适的阈值可以解决这个问题。</p>
<p>​	2、加入BN层，其优点包括可加速收敛、控制过拟合，可以少用或不用Dropout和正则、降低网络对初始化权重不敏感，且能允许使用较大的学习率等。</p>
<p>​	2、改变传播结构，LSTM结构可以有效解决这个问题。下面将介绍LSTM相关内容。</p>
<h2 id="6-11-LSTM">6.11 LSTM</h2>
<h3 id="6-11-1-LSTM的产生原因">6.11.1 LSTM的产生原因</h3>
<p>​	RNN在处理长期依赖（时间序列上距离较远的节点）时会遇到巨大的困难，因为计算距离较远的节点之间的联系时会涉及雅可比矩阵的多次相乘，会造成梯度消失或者梯度膨胀的现象。为了解决该问题，研究人员提出了许多解决办法，例如ESN（Echo State Network），增加有漏单元（Leaky Units）等等。其中最成功应用最广泛的就是门限RNN（Gated RNN），而LSTM就是门限RNN中最著名的一种。有漏单元通过设计连接间的权重系数，从而允许RNN累积距离较远节点间的长期联系；而门限RNN则泛化了这样的思想，允许在不同时刻改变该系数，且允许网络忘记当前已经累积的信息。</p>
<h3 id="6-11-2-图解标准RNN和LSTM的区别">6.11.2 图解标准RNN和LSTM的区别</h3>
<p>​	所有 RNN 都具有一种重复神经网络模块的链式的形式。在标准的 RNN 中，这个重复的模块只有一个非常简单的结构，例如一个 tanh 层，如下图所示：</p>
<p><img src="LSTM1.png" alt></p>
<p>​	LSTM 同样是这样的结构，但是重复的模块拥有一个不同的结构。不同于单一神经网络层，这里是有四个，以一种非常特殊的方式进行交互。</p>
<p><img src="LSTM2.png" alt></p>
<p>注：上图图标具体含义如下所示：</p>
<p><img src="LSTM3.png" alt></p>
<p>​	上图中，每一条黑线传输着一整个向量，从一个节点的输出到其他节点的输入。粉色的圈代表 pointwise 的操作，诸如向量的和，而黄色的矩阵就是学习到的神经网络层。合在一起的线表示向量的连接，分开的线表示内容被复制，然后分发到不同的位置。</p>
<h3 id="6-11-3-LSTM核心思想图解">6.11.3 LSTM核心思想图解</h3>
<p>​	LSTM 的关键就是细胞状态，水平线在图上方贯穿运行。细胞状态类似于传送带。直接在整个链上运行，只有一些少量的线性交互。信息在上面流传保持不变会很容易。示意图如下所示：</p>
<p><img src="LSTM4.png" alt></p>
<p>LSTM 有通过精心设计的称作为“门”的结构来去除或者增加信息到细胞状态的能力。门是一种让信息选择式通过的方法。他们包含一个 sigmoid 神经网络层和一个 pointwise 乘法操作。示意图如下：</p>
<p><img src="LSTM5.png" alt></p>
<p>LSTM 拥有三个门，分别是忘记层门，输入层门和输出层门，来保护和控制细胞状态。</p>
<p><strong>忘记层门</strong></p>
<p>​	作用对象：细胞状态 。</p>
<p>​	作用：将细胞状态中的信息选择性的遗忘。</p>
<p>​	操作步骤：该门会读取 $h_{t-1}$ 和 $x_t$ ，输出一个在 0 到 1 之间的数值给每个在细胞状态 $C_{t-1}​$ 中的数字。1 表示“完全保留”，0 表示“完全舍弃”。示意图如下：</p>
<p><img src="LSTM6.png" alt></p>
<p><strong>输入层门</strong></p>
<p>​	作用对象：细胞状态</p>
<p>​	作用：将新的信息选择性的记录到细胞状态中。</p>
<p>​	操作步骤：</p>
<p>​	步骤一，sigmoid 层称 “输入门层” 决定什么值我们将要更新。</p>
<p>​	步骤二，tanh 层创建一个新的候选值向量 $\tilde{C}_t$ 加入到状态中。其示意图如下：</p>
<p><img src="LSTM7.png" alt></p>
<p>​	步骤三：将 $c_{t-1}$ 更新为 $c_{t}$ 。将旧状态与 $f_t$ 相乘，丢弃掉我们确定需要丢弃的信息。接着加上 $i_t * \tilde{C}_t$ 得到新的候选值，根据我们决定更新每个状态的程度进行变化。其示意图如下：</p>
<p><img src="LSTM8.png" alt></p>
<p><strong>输出层门</strong><br>
作用对象：隐层 $h_t$</p>
<p>​	作用：确定输出什么值。</p>
<p>​	操作步骤：</p>
<p>​	步骤一：通过sigmoid 层来确定细胞状态的哪个部分将输出。</p>
<p>​	步骤二：把细胞状态通过 tanh 进行处理，并将它和 sigmoid 门的输出相乘，最终我们仅仅会输出我们确定输出的那部分。</p>
<p>其示意图如下所示：</p>
<p><img src="LSTM9.png" alt></p>
<h3 id="6-11-4-LSTM流行的变体">6.11.4 LSTM流行的变体</h3>
<p><strong>增加peephole 连接</strong></p>
<p>​	在正常的LSTM结构中，Gers F A 等人提出增加peephole 连接，可以门层接受细胞状态的输入。示意图如下所示：</p>
<p><img src="LSTM10.png" alt></p>
<p><strong>对忘记门和输入门进行同时确定</strong></p>
<p>​	不同于之前是分开确定什么忘记和需要添加什么新的信息，这里是一同做出决定。示意图如下所示：</p>
<p><img src="LSTM11.png" alt></p>
<p><strong>Gated Recurrent Unit</strong></p>
<p>​	 由Kyunghyun Cho等人提出的Gated Recurrent Unit (GRU)，其将忘记门和输入门合成了一个单一的更新门，同样还混合了细胞状态和隐藏状态，和其他一些改动。其示意图如下：</p>
<p><img src="LSTM12.png" alt></p>
<p>最终的模型比标准的 LSTM 模型要简单，也是非常流行的变体。</p>
<h2 id="6-12-LSTMs与GRUs的区别">6.12 LSTMs与GRUs的区别</h2>
<p>LSTMs与GRUs的区别如图所示：</p>
<p><img src="figure_6.6.6_2.png" alt></p>
<p>从上图可以看出，二者结构十分相似，<strong>不同在于</strong>：</p>
<ol>
<li>new memory都是根据之前state及input进行计算，但是GRUs中有一个reset gate控制之前state的进入量，而在LSTMs里没有类似gate；</li>
<li>产生新的state的方式不同，LSTMs有两个不同的gate，分别是forget gate (f gate)和input gate(i gate)，而GRUs只有一种update gate(z gate)；</li>
<li>LSTMs对新产生的state可以通过output gate(o gate)进行调节，而GRUs对输出无任何调节。</li>
</ol>
<h2 id="6-13-RNNs在NLP中典型应用？">6.13 RNNs在NLP中典型应用？</h2>
<p><strong>（1）语言模型与文本生成(Language Modeling and Generating Text)</strong></p>
<p>​	给定一组单词序列，需要根据前面单词预测每个单词出现的可能性。语言模型能够评估某个语句正确的可能性，可能性越大，语句越正确。另一种应用便是使用生成模型预测下一个单词的出现概率，从而利用输出概率的采样生成新的文本。</p>
<p><strong>（2）机器翻译(Machine Translation)</strong></p>
<p>​	机器翻译是将一种源语言语句变成意思相同的另一种源语言语句，如将英语语句变成同样意思的中文语句。与语言模型关键的区别在于，需要将源语言语句序列输入后，才进行输出，即输出第一个单词时，便需要从完整的输入序列中进行获取。</p>
<p><strong>（3）语音识别(Speech Recognition)</strong></p>
<p>​	语音识别是指给定一段声波的声音信号，预测该声波对应的某种指定源语言语句以及计算该语句的概率值。</p>
<p><strong>（4）图像描述生成 (Generating Image Descriptions)</strong></p>
<p>​	同卷积神经网络一样，RNNs已经在对无标图像描述自动生成中得到应用。CNNs与RNNs结合也被应用于图像描述自动生成。<br>
<img src="figure_6.4_1.png" alt></p>
<h2 id="6-13-常见的RNNs扩展和改进模型">6.13 常见的RNNs扩展和改进模型</h2>
<h3 id="6-13-1-Simple-RNNs-SRNs">6.13.1 Simple RNNs(SRNs)</h3>
<ol>
<li>SRNs是一个三层网络，其在隐藏层增加了上下文单元。下图中的y是隐藏层，u是上下文单元。上下文单元节点与隐藏层中节点的连接是固定的，并且权值也是固定的。上下文节点与隐藏层节点一一对应，并且值是确定的。</li>
<li>在每一步中，使用标准的前向反馈进行传播，然后使用学习算法进行学习。上下文每一个节点保存其连接隐藏层节点上一步输出，即保存上文，并作用于当前步对应的隐藏层节点状态，即隐藏层的输入由输入层的输出与上一步的自身状态所决定。因此SRNs能够解决标准多层感知机(MLP)无法解决的对序列数据进行预测的问题。<br>
SRNs网络结构如下图所示：</li>
</ol>
<p><img src="figure_6.6.1_1.png" alt></p>
<h3 id="6-13-2-Bidirectional-RNNs">6.13.2 Bidirectional RNNs</h3>
<p>​	Bidirectional RNNs(双向网络)将两层RNNs叠加在一起，当前时刻输出(第t步的输出)不仅仅与之前序列有关，还与之后序列有关。例如：为了预测一个语句中的缺失词语，就需要该词汇的上下文信息。Bidirectional RNNs是一个相对较简单的RNNs，是由两个RNNs上下叠加在一起组成的。输出由前向RNNs和后向RNNs共同决定。如下图所示：</p>
<p><img src="figure_6.6.2_1.png" alt></p>
<h3 id="6-13-3-Deep-RNNs">6.13.3 Deep RNNs</h3>
<p>​	Deep RNNs与Bidirectional RNNs相似，其也是又多层RNNs叠加，因此每一步的输入有了多层网络。该网络具有更强大的表达与学习能力，但是复杂性也随之提高，同时需要更多的训练数据。Deep RNNs的结构如下图所示：<br>
<img src="figure_6.6.3_1.png" alt></p>
<h3 id="6-13-4-Echo-State-Networks（ESNs）">6.13.4 Echo State Networks（ESNs）</h3>
<p><strong>ESNs特点</strong>：</p>
<ol>
<li>它的核心结构为一个随机生成、且保持不变的储备池(Reservoir)。储备池是大规模随机生成稀疏连接(SD通常保持1%～5%，SD表示储备池中互相连接的神经元占总神经元个数N的比例)的循环结构；</li>
<li>从储备池到输出层的权值矩阵是唯一需要调整的部分；</li>
<li>简单的线性回归便能够完成网络训练；</li>
</ol>
<p><strong>ESNs基本思想</strong>：</p>
<p>​	使用大规模随机连接的循环网络取代经典神经网络中的中间层，从而简化网络的训练过程。<br>
网络中的参数包括：<br>
（1）W - 储备池中节点间连接权值矩阵；<br>
（2）Win - 输入层到储备池之间连接权值矩阵，表明储备池中的神经元之间是相互连接；<br>
（3）Wback - 输出层到储备池之间的反馈连接权值矩阵，表明储备池会有输出层来的反馈；<br>
（4）Wout - 输入层、储备池、输出层到输出层的连接权值矩阵，表明输出层不仅与储备池连接，还与输入层和自己连接。<br>
（5）Woutbias - 输出层的偏置项。</p>
<p>​	ESNs的结构如下图所示：</p>
<p><img src="figure_6.6.4_2.png" alt></p>
<h3 id="6-13-4-Gated-Recurrent-Unit-Recurrent-Neural-Networks">6.13.4 Gated Recurrent Unit Recurrent Neural Networks</h3>
<p>GRUs是一般的RNNs的变型版本，其主要是从以下两个方面进行改进。</p>
<ol>
<li>
<p>以语句为例，序列中不同单词处的数据对当前隐藏层状态的影响不同，越前面的影响越小，即每个之前状态对当前的影响进行了距离加权，距离越远，权值越小。</p>
</li>
<li>
<p>在产生误差error时，其可能是由之前某一个或者几个单词共同造成，所以应当对对应的单词weight进行更新。GRUs的结构如下图所示。GRUs首先根据当前输入单词向量word vector以及前一个隐藏层状态hidden state计算出update gate和reset gate。再根据reset gate、当前word vector以及前一个hidden state计算新的记忆单元内容(new memory content)。当reset gate为1的时候，new memory content忽略之前所有memory content，最终的memory是由之前的hidden state与new memory content一起决定。</p>
</li>
</ol>
<p><img src="figure_6.6.5_1.png" alt></p>
<h3 id="6-13-5-Bidirectional-LSTMs">6.13.5 Bidirectional LSTMs</h3>
<ol>
<li>与bidirectional RNNs 类似，bidirectional LSTMs有两层LSTMs。一层处理过去的训练信息，另一层处理将来的训练信息。</li>
<li>在bidirectional LSTMs中，通过前向LSTMs获得前向隐藏状态，后向LSTMs获得后向隐藏状态，当前隐藏状态是前向隐藏状态与后向隐藏状态的组合。</li>
</ol>
<h3 id="6-13-6-Stacked-LSTMs">6.13.6 Stacked LSTMs</h3>
<ol>
<li>与deep rnns 类似，stacked LSTMs 通过将多层LSTMs叠加起来得到一个更加复杂的模型。</li>
<li>不同于bidirectional LSTMs，stacked LSTMs只利用之前步骤的训练信息。</li>
</ol>
<h3 id="6-13-7-Clockwork-RNNs-CW-RNNs">6.13.7 Clockwork RNNs(CW-RNNs)</h3>
<p>​	CW-RNNs是RNNs的改良版本，其使用时钟频率来驱动。它将隐藏层分为几个块(组，Group/Module)，每一组按照自己规定的时钟频率对输入进行处理。为了降低RNNs的复杂度，CW-RNNs减少了参数数量，并且提高了网络性能，加速网络训练。CW-RNNs通过不同隐藏层模块在不同时钟频率下工作来解决长时依赖问题。将时钟时间进行离散化，不同的隐藏层组将在不同时刻进行工作。因此，所有的隐藏层组在每一步不会全部同时工作，这样便会加快网络的训练。并且，时钟周期小组的神经元不会连接到时钟周期大组的神经元，只允许周期大的神经元连接到周期小的(组与组之间的连接以及信息传递是有向的)。周期大的速度慢，周期小的速度快，因此是速度慢的神经元连速度快的神经元，反之则不成立。</p>
<p>​	CW-RNNs与SRNs网络结构类似，也包括输入层(Input)、隐藏层(Hidden)、输出层(Output)，它们之间存在前向连接，输入层到隐藏层连接，隐藏层到输出层连接。但是与SRN不同的是，隐藏层中的神经元会被划分为若干个组，设为 $g​$ ，每一组中的神经元个数相同，设为 $k​$ ，并为每一个组分配一个时钟周期 $T_i\epsilon\{T_1,T_2,...,T_g\}​$ ，每一组中的所有神经元都是全连接，但是组 $j​$ 到组 $i​$ 的循环连接则需要满足 $T_j​$ 大于 $T_i​$ 。如下图所示，将这些组按照时钟周期递增从左到右进行排序，即 $T_1<T_2<...<T_g​$ 4="64个节点，第一组隐藏层与隐藏层的连接矩阵为64" ，那么连接便是从右到左。例如：隐藏层共有256个节点，分为四组，周期分别是[1,2,4,8]，那么每个隐藏层组256 $\times​$ 64的矩阵，第二层的矩阵则为64 128矩阵，第三组为64 (3 64)="64" 192矩阵，第四组为64 (4 256矩阵。这就解释了上一段中速度慢的组连接到速度快的组，反之则不成立。< p>
<p><strong>CW-RNNs的网络结构如下图所示</strong>：</p>
<p><img src="figure_6.6.7_1.png" alt></p>
<h3 id="6-13-8-CNN-LSTMs">6.13.8 CNN-LSTMs</h3>
<ol>
<li>为了同时利用CNN以及LSTMs的优点，CNN-LSTMs被提出。在该模型中，CNN用于提取对象特征，LSTMs用于预测。CNN由于卷积特性，其能够快速而且准确地捕捉对象特征。LSTMs的优点在于能够捕捉数据间的长时依赖性。</li>
</ol>
<h2 id="参考文献">参考文献</h2>
<p>[1] 何之源.<a href="https://zhuanlan.zhihu.com/p/28054589">https://zhuanlan.zhihu.com/p/28054589</a>.</p>
<p>[2] <a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/">http://colah.github.io/posts/2015-08-Understanding-LSTMs/</a></p>
<p>[3] <a href="https://blog.csdn.net/zhaojc1995/article/details/80572098">https://blog.csdn.net/zhaojc1995/article/details/80572098</a></p>
<p>[4] Graves A. Supervised Sequence Labelling with Recurrent Neural Networks[J]. Studies in Computational Intelligence, 2008, 385.</p>
<p>[5] Graves A. Generating Sequences With Recurrent Neural Networks[J]. Computer Science, 2013.</p>
<p>[6]  Greff K ,  Srivastava R K , Koutník, Jan, et al. LSTM: A Search Space Odyssey[J]. IEEE Transactions on Neural Networks &amp; Learning Systems, 2015, 28(10):2222-2232.</p>
<p>[7] Lanchantin J, Singh R, Wang B, et al. DEEP MOTIF DASHBOARD: VISUALIZING AND UNDERSTANDING GENOMIC SEQUENCES USING DEEP NEURAL NETWORKS.[J]. Pacific Symposium on Biocomputing Pacific Symposium on Biocomputing, 2016, 22:254.</p>
<p>[8]  Pascanu R ,  Mikolov T ,  Bengio Y . On the difficulty of training Recurrent Neural Networks[J].  2012.</p>
<p>[9]  Hochreiter S. The Vanishing Gradient Problem During Learning Recurrent Neural Nets and Problem Solutions[J]. International Journal of Uncertainty, Fuzziness and Knowledge-Based Systems, 1998, 06(02):-.</p>
<p>[10] Dyer C, Kuncoro A, Ballesteros M, et al. Recurrent Neural Network Grammars[C]// Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies. 2016.</p>
<p>[11]  Mulder W D ,  Bethard S ,  Moens M F . A survey on the application of recurrent neural networks to statistical language modeling.[M]. Academic Press Ltd.  2015.</p>
<p>[12] Graves A. Generating Sequences With Recurrent Neural Networks[J]. Computer Science, 2013.</p>
<p>[13] Zhang B, Xiong D, Su J. Neural Machine Translation with Deep Attention[J]. IEEE Transactions on Pattern Analysis and Machine Intelligence, 2018, PP(99):1-1.</p>
<p>[14] <a href="https://github.com/xuanyuansen/scalaLSTM">https://github.com/xuanyuansen/scalaLSTM</a></p>
<p>[15] Deep Learning，Ian Goodfellow Yoshua Bengio and Aaron Courville，Book in preparation for MIT Press，2016；</p>
<p>[16] <a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/">http://colah.github.io/posts/2015-08-Understanding-LSTMs/</a></p>
<p>[17] Greff K, Srivastava R K, Koutník J, et al. LSTM: A Search Space Odyssey[J]. IEEE Transactions on Neural Networks &amp; Learning Systems, 2016, 28(10):2222-2232.</p>
<p>[18] Yao K ,  Cohn T ,  Vylomova K , et al. Depth-Gated Recurrent Neural Networks[J].  2015.</p>
<p>[19] Koutník J, Greff K, Gomez F, et al. A Clockwork RNN[J]. Computer Science, 2014:1863-1871.</p>
<p>[20]  Gers F A ,  Schmidhuber J . Recurrent nets that time and count[C]// Neural Networks, 2000. IJCNN 2000, Proceedings of the IEEE-INNS-ENNS International Joint Conference on. IEEE, 2000.</p>
<p>[21] Li S, Wu C, Hai L, et al. FPGA Acceleration of Recurrent Neural Network Based Language Model[C]// IEEE International Symposium on Field-programmable Custom Computing Machines. 2015.</p>
<p>[22]  Mikolov T ,  Kombrink S ,  Burget L , et al. Extensions of recurrent neural network language model[C]// Acoustics, Speech and Signal Processing (ICASSP), 2011 IEEE International Conference on. IEEE, 2011.</p>
<p>[23]  Graves A . Generating Sequences With Recurrent Neural Networks[J]. Computer Science, 2013.</p>
<p>[24]  Sutskever I ,  Vinyals O ,  Le Q V . Sequence to Sequence Learning with Neural Networks[J].  2014.</p>
<p>[25] Liu B, Lane I. Joint Online Spoken Language Understanding and Language Modeling with Recurrent Neural Networks[J].  2016.</p>
<p>[26] Graves A, Mohamed A R, Hinton G. Speech recognition with deep recurrent neural networks[C]// IEEE International Conference on Acoustics. 2013.</p>
<p>[27] <a href="https://cs.stanford.edu/people/karpathy/deepimagesent/">https://cs.stanford.edu/people/karpathy/deepimagesent/</a></p>
<p>[28] Cho K, Van Merriënboer B, Gulcehre C, et al. Learning phrase representations using RNN encoder-decoder for statistical machine translation[J]. arXiv preprint arXiv:1406.1078, 2014.</p>
</T_2<...<T_g​$></p>]]></content>
      <categories>
        <category>算法面试</category>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>刷八股</tag>
      </tags>
  </entry>
  <entry>
    <title>卷积神经网络面试题</title>
    <url>/2024/03/19/deep_learning/ch5/</url>
    <content><![CDATA[<h1>卷积神经网络（CNN）</h1>
<p>​	卷积神经网络是一种用来处理局部和整体相关性的计算网络结构，被应用在图像识别、自然语言处理甚至是语音识别领域，因为图像数据具有显著的局部与整体关系，其在图像识别领域的应用获得了巨大的成功。</p>
<h2 id="5-1-卷积神经网络的组成层">5.1 卷积神经网络的组成层</h2>
<p>​	以图像分类任务为例，在表5.1所示卷积神经网络中，一般包含5种类型的网络层次结构：</p>
<p>​                                                                 表5.1 卷积神经网络的组成</p>
<table>
<thead>
<tr>
<th style="text-align:center">CNN层次结构</th>
<th style="text-align:center">输出尺寸</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">输入层</td>
<td style="text-align:center">$W_1\times H_1\times 3$</td>
<td style="text-align:left">卷积网络的原始输入，可以是原始或预处理后的像素矩阵</td>
</tr>
<tr>
<td style="text-align:center">卷积层</td>
<td style="text-align:center">$W_1\times H_1\times K$</td>
<td style="text-align:left">参数共享、局部连接，利用平移不变性从全局特征图提取局部特征</td>
</tr>
<tr>
<td style="text-align:center">激活层</td>
<td style="text-align:center">$W_1\times H_1\times K$</td>
<td style="text-align:left">将卷积层的输出结果进行非线性映射</td>
</tr>
<tr>
<td style="text-align:center">池化层</td>
<td style="text-align:center">$W_2\times H_2\times K$</td>
<td style="text-align:left">进一步筛选特征，可以有效减少后续网络层次所需的参数量</td>
</tr>
<tr>
<td style="text-align:center">全连接层</td>
<td style="text-align:center">$(W_2 \cdot H_2 \cdot K)\times C$</td>
<td style="text-align:left">将多维特征展平为2维特征，通常低维度特征对应任务的学习目标（类别或回归值）</td>
</tr>
</tbody>
</table>
<blockquote>
 $W_1\times H_1\times 3$ 对应原始图像或经过预处理的像素值矩阵，3对应RGB图像的通道; $K$ 表示卷积层中卷积核（滤波器）的个数; $W_2\times H_2$  为池化后特征图的尺度，在全局池化中尺度对应 $1\times 1$ ; $(W_2 \cdot H_2 \cdot K)$ 是将多维特征压缩到1维之后的大小， $C$ 对应的则是图像类别个数。
</blockquote>
<h3 id="5-1-1-输入层">5.1.1 输入层</h3>
<p>​	输入层(Input Layer)通常是输入卷积神经网络的原始数据或经过预处理的数据，可以是图像识别领域中原始三维的多彩图像，也可以是音频识别领域中经过傅利叶变换的二维波形数据，甚至是自然语言处理中一维表示的句子向量。以图像分类任务为例，输入层输入的图像一般包含RGB三个通道，是一个由长宽分别为 $H$ 和 $W$ 组成的3维像素值矩阵 $H\times W \times 3$ ，卷积网络会将输入层的数据传递到一系列卷积、池化等操作进行特征提取和转化，最终由全连接层对特征进行汇总和结果输出。根据计算能力、存储大小和模型结构的不同，卷积神经网络每次可以批量处理的图像个数不尽相同，若指定输入层接收到的图像个数为 $N$ ，则输入层的输出数据为 $N\times H\times W\times 3$ 。</p>
<h3 id="5-1-2-卷积层">5.1.2 卷积层</h3>
<p>​	卷积层(Convolution Layer)通常用作对输入层输入数据进行特征提取，通过卷积核矩阵对原始数据中隐含关联性的一种抽象。卷积操作原理上其实是对两张像素矩阵进行点乘求和的数学操作，其中一个矩阵为输入的数据矩阵，另一个矩阵则为卷积核（滤波器或特征矩阵），求得的结果表示为原始图像中提取的特定局部特征。图5.1表示卷积操作过程中的不同填充策略，上半部分采用零填充，下半部分采用有效卷积（舍弃不能完整运算的边缘部分）。<br>
​                                                 <img src="convolution.png" alt="conv-same"><br>
​                                                        图5.1 卷积操作示意图</p>
<h3 id="5-1-3-激活层">5.1.3 激活层</h3>
<p>​	激活层(Activation Layer)负责对卷积层抽取的特征进行激活，由于卷积操作是由输入矩阵与卷积核矩阵进行相差的线性变化关系，需要激活层对其进行非线性的映射。激活层主要由激活函数组成，即在卷积层输出结果的基础上嵌套一个非线性函数，让输出的特征图具有非线性关系。卷积网络中通常采用ReLU来充当激活函数（还包括tanh和sigmoid等）ReLU的函数形式如公式（5-1）所示，能够限制小于0的值为0,同时大于等于0的值保持不变。</p>
 $$
f(x)=\begin{cases}
   0 &\text{if } x<0 0 \\ x &\text{if } x\ge \end{cases} \tag{5-1} $$ <h3 id="5-1-4-池化层">5.1.4 池化层
<p>​	池化层又称为降采样层(Downsampling Layer)，作用是对感受域内的特征进行筛选，提取区域内最具代表性的特征，能够有效地降低输出特征尺度，进而减少模型所需要的参数量。按操作类型通常分为最大池化(Max Pooling)、平均池化(Average Pooling)和求和池化(Sum Pooling)，它们分别提取感受域内最大、平均与总和的特征值作为输出，最常用的是最大池化。</p>
<h3 id="5-1-5-全连接层">5.1.5 全连接层</h3>
<p>​	全连接层(Full Connected Layer)负责对卷积神经网络学习提取到的特征进行汇总，将多维的特征输入映射为二维的特征输出，高维表示样本批次，低位常常对应任务目标。</p>
<h2 id="5-2-卷积在图像中有什么直观作用">5.2 卷积在图像中有什么直观作用</h2>
<p>​	在卷积神经网络中，卷积常用来提取图像的特征，但不同层次的卷积操作提取到的特征类型是不相同的，特征类型粗分如表5.2所示。<br>
​                                                                 表5.2 卷积提取的特征类型</p>
<table>
<thead>
<tr>
<th style="text-align:center">卷积层次</th>
<th style="text-align:center">特征类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">浅层卷积</td>
<td style="text-align:center">边缘特征</td>
</tr>
<tr>
<td style="text-align:center">中层卷积</td>
<td style="text-align:center">局部特征</td>
</tr>
<tr>
<td style="text-align:center">深层卷积</td>
<td style="text-align:center">全局特征</td>
</tr>
</tbody>
</table>
<p>图像与不同卷积核的卷积可以用来执行边缘检测、锐化和模糊等操作。表5.3显示了应用不同类型的卷积核（滤波器）后的各种卷积图像。<br>
​                                                                 表5.3 一些常见卷积核的作用</p>
<table>
<thead>
<tr>
<th style="text-align:center">卷积作用</th>
<th style="text-align:center">卷积核</th>
<th style="text-align:center">卷积后图像</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">输出原图</td>
<td style="text-align:center">$\begin{bmatrix} 0 & 0 & 0 \\ 0 & 1 & 0 \\ 0 & 0 & 0 \end{bmatrix}$</td>
<td style="text-align:center"><img src="cat.jpg" alt="origin_img"></td>
</tr>
<tr>
<td style="text-align:center">边缘检测（突出边缘差异）</td>
<td style="text-align:center">$\begin{bmatrix} 1 & 0 & -1 \\ 0 & 0 & 0 \\ -1 & 0 & 1 \end{bmatrix}$</td>
<td style="text-align:center"><img src="cat-edgeDetect.jpg" alt="edgeDetect-1"></td>
</tr>
<tr>
<td style="text-align:center">边缘检测（突出中间值）</td>
<td style="text-align:center">$\begin{bmatrix} -1 & -1 & -1 \\ -1 & 8 & -1 \\ -1 & -1 & -1 \end{bmatrix}$</td>
<td style="text-align:center"><img src="cat-edgeDetect-2.jpg" alt="edgeDetect-2"></td>
</tr>
<tr>
<td style="text-align:center">图像锐化</td>
<td style="text-align:center">$\begin{bmatrix} 0 & -1 & 0 \\ -1 & 5 & -1 \\ 0 & -1 & 0 \end{bmatrix}$</td>
<td style="text-align:center"><img src="cat-sharpen.jpg" alt="sharpen_img"></td>
</tr>
<tr>
<td style="text-align:center">方块模糊</td>
<td style="text-align:center">$\begin{bmatrix} 1 & 1 & 1 \\ 1 & 1 & 1 \\ 1 & 1 & 1 \end{bmatrix} \times \frac{1}{9}$</td>
<td style="text-align:center"><img src="cat-boxblur.jpg" alt="box_blur"></td>
</tr>
<tr>
<td style="text-align:center">高斯模糊</td>
<td style="text-align:center">$\begin{bmatrix} 1 & 2 & 1 \\ 2 & 4 & 2 \\ 1 & 2 & 1 \end{bmatrix} \times \frac{1}{16}$</td>
<td style="text-align:center"><img src="cat-blur-gaussian.jpg" alt="gaussian_blur"></td>
</tr>
</tbody>
</table>
<h2 id="5-3-卷积层有哪些基本参数？">5.3 卷积层有哪些基本参数？</h2>
<p>​	卷积层中需要用到卷积核（滤波器或特征检测器）与图像特征矩阵进行点乘运算，利用卷积核与对应的特征感受域进行划窗式运算时，需要设定卷积核对应的大小、步长、个数以及填充的方式，如表5.4所示。</p>
<p>​                                                            		     表5.4 卷积层的基本参数</p>
<table>
<thead>
<tr>
<th style="text-align:center">参数名</th>
<th style="text-align:left">作用</th>
<th style="text-align:left">常见设置</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">卷积核大小 (Kernel Size)</td>
<td style="text-align:left">卷积核的大小定义了卷积的感受野</td>
<td style="text-align:left">在过去常设为5，如LeNet-5；现在多设为3，通过堆叠 $3\times3$ 的卷积核来达到更大的感受域</td>
</tr>
<tr>
<td style="text-align:center">卷积核步长 (Stride)</td>
<td style="text-align:left">定义了卷积核在卷积过程中的步长</td>
<td style="text-align:left">常见设置为1，表示滑窗距离为1，可以覆盖所有相邻位置特征的组合；当设置为更大值时相当于对特征组合降采样</td>
</tr>
<tr>
<td style="text-align:center">填充方式 (Padding)</td>
<td style="text-align:left">在卷积核尺寸不能完美匹配输入的图像矩阵时需要进行一定的填充策略</td>
<td style="text-align:left">设置为’SAME’表示对不足卷积核大小的边界位置进行某种填充（通常零填充）以保证卷积输出维度与与输入维度一致；当设置为’VALID’时则对不足卷积尺寸的部分进行舍弃，输出维度就无法保证与输入维度一致</td>
</tr>
<tr>
<td style="text-align:center">输入通道数 (In Channels)</td>
<td style="text-align:left">指定卷积操作时卷积核的深度</td>
<td style="text-align:left">默认与输入的特征矩阵通道数（深度）一致；在某些压缩模型中会采用通道分离的卷积方式</td>
</tr>
<tr>
<td style="text-align:center">输出通道数 (Out Channels)</td>
<td style="text-align:left">指定卷积核的个数</td>
<td style="text-align:left">若设置为与输入通道数一样的大小，可以保持输入输出维度的一致性；若采用比输入通道数更小的值，则可以减少整体网络的参数量</td>
</tr>
</tbody>
</table>
<blockquote>
<p>卷积操作维度变换公式：</p>
 $O_d =\begin{cases} \lceil \frac{(I_d - k_{size})+ 1)}{s}\rceil ,& \text{padding=VALID}\\ \lceil \frac{I_d}{s}\rceil,&\text{padding=SAME} \end{cases}$ 
<p>其中， $I_d$ 为输入维度， $O_d$ 为输出维度， $k_{size}$ 为卷积核大小， $s$ 为步长</p>
</blockquote>
<h2 id="5-4-卷积核有什么类型？">5.4 卷积核有什么类型？</h2>
<p>​	常见的卷积主要是由连续紧密的卷积核对输入的图像特征进行滑窗式点乘求和操作，除此之外还有其他类型的卷积核在不同的任务中会用到，具体分类如表5.5所示。<br>
​                                                                 	表5.5 卷积核分类</p>
<table>
<thead>
<tr>
<th style="text-align:center">卷积类别</th>
<th style="text-align:center">示意图</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">标准卷积</td>
<td style="text-align:center"><img src="img7.png" alt="image"></td>
<td style="text-align:left">最常用的卷积核，连续紧密的矩阵形式可以提取图像区域中的相邻像素之间的关联关系， $3\times3$ 的卷积核可以获得 $3\times3$ 像素范围的感受视野</td>
</tr>
<tr>
<td style="text-align:center">扩张卷积（带孔卷积或空洞卷积）</td>
<td style="text-align:center"><img src="img8.png" alt="image"></td>
<td style="text-align:left">引入一个称作扩张率（Dilation Rate）的参数，使同样尺寸的卷积核可以获得更大的感受视野，相应的在相同感受视野的前提下比普通卷积采用更少的参数。同样是 $3\times3$ 的卷积核尺寸，扩张卷积可以提取 $5\times5$ 范围的区域特征，在实时图像分割领域广泛应用</td>
</tr>
<tr>
<td style="text-align:center">转置卷积</td>
<td style="text-align:center"><img src="img10.png" alt="image"></td>
<td style="text-align:left">先对原始特征矩阵进行填充使其维度扩大到适配卷积目标输出维度，然后进行普通的卷积操作的一个过程，其输入到输出的维度变换关系恰好与普通卷积的变换关系相反，但这个变换并不是真正的逆变换操作，通常称为转置卷积(Transpose Convolution)而不是反卷积(Deconvolution)。转置卷积常见于目标检测领域中对小目标的检测和图像分割领域还原输入图像尺度。</td>
</tr>
<tr>
<td style="text-align:center">可分离卷积</td>
<td style="text-align:center"><img src="img11.png" alt="image"></td>
<td style="text-align:left">标准的卷积操作是同时对原始图像 $H\times W\times C$ 三个方向的卷积运算，假设有 $K$ 个相同尺寸的卷积核，这样的卷积操作需要用到的参数为 $H\times W\times C\times K$ 个；若将长宽与深度方向的卷积操作分离出变为 $H\times W$ 与 $C$ 的两步卷积操作，则同样的卷积核个数 $K$ ，只需要 $(H\times W + C)\times K$ 个参数，便可得到同样的输出尺度。可分离卷积(Seperable Convolution)通常应用在模型压缩或一些轻量的卷积神经网络中，如MobileNet $^{[1]}$ 、Xception $^{[2]}$ 等</td>
</tr>
</tbody>
</table>
<h2 id="5-5-二维卷积与三维卷积有什么区别？">5.5 二维卷积与三维卷积有什么区别？</h2>
<ul>
<li><strong>二维卷积</strong><br>
二维卷积操作如图5.3所示，为了更直观的说明，分别展示在单通道和多通道输入中，对单个通道输出的卷积操作。在单通道输入的情况下，若输入卷积核尺寸为  $(k_h, k_w, 1)​$ ，卷积核在输入图像的空间维度上进行滑窗操作，每次滑窗和  $(k_h, k_w)​$ 窗口内的值进行卷积操作，得到输出图像中的一个值。在多通道输入的情况下，假定输入图像特征通道数为3，卷积核尺寸则为 $(k_h, k_w, 3)​$ ，每次滑窗与3个通道上的 $(k_h, k_w)​$ 窗口内的所有值进行卷积操作，得到输出图像中的一个值。</li>
</ul>
<p><img src="5.6.1.png" alt="image"></p>
<ul>
<li><strong>三维卷积</strong><br>
3D卷积操作如图所示，同样分为单通道和多通道，且假定只使用1个卷积核，即输出图像仅有一个通道。对于单通道输入，与2D卷积不同之处在于，输入图像多了一个深度(depth)维度，卷积核也多了一个 $k_d​$ 维度，因此3D卷积核的尺寸为 $(k_h, k_w, k_d)​$ ，每次滑窗与 $(k_h, k_w, k_d)​$ 窗口内的值进行相关操作，得到输出3D图像中的一个值。对于多通道输入，则与2D卷积的操作一样，每次滑窗与3个channels上的 $(k_h, k_w, k_d)​$ 窗口内的所有值进行相关操作，得到输出3D图像中的一个值。</li>
</ul>
<p><img src="5.6.2.png" alt="image"></p>
<h2 id="5-7-有哪些池化方法？">5.7 有哪些池化方法？</h2>
<p>​	池化操作通常也叫做子采样(Subsampling)或降采样(Downsampling)，在构建卷积神经网络时，往往会用在卷积层之后，通过池化来降低卷积层输出的特征维度，有效减少网络参数的同时还可以防止过拟合现象。池化操作可以降低图像维度的原因，本质上是因为图像具有一种“静态性”的属性，这个意思是说在一个图像区域有用的特征极有可能在另一个区域同样有用。因此，为了描述一个大的图像，很直观的想法就是对不同位置的特征进行聚合统计。例如，可以计算图像在固定区域上特征的平均值 (或最大值)来代表这个区域的特征。<br>
​                                                                              表5.6 池化分类</p>
<table>
<thead>
<tr>
<th style="text-align:center">池化类型</th>
<th style="text-align:center">示意图</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">一般池化(General Pooling)</td>
<td style="text-align:center"><img src="general_pooling.png" alt="max_pooling"></td>
<td style="text-align:left">通常包括最大池化(Max Pooling)和平均池化(Mean Pooling)。以最大池化为例，池化范围 $(2\times2)$ 和滑窗步长 $(stride=2)$  相同，仅提取一次相同区域的范化特征。</td>
</tr>
<tr>
<td style="text-align:center">重叠池化(Overlapping Pooling)</td>
<td style="text-align:center"><img src="overlap_pooling.png" alt="overlap_pooling"></td>
<td style="text-align:left">与一般池化操作相同，但是池化范围 $P_{size}$ 与滑窗步长 $stride$ 关系为 $P_{size}>stride$ ，同一区域内的像素特征可以参与多次滑窗提取，得到的特征表达能力更强，但计算量更大。</td>
</tr>
<tr>
<td style="text-align:center">空间金字塔池化 $^*$ (Spatial Pyramid Pooling)</td>
<td style="text-align:center"><img src="spatial_pooling.png" alt="spatial_pooling"></td>
<td style="text-align:left">在进行多尺度目标的训练时，卷积层允许输入的图像特征尺度是可变的，紧接的池化层若采用一般的池化方法会使得不同的输入特征输出相应变化尺度的特征，而卷积神经网络中最后的全连接层则无法对可变尺度进行运算，因此需要对不同尺度的输出特征采样到相同输出尺度。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>SPPNet $^{[3]}$ 就引入了空间池化的组合，对不同输出尺度采用不同的滑窗大小和步长以确保输出尺度相同 $(win_{size}=\lceil \frac{in}{out}\rceil; stride=\lfloor \frac{in}{out}\rfloor; )$ ，同时用如金字塔式叠加的多种池化尺度组合，以提取更加丰富的图像特征。常用于多尺度训练和目标检测中的区域提议网络(Region Proposal Network)的兴趣区域(Region of Interest)提取</p>
</blockquote>
<h2 id="5-8-swig￼58-卷积作用？">5.8  $1\times1$ 卷积作用？</h2>
<p>​	NIN(Network in Network) $^{[4]}​$ 是第一篇探索 $1\times1​$ 卷积核的论文，这篇论文通过在卷积层中使用MLP替代传统线性的卷积核，使单层卷积层内具有非线性映射的能力，也因其网络结构中嵌套MLP子网络而得名NIN。NIN对不同通道的特征整合到MLP自网络中，让不同通道的特征能够交互整合，使通道之间的信息得以流通，其中的MLP子网络恰恰可以用 $1\times1​$ 的卷积进行代替。</p>
<p>​	GoogLeNet $^{[5]}​$ 则采用 $1\times1​$ 卷积核来减少模型的参数量。在原始版本的Inception模块中，由于每一层网络采用了更多的卷积核，大大增加了模型的参数量。此时在每一个较大卷积核的卷积层前引入 $1\times1​$ 卷积，可以通过分离通道与宽高卷积来减少模型参数量。以图5.2为例，在不考虑参数偏置项的情况下，若输入和输出的通道数为 $C_1=16​$ ，则左半边网络模块所需的参数为 $(1\times1+3\times3+5\times5+0)\times C_1\times C_1=8960​$ ；假定右半边网络模块采用的 $1\times1​$ 卷积通道数为 $C_2=8​ {% raw%}$$(满足C_1>C_2)​${% endraw %} ，则右半部分的网络结构所需参数量为 {% raw%}$(1\times1\times (3C_1+C_2)+3\times3\times C_2 +5\times5\times C_2)\times C_1=5248​${% endraw %}  ，可以在不改变模型表达能力的前提下大大减少所使用的参数量。</p>
<p><img src="5.8-1.png" alt="image"></p>
<p>​								图5.2 Inception模块</p>
<p>综上所述， {% raw%}$1\times 1​${% endraw %} 卷积的作用主要为以下两点：</p>
<ul>
<li>实现信息的跨通道交互和整合。</li>
<li>对卷积核通道数进行降维和升维，减小参数量。</li>
</ul>
<h2 id="5-9-卷积层和池化层有什么区别？">5.9 卷积层和池化层有什么区别？</h2>
<p>​	卷积层核池化层在结构上具有一定的相似性，都是对感受域内的特征进行提取，并且根据步长设置获取到不同维度的输出，但是其内在操作是有本质区别的，如表5.7所示。</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">卷积层</th>
<th style="text-align:center">池化层</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>结构</strong></td>
<td style="text-align:center">零填充时输出维度不变，而通道数改变</td>
<td style="text-align:center">通常特征维度会降低，通道数不变</td>
</tr>
<tr>
<td style="text-align:center"><strong>稳定性</strong></td>
<td style="text-align:center">输入特征发生细微改变时，输出结果会改变</td>
<td style="text-align:center">感受域内的细微变化不影响输出结果</td>
</tr>
<tr>
<td style="text-align:center"><strong>作用</strong></td>
<td style="text-align:center">感受域内提取局部关联特征</td>
<td style="text-align:center">感受域内提取泛化特征，降低维度</td>
</tr>
<tr>
<td style="text-align:center"><strong>参数量</strong></td>
<td style="text-align:center">与卷积核尺寸、卷积核个数相关</td>
<td style="text-align:center">不引入额外参数</td>
</tr>
</tbody>
</table>
<h2 id="5-10-卷积核是否一定越大越好？">5.10 卷积核是否一定越大越好？</h2>
<p>​	在早期的卷积神经网络中（如LeNet-5、AlexNet），用到了一些较大的卷积核（ {% raw%}$11\times11${% endraw %} 和 {% raw%}$5\times 5${% endraw %} ），受限于当时的计算能力和模型结构的设计，无法将网络叠加得很深，因此卷积网络中的卷积层需要设置较大的卷积核以获取更大的感受域。但是这种大卷积核反而会导致计算量大幅增加，不利于训练更深层的模型，相应的计算性能也会降低。后来的卷积神经网络（VGG、GoogLeNet等），发现通过堆叠2个 {% raw%}$3\times 3${% endraw %} 卷积核可以获得与 {% raw%}$5\times 5${% endraw %} 卷积核相同的感受视野，同时参数量会更少（ {% raw%}$3×3×2+1${% endraw %}  &lt;  {% raw%}$ 5×5×1+1${% endraw %} ）， {% raw%}$3\times 3${% endraw %} 卷积核被广泛应用在许多卷积神经网络中。因此可以认为，在大多数情况下通过堆叠较小的卷积核比直接采用单个更大的卷积核会更加有效。</p>
<p>​	但是，这并不是表示更大的卷积核就没有作用，在某些领域应用卷积神经网络时仍然可以采用较大的卷积核。譬如在自然语言处理领域，由于文本内容不像图像数据可以对特征进行很深层的抽象，往往在该领域的特征提取只需要较浅层的神经网络即可。在将卷积神经网络应用在自然语言处理领域时，通常都是较为浅层的卷积层组成，但是文本特征有时又需要有较广的感受域让模型能够组合更多的特征（如词组和字符），此时直接采用较大的卷积核将是更好的选择。</p>
<p>​	综上所述，卷积核的大小并没有绝对的优劣，需要视具体的应用场景而定，但是极大和极小的卷积核都是不合适的，单独的 {% raw%}$1\times 1${% endraw %} 极小卷积核只能用作分离卷积而不能对输入的原始特征进行有效的组合，极大的卷积核通常会组合过多的无意义特征从而浪费了大量的计算资源。</p>
<h2 id="5-11-每层卷积是否只能用一种尺寸的卷积核？">5.11 每层卷积是否只能用一种尺寸的卷积核？</h2>
<p>​	经典的神经网络一般都属于层叠式网络，每层仅用一个尺寸的卷积核，如VGG结构中使用了大量的 {% raw%}$3×3${% endraw %} 卷积层。事实上，同一层特征图可以分别使用多个不同尺寸的卷积核，以获得不同尺度的特征，再把这些特征结合起来，得到的特征往往比使用单一卷积核的要好，如GoogLeNet、Inception系列的网络，均是每层使用了多个卷积核结构。如图5.3所示，输入的特征在同一层分别经过 {% raw%}$1×1${% endraw %} 、 {% raw%}$3×3${% endraw %} 和 {% raw%}$5×5${% endraw %} 三种不同尺寸的卷积核，再将分别得到的特征进行整合，得到的新特征可以看作不同感受域提取的特征组合，相比于单一卷积核会有更强的表达能力。</p>
<p><img src="5.11-1.png" alt="image"></p>
<p>​								图5.3 Inception模块结构</p>
<h2 id="5-12-怎样才能减少卷积层参数量？">5.12 怎样才能减少卷积层参数量？</h2>
<p>减少卷积层参数量的方法可以简要地归为以下几点：</p>
<ul>
<li>使用堆叠小卷积核代替大卷积核：VGG网络中2个 {% raw%}$3\times 3${% endraw %} 的卷积核可以代替1个 {% raw%}$5\times 5${% endraw %} 的卷积核</li>
<li>使用分离卷积操作：将原本 {% raw%}$K\times K\times C${% endraw %} 的卷积操作分离为 {% raw%}$K\times K\times 1${% endraw %} 和 {% raw%}$1\times1\times C${% endraw %} 的两部分操作</li>
<li>添加 {% raw%}$1\times 1${% endraw %} 的卷积操作：与分离卷积类似，但是通道数可变，在 {% raw%}$K\times K\times C_1${% endraw %} 卷积前添加 {% raw%}$1\times1\times C_2${% endraw %} 的卷积核（满足 {% raw%}$C_2 <C_1${% endraw %} ）< li>
<li>在卷积层前使用池化操作：池化可以降低卷积层的输入特征维度</li>
</C_1${%></li></ul>
<h2 id="5-13-在进行卷积操作时，必须同时考虑通道和区域吗？">5.13 在进行卷积操作时，必须同时考虑通道和区域吗？</h2>
<p>​	标准卷积中，采用区域与通道同时处理的操作，如下图所示：</p>
<p><img src="5.13-1.png" alt="image"></p>
<p>​	这样做可以简化卷积层内部的结构，每一个输出的特征像素都由所有通道的同一个区域提取而来。</p>
<p>​	但是这种方式缺乏灵活性，并且在深层的网络结构中使得运算变得相对低效，更为灵活的方式是使区域和通道的卷积分离开来，通道分离（深度分离）卷积网络由此诞生。如下图所示，Xception网络可解决上述问题。</p>
<p><img src="5.13-2.png" alt="image"></p>
<p>​	我们首先对每一个通道进行各自的卷积操作，有多少个通道就有多少个过滤器。得到新的通道特征矩阵之后，再对这批新通道特征进行标准的 {% raw%}$1×1​${% endraw %} 跨通道卷积操作。</p>
<h2 id="5-14-采用宽卷积的好处有什么？">5.14 采用宽卷积的好处有什么？</h2>
<p>​	宽卷积对应的是窄卷积，实际上并不是卷积操作的类型，指的是卷积过程中的填充方法，对应的是’SAME’填充和’VALID’填充。'SAME’填充通常采用零填充的方式对卷积核不满足整除条件的输入特征进行补全，以使卷积层的输出维度保持与输入特征维度一致；'VALID’填充的方式则相反，实际并不进行任何填充，在输入特征边缘位置若不足以进行卷积操作，则对边缘信息进行舍弃，因此在步长为1的情况下该填充方式的卷积层输出特征维度可能会略小于输入特征的维度。此外，由于前一种方式通过补零来进行完整的卷积操作，可以有效地保留原始的输入特征信息。</p>
<p>​	比如下图左部分为窄卷积。注意到越在边缘的位置被卷积的次数越少。宽卷积可以看作在卷积之前在边缘用0补充，常见有两种情况，一个是全补充，如下图右部分，这样输出大于输入的维度。另一种常用的方法是补充一一部分0值，使得输出和输入的维度一致。</p>
<p><img src="5.14.1.png" alt="image"></p>
<h2 id="5-15-理解转置卷积与棋盘效应">5.15 理解转置卷积与棋盘效应</h2>
<h3 id="5-15-1-标准卷积">5.15.1 标准卷积</h3>
<p>在理解转置卷积之前，需要先理解标准卷积的运算方式。</p>
<p>首先给出一个输入输出结果</p>
<p><img src="img32.png" alt="image"></p>
<p>那是怎样计算的呢？</p>
<p>卷积的时候需要对卷积核进行180的旋转，同时卷积核中心与需计算的图像像素对齐，输出结构为中心对齐像素的一个新的像素值，计算例子如下：</p>
<p><img src="5.19.1-2.png" alt="image"></p>
<p>这样计算出左上角(即第一行第一列)像素的卷积后像素值。</p>
<p>给出一个更直观的例子，从左到右看，原像素经过卷积由1变成-8。</p>
<p><img src="5.19.1-3.png" alt="image"></p>
<p>通过滑动卷积核，就可以得到整张图片的卷积结果。</p>
<h3 id="5-15-2-转置卷积">5.15.2 转置卷积</h3>
<p>图像的deconvolution过程如下：</p>
<p><img src="5.19.2-5.png" alt="image"></p>
<p>输入：2x2， 卷积核：4x4， 滑动步长：3， 输出：7x7</p>
<p>过程如下：</p>
<ol>
<li>
<p>输入图片每个像素进行一次full卷积，根据full卷积大小计算可以知道每个像素的卷积后大小为 1+4-1=4， 即4x4大小的特征图，输入有4个像素所以4个4x4的特征图</p>
</li>
<li>
<p>将4个特征图进行步长为3的相加； 输出的位置和输入的位置相同。步长为3是指每隔3个像素进行相加，重叠部分进行相加，即输出的第1行第4列是由红色特阵图的第一行第四列与绿色特征图的第一行第一列相加得到，其他如此类推。</p>
<p>可以看出翻卷积的大小是由卷积核大小与滑动步长决定， in是输入大小， k是卷积核大小， s是滑动步长， out是输出大小 得到 out = (in - 1) * s + k 上图过程就是， (2 - 1) * 3 + 4 = 7。</p>
</li>
</ol>
<h3 id="5-15-3-棋盘效应">5.15.3 棋盘效应</h3>
<h2 id="5-16-卷积神经网络的参数设置">5.16 卷积神经网络的参数设置</h2>
<p>​	卷积神经网络中常见的参数在其他类型的神经网络中也是类似的，但是参数的设置还得结合具体的任务才能设置在合理的范围，具体的参数列表如表XX所示。<br>
​                                                    表XX 卷积神经网络常见参数</p>
<table>
<thead>
<tr>
<th style="text-align:center">参数名</th>
<th style="text-align:center">常见设置</th>
<th style="text-align:left">参数说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">学习率(Learning Rate)</td>
<td style="text-align:center">{% raw%}$0-1${% endraw %}</td>
<td style="text-align:left">反向传播网络中更新权值矩阵的步长，在一些常见的网络中会在固定迭代次数或模型不再收敛后对学习率进行指数下降(如 {% raw%}$lr=lr\times 0.1${% endraw %} )。当学习率越大计算误差对权值矩阵的影响越大，容易在某个局部最优解附近震荡；越小的学习率对网络权值的更新越精细，但是需要花费更多的时间去迭代</td>
</tr>
<tr>
<td style="text-align:center">批次大小(Batch Size)</td>
<td style="text-align:center">{% raw%}$1-N${% endraw %}</td>
<td style="text-align:left">批次大小指定一次性流入模型的数据样本个数，根据任务和计算性能限制判断实际取值，在一些图像任务中往往由于计算性能和存储容量限制只能选取较小的值。在相同迭代次数的前提下，数值越大模型越稳定，泛化能力越强，损失值曲线越平滑，模型也更快地收敛，但是每次迭代需要花费更多的时间</td>
</tr>
<tr>
<td style="text-align:center">数据轮次(Epoch)</td>
<td style="text-align:center">{% raw%}$1-N${% endraw %}</td>
<td style="text-align:left">数据轮次指定所有训练数据在模型中训练的次数，根据数据集规模和分布情况会设置为不同的值。当模型较为简单或训练数据规模较小时，通常轮次不宜过高，否则模型容易过拟合；模型较为复杂或训练数据规模足够大时，可适当提高数据的训练轮次。</td>
</tr>
<tr>
<td style="text-align:center">权重衰减系数(Weight Decay)</td>
<td style="text-align:center">{% raw%}$0-0.001${% endraw %}</td>
<td style="text-align:left">模型训练过程中反向传播权值更新的权重衰减值</td>
</tr>
</tbody>
</table>
<h2 id="5-17-提高卷积神经网络的泛化能力">5.17 提高卷积神经网络的泛化能力</h2>
<p>​	卷积神经网络与其他类型的神经网络类似，在采用反向传播进行训练的过程中比较依赖输入的数据分布，当数据分布较为极端的情况下容易导致模型欠拟合或过拟合，表XX记录了提高卷积网络泛化能力的方法。<br>
​                                                                   表XX 提高卷积网络化能力的方法</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">使用更多数据</td>
<td style="text-align:left">在有条件的前提下，尽可能多地获取训练数据是最理想的方法，更多的数据可以让模型得到充分的学习，也更容易提高泛化能力</td>
</tr>
<tr>
<td style="text-align:center">使用更大批次</td>
<td style="text-align:left">在相同迭代次数和学习率的条件下，每批次采用更多的数据将有助于模型更好的学习到正确的模式，模型输出结果也会更加稳定</td>
</tr>
<tr>
<td style="text-align:center">调整数据分布</td>
<td style="text-align:left">大多数场景下的数据分布是不均匀的，模型过多地学习某类数据容易导致其输出结果偏向于该类型的数据，此时通过调整输入的数据分布可以一定程度提高泛化能力</td>
</tr>
<tr>
<td style="text-align:center">调整目标函数</td>
<td style="text-align:left">在某些情况下，目标函数的选择会影响模型的泛化能力，如目标函数 {% raw%}$f(y,y')=|y-y'|${% endraw %} 在某类样本已经识别较为准确而其他样本误差较大的侵害概况下，不同类别在计算损失结果的时候距离权重是相同的，若将目标函数改成 {% raw%}$f(y,y')=(y-y')^2${% endraw %} 则可以使误差小的样本计算损失的梯度比误差大的样本更小，进而有效地平衡样本作用，提高模型泛化能力</td>
</tr>
<tr>
<td style="text-align:center">调整网络结构</td>
<td style="text-align:left">在浅层卷积神经网络中，参数量较少往往使模型的泛化能力不足而导致欠拟合，此时通过叠加卷积层可以有效地增加网络参数，提高模型表达能力；在深层卷积网络中，若没有充足的训练数据则容易导致模型过拟合，此时通过简化网络结构减少卷积层数可以起到提高模型泛化能力的作用</td>
</tr>
<tr>
<td style="text-align:center">数据增强</td>
<td style="text-align:left">数据增强又叫数据增广，在有限数据的前提下通过平移、旋转、加噪声等一些列变换来增加训练数据，同类数据的表现形式也变得更多样，有助于模型提高泛化能力，需要注意的是数据变化应尽可能不破坏元数数据的主体特征(如在图像分类任务中对图像进行裁剪时不能将分类主体目标裁出边界)。</td>
</tr>
<tr>
<td style="text-align:center">权值正则化</td>
<td style="text-align:left">权值正则化就是通常意义上的正则化，一般是在损失函数中添加一项权重矩阵的正则项作为惩罚项，用来惩罚损失值较小时网络权重过大的情况，此时往往是网络权值过拟合了数据样本(如 {% raw%}$Loss=f(WX+b,y')+\frac{\lambda}{\eta}\sum{|W|}${% endraw %} )。</td>
</tr>
<tr>
<td style="text-align:center">屏蔽网络节点</td>
<td style="text-align:left">该方法可以认为是网络结构上的正则化，通过随机性地屏蔽某些神经元的输出让剩余激活的神经元作用，可以使模型的容错性更强。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>对大多数神经网络模型同样通用</p>
</blockquote>
<h2 id="5-18-卷积神经网络在不同领域的应用">5.18 卷积神经网络在不同领域的应用</h2>
<p>​	卷积神经网络中的卷积操作是其关键组成，而卷积操作只是一种数学运算方式，实际上对不同类型的数值表示数据都是通用的，尽管这些数值可能表示的是图像像素值、文本序列中单个字符或是语音片段中单字的音频。只要使原始数据能够得到有效地数值化表示，卷积神经网络能够在不同的领域中得到应用，要关注的是如何将卷积的特性更好地在不同领域中应用，如表XX所示。<br>
​                                                    表XX 卷积神经网络不同领域的应用</p>
<table>
<thead>
<tr>
<th style="text-align:center">应用领域</th>
<th style="text-align:center">输入数据图示</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">图像处理</td>
<td style="text-align:center"><img src="Image-process.png" alt="image_process"></td>
<td style="text-align:left">卷积神经网络在图像处理领域有非常广泛的应用，这是因为图像数据本身具有的局部完整性非常</td>
</tr>
<tr>
<td style="text-align:center">自然语言处理</td>
<td style="text-align:center"><img src="NLP.png" alt="NLP"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">语音处理</td>
<td style="text-align:center"><img src="audio-recognition.png" alt="audio_process"></td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<h3 id="5-18-1-联系">5.18.1 联系</h3>
<p>​	自然语言处理是对一维信号（词序列）做操作。<br>
​	计算机视觉是对二维（图像）或三维（视频流）信号做操作。</p>
<h3 id="5-18-2-区别">5.18.2 区别</h3>
<p>​	自然语言处理的输入数据通常是离散取值（例如表示一个单词或字母通常表示为词典中的one hot向量），计算机视觉则是连续取值（比如归一化到0，1之间的灰度值）。CNN有两个主要特点，区域不变性(location invariance)和组合性(Compositionality)。</p>
<ol>
<li>区域不变性：滤波器在每层的输入向量(图像)上滑动，检测的是局部信息，然后通过pooling取最大值或均值。pooling这步综合了局部特征，失去了每个特征的位置信息。这很适合基于图像的任务，比如要判断一幅图里有没有猫这种生物，你可能不会去关心这只猫出现在图像的哪个区域。但是在NLP里，词语在句子或是段落里出现的位置，顺序，都是很重要的信息。</li>
<li>局部组合性：CNN中，每个滤波器都把较低层的局部特征组合生成较高层的更全局化的特征。这在CV里很好理解，像素组合成边缘，边缘生成形状，最后把各种形状组合起来得到复杂的物体表达。在语言里，当然也有类似的组合关系，但是远不如图像来的直接。而且在图像里，相邻像素必须是相关的，相邻的词语却未必相关。</li>
</ol>
<h2 id="5-19-卷积神经网络凸显共性的方法？">5.19 卷积神经网络凸显共性的方法？</h2>
<h3 id="5-19-1-局部连接">5.19.1 局部连接</h3>
<p>​	我们首先了解一个概念，感受野，即每个神经元仅与输入神经元相连接的一块区域。<br>
在图像卷积操作中，神经元在空间维度上是局部连接，但在深度上是全连接。局部连接的思想，是受启发于生物学里的视觉系统结构，视觉皮层的神经元就是仅用局部接受信息。对于二维图像，局部像素关联性较强。这种局部连接保证了训练后的滤波器能够对局部特征有最强的响应，使神经网络可以提取数据的局部特征；<br>
下图是一个很经典的图示，左边是全连接，右边是局部连接。</p>
<p><img src="5.27.1.png" alt="image"></p>
<p>对于一个1000 × 1000的输入图像而言，如果下一个隐藏层的神经元数目为10^6个，采用全连接则有1000 × 1000 × 10^6 = 10^12个权值参数，如此巨大的参数量几乎难以训练；而采用局部连接，隐藏层的每个神经元仅与图像中10 × 10的局部图像相连接，那么此时的权值参数数量为10 × 10 × 10^6 = 10^8，将直接减少4个数量级。</p>
<h3 id="5-19-2-权值共享">5.19.2 权值共享</h3>
<p>​	权值共享，即计算同一深度的神经元时采用的卷积核参数是共享的。权值共享在一定程度上讲是有意义的，是由于在神经网络中，提取的底层边缘特征与其在图中的位置无关。但是在另一些场景中是无意的，如在人脸识别任务，我们期望在不同的位置学到不同的特征。<br>
需要注意的是，权重只是对于同一深度切片的神经元是共享的。在卷积层中，通常采用多组卷积核提取不同的特征，即对应的是不同深度切片的特征，而不同深度切片的神经元权重是不共享。相反，偏置这一权值对于同一深度切片的所有神经元都是共享的。<br>
权值共享带来的好处是大大降低了网络的训练难度。如下图，假设在局部连接中隐藏层的每一个神经元连接的是一个10 × 10的局部图像，因此有10 × 10个权值参数，将这10 × 10个权值参数共享给剩下的神经元，也就是说隐藏层中10^6个神经元的权值参数相同，那么此时不管隐藏层神经元的数目是多少，需要训练的参数就是这 10 × 10个权值参数（也就是卷积核的大小）。</p>
<p><img src="5.27.2.png" alt="image"></p>
<p>这里就体现了卷积神经网络的奇妙之处，使用少量的参数，却依然能有非常出色的性能。上述仅仅是提取图像一种特征的过程。如果要多提取出一些特征，可以增加多个卷积核，不同的卷积核能够得到图像不同尺度下的特征，称之为特征图（feature map）。</p>
<h3 id="5-19-3-池化操作">5.19.3 池化操作</h3>
<p>池化操作与多层次结构一起，实现了数据的降维，将低层次的局部特征组合成为较高层次的特征，从而对整个图片进行表示。如下图：</p>
<p><img src="5.27.3.png" alt="image"></p>
<h2 id="5-20-全连接、局部连接、全卷积与局部卷积">5.20 全连接、局部连接、全卷积与局部卷积</h2>
<p>​	大多数神经网络中高层网络通常会采用全连接层(Global Connected Layer)，通过多对多的连接方式对特征进行全局汇总，可以有效地提取全局信息。但是全连接的方式需要大量的参数，是神经网络中最占资源的部分之一，因此就需要由局部连接(Local Connected Layer)，仅在局部区域范围内产生神经元连接，能够有效地减少参数量。根据卷积操作的作用范围可以分为全卷积(Global Convolution)和局部卷积(Local Convolution)。实际上这里所说的全卷积就是标准卷积，即在整个输入特征维度范围内采用相同的卷积核参数进行运算，全局共享参数的连接方式可以使神经元之间的连接参数大大减少;局部卷积又叫平铺卷积(Tiled Convolution)或非共享卷积(Unshared Convolution)，是局部连接与全卷积的折衷。四者的比较如表XX所示。<br>
​                                                     表XX 卷积网络中连接方式的对比</p>
<table>
<thead>
<tr>
<th style="text-align:center">连接方式</th>
<th style="text-align:center">示意图</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">全连接</td>
<td style="text-align:center"><img src="full-connected.png" alt="full-connected"></td>
<td style="text-align:left">层间神经元完全连接，每个输出神经元可以获取到所有输入神经元的信息，有利于信息汇总，常置于网络末层；连接与连接之间独立参数，大量的连接大大增加模型的参数规模。</td>
</tr>
<tr>
<td style="text-align:center">局部连接</td>
<td style="text-align:center"><img src="local-connected.png" alt="local-connected"></td>
<td style="text-align:left">层间神经元只有局部范围内的连接，在这个范围内采用全连接的方式，超过这个范围的神经元则没有连接；连接与连接之间独立参数，相比于全连接减少了感受域外的连接，有效减少参数规模</td>
</tr>
<tr>
<td style="text-align:center">全卷积</td>
<td style="text-align:center"><img src="conv.png" alt="convolution"></td>
<td style="text-align:left">层间神经元只有局部范围内的连接，在这个范围内采用全连接的方式，连接所采用的参数在不同感受域之间共享，有利于提取特定模式的特征；相比于局部连接，共用感受域之间的参数可以进一步减少参数量。</td>
</tr>
<tr>
<td style="text-align:center">局部卷积</td>
<td style="text-align:center"><img src="local-conv.png" alt="local-conv"></td>
<td style="text-align:left">层间神经元只有局部范围内的连接，感受域内采用全连接的方式，而感受域之间间隔采用局部连接与全卷积的连接方式；相比与全卷积成倍引入额外参数，但有更强的灵活性和表达能力；相比于局部连接，可以有效控制参数量</td>
</tr>
</tbody>
</table>
<h2 id="5-21-局部卷积的应用">5.21 局部卷积的应用</h2>
<p>并不是所有的卷积都会进行权重共享，在某些特定任务中，会使用不权重共享的卷积。下面通过人脸这一任务来进行讲解。在读人脸方向的一些paper时，会发现很多都会在最后加入一个Local Connected Conv，也就是不进行权重共享的卷积层。总的来说，这一步的作用就是使用3D模型来将人脸对齐，从而使CNN发挥最大的效果。<br>
<img src="img66.png" alt="image"></p>
<p>截取论文中的一部分图，经过3D对齐以后，形成的图像均是152×152，输入到上述的网络结构中。该结构的参数如下：</p>
<p>Conv：32个11×11×3的卷积核，</p>
<p>Max-pooling: 3×3，stride=2，</p>
<p>Conv: 16个9×9的卷积核，</p>
<p>Local-Conv: 16个9×9的卷积核，</p>
<p>Local-Conv: 16个7×7的卷积核，</p>
<p>Local-Conv: 16个5×5的卷积核，</p>
<p>Fully-connected: 4096维，</p>
<p>Softmax: 4030维。</p>
<p>前三层的目的在于提取低层次的特征，比如简单的边和纹理。其中Max-pooling层使得卷积的输出对微小的偏移情况更加鲁棒。但不能使用更多的Max-pooling层，因为太多的Max-pooling层会使得网络损失图像信息。全连接层将上一层的每个单元和本层的所有单元相连，用来捕捉人脸图像不同位置特征之间的相关性。最后使用softmax层用于人脸分类。<br>
中间三层都是使用参数不共享的卷积核，之所以使用参数不共享，有如下原因：</p>
<p>（1）对齐的人脸图片中，不同的区域会有不同的统计特征，因此并不存在特征的局部稳定性，所以使用相同的卷积核会导致信息的丢失。</p>
<p>（2）不共享的卷积核并不增加inference时特征的计算量，仅会增加训练时的计算量。<br>
使用不共享的卷积核，由于需要训练的参数量大大增加，因此往往需要通过其他方法增加数据量。</p>
<h2 id="5-22-NetVLAD池化-（贡献者：熊楚原-中国人民大学）">5.22 NetVLAD池化    （贡献者：熊楚原-中国人民大学）</h2>
<p>NetVLAD是论文[15]提出的一个局部特征聚合的方法。</p>
<p>在传统的网络里面，例如VGG啊，最后一层卷积层输出的特征都是类似于Batchsize x 3 x 3 x 512的这种东西，然后会经过FC聚合，或者进行一个Global Average Pooling（NIN里的做法），或者怎么样，变成一个向量型的特征，然后进行Softmax or 其他的Loss。</p>
<p>这种方法说简单点也就是输入一个图片或者什么的结构性数据，然后经过特征提取得到一个长度固定的向量，之后可以用度量的方法去进行后续的操作，比如分类啊，检索啊，相似度对比等等。</p>
<p>那么NetVLAD考虑的主要是最后一层卷积层输出的特征这里，我们不想直接进行欠采样或者全局映射得到特征，对于最后一层输出的W x H x D，设计一个新的池化，去聚合一个“局部特征“，这即是NetVLAD的作用。</p>
<p>NetVLAD的一个输入是一个W x H x D的图像特征，例如VGG-Net最后的3 x 3 x 512这样的矩阵，在网络中还需加一个维度为Batchsize。</p>
<p>NetVLAD还需要另输入一个标量K即表示VLAD的聚类中心数量，它主要是来构成一个矩阵C，是通过原数据算出来的每一个 {% raw%}$W \times H${% endraw %} 特征的聚类中心，C的shape即 {% raw%}$C: K \times D${% endraw %} ，然后根据三个输入，VLAD是计算下式的V:</p>
<p>$$ V(j, k) = \sum_{i=1}^{N}{a_k(x_i)(x_i(j) - c_k(j))} $$

其中j表示维度，从1到D，可以看到V的j是和输入与c对应的，对每个类别k，都对所有的x进行了计算，如果 {% raw%}$x_i${% endraw %} 属于当前类别k， {% raw%}$a_k=1${% endraw %} ，否则 {% raw%}$a_k=0${% endraw %} ，计算每一个x和它聚类中心的残差，然后把残差加起来，即是每个类别k的结果，最后分别L2正则后拉成一个长向量后再做L2正则，正则非常的重要，因为这样才能统一所有聚类算出来的值，而残差和的目的主要是消减不同聚类上的分布不均，两者共同作用才能得到最后正常的输出。</p>
<p>输入与输出如下图所示：</p>
<p><img src="http://www.ecohnoch.cn/netvlad.jpeg" alt="image"></p>
<p>中间得到的K个D维向量即是对D个x都进行了与聚类中心计算残差和的过程，最终把K个D维向量合起来后进行即得到最终输出的 {% raw%}$K \times D${% endraw %} 长度的一维向量。</p>
<p>而VLAD本身是不可微的，因为上面的a要么是0要么是1，表示要么当前描述x是当前聚类，要么不是，是个离散的，NetVLAD为了能够在深度卷积网络里使用反向传播进行训练，对a进行了修正。</p>
<p>那么问题就是如何重构一个a，使其能够评估当前的这个x和各个聚类的关联程度？用softmax来得到：</p>
<p>$$ a_k = \frac{e^{W_k^T x_i + b_k}}{e^{W_{k’}^T x_i + b_{k’}}} $$

将这个把上面的a替换后，即是NetVLAD的公式，可以进行反向传播更新参数。

所以一共有三个可训练参数，上式a中的 {% raw%}$W: K \times D${% endraw %} ，上式a中的 {% raw%}$b: K \times 1${% endraw %} ，聚类中心 {% raw%}$c: K \times D${% endraw %} ，而原始VLAD只有一个参数c。</p>
<p>最终池化得到的输出是一个恒定的K x D的一维向量（经过了L2正则），如果带Batchsize，输出即为Batchsize x (K x D)的二维矩阵。</p>
<p>NetVLAD作为池化层嵌入CNN网络即如下图所示，</p>
<p><img src="http://www.ecohnoch.cn/netvlad_emb.png" alt="image"></p>
<p>原论文中采用将传统图像检索方法VLAD进行改进后应用在CNN的池化部分作为一种另类的局部特征池化，在场景检索上取得了很好的效果。</p>
<p>后续相继又提出了ActionVLAD、ghostVLAD等改进。</p>
<h2 id="参考文献">参考文献</h2>
<p>[1] 卷积神经网络研究综述[J]. 计算机学报, 2017, 40(6):1229-1251.</p>
<p>[2] 常亮, 邓小明, 周明全,等. 图像理解中的卷积神经网络[J]. 自动化学报, 2016, 42(9):1300-1312.</p>
<p>[3] Chua L O. CNN: A Paradigm for Complexity[M]// CNN a paradigm for complexity /.  1998.</p>
<p>[4] He K, Gkioxari G, Dollar P, et al. Mask R-CNN[J]. IEEE Transactions on Pattern Analysis &amp; Machine Intelligence, 2017, PP(99):1-1.</p>
<p>[5] Hoochang S, Roth H R, Gao M, et al. Deep Convolutional Neural Networks for Computer-Aided Detection: CNN Architectures, Dataset Characteristics and Transfer Learning[J]. IEEE Transactions on Medical Imaging, 2016, 35(5):1285-1298.</p>
<p>[6] 许可. 卷积神经网络在图像识别上的应用的研究[D]. 浙江大学, 2012.</p>
<p>[7] 陈先昌. 基于卷积神经网络的深度学习算法与应用研究[D]. 浙江工商大学, 2014.</p>
<p>[8] <a href="http://cs231n.github.io/convolutional-networks/">CS231n Convolutional Neural Networks for Visual Recognition, Stanford</a></p>
<p>[9] <a href="https://medium.com/@ageitgey/machine-learning-is-fun-part-3-deep-learning-and-convolutional-neural-networks-f40359318721#.2gfx5zcw3">Machine Learning is Fun! Part 3: Deep Learning and Convolutional Neural Networks</a></p>
<p>[10] cs231n 动态卷积图：<a href="http://cs231n.github.io/assets/conv-demo/index.html">http://cs231n.github.io/assets/conv-demo/index.html</a></p>
<p>[11] Krizhevsky A, Sutskever I, Hinton G E. Imagenet classification with deep convolutional neural networks[C]//Advances in neural information processing systems. 2012: 1097-1105.</p>
<p>[12] Sun Y, Wang X, Tang X. Deep learning face representation from predicting 10,000 classes[C]//Computer Vision and Pattern Recognition (CVPR), 2014 IEEE Conference on. IEEE, 2014: 1891-1898.</p>
<p>[13] 魏秀参.解析深度学习——卷积神经网络原理与视觉实践[M].电子工业出版社, 2018</p>
<p>[14]  Jianxin W U ,  Gao B B ,  Wei X S , et al. Resource-constrained deep learning: challenges and practices[J]. Scientia Sinica(Informationis), 2018.</p>
<p>[15] Arandjelovic R , Gronat P , Torii A , et al. [IEEE 2016 IEEE Conference on Computer Vision and Pattern Recognition (CVPR) - Las Vegas, NV, USA (2016.6.27-2016.6.30)] 2016 IEEE Conference on Computer Vision and Pattern Recognition (CVPR) - NetVLAD: CNN Architecture for Weakly Supervised Place Recognition[C]// 2016:5297-5307.</p>
</0>]]></content>
      <categories>
        <category>算法面试</category>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>刷八股</tag>
      </tags>
  </entry>
  <entry>
    <title>生成对抗网络面试题</title>
    <url>/2024/03/19/deep_learning/ch7/</url>
    <content><![CDATA[<h1>生成对抗网络</h1>
<h2 id="7-1-GAN基本概念">7.1 GAN基本概念</h2>
<h3 id="7-1-1-如何通俗理解GAN？">7.1.1 如何通俗理解GAN？</h3>
<p>​	生成对抗网络(GAN, Generative adversarial network)自从2014年被Ian Goodfellow提出以来，掀起来了一股研究热潮。GAN由生成器和判别器组成，生成器负责生成样本，判别器负责判断生成器生成的样本是否为真。生成器要尽可能迷惑判别器，而判别器要尽可能区分生成器生成的样本和真实样本。</p>
<p>​	在GAN的原作[1]中，作者将生成器比喻为印假钞票的犯罪分子，判别器则类比为警察。犯罪分子努力让钞票看起来逼真，警察则不断提升对于假钞的辨识能力。二者互相博弈，随着时间的进行，都会越来越强。那么类比于图像生成任务，生成器不断生成尽可能逼真的假图像。判别器则判断图像是否是真实的图像，还是生成的图像，二者不断博弈优化。最终生成器生成的图像使得判别器完全无法判别真假。</p>
<h3 id="7-1-2-GAN的形式化表达">7.1.2 GAN的形式化表达</h3>
<p>​	上述例子只是简要介绍了一下GAN的思想，下面对于GAN做一个形式化的，更加具体的定义。通常情况下，无论是生成器还是判别器，我们都可以用神经网络来实现。那么，我们可以把通俗化的定义用下面这个模型来表示：<br>
<img src="7.1.png" alt="GAN网络结构"></p>
<p>​	上述模型左边是生成器G，其输入是 $z$ ，对于原始的GAN， $z$ 是由高斯分布随机采样得到的噪声。噪声 $z$ 通过生成器得到了生成的假样本。</p>
<p>​	生成的假样本与真实样本放到一起，被随机抽取送入到判别器D，由判别器去区分输入的样本是生成的假样本还是真实的样本。整个过程简单明了，生成对抗网络中的“生成对抗”主要体现在生成器和判别器之间的对抗。</p>
<h3 id="7-1-3-GAN的目标函数是什么？">7.1.3 GAN的目标函数是什么？</h3>
<p>​	对于上述神经网络模型，如果想要学习其参数，首先需要一个目标函数。GAN的目标函数定义如下：</p>
 $$
\mathop {\min }\limits_G \mathop {\max }\limits_D V(D,G) = {\rm E}_{x\sim{p_{data}(x)}}[\log D(x)] + {\rm E}_{z\sim{p_z}(z)}[\log (1 - D(G(z)))]
$$ 
<p>​	这个目标函数可以分为两个部分来理解：</p>
<p>​	第一部分：判别器的优化通过 $\mathop {\max}\limits_D V(D,G)$ 实现， $V(D,G)$ 为判别器的目标函数，其第一项 ${\rm E}_{x\sim{p_{data}(x)}}[\log D(x)]$ 表示对于从真实数据分布 中采用的样本 ,其被判别器判定为真实样本概率的数学期望。对于真实数据分布 中采样的样本，其预测为正样本的概率当然是越接近1越好。因此希望最大化这一项。第二项 ${\rm E}_{z\sim{p_z}(z)}[\log (1 - D(G(z)))]$ 表示：对于从噪声 $P_z(z)​$ 分布当中采样得到的样本，经过生成器生成之后得到的生成图片，然后送入判别器，其预测概率的负对数的期望，这个值自然是越大越好，这个值越大， 越接近0，也就代表判别器越好。</p>
<p>​	第二部分：生成器的优化通过 $\mathop {\min }\limits_G({\mathop {\max }\limits_D V(D,G)})$ 来实现。注意，生成器的目标不是 $\mathop {\min }\limits_GV(D,G)$ ，即生成器不是最小化判别器的目标函数，二是最小化判别器目标函数的最大值，判别器目标函数的最大值代表的是真实数据分布与生成数据分布的JS散度(详情可以参阅附录的推导)，JS散度可以度量分布的相似性，两个分布越接近，JS散度越小。</p>
<h3 id="7-1-4-GAN的目标函数和交叉熵有什么区别？">7.1.4 GAN的目标函数和交叉熵有什么区别？</h3>
<p>​	判别器目标函数写成离散形式即为:</p>
 $$
V(D,G)=-\frac{1}{m}\sum_{i=1}^{i=m}logD(x^i)-\frac{1}{m}\sum_{i=1}^{i=m}log(1-D(\tilde{x}^i))
$$ 
<p>​	可以看出，这个目标函数和交叉熵是一致的，即<strong>判别器的目标是最小化交叉熵损失，生成器的目标是最小化生成数据分布和真实数据分布的JS散度</strong>。</p>
<hr>
<p>[1]: Goodfellow, Ian, et al. “Generative adversarial nets.” Advances in neural information processing systems. 2014.</p>
<h3 id="7-1-5-GAN的Loss为什么降不下去？">7.1.5 GAN的Loss为什么降不下去？</h3>
<p>​	对于很多GAN的初学者在实践过程中可能会纳闷，为什么GAN的Loss一直降不下去。GAN到底什么时候才算收敛？其实，作为一个训练良好的GAN，其Loss就是降不下去的。衡量GAN是否训练好了，只能由人肉眼去看生成的图片质量是否好。不过，对于没有一个很好的评价是否收敛指标的问题，也有许多学者做了一些研究，后文提及的WGAN就提出了一种新的Loss设计方式，较好的解决了难以判断收敛性的问题。下面我们分析一下GAN的Loss为什么降不下去？<br>
​	对于判别器而言，GAN的Loss如下：</p>
 $$
\mathop {\min }\limits_G \mathop {\max }\limits_D V(D,G) = {\rm E}_{x\sim{p_{data}(x)}}[\log D(x)] + {\rm E}_{z\sim{p_z}(z)}[\log (1 - D(G(z)))]
$$ 
<p>​	从 $\mathop {\min }\limits_G \mathop {\max }\limits_D V(D,G)​$ 可以看出，生成器和判别器的目的相反，也就是说两个生成器网络和判别器网络互为对抗，此消彼长。不可能Loss一直降到一个收敛的状态。</p>
<ul>
<li>对于生成器，其Loss下降快，很有可能是判别器太弱，导致生成器很轻易的就&quot;愚弄&quot;了判别器。</li>
<li>对于判别器，其Loss下降快，意味着判别器很强，判别器很强则说明生成器生成的图像不够逼真，才使得判别器轻易判别，导致Loss下降很快。</li>
</ul>
<p>​	也就是说，无论是判别器，还是生成器。loss的高低不能代表生成器的好坏。一个好的GAN网络，其GAN Loss往往是不断波动的。</p>
<p>​	看到这里可能有点让人绝望，似乎判断模型是否收敛就只能看生成的图像质量了。实际上，后文探讨的WGAN，提出了一种新的loss度量方式，让我们可以通过一定的手段来判断模型是否收敛。</p>
<h3 id="7-1-6-生成式模型、判别式模型的区别？">7.1.6 生成式模型、判别式模型的区别？</h3>
<p>​	对于机器学习模型，我们可以根据模型对数据的建模方式将模型分为两大类，生成式模型和判别式模型。如果我们要训练一个关于猫狗分类的模型，对于判别式模型，只需要学习二者差异即可。比如说猫的体型会比狗小一点。而生成式模型则不一样，需要学习猫张什么样，狗张什么样。有了二者的长相以后，再根据长相去区分。具体而言：</p>
<ul>
<li>
<p>生成式模型：由数据学习联合概率分布P(X,Y), 然后由P(Y|X)=P(X,Y)/P(X)求出概率分布P(Y|X)作为预测的模型。该方法表示了给定输入X与产生输出Y的生成关系</p>
</li>
<li>
<p>判别式模型：由数据直接学习决策函数Y=f(X)或条件概率分布P(Y|X)作为预测模型，即判别模型。判别方法关心的是对于给定的输入X，应该预测什么样的输出Y。</p>
</li>
</ul>
<p>​	对于上述两种模型，从文字上理解起来似乎不太直观。我们举个例子来阐述一下，对于性别分类问题，分别用不同的模型来做：</p>
<p>​	1）如果用生成式模型：可以训练一个模型，学习输入人的特征X和性别Y的关系。比如现在有下面一批数据：</p>
<table>
<thead>
<tr>
<th>Y（性别）</th>
<th></th>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td>X（特征）</td>
<td>0</td>
<td>1/4</td>
<td>3/4</td>
</tr>
<tr>
<td></td>
<td>1</td>
<td>3/4</td>
<td>1/4</td>
</tr>
</tbody>
</table>
<p>​	这个数据可以统计得到，即统计人的特征X=0,1….的时候，其类别为Y=0,1的概率。统计得到上述联合概率分布P(X, Y)后，可以学习一个模型，比如让二维高斯分布去拟合上述数据，这样就学习到了X，Y的联合分布。在预测时，如果我们希望给一个输入特征X，预测其类别，则需要通过贝叶斯公式得到条件概率分布才能进行推断：</p>
 $$
P(Y|X)={\frac{P(X,Y)}{P(X)}}={\frac{P(X,Y)}{P(X|Y)P(Y)}}
$$ 
<p>​	2）如果用判别式模型：可以训练一个模型，输入人的特征X，这些特征包括人的五官，穿衣风格，发型等。输出则是对于性别的判断概率，这个概率服从一个分布，分布的取值只有两个，要么男，要么女，记这个分布为Y。这个过程学习了一个条件概率分布P(Y|X)，即输入特征X的分布已知条件下，Y的概率分布。</p>
<p>​	显然，从上面的分析可以看出。判别式模型似乎要方便很多，因为生成式模型要学习一个X，Y的联合分布往往需要很多数据，而判别式模型需要的数据则相对少，因为判别式模型更关注输入特征的差异性。不过生成式既然使用了更多数据来生成联合分布，自然也能够提供更多的信息，现在有一个样本（X,Y）,其联合概率P（X,Y）经过计算特别小，那么可以认为这个样本是异常样本。这种模型可以用来做outlier detection。</p>
<h3 id="7-1-7-什么是mode-collapsing">7.1.7 什么是mode collapsing?</h3>
<p>​	某个模式(mode)出现大量重复样本，例如：<br>
<img src="model_collpsing.png" alt="model collapsing"><br>
​	上图左侧的蓝色五角星表示真实样本空间，黄色的是生成的。生成样本缺乏多样性，存在大量重复。比如上图右侧中，红框里面人物反复出现。</p>
<h3 id="7-1-8-如何解决mode-collapsing？">7.1.8 如何解决mode collapsing？</h3>
<p>方法一：<strong>针对目标函数的改进方法</strong></p>
<p>​	为了避免前面提到的由于优化maxmin导致mode跳来跳去的问题，UnrolledGAN采用修改生成器loss来解决。具体而言，UnrolledGAN在更新生成器时更新k次生成器，参考的Loss不是某一次的loss，是判别器后面k次迭代的loss。注意，判别器后面k次迭代不更新自己的参数，只计算loss用于更新生成器。这种方式使得生成器考虑到了后面k次判别器的变化情况，避免在不同mode之间切换导致的模式崩溃问题。此处务必和迭代k次生成器，然后迭代1次判别器区分开[8]。DRAGAN则引入博弈论中的无后悔算法，改造其loss以解决mode collapse问题[9]。前文所述的EBGAN则是加入VAE的重构误差以解决mode collapse。</p>
<p>方法二：<strong>针对网络结构的改进方法</strong></p>
<p>​	Multi agent diverse GAN(MAD-GAN)采用多个生成器，一个判别器以保障样本生成的多样性。具体结构如下：</p>
<p><img src="MAD_GAN.png" alt></p>
<p>​	相比于普通GAN，多了几个生成器，且在loss设计的时候，加入一个正则项。正则项使用余弦距离惩罚三个生成器生成样本的一致性。</p>
<p>​	MRGAN则添加了一个判别器来惩罚生成样本的mode collapse问题。具体结构如下：</p>
<p><img src="MRGAN.png" alt></p>
<p>​	输入样本 $x​$ 通过一个Encoder编码为隐变量 $E(x)​$ ，然后隐变量被Generator重构，训练时，Loss有三个。 $D_M​$ 和 $R​$ （重构误差）用于指导生成real-like的样本。而 $D_D​$ 则对 $E(x)​$ 和 $z​$ 生成的样本进行判别，显然二者生成样本都是fake samples，所以这个判别器主要用于判断生成的样本是否具有多样性，即是否出现mode collapse。</p>
<p>方法三：<strong>Mini-batch Discrimination</strong></p>
<p>​	Mini-batch discrimination在判别器的中间层建立一个mini-batch layer用于计算基于L1距离的样本统计量，通过建立该统计量，实现了一个batch内某个样本与其他样本有多接近。这个信息可以被判别器利用到，从而甄别出哪些缺乏多样性的样本。对生成器而言，则要试图生成具有多样性的样本。</p>
<h2 id="7-2-GAN的生成能力评价">7.2 GAN的生成能力评价</h2>
<h3 id="7-2-1-如何客观评价GAN的生成能力？">7.2.1 如何客观评价GAN的生成能力？</h3>
<p>​	最常见评价GAN的方法就是主观评价。主观评价需要花费大量人力物力，且存在以下问题：</p>
<ul>
<li>
<p>评价带有主管色彩，有些bad case没看到很容易造成误判</p>
</li>
<li>
<p>如果一个GAN过拟合了，那么生成的样本会非常真实，人类主观评价得分会非常高，可是这并不是一个好的GAN。</p>
</li>
</ul>
<p>因此，就有许多学者提出了GAN的客观评价方法。</p>
<h3 id="7-2-2-Inception-Score">7.2.2 Inception Score</h3>
<p>​	对于一个在ImageNet训练良好的GAN，其生成的样本丢给Inception网络进行测试的时候，得到的判别概率应该具有如下特性：</p>
<ul>
<li>对于同一个类别的图片，其输出的概率分布应该趋向于一个脉冲分布。可以保证生成样本的准确性。</li>
<li>对于所有类别，其输出的概率分布应该趋向于一个均匀分布，这样才不会出现mode dropping等，可以保证生成样本的多样性。</li>
</ul>
<p>​	因此，可以设计如下指标：</p>
 $$
IS(P_g)=e^{E_{x\sim P_g}[KL(p_M(y|x)\Vert{p_M(y)})]}
根据前面分析，如果是一个训练良好的GAN， {% raw%}$p_M(y|x)​${% endraw %} 趋近于脉冲分布， {% raw%}$p_M(y)​${% endraw %} 趋近于均匀分布。二者KL散度会很大。Inception Score自然就高。实际实验表明，Inception Score和人的主观判别趋向一致。IS的计算没有用到真实数据，具体值取决于模型M的选择
<p>$$<br>
​	根据前面分析，如果是一个训练良好的GAN， $p_M(y|x)$ 趋近于脉冲分布， $p_M(y)$ 趋近于均匀分布。二者KL散度会很大。Inception Score自然就高。实际实验表明，Inception Score和人的主观判别趋向一致。IS的计算没有用到真实数据，具体值取决于模型M的选择。</p>
<p>​	<strong>特点：可以一定程度上衡量生成样本的多样性和准确性，但是无法检测过拟合。Mode Score也是如此。不推荐在和ImageNet数据集差别比较大的数据上使用。</strong></p>
<h3 id="7-2-3-Mode-Score">7.2.3 Mode Score</h3>
<p>​	Mode Score作为Inception Score的改进版本，添加了关于生成样本和真实样本预测的概率分布相似性度量一项。具体公式如下：</p>
 $$
MS(P_g)=e^{E_{x\sim P_g}[KL(p_M(y|x)\Vert{p_M(y)})-KL(p_M(y)\Vert p_M(y^*))]}
$$ 
<h3 id="7-2-4-Kernel-MMD-Maximum-Mean-Discrepancy">7.2.4 Kernel MMD (Maximum Mean Discrepancy)</h3>
<p>计算公式如下：</p>
 $$
MMD^2(P_r,P_g)=E_{x_r\sim{P_r},x_g\sim{P_g}}[\lVert\Sigma_{i=1}^{n1}k(x_r)-\Sigma_{i=1}^{n2}k(x_g)\rVert]
$$ 
<p>​	对于Kernel MMD值的计算，首先需要选择一个核函数 $k$ ，这个核函数把样本映射到再生希尔伯特空间(Reproducing Kernel Hilbert Space, RKHS) ，RKHS相比于欧几里得空间有许多优点，对于函数内积的计算是完备的。将上述公式展开即可得到下面的计算公式：</p>
 $$
MMD^2(P_r,P_g)=E_{x_r,x_r{'}\sim{P_r},x_g,x_g{'}\sim{P_g}}[k(x_r,x_r{'})-2k(x_r,x_g)+k(x_g,x_g{'})]
$$ 
<p>MMD值越小，两个分布越接近。</p>
<p><strong>特点：可以一定程度上衡量模型生成图像的优劣性，计算代价小。推荐使用。</strong></p>
<h3 id="7-2-5-Wasserstein-distance">7.2.5 Wasserstein distance</h3>
<p>​	Wasserstein distance在最优传输问题中通常也叫做推土机距离。这个距离的介绍在WGAN中有详细讨论。公式如下：</p>
 $$
WD(P_r,P_g)=min_{\omega\in\mathbb{R}^{m\times n}}\Sigma_{i=1}^n\Sigma_{i=1}^m\omega_{ij}d(x_i^r,x_j^g)
$$ 
 $$
s.t. \Sigma_{i=1}^mw_{i,j}=p_r(x_i^r),  \forall i;\Sigma_{j=1}^nw_{i,j}=p_g(x_j^g),  \forall j
$$ 
<p>​	Wasserstein distance可以衡量两个分布之间的相似性。距离越小，分布越相似。</p>
<p><strong>特点：如果特征空间选择合适，会有一定的效果。但是计算复杂度为 $O(n^3)​$ 太高</strong></p>
<h3 id="7-2-6-Frechet-Inception-Distance-FID">7.2.6 Fréchet Inception Distance (FID)</h3>
<p>​	FID距离计算真实样本，生成样本在特征空间之间的距离。首先利用Inception网络来提取特征，然后使用高斯模型对特征空间进行建模。根据高斯模型的均值和协方差来进行距离计算。具体公式如下：</p>
 $$
FID(\mathbb P_r,\mathbb P_g)=\lVert\mu_r-\mu_g\rVert+Tr(C_r+C_g-2(C_rC_g)^{1/2})
 {% raw%}$\mu,C${% endraw %} 分别代表协方差和均值。
<p>$$</p>
 $\mu,C​$ 分别代表协方差和均值。
<p>​	<strong>特点：尽管只计算了特征空间的前两阶矩，但是鲁棒，且计算高效。</strong></p>
<h3 id="7-2-7-1-Nearest-Neighbor-classifier">7.2.7 1-Nearest Neighbor classifier</h3>
<p>​	使用留一法，结合1-NN分类器（别的也行）计算真实图片，生成图像的精度。如果二者接近，则精度接近50%，否则接近0%。对于GAN的评价问题，作者分别用正样本的分类精度，生成样本的分类精度去衡量生成样本的真实性，多样性。</p>
<ul>
<li>对于真实样本 $x_r$ ，进行1-NN分类的时候，如果生成的样本越真实。则真实样本空间 $\mathbb R$ 将被生成的样本 $x_g$ 包围。那么 $x_r$ 的精度会很低。</li>
<li>对于生成的样本 $x_g​$ ，进行1-NN分类的时候，如果生成的样本多样性不足。由于生成的样本聚在几个mode，则 $x_g​$ 很容易就和 $x_r​$ 区分，导致精度会很高。</li>
</ul>
<p><strong>特点：理想的度量指标，且可以检测过拟合。</strong></p>
<h3 id="7-2-8-其他评价方法">7.2.8 其他评价方法</h3>
<p>​	AIS，KDE方法也可以用于评价GAN，但这些方法不是model agnostic metrics。也就是说，这些评价指标的计算无法只利用：生成的样本，真实样本来计算。</p>
<h2 id="7-3-其他常见的生成式模型有哪些？">7.3 其他常见的生成式模型有哪些？</h2>
<h3 id="7-3-1-什么是自回归模型：pixelRNN与pixelCNN？">7.3.1 什么是自回归模型：pixelRNN与pixelCNN？</h3>
<p>​	自回归模型通过对图像数据的概率分布 $p_{data}(x)$ 进行显式建模，并利用极大似然估计优化模型。具体如下：</p>
 $$
p_{data}(x)=\prod_{i=1}^np(x_i|x_1,x_2,...,x_{i-1})
$$ 
<p>​	上述公式很好理解，给定 $x_1,x_2,...,x_{i-1}$ 条件下，所有 $p(x_i)$ 的概率乘起来就是图像数据的分布。如果使用RNN对上述依然关系建模，就是pixelRNN。如果使用CNN，则是pixelCNN。具体如下[5]：</p>
<p><img src="pixRNN.png" alt></p>
<p><img src="pixCNN.png" alt></p>
<p>​	显然，不论是对于pixelCNN还是pixelRNN，由于其像素值是一个个生成的，速度会很慢。语音领域大火的WaveNet就是一个典型的自回归模型。</p>
<h3 id="7-3-2-什么是VAE？">7.3.2 什么是VAE？</h3>
<p>​	PixelCNN/RNN定义了一个易于处理的密度函数，我们可以直接优化训练数据的似然；对于变分自编码器我们将定义一个不易处理的密度函数，通过附加的隐变量 $z$ 对密度函数进行建模。 VAE原理图如下[6]：</p>
<p><img src="VAE.png" alt></p>
<p>​	在VAE中，真实样本 $X$ 通过神经网络计算出均值方差（假设隐变量服从正太分布），然后通过采样得到采样变量 $Z$ 并进行重构。VAE和GAN均是学习了隐变量 $z$ 到真实数据分布的映射。但是和GAN不同的是：</p>
<ul>
<li>GAN的思路比较粗暴，使用一个判别器去度量分布转换模块（即生成器）生成分布与真实数据分布的距离。</li>
<li>VAE则没有那么直观，VAE通过约束隐变量 $z$ 服从标准正太分布以及重构数据实现了分布转换映射 $X=G(z)$</li>
</ul>
<p><strong>生成式模型对比</strong></p>
<ul>
<li>自回归模型通过对概率分布显式建模来生成数据</li>
<li>VAE和GAN均是：假设隐变量 $z$ 服从某种分布，并学习一个映射 $X=G(z)$ ，实现隐变量分布 $z$ 与真实数据分布 $p_{data}(x)$ 的转换。</li>
<li>GAN使用判别器去度量映射 $X=G(z)$ 的优劣，而VAE通过隐变量 $z$ 与标准正太分布的KL散度和重构误差去度量。</li>
</ul>
<h2 id="7-4-GAN的改进与优化">7.4 GAN的改进与优化</h2>
<h3 id="7-4-1-如何生成指定类型的图像——条件GAN">7.4.1 如何生成指定类型的图像——条件GAN</h3>
<p>​	条件生成对抗网络（CGAN, Conditional Generative Adversarial Networks）作为一个GAN的改进，其一定程度上解决了GAN生成结果的不确定性。如果在Mnist数据集上训练原始GAN，GAN生成的图像是完全不确定的，具体生成的是数字1，还是2，还是几，根本不可控。为了让生成的数字可控，我们可以把数据集做一个切分，把数字0~9的数据集分别拆分开训练9个模型，不过这样太麻烦了，也不现实。因为数据集拆分不仅仅是分类麻烦，更主要在于，每一个类别的样本少，拿去训练GAN很有可能导致欠拟合。因此，CGAN就应运而生了。我们先看一下CGAN的网络结构：<br>
<img src="CGAN%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84.png" alt="CGAN网络结构"><br>
​	从网络结构图可以看到，对于生成器Generator，其输入不仅仅是随机噪声的采样z，还有欲生成图像的标签信息。比如对于mnist数据生成，就是一个one-hot向量，某一维度为1则表示生成某个数字的图片。同样地，判别器的输入也包括样本的标签。这样就使得判别器和生成器可以学习到样本和标签之间的联系。Loss如下：</p>
 $$
\mathop {\min }\limits_G \mathop {\max }\limits_D V(D,G) = {\rm E}_{x\sim{p_{data}(x)}}[\log D(x|y)] + {\rm E}_{z\sim{p_z}(z)}[\log (1 - D(G(z|y)))]
$$ 
<p>​	Loss设计和原始GAN基本一致，只不过生成器，判别器的输入数据是一个条件分布。在具体编程实现时只需要对随机噪声采样z和输入条件y做一个级联即可。</p>
<h3 id="7-4-2-CNN与GAN——DCGAN">7.4.2 CNN与GAN——DCGAN</h3>
<p>​	前面我们聊的GAN都是基于简单的神经网络构建的。可是对于视觉问题，如果使用原始的基于DNN的GAN，则会出现许多问题。如果输入GAN的随机噪声为100维的随机噪声，输出图像为256x256大小。也就是说，要将100维的信息映射为65536维。如果单纯用DNN来实现，那么整个模型参数会非常巨大，而且学习难度很大（低维度映射到高维度需要添加许多信息）。因此，DCGAN就出现了。具体而言，DCGAN将传统GAN的生成器，判别器均采用GAN实现，且使用了一下tricks：</p>
<ul>
<li>将pooling层convolutions替代，其中，在discriminator上用strided convolutions替代，在generator上用fractional-strided convolutions替代。</li>
<li>在generator和discriminator上都使用batchnorm。</li>
<li>移除全连接层，global pooling增加了模型的稳定性，但伤害了收敛速度。</li>
<li>在generator的除了输出层外的所有层使用ReLU，输出层采用tanh。</li>
<li>在discriminator的所有层上使用LeakyReLU。</li>
</ul>
<p>网络结构图如下：<br>
<img src="DCGAN%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="CGAN网络结构图"></p>
<h3 id="7-4-3-如何理解GAN中的输入随机噪声？">7.4.3 如何理解GAN中的输入随机噪声？</h3>
<p>​	为了了解输入随机噪声每一个维度代表的含义，作者做了一个非常有趣的工作。即在隐空间上，假设知道哪几个变量控制着某个物体，那么僵这几个变量挡住是不是就可以将生成图片中的某个物体消失？论文中的实验是这样的：首先，生成150张图片，包括有窗户的和没有窗户的，然后使用一个逻辑斯底回归函数来进行分类，对于权重不为0的特征，认为它和窗户有关。将其挡住，得到新的生成图片，结果如下：<br>
<img src="7.4.3.png" alt="DCGAN输入噪声理解"><br>
此外，将几个输入噪声进行算数运算，可以得到语义上进行算数运算的非常有趣的结果。类似于word2vec。<br>
<img src="7.4.3-2.png" alt="DCGAN输入噪声算术运算"></p>
<h3 id="7-4-4-GAN为什么容易训练崩溃？">7.4.4 GAN为什么容易训练崩溃？</h3>
<p>​	所谓GAN的训练崩溃，指的是训练过程中，生成器和判别器存在一方压倒另一方的情况。<br>
GAN原始判别器的Loss在判别器达到最优的时候，等价于最小化生成分布与真实分布之间的JS散度，由于随机生成分布很难与真实分布有不可忽略的重叠以及JS散度的突变特性，使得生成器面临梯度消失的问题；可是如果不把判别器训练到最优，那么生成器优化的目标就失去了意义。因此需要我们小心的平衡二者，要把判别器训练的不好也不坏才行。否则就会出现训练崩溃，得不到想要的结果</p>
<h3 id="7-4-5-WGAN如何解决训练崩溃问题？">7.4.5 WGAN如何解决训练崩溃问题？</h3>
<p>​	WGAN作者提出了使用Wasserstein距离，以解决GAN网络训练过程难以判断收敛性的问题。Wasserstein距离定义如下:</p>
 $$
L={\rm E}_{x\sim{p_{data}}(x)}[f_w(x)] - {\rm E}_{x\sim{p_g}(x)}[f_w(x)]
$$ 
<p>通过最小化Wasserstein距离，得到了WGAN的Loss：</p>
<ul>
<li>WGAN生成器Loss： $- {\rm E}_{x\sim{p_g}(x)}[f_w(x)]​$</li>
<li>WGAN判别器Loss： $L=-{\rm E}_{x\sim{p_{data}}(x)}[f_w(x)] + {\rm E}_{x\sim{p_g}(x)}[f_w(x)]$</li>
</ul>
<p>从公式上GAN似乎总是让人摸不着头脑，在代码实现上来说，其实就以下几点：</p>
<ul>
<li>判别器最后一层去掉sigmoid</li>
<li>生成器和判别器的loss不取log</li>
<li>每次更新判别器的参数之后把它们的绝对值截断到不超过一个固定常数c</li>
</ul>
<h3 id="7-4-6-WGAN-GP：带有梯度正则的WGAN">7.4.6 WGAN-GP：带有梯度正则的WGAN</h3>
<p>​	实际实验过程发现，WGAN没有那么好用，主要原因在于WAGN进行梯度截断。梯度截断将导致判别网络趋向于一个二值网络，造成模型容量的下降。<br>
于是作者提出使用梯度惩罚来替代梯度裁剪。公式如下：</p>
 $$
L=-{\rm E}_{x\sim{p_{data}}(x)}[f_w(x)] + {\rm E}_{x\sim{p_g}(x)}[f_w(x)]+\lambda{\rm E}_{x\sim{p_x}(x)}[\lVert\nabla_x(D(x))\rVert_p-1]^2
由于上式是对每一个梯度进行惩罚，所以不适合使用BN，因为它会引入同个batch中不同样本的相互依赖关系。如果需要的话，可以选择Layer Normalization。实际训练过程中，就可以通过Wasserstein距离来度量模型收敛程度了：
![Wass距离随迭代次数变化](ch7/Wass%E8%B7%9D%E7%A6%BB%E9%9A%8F%E8%BF%AD%E4%BB%A3%E6%AC%A1%E6%95%B0%E5%8F%98%E5%8C%96.png)
上图纵坐标是Wasserstein距离，横坐标是迭代次数。可以看出，随着迭代的进行，Wasserstein距离趋于收敛，生成图像也趋于稳定。
$$ 
<p>​	由于上式是对每一个梯度进行惩罚，所以不适合使用BN，因为它会引入同个batch中不同样本的相互依赖关系。如果需要的话，可以选择Layer Normalization。实际训练过程中，就可以通过Wasserstein距离来度量模型收敛程度了：<br>
<img src="Wass%E8%B7%9D%E7%A6%BB%E9%9A%8F%E8%BF%AD%E4%BB%A3%E6%AC%A1%E6%95%B0%E5%8F%98%E5%8C%96.png" alt="Wass距离随迭代次数变化"><br>
​	上图纵坐标是Wasserstein距离，横坐标是迭代次数。可以看出，随着迭代的进行，Wasserstein距离趋于收敛，生成图像也趋于稳定。</p>
<h3 id="7-4-7-LSGAN">7.4.7 LSGAN</h3>
<p>​	LSGAN（Least Squares GAN）这篇文章主要针对标准GAN的稳定性和图片生成质量不高做了一个改进。作者将原始GAN的交叉熵损失采用最小二乘损失替代。LSGAN的Loss：</p>
 $$
\mathop{\min }\limits_DJ(D)=\mathop{\min}\limits_D[{\frac{1}{2}}{\rm E}_{x\sim{p_{data}}(x)}[D(x)-a]^2 + {\frac{1}{2}}{\rm E}_{z\sim{p_z}(z)}[D(G(z))-b]^2]
$$ 
 $$
\mathop{\min }\limits_GJ(G)=\mathop{\min}\limits_G{\frac{1}{2}}{\rm E}_{z\sim{p_z}(z)}[D(G(z))-c]^2
$$ 
<p>​	实际实现的时候非常简单，最后一层去掉sigmoid，并且计算Loss的时候用平方误差即可。之所以这么做，作者在原文给出了一张图:<br>
![LSGAN交叉熵与最小二乘损失对比图](ch7/lsgan loss compare.png)<br>
​	上面是作者给出的基于交叉熵损失以及最小二乘损失的Loss函数。横坐标代表Loss函数的输入，纵坐标代表输出的Loss值。可以看出，随着输入的增大，sigmoid交叉熵损失很快趋于0，容易导致梯度饱和问题。如果使用右边的Loss设计，则只在x=0点处饱和。因此使用LSGAN可以很好的解决交叉熵损失的问题。</p>
<h3 id="7-4-8-如何尽量避免GAN的训练崩溃问题？">7.4.8 如何尽量避免GAN的训练崩溃问题？</h3>
<ul>
<li>归一化图像输入到（-1，1）之间；Generator最后一层使用tanh激活函数</li>
<li>生成器的Loss采用：min (log 1-D)。因为原始的生成器Loss存在梯度消失问题；训练生成器的时候，考虑反转标签，real=fake, fake=real</li>
<li>不要在均匀分布上采样，应该在高斯分布上采样</li>
<li>一个Mini-batch里面必须只有正样本，或者负样本。不要混在一起；如果用不了Batch Norm，可以用Instance Norm</li>
<li>避免稀疏梯度，即少用ReLU，MaxPool。可以用LeakyReLU替代ReLU，下采样可以用Average Pooling或者Convolution + stride替代。上采样可以用PixelShuffle, ConvTranspose2d + stride</li>
<li>平滑标签或者给标签加噪声；平滑标签，即对于正样本，可以使用0.7-1.2的随机数替代；对于负样本，可以使用0-0.3的随机数替代。  给标签加噪声：即训练判别器的时候，随机翻转部分样本的标签。</li>
<li>如果可以，请用DCGAN或者混合模型：KL+GAN，VAE+GAN。</li>
<li>使用LSGAN，WGAN-GP</li>
<li>Generator使用Adam，Discriminator使用SGD</li>
<li>尽快发现错误；比如：判别器Loss为0，说明训练失败了；如果生成器Loss稳步下降，说明判别器没发挥作用</li>
<li>不要试着通过比较生成器，判别器Loss的大小来解决训练过程中的模型坍塌问题。比如：<br>
While Loss D &gt; Loss A:<br>
Train D<br>
While Loss A &gt; Loss D:<br>
Train A</li>
<li>如果有标签，请尽量利用标签信息来训练</li>
<li>给判别器的输入加一些噪声，给G的每一层加一些人工噪声。</li>
<li>多训练判别器，尤其是加了噪声的时候</li>
<li>对于生成器，在训练，测试的时候使用Dropout</li>
</ul>
<h2 id="7-3-GAN的应用（图像翻译）">7.3 GAN的应用（图像翻译）</h2>
<h3 id="7-3-1-什么是图像翻译？">7.3.1 什么是图像翻译？</h3>
<p>​	GAN作为一种强有力的生成模型，其应用十分广泛。最为常见的应用就是图像翻译。所谓图像翻译，指从一副图像到另一副图像的转换。可以类比机器翻译，一种语言转换为另一种语言。常见的图像翻译任务有：</p>
<ul>
<li>
<p>图像去噪</p>
</li>
<li>
<p>图像超分辨</p>
</li>
<li>
<p>图像补全</p>
</li>
<li>
<p>风格迁移</p>
</li>
<li>
<p>…</p>
<p>本节将介绍一个经典的图像翻译网络及其改进。图像翻译可以分为有监督图像翻译和无监督图像翻译：</p>
</li>
<li>
<p>有监督图像翻译：原始域与目标域存在一一对应数据</p>
</li>
<li>
<p>无监督图像翻译：原始域与目标域不存在一一对应数据</p>
</li>
</ul>
<h3 id="7-3-2-有监督图像翻译：pix2pix">7.3.2 有监督图像翻译：pix2pix</h3>
<p>​	在这篇paper里面，作者提出的框架十分简洁优雅（好用的算法总是简洁优雅的）。相比以往算法的大量专家知识，手工复杂的loss。这篇paper非常粗暴，使用CGAN处理了一系列的转换问题。下面是一些转换示例：<br>
<img src="pix2pix%E7%BB%93%E6%9E%9C%E7%A4%BA%E4%BE%8B.png" alt="pix2pix结果示例"></p>
<p>​	上面展示了许多有趣的结果，比如分割图 $\longrightarrow$ 街景图，边缘图 $\longrightarrow$ 真实图。对于第一次看到的时候还是很惊艳的，那么这个是怎么做到的呢？我们可以设想一下，如果是我们，我们自己会如何设计这个网络？</p>
<p><strong>直观的想法</strong>？</p>
<p>​	最直接的想法就是，设计一个CNN网络，直接建立输入-输出的映射，就像图像去噪问题一样。可是对于上面的问题，这样做会带来一个问题。<strong>生成图像质量不清晰。</strong></p>
<p>​	拿左上角的分割图 $\longrightarrow$ 街景图为例，语义分割图的每个标签比如“汽车”可能对应不同样式，颜色的汽车。那么模型学习到的会是所有不同汽车的评均，这样会造成模糊。<img src="pix2pix%E8%AF%AD%E4%B9%89%E5%9C%B0%E5%9B%BEL1loss%E7%BB%93%E6%9E%9C.png" alt="pix2pix语义地图L1loss结果"></p>
<p><strong>如何解决生成图像的模糊问题</strong>？</p>
<p>​	这里作者想了一个办法，即加入GAN的Loss去惩罚模型。GAN相比于传统生成式模型可以较好的生成高分辨率图片。思路也很简单，在上述直观想法的基础上加入一个判别器，判断输入图片是否是真实样本。模型示意图如下：<br>
<img src="pix2pix%E6%A8%A1%E5%9E%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="pix2pix模型示意图"></p>
<p>​	上图模型和CGAN有所不同，但它是一个CGAN，只不过输入只有一个，这个输入就是条件信息。原始的CGAN需要输入随机噪声，以及条件。这里之所有没有输入噪声信息，是因为在实际实验中，如果输入噪声和条件，噪声往往被淹没在条件C当中，所以这里直接省去了。</p>
<h3 id="7-3-3-其他图像翻译的tricks">7.3.3  其他图像翻译的tricks</h3>
<p>从上面两点可以得到最终的Loss由两部分构成：</p>
<ul>
<li>
<p>输出和标签信息的L1 Loss。</p>
</li>
<li>
<p>GAN Loss</p>
</li>
<li>
<p>测试也使用Dropout，以使输出多样化</p>
 $$
  G^*=arg\mathop {\min }\limits_G \mathop {\max }\limits_D \Gamma_{cGAN}(G,D)+\lambda\Gamma_{L1}(G)
  $$ 
</li>
</ul>
<p>​	采用L1 Loss而不是L2 Loss的理由很简单，L1 Loss相比于L2 Loss保边缘（L2 Loss基于高斯先验，L1 Loss基于拉普拉斯先验）。</p>
<p>​	GAN Loss为LSGAN的最小二乘Loss，并使用PatchGAN(进一步保证生成图像的清晰度)。PatchGAN将图像换分成很多个Patch，并对每一个Patch使用判别器进行判别（实际代码实现有更取巧的办法），将所有Patch的Loss求平均作为最终的Loss。</p>
<h3 id="7-3-4-如何生成高分辨率图像和高分辨率视频？">7.3.4 如何生成高分辨率图像和高分辨率视频？</h3>
<p>​	pix2pix提出了一个通用的图像翻译框架。对于高分辨率的图像生成以及高分辨率的视频生成，则需要利用更好的网络结构以及更多的先验只是。pix2pixHD提出了一种多尺度的生成器以及判别器等方式从而生成高分辨率图像。Vid2Vid则在pix2pixHD的基础上利用光流，时序约束生成了高分辨率视频。</p>
<h3 id="7-3-5-有监督的图像翻译的缺点？">7.3.5 有监督的图像翻译的缺点？</h3>
<p>​	许多图像翻译算法如前面提及的pix2pix系列，需要一一对应的图像。可是在许多应用场景下，往往没有这种一一对应的强监督信息。比如说以下一些应用场景：<br>
<img src="CycleGAN%E7%BB%93%E6%9E%9C%E4%BE%8B%E5%AD%90.png" alt="CycleGAN结果例子"><br>
以第一排第一幅图为例，要找到这种一一配对的数据是不现实的。因此，无监督图像翻译算法就被引入了。</p>
<h3 id="7-3-6-无监督图像翻译：CycleGAN">7.3.6 无监督图像翻译：CycleGAN</h3>
<p><strong>模型结构</strong></p>
<p>​	总体思路如下，假设有两个域的数据，记为A，B。对于上图第一排第一幅图A域就是普通的马，B域就是斑马。由于A-&gt;B的转换缺乏监督信息，于是，作者提出采用如下方法进行转换：</p>
<blockquote>
<p>a.	A-&gt;fake_B-&gt;rec_A<br>
b.	B-&gt;fake_A-&gt;rec_B</p>
</blockquote>
<p>​	对于A域的所有图像，学习一个网络G_B，该网络可以生成B。对于B域的所有图像，也学习一个网络G_A，该网络可以生成G_B。</p>
<p>​	训练过程分成两步，首先对于A域的某张图像，送入G_B生成fake_B，然后对fake_B送入G_A，得到重构后的A图像rec_A。对于B域的某一张图像也是类似。重构后的图像rec_A/rec_B可以和原图A/B做均方误差，实现了有监督的训练。此处值得注意的是A-&gt;fake_B(B-&gt;fake_A)和fake_A-&gt;rec_B(fake_B-&gt;rec_A)的网络是一模一样的。下图是形象化的网络结构图：<br>
<img src="CycleGAN%E6%A8%A1%E5%9E%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="CycleGAN模型示意图"><br>
​	cycleGAN的生成器采用U-Net，判别器采用LS-GAN。</p>
<p><strong>Loss设计</strong></p>
<p>​	总的Loss就是X域和Y域的GAN Loss，以及Cycle consistency loss：</p>
 $$
L(G,F,D_X,D_Y)=L_{GAN}(G,D_Y,X,Y)+L_{GAN}(F,D_X,Y,X)+\lambda L_{cycle}(G,F)
$$ 
<p>整个过程End to end训练，效果非常惊艳，利用这一框架可以完成非常多有趣的任务</p>
<h3 id="7-3-7-多领域的无监督图像翻译：StarGAN">7.3.7 多领域的无监督图像翻译：StarGAN</h3>
<p>cycleGAN模型较好的解决了无监督图像转换问题，可是这种单一域的图像转换还存在一些问题：</p>
<ul>
<li>
<p>要针对每一个域训练一个模型，效率太低。举例来说，我希望可以将橘子转换为红苹果和青苹果。对于cycleGAN而言，需要针对红苹果，青苹果分别训练一个模型。</p>
</li>
<li>
<p>对于每一个域都需要搜集大量数据，太麻烦。还是以橘子转换为红苹果和青苹果为例。不管是红苹果还是青苹果，都是苹果，只是颜色不一样而已。这两个任务信息是可以共享的，没必要分别训练两个模型。而且针对红苹果，青苹果分别取搜集大量数据太费事。</p>
<p>starGAN则提出了一个多领域的无监督图像翻译框架，实现了多个领域的图像转换，且对于不同领域的数据可以混合在一起训练，提高了数据利用率</p>
</li>
</ul>
<h2 id="7-4-GAN的应用（文本生成）">7.4 GAN的应用（文本生成）</h2>
<h3 id="7-4-1-GAN为什么不适合文本任务？">7.4.1 GAN为什么不适合文本任务？</h3>
<p>​	GAN在2014年被提出之后，在图像生成领域取得了广泛的研究应用。然后在文本领域却一直没有很惊艳的效果。主要在于文本数据是离散数据，而GAN在应用于离散数据时存在以下几个问题：</p>
<ul>
<li>GAN的生成器梯度来源于判别器对于正负样本的判别。然而，对于文本生成问题，RNN输出的是一个概率序列，然后取argmax。这会导致生成器Loss不可导。还可以站在另一个角度理解，由于是argmax，所以参数更新一点点并不会改变argmax的结果，这也使得GAN不适合离散数据。</li>
<li>GAN只能评估整个序列的loss，但是无法评估半句话，或者是当前生成单词对后续结果好坏的影响。</li>
<li>如果不加argmax，那么由于生成器生成的都是浮点数值，而ground truth都是one-hot encoding，那么判别器只要判别生成的结果是不是0/1序列组成的就可以了。这容易导致训练崩溃。</li>
</ul>
<h3 id="7-4-2-seqGAN用于文本生成">7.4.2 seqGAN用于文本生成</h3>
<p>​	seqGAN在GAN的框架下，结合强化学习来做文本生成。 模型示意图如下：</p>
<p><img src="seqGAN%E6%A8%A1%E5%9E%8B.png" alt="seqGAN模型"><br>
在文本生成任务，seqGAN相比较于普通GAN区别在以下几点：</p>
<ul>
<li>生成器不取argmax。</li>
<li>每生成一个单词，则根据当前的词语序列进行蒙特卡洛采样生成完成的句子。然后将句子送入判别器计算reward。</li>
<li>根据得到的reward进行策略梯度下降优化模型。</li>
</ul>
<h2 id="7-5-GAN在其他领域的应用">7.5 GAN在其他领域的应用</h2>
<h3 id="7-5-1-数据增广">7.5.1 数据增广</h3>
<p>​	GAN的良好生成特性近年来也开始被用于数据增广。以行人重识别为例，有许多GAN用于数据增广的工作[1-4]。行人重识别问题一个难点在于不同摄像头下拍摄的人物环境，角度差别非常大，导致存在较大的Domain gap。因此，可以考虑使用GAN来产生不同摄像头下的数据进行数据增广。以论文[1]为例，本篇paper提出了一个cycleGAN用于数据增广的方法。具体模型结构如下：</p>
<p><img src="cycleGAN%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%B9%BF.png" alt="cycleGAN数据增广"></p>
<p>​	对于每一对摄像头都训练一个cycleGAN，这样就可以实现将一个摄像头下的数据转换成另一个摄像头下的数据，但是内容（人物）保持不变。<br>
在CVPR19中，[9]进一步提升了图像的生成质量，进行了“淘宝换衣”式的高质量图像生成（如下图），提供了更高质量的行人训练数据。</p>
<p><img src="https://github.com/NVlabs/DG-Net/raw/master/NxN.jpg" alt="DG-Net数据增广"></p>
<h3 id="7-5-2-图像超分辨与图像补全">7.5.2 图像超分辨与图像补全</h3>
<p>​	图像超分辨与补全均可以作为图像翻译问题，该类问题的处理办法也大都是训练一个端到端的网络，输入是原始图片，输出是超分辨率后的图片，或者是补全后的图片。文献[5]利用GAN作为判别器，使得超分辨率模型输出的图片更加清晰，更符合人眼主管感受。日本早稻田大学研究人员[6]提出一种全局+局部一致性的GAN实现图像补全，使得修复后的图像不仅细节清晰，且具有整体一致性。</p>
<h3 id="7-5-3-语音领域">7.5.3 语音领域</h3>
<p>​	相比于图像领域遍地开花，GAN在语音领域则应用相对少了很多。这里零碎的找一些GAN在语音领域进行应用的例子作为介绍。文献[7]提出了一种音频去噪的SEGAN，缓解了传统方法支持噪声种类稀少，泛化能力不强的问题。Donahue利用GAN进行语音增强，提升了ASR系统的识别率。</p>
<h2 id="参考文献">参考文献</h2>
<p>[1] Zheng Z , Zheng L , Yang Y . Unlabeled Samples Generated by GAN Improve the Person Re-identification Baseline in Vitro[C]// 2017 IEEE International Conference on Computer Vision (ICCV). IEEE Computer Society, 2017.</p>
<p>[2]  Zhong Z ,  Zheng L ,  Zheng Z , et al. Camera Style Adaptation for Person Re-identification[J].  2017.</p>
<p>[3]  Deng W ,  Zheng L ,  Ye Q , et al. Image-Image Domain Adaptation with Preserved Self-Similarity and Domain-Dissimilarity for Person Re-identification[J].  2017.</p>
<p>[4]  Wei L ,  Zhang S ,  Gao W , et al. Person Transfer GAN to Bridge Domain Gap for Person Re-Identification[J].  CVPR, 2017.</p>
<p>[5]  Ledig C ,  Theis L ,  Huszar F , et al. Photo-Realistic Single Image Super-Resolution Using a Generative Adversarial Network[J].  CVPR, 2016.</p>
<p>[6]  Iizuka S ,  Simo-Serra E ,  Ishikawa H . Globally and locally consistent image completion[J]. ACM Transactions on Graphics, 2017, 36(4):1-14.</p>
<p>[7] Pascual S , Bonafonte A , Serrà, Joan. SEGAN: Speech Enhancement Generative Adversarial Network[J]. 2017.</p>
<p>[8]  Donahue C ,  Li B ,  Prabhavalkar R . Exploring Speech Enhancement with Generative Adversarial Networks for Robust Speech Recognition[J].  2017.</p>
<p>[9] Zheng, Z., Yang, X., Yu, Z., Zheng, L., Yang, Y., &amp; Kautz, J. Joint discriminative and generative learning for person re-identification. IEEE Conference on Computer Vision and Pattern Recognition (CVPR)[C]. 2019.</p>
]]></content>
      <categories>
        <category>算法面试</category>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>刷八股</tag>
      </tags>
  </entry>
  <entry>
    <title>目标检测面试题</title>
    <url>/2024/03/19/deep_learning/ch8/</url>
    <content><![CDATA[<h1>目标检测</h1>
<h2 id="8-1-基本概念">8.1 基本概念</h2>
<h3 id="8-1-1-什么是目标检测？">8.1.1 什么是目标检测？</h3>
<p>​	目标检测（Object Detection）的任务是找出图像中所有感兴趣的目标（物体），确定它们的类别和位置，是计算机视觉领域的核心问题之一。由于各类物体有不同的外观、形状和姿态，加上成像时光照、遮挡等因素的干扰，目标检测一直是计算机视觉领域最具有挑战性的问题。</p>
<p>​	计算机视觉中关于图像识别有四大类任务：</p>
<p><strong>分类-Classification</strong>：解决“是什么？”的问题，即给定一张图片或一段视频判断里面包含什么类别的目标。</p>
<p><strong>定位-Location</strong>：解决“在哪里？”的问题，即定位出这个目标的的位置。</p>
<p><strong>检测-Detection</strong>：解决“是什么？在哪里？”的问题，即定位出这个目标的的位置并且知道目标物是什么。</p>
<p><strong>分割-Segmentation</strong>：分为实例的分割（Instance-level）和场景分割（Scene-level），解决“每一个像素属于哪个目标物或场景”的问题。</p>
<p><img src="8.1.1.png" alt="图像识别四大类任务，图像来源于cs231n 2016课件Lecture 8"></p>
<h3 id="8-1-2-目标检测要解决的核心问题？">8.1.2 目标检测要解决的核心问题？</h3>
<p>除了图像分类之外，目标检测要解决的核心问题是：</p>
<p>1.目标可能出现在图像的任何位置。</p>
<p>2.目标有各种不同的大小。</p>
<p>3.目标可能有各种不同的形状。</p>
<h3 id="8-1-3-目标检测算法分类？">8.1.3 目标检测算法分类？</h3>
<p>基于深度学习的目标检测算法主要分为两类：</p>
<p><strong>1.Two stage目标检测算法</strong></p>
<p>​	先进行区域生成（region proposal，RP）（一个有可能包含待检物体的预选框），再通过卷积神经网络进行样本分类。</p>
<p>​	任务：特征提取—&gt;生成RP—&gt;分类/定位回归。</p>
<p>​	常见的two stage目标检测算法有：R-CNN、SPP-Net、Fast R-CNN、Faster R-CNN和R-FCN等。</p>
<p><strong>2.One stage目标检测算法</strong></p>
<p>​	不用RP，直接在网络中提取特征来预测物体分类和位置。</p>
<p>​	任务：特征提取—&gt;分类/定位回归。</p>
<p>​	常见的one stage目标检测算法有：OverFeat、YOLOv1、YOLOv2、YOLOv3、SSD和RetinaNet等。</p>
<p><img src="8.1.2.png" alt></p>
<h3 id="8-1-4-目标检测有哪些应用？">8.1.4 目标检测有哪些应用？</h3>
<p>​	目标检测具有巨大的实用价值和应用前景。应用领域包括人脸检测、行人检测、车辆检测、飞机航拍或卫星图像中道路的检测、车载摄像机图像中的障碍物检测、医学影像在的病灶检测等。还有在安防领域中，可以实现比如安全帽、安全带等动态检测，移动侦测、区域入侵检测、物品看护等功能。</p>
<h2 id="8-2-Two-Stage目标检测算法">8.2 Two Stage目标检测算法</h2>
<h3 id="8-2-1-R-CNN">8.2.1 R-CNN</h3>
<p><strong>R-CNN有哪些创新点？</strong></p>
<ol>
<li>使用CNN（ConvNet）对 region proposals 计算 feature vectors。从经验驱动特征（SIFT、HOG）到数据驱动特征（CNN feature map），提高特征对样本的表示能力。</li>
<li>采用大样本下（ILSVRC）有监督预训练和小样本（PASCAL）微调（fine-tuning）的方法解决小样本难以训练甚至过拟合等问题。</li>
</ol>
<p>注：ILSVRC其实就是众所周知的ImageNet的挑战赛，数据量极大；PASCAL数据集（包含目标检测和图像分割等），相对较小。</p>
<p><strong>R-CNN 介绍</strong></p>
<p>​	R-CNN作为R-CNN系列的第一代算法，其实没有过多的使用“深度学习”思想，而是将“深度学习”和传统的“计算机视觉”的知识相结合。比如R-CNN pipeline中的第二步和第四步其实就属于传统的“计算机视觉”技术。使用selective search提取region proposals，使用SVM实现分类。</p>
<p><img src="8.2.1-1.png" alt></p>
<p>原论文中R-CNN pipeline只有4个步骤，光看上图无法深刻理解R-CNN处理机制，下面结合图示补充相应文字</p>
<ol>
<li>
<p>预训练模型。选择一个预训练 （pre-trained）神经网络（如AlexNet、VGG）。</p>
</li>
<li>
<p>重新训练全连接层。使用需要检测的目标重新训练（re-train）最后全连接层（connected layer）。</p>
</li>
<li>
<p>提取 proposals并计算CNN 特征。利用选择性搜索（Selective Search）算法提取所有proposals（大约2000幅images），调整（resize/warp）它们成固定大小，以满足 CNN输入要求（因为全连接层的限制），然后将feature map 保存到本地磁盘。</p>
<p><img src="8.1.4.png" alt></p>
</li>
<li>
<p>训练SVM。利用feature map 训练SVM来对目标和背景进行分类（每个类一个二进制SVM）</p>
</li>
<li>
<p>边界框回归（Bounding boxes Regression）。训练将输出一些校正因子的线性回归分类器</p>
</li>
</ol>
<p><img src="8.1.5.png" alt></p>
<p><strong>R-CNN 实验结果</strong></p>
<p>R-CNN在VOC 2007测试集上mAP达到58.5%，打败当时所有的目标检测算法。</p>
<p><img src="8.1.6.png" alt></p>
<h3 id="8-2-2-Fast-R-CNN">8.2.2 Fast R-CNN</h3>
<p><strong>Fast R-CNN有哪些创新点？</strong></p>
<ol>
<li>只对整幅图像进行一次特征提取，避免R-CNN中的冗余特征提取</li>
<li>用RoI pooling层替换最后一层的max pooling层，同时引入建议框数据，提取相应建议框特征</li>
<li>Fast R-CNN网络末尾采用并行的不同的全连接层，可同时输出分类结果和窗口回归结果，实现了end-to-end的多任务训练【建议框提取除外】，也不需要额外的特征存储空间【R-CNN中的特征需要保持到本地，来供SVM和Bounding-box regression进行训练】</li>
<li>采用SVD对Fast R-CNN网络末尾并行的全连接层进行分解，减少计算复杂度，加快检测速度。</li>
</ol>
<p><strong>Fast R-CNN 介绍</strong></p>
<p>​	Fast R-CNN是基于R-CNN和SPPnets进行的改进。SPPnets，其创新点在于计算整幅图像的the shared feature map，然后根据object proposal在shared feature map上映射到对应的feature vector（就是不用重复计算feature map了）。当然，SPPnets也有缺点：和R-CNN一样，训练是多阶段（multiple-stage pipeline）的，速度还是不够&quot;快&quot;，特征还要保存到本地磁盘中。</p>
<p>将候选区域直接应用于特征图，并使用RoI池化将其转化为固定大小的特征图块。以下是Fast R-CNN的流程图</p>
<p><img src="8.2.2-1.png" alt></p>
<p><strong>RoI Pooling层详解</strong></p>
<p>因为Fast R-CNN使用全连接层，所以应用RoI Pooling将不同大小的ROI转换为固定大小。</p>
<p>RoI Pooling 是Pooling层的一种，而且是针对RoI的Pooling，其特点是输入特征图尺寸不固定，但是输出特征图尺寸固定（如7x7）。</p>
<p><strong>什么是RoI呢？</strong></p>
<p>RoI是Region of Interest的简写，一般是指图像上的区域框，但这里指的是由Selective Search提取的候选框。</p>
<p><img src="8.2.2-2.png" alt></p>
<p>往往经过RPN后输出的不止一个矩形框，所以这里我们是对多个RoI进行Pooling。</p>
<p><strong>RoI Pooling的输入</strong></p>
<p>输入有两部分组成：</p>
<ol>
<li>特征图（feature map）：指的是上面所示的特征图，在Fast RCNN中，它位于RoI Pooling之前，在Faster RCNN中，它是与RPN共享那个特征图，通常我们常常称之为“share_conv”；</li>
<li>RoIs，其表示所有RoI的N*5的矩阵。其中N表示RoI的数量，第一列表示图像index，其余四列表示其余的左上角和右下角坐标。</li>
</ol>
<p>在Fast RCNN中，指的是Selective Search的输出；在Faster RCNN中指的是RPN的输出，一堆矩形候选框，形状为1x5x1x1（4个坐标+索引index），其中值得注意的是：坐标的参考系不是针对feature map这张图的，而是针对原图的（神经网络最开始的输入）。其实关于ROI的坐标理解一直很混乱，到底是根据谁的坐标来。其实很好理解，我们已知原图的大小和由Selective Search算法提取的候选框坐标，那么根据&quot;映射关系&quot;可以得出特征图（featurwe map）的大小和候选框在feature map上的映射坐标。至于如何计算，其实就是比值问题，下面会介绍。所以这里把ROI理解为原图上各个候选框（region proposals），也是可以的。</p>
<p>注：说句题外话，由Selective Search算法提取的一系列可能含有object的bounding box，这些通常称为region proposals或者region of interest（ROI）。</p>
<p><strong>RoI的具体操作</strong></p>
<ol>
<li>
<p>根据输入image，将ROI映射到feature map对应位置</p>
<p>注：映射规则比较简单，就是把各个坐标除以“输入图片与feature map的大小的比值”，得到了feature map上的box坐标</p>
</li>
<li>
<p>将映射后的区域划分为相同大小的sections（sections数量与输出的维度相同）</p>
</li>
<li>
<p>对每个sections进行max pooling操作</p>
</li>
</ol>
<p>这样我们就可以从不同大小的方框得到固定大小的相应 的feature maps。值得一提的是，输出的feature maps的大小不取决于ROI和卷积feature maps大小。RoI Pooling 最大的好处就在于极大地提高了处理速度。</p>
<p><strong>RoI Pooling的输出</strong></p>
<p>输出是batch个vector，其中batch的值等于RoI的个数，vector的大小为channel * w * h；RoI Pooling的过程就是将一个个大小不同的box矩形框，都映射成大小固定（w * h）的矩形框。</p>
<p><strong>RoI Pooling示例</strong></p>
<p><img src="8.1.11.gif" alt></p>
<h3 id="8-2-3-Faster-R-CNN">8.2.3 Faster R-CNN</h3>
<p><strong>Faster R-CNN有哪些创新点？</strong></p>
<p>Fast R-CNN依赖于外部候选区域方法，如选择性搜索。但这些算法在CPU上运行且速度很慢。在测试中，Fast R-CNN需要2.3秒来进行预测，其中2秒用于生成2000个ROI。Faster R-CNN采用与Fast R-CNN相同的设计，只是它用内部深层网络代替了候选区域方法。新的候选区域网络（RPN）在生成ROI时效率更高，并且以每幅图像10毫秒的速度运行。<br>
<img src="8.2.3-1.png" alt></p>
<p>图8.1.13 Faster R-CNN的流程图<br>
Faster R-CNN的流程图与Fast R-CNN相同，采用外部候选区域方法代替了内部深层网络。<br>
<img src="8.2.3-2.png" alt></p>
<p>图8.1.14<br>
<strong>候选区域网络</strong></p>
<p>候选区域网络（RPN）将第一个卷积网络的输出特征图作为输入。它在特征图上滑动一个3×3的卷积核，以使用卷积网络（如下所示的ZF网络）构建与类别无关的候选区域。其他深度网络（如VGG或ResNet）可用于更全面的特征提取，但这需要以速度为代价。ZF网络最后会输出256个值，它们将馈送到两个独立的全连接层，以预测边界框和两个objectness分数，这两个objectness分数度量了边界框是否包含目标。我们其实可以使用回归器计算单个objectness分数，但为简洁起见，Faster R-CNN使用只有两个类别的分类器：即带有目标的类别和不带有目标的类别。<br>
<img src="8.2.3-3.png" alt></p>
<p>图8.1.15<br>
对于特征图中的每一个位置，RPN会做k次预测。因此，RPN将输出4×k个坐标和每个位置上2×k个得分。下图展示了8×8的特征图，且有一个3×3的卷积核执行运算，它最后输出8×8×3个ROI（其中k=3）。下图（右）展示了单个位置的3个候选区域。<br>
<img src="8.2.3-4.png" alt></p>
<p>图8.1.16<br>
假设最好涵盖不同的形状和大小。因此，Faster R-CNN不会创建随机边界框。相反，它会预测一些与左上角名为锚点的参考框相关的偏移量（如x, y）。我们限制这些偏移量的值，因此我们的猜想仍然类似于锚点。<br>
<img src="8.1.17.png" alt></p>
<p>图8.1.17<br>
要对每个位置进行k个预测，我们需要以每个位置为中心的k个锚点。每个预测与特定锚点相关联，但不同位置共享相同形状的锚点。<br>
<img src="8.2.3-6.png" alt></p>
<p>图8.1.18<br>
这些锚点是精心挑选的，因此它们是多样的，且覆盖具有不同比例和宽高比的现实目标。这使得我们可以用更好的猜想来指导初始训练，并允许每个预测专门用于特定的形状。该策略使早期训练更加稳定和简便。<br>
<img src="8.2.3-7.png" alt></p>
<p>图8.1.19<br>
Faster R-CNN使用更多的锚点。它部署9个锚点框：3个不同宽高比的3个不同大小的锚点（Anchor）框。每一个位置使用9个锚点，每个位置会生成2×9个objectness分数和4×9个坐标。</p>
<h3 id="8-2-4-R-FCN">8.2.4 R-FCN</h3>
<p><strong>R-FCN有哪些创新点？</strong></p>
<p>R-FCN 仍属于two-stage 目标检测算法：RPN+R-FCN</p>
<ol>
<li>Fully convolutional</li>
<li>位置敏感得分图（position-sentive score maps）</li>
</ol>
<blockquote>
<p>our region-based detector is <strong>fully convolutional</strong> with almost all computation shared on the entire image. To achieve this goal, we propose <strong>position-sensitive score maps</strong> to address a dilemma between translation-invariance in image classification and translation-variance in object detection.</p>
</blockquote>
<p>R-FCN backbone：ResNet</p>
<p>ResNet-101+R-FCN：83.6% in PASCAL VOC 2007 test datasets</p>
<p>既提高了mAP，又加快了检测速度</p>
<pre><code>假设我们只有一个特征图用来检测右眼。那么我们可以使用它定位人脸吗？应该可以。因为右眼应该在人脸图像的左上角，所以我们可以利用这一点定位整个人脸。如果我们还有其他用来检测左眼、鼻子或嘴巴的特征图，那么我们可以将检测结果结合起来，更好地定位人脸。现在我们回顾一下所有问题。在Faster R-CNN中，检测器使用了多个全连接层进行预测。如果有2000个ROI，那么成本非常高。R-FCN通过减少每个ROI所需的工作量实现加速。上面基于区域的特征图与ROI是独立的，可以在每个ROI之外单独计算。剩下的工作就比较简单了，因此R-FCN的速度比Faster R-CNN快。
</code></pre>
<p><img src="8.2.4-1.png" alt></p>
<pre><code>图8.2.1 人脸检测
现在我们来看一下5×5的特征图M，内部包含一个蓝色方块。我们将方块平均分成3×3个区域。现在，我们在M中创建了一个新的特征图，来检测方块的左上角（TL）。这个新的特征图如下图（右）所示。只有黄色的网格单元[2,2]处于激活状态。在左侧创建一个新的特征图，用于检测目标的左上角。
</code></pre>
<p><img src="8.2.4-2.png" alt></p>
<pre><code>图8.2.2 检测示例
我们将方块分成9个部分，由此创建了9个特征图，每个用来检测对应的目标区域。这些特征图叫做位置敏感得分图（position-sensitive score map），因为每个图检测目标的子区域（计算其得分）。
</code></pre>
<p><img src="8.2.4-3.png" alt></p>
<pre><code>图8.2.3生成9个得分图
下图中红色虚线矩形是建议的ROI。我们将其分割成3×3个区域，并询问每个区域包含目标对应部分的概率是多少。例如，左上角ROI区域包含左眼的概率。我们将结果存储成3×3 vote数组，如下图（右）所示。例如，vote_array[0][0]包含左上角区域是否包含目标对应部分的得分。
</code></pre>
<p><img src="8.2.4-4.png" alt></p>
<pre><code>图8.2.4
将ROI应用到特征图上，输出一个3x3数组。将得分图和ROI映射到vote数组的过程叫做位置敏感ROI池化（position-sensitive ROI-pool）。该过程与前面讨论过的ROI池化非常接近。
</code></pre>
<p><img src="8.2.4-5.png" alt></p>
<pre><code>图8.2.5
将ROI的一部分叠加到对应的得分图上，计算V[i][j]。在计算出位置敏感ROI池化的所有值后，类别得分是其所有元素得分的平均值。
</code></pre>
<p><img src="8.2.6.png" alt></p>
<pre><code>图8.2.6 ROI池化
假如我们有C个类别要检测。我们将其扩展为C+1个类别，这样就为背景（非目标）增加了一个新的类别。每个类别有3×3个得分图，因此一共有(C+1)×3×3个得分图。使用每个类别的得分图可以预测出该类别的类别得分。然后我们对这些得分应用 softmax 函数，计算出每个类别的概率。以下是数据流图，在本案例中，k=3。
</code></pre>
<p><img src="8.2.7.png" alt></p>
<pre><code>图8.2.7
</code></pre>
<h3 id="8-2-5-FPN">8.2.5 FPN</h3>
<p><strong>FPN有哪些创新点？</strong></p>
<ol>
<li>多层特征</li>
<li>特征融合</li>
</ol>
<p>解决目标检测中的多尺度问题，通过简单的网络连接改变，在基本不增加原有模型计算量的情况下，大幅度提升小物体（small object）检测的性能。</p>
<p>在物体检测里面，有限计算量情况下，网络的深度（对应到感受野）与 stride 通常是一对矛盾的东西，常用的网络结构对应的 stride 一般会比较大（如 32），而图像中的小物体甚至会小于 stride 的大小，造成的结果就是小物体的检测性能急剧下降。传统解决这个问题的思路包括：</p>
<ol>
<li>图像金字塔（image pyramid），即多尺度训练和测试。但该方法计算量大，耗时较久。</li>
<li>特征分层，即每层分别预测对应的scale分辨率的检测结果，如SSD算法。该方法强行让不同层学习同样的语义信息，但实际上不同深度对应于不同层次的语义特征，浅层网络分辨率高，学到更多是细节特征，深层网络分辨率低，学到更多是语义特征。</li>
</ol>
<p>因而，目前多尺度的物体检测主要面临的挑战为：</p>
<ol>
<li>如何学习具有强语义信息的多尺度特征表示？</li>
<li>如何设计通用的特征表示来解决物体检测中的多个子问题？如 object proposal, box localization, instance segmentation.</li>
<li>如何高效计算多尺度的特征表示？</li>
</ol>
<p>FPN网络直接在Faster R-CNN单网络上做修改，每个分辨率的 feature map 引入后一分辨率缩放两倍的 feature map 做 element-wise 相加的操作。通过这样的连接，每一层预测所用的 feature map 都融合了不同分辨率、不同语义强度的特征，融合的不同分辨率的 feature map 分别做对应分辨率大小的物体检测。这样保证了每一层都有合适的分辨率以及强语义（rich semantic）特征。同时，由于此方法只是在原网络基础上加上了额外的跨层连接，在实际应用中几乎不增加额外的时间和计算量。作者接下来实验了将 FPN 应用在 Faster RCNN 上的性能，在 COCO 上达到了 state-of-the-art 的单模型精度。在RPN上，FPN增加了8.0个点的平均召回率（average recall，AR）；在后面目标检测上，对于COCO数据集，FPN增加了2.3个点的平均精确率（average precision，AP），对于VOC数据集，FPN增加了3.8个点的AP。</p>
<p><img src="FPN-01.png" alt></p>
<p>FPN算法主要由三个模块组成，分别是：</p>
<ol>
<li>Bottom-up pathway（自底向上线路）</li>
<li>Lareral connections（横向链接）</li>
<li>Top-down path（自顶向下线路）</li>
</ol>
<p><img src="FPN-02.png" alt></p>
<p><strong>Bottom-up pathway</strong></p>
<p>FPN是基于Faster R-CNN进行改进，其backbone是ResNet-101，FPN主要应用在Faster R-CNN中的RPN（用于bouding box proposal generation）和Fast R-CNN（用于object detection）两个模块中。</p>
<p>其中 RPN 和 Fast RCNN 分别关注的是召回率（recall）和精确率（precision），在这里对比的指标分别为 Average Recall(AR) 和 Average Precision(AP)。</p>
<p>注：Bottom-up可以理解为自底向上，Top-down可以理解为自顶向下。这里的下是指low-level，上是指high-level，分别对应于提取的低级（浅层）特征和高级语义（高层）特征。</p>
<p>Bottom-up pathway 是卷积网络的前向传播过程。在前向传播过程中，feature map的大小可以在某些层发生改变。一些尺度（scale）因子为2，所以后一层feature map的大小是前一层feature map大小的二分之一，根据此关系进而构成了feature pyramid（hierarchy）。</p>
<p>然而还有很多层输出的feature map是一样的大小（即不进行缩放的卷积），作者将这些层归为同一 stage。对于feature pyramid，作者为每个stage定义一个pyramid level。</p>
<p>作者将每个stage的最后一层的输出作为feature map，然后不同stage进行同一操作，便构成了feature pyramid。</p>
<p>具体来说，对于ResNets-101，作者使用了每个stage的最后一个残差结构的特征激活输出。将这些残差模块输出表示为{C2, C3, C4, C5}，对应于conv2，conv3，conv4和conv5的输出，并且注意它们相对于输入图像具有{4, 8, 16, 32}像素的步长。考虑到内存占用，没有将conv1包含在金字塔中。</p>
<p><img src="FPN-03.png" alt></p>
<p><strong>Top-down pathway and lateral connections</strong></p>
<p>Top-town pathway是上采样（upsampling）过程。而later connection（横向连接）是将上采样的结果和bottom-up pathway生成的相同大小的feature map进行融合（merge）。</p>
<p>注：上采样尺度因子为2，因为为了和之前下采样卷积的尺度因子=2一样。上采样是放大，下采样是缩小。</p>
<p>具体操作如下图所示，上采样（2x up）feature map与相同大小的bottom-up feature map进行逐像素相加融合（element-wise addition），其中bottom-up feature先要经过1x1卷积层，目的是为了减少通道维度（reduce channel dimensions）。</p>
<p>注：减少通道维度是为了将bottom-up feature map的通道数量与top-down feature map的通道数量保持一致，又因为两者feature map大小一致，所以可以进行对应位置像素的叠加（element-wise addition）。</p>
<p><img src="FPN-04.png" alt></p>
<h3 id="8-2-6-Mask-R-CNN">8.2.6 Mask R-CNN</h3>
<p><strong>Mask R-CNN有哪些创新点？</strong></p>
<ol>
<li>Backbone：ResNeXt-101+FPN</li>
<li>RoI Align替换RoI Pooling</li>
</ol>
<p>Mask R-CNN是一个实例分割（Instance segmentation）算法，主要是在目标检测的基础上再进行分割。Mask R-CNN算法主要是Faster R-CNN+FCN，更具体一点就是ResNeXt+RPN+RoI Align+Fast R-CNN+FCN。</p>
<p>![](ch8/Mask R-CNN-01.png)</p>
<p><strong>Mask R-CNN算法步骤</strong></p>
<ol>
<li>输入一幅你想处理的图片，然后进行对应的预处理操作，或者预处理后的图片；</li>
<li>将其输入到一个预训练好的神经网络中（ResNeXt等）获得对应的feature map；</li>
<li>对这个feature map中的每一点设定预定个的RoI，从而获得多个候选RoI；</li>
<li>将这些候选的RoI送入RPN网络进行二值分类（前景或背景）和BB回归，过滤掉一部分候选的RoI；</li>
<li>对这些剩下的RoI进行RoI Align操作（即先将原图和feature map的pixel对应起来，然后将feature map和固定的feature对应起来）；</li>
<li>对这些RoI进行分类（N类别分类）、BB回归和MASK生成（在每一个RoI里面进行FCN操作）。</li>
</ol>
<p><strong>RoI Pooling和RoI Align有哪些不同？</strong></p>
<p>ROI Align 是在Mask-RCNN中提出的一种区域特征聚集方式，很好地解决了RoI Pooling操作中两次量化造成的区域不匹配(mis-alignment)的问题。实验显示，在检测测任务中将 RoI Pooling 替换为 RoI Align 可以提升检测模型的准确性。</p>
<p>在常见的两级检测框架（比如Fast-RCNN，Faster-RCNN，RFCN）中，RoI Pooling 的作用是根据预选框的位置坐标在特征图中将相应区域池化为固定尺寸的特征图，以便进行后续的分类和包围框回归操作。由于预选框的位置通常是由模型回归得到的，一般来讲是浮点数，而池化后的特征图要求尺寸固定。故RoI Pooling这一操作存在两次量化的过程。</p>
<ul>
<li>将候选框边界量化为整数点坐标值。</li>
<li>将量化后的边界区域平均分割成  $k\times k$  个单元(bin),对每一个单元的边界进行量化。</li>
</ul>
<p>事实上，经过上述两次量化，此时的候选框已经和最开始回归出来的位置有一定的偏差，这个偏差会影响检测或者分割的准确度。在论文里，作者把它总结为“不匹配问题（misalignment）”。</p>
<p>下面我们用直观的例子具体分析一下上述区域不匹配问题。如下图所示，这是一个Faster-RCNN检测框架。输入一张 $800\times 800$ 的图片，图片上有一个 $665\times 665$ 的包围框（框着一只狗）。图片经过主干网络提取特征后，特征图缩放步长（stride）为32。因此，图像和包围框的边长都是输入时的1/32。800正好可以被32整除变为25。但665除以32以后得到20.78，带有小数，于是RoI Pooling 直接将它量化成20。接下来需要把框内的特征池化 $7\times 7$ 的大小，因此将上述包围框平均分割成 $7\times 7$ 个矩形区域。显然，每个矩形区域的边长为2.86，又含有小数。于是ROI Pooling 再次把它量化到2。经过这两次量化，候选区域已经出现了较明显的偏差（如图中绿色部分所示）。更重要的是，该层特征图上0.1个像素的偏差，缩放到原图就是3.2个像素。那么0.8的偏差，在原图上就是接近30个像素点的差别，这一差别不容小觑。</p>
<p>![](ch8/Mask R-CNN-02.png)</p>
<p>为了解决RoI Pooling的上述缺点，作者提出了RoI Align这一改进的方法(如图2)。</p>
<p>![](ch8/Mask R-CNN-03.png)</p>
<p>RoI Align的思路很简单：取消量化操作，使用双线性内插的方法获得坐标为浮点数的像素点上的图像数值，从而将整个特征聚集过程转化为一个连续的操作。值得注意的是，在具体的算法操作上，RoI Align并不是简单地补充出候选区域边界上的坐标点，然后将这些坐标点进行池化，而是重新设计了一套比较优雅的流程，如下图所示：</p>
<ol>
<li>
<p>遍历每一个候选区域，保持浮点数边界不做量化。</p>
</li>
<li>
<p>将候选区域分割成 $k\times k$ 个单元，每个单元的边界也不做量化。</p>
</li>
<li>
<p>在每个单元中计算固定四个坐标位置，用双线性内插的方法计算出这四个位置的值，然后进行最大池化操作。</p>
</li>
</ol>
<p>这里对上述步骤的第三点作一些说明：这个固定位置是指在每一个矩形单元（bin）中按照固定规则确定的位置。比如，如果采样点数是1，那么就是这个单元的中心点。如果采样点数是4，那么就是把这个单元平均分割成四个小方块以后它们分别的中心点。显然这些采样点的坐标通常是浮点数，所以需要使用插值的方法得到它的像素值。在相关实验中，作者发现将采样点设为4会获得最佳性能，甚至直接设为1在性能上也相差无几。事实上，RoI Align 在遍历取样点的数量上没有RoI Pooling那么多，但却可以获得更好的性能，这主要归功于解决了mis alignment的问题。值得一提的是，我在实验时发现，RoI Align在VOC 2007数据集上的提升效果并不如在COCO上明显。经过分析，造成这种区别的原因是COCO上小目标的数量更多，而小目标受mis alignment问题的影响更大（比如，同样是0.5个像素点的偏差，对于较大的目标而言显得微不足道，但是对于小目标，误差的影响就要高很多）。</p>
<p>![](ch8/Mask R-CNN-04.png)</p>
<h3 id="8-2-7-DetNet（贡献者：北京理工大学–明奇）">8.2.7  DetNet（贡献者：北京理工大学–明奇）</h3>
<p>DetNet是发表在ECCV2018的论文，比较新，出发点是现有的检测任务backbone都是从分类任务衍生而来的，因此作者想针对检测专用的backbone做一些讨论和研究而设计了DetNet，思路比较新奇。</p>
<ol>
<li><strong>Introduction</strong><br>
  很多backbone的提出都是用于挑战ImageNet分类任务后被应用到检测上来，而鲜有单独<u>针对检测任务设计的backbone</u>。</li>
</ol>
<p>  <strong>检测和分类有明显的区别</strong>：（1）不仅需要分类，还需要精确的定位 （2）最近的检测器都是基于类似FPN结构，在分类网络基础上加额外多尺度特征进行检测，应对不同尺度变化的目标。这两点又是相互补充，共同协助网络完成分类到检测任务的转变。例如分类任务是检测的一环所以必不可少，但是传统分类采用的最高级特征定位细节不够，因此很多最近网络设法用类似FPN的结构去处理尺度变化的问题，就将分类较好地过渡到检测任务上了。</p>
<ol start="2">
<li><strong>DetNet</strong></li>
</ol>
<p>2.1 <strong>Motivation</strong><br>
  主要着眼点是<strong>分辨率</strong>，从大目标和小目标分别阐述保持分辨率的重要性。所以DetNet也是从分辨率的保持着手，解决多尺度物体的识别问题。</p>
<ul>
<li>
<p>Weak visibility of large objects<br>
  网络在较深层如P6（FPN）P7（RetinaNet）大目标的边界不明确使精确定位困难。</p>
</li>
<li>
<p>Invisibility of small objects<br>
  小目标就很惨了，降采样容易丢。这个就不赘述了，所以只要避开降采样就能防止目标丢失，但是这种方法又会导致抽象能力不够</p>
</li>
</ul>
<p>​    2.2  <strong>DetNet Design</strong><br>
  保持分辨率有两个麻烦的问题：（1）内存消耗大，计算大 （2）降采样减少导致高层的抽象特征不足以很好地进行分类任务。下面设计时会同时考虑时间和高层抽象信息两点。<br>
  先放出DetNet的多尺度各stage的尺寸如下图， 可以看到，相比前两种方式，DetNet在P4之后就不再进一步降采样了，进行分辨率的保持。</p>
<p><img src="DetNet-1.png" alt></p>
<p>  实现细节如下图：</p>
<p><img src="DetNet-2.png" alt></p>
<ul>
<li>采用的backbone是ResNet-50，改进设计了DetNet-59。</li>
<li>对bottlenecks进行了改进，传统的其实不止C，也包含两种，即将AB的膨胀卷积换成普通卷积。AB是新的基础模块。</li>
<li>为了减少分辨率保持带来的时间和内存成本消耗，通道数固定为256（思考：降采样和膨胀卷积都会有信息丢失，这里可以想想）。</li>
<li>DetNet也可以加FPN结构，方法类似。</li>
</ul>
<ol start="3">
<li><strong>Experiments</strong><br>
  检测和训练的细节配置就不看了。</li>
</ol>
<p>3.1 <strong>Main Results</strong></p>
<p><img src="DetNet-3.png" alt></p>
<ul>
<li>在FPN基础上明显有大物体涨点，同时由于高分辨率，小物体也有不错的提升。</li>
<li>膨胀卷积提供的大感受野使得分类也不逊色<br>
<img src="DetNet-4.png" alt></li>
</ul>
<p>​	3.2  <strong>Results analysis</strong><br>
<img src="DetNet-5.png" alt></p>
<ul>
<li>
<p>从AP50看出，高好1.7；从AP80看出，高了3.7。由此可以看出确实提高了检测性能。（</p>
</li>
<li>
<p>从定位性能来看，大物体的提升比小物体更多。作者认为是高分辨率解决了大物体边界模糊的问题。其实有一种解释：小目标没有大目标明显，因为膨胀卷积核降采样都会丢失小目标，只是膨胀卷积可能离散采样不至于像降采样直接给到后面没了，但是没有根本性的解决，所以小目标不大。<br>
<img src="DetNet-6.png" alt></p>
</li>
<li>
<p>AR指标也有类似结论</p>
</li>
<li>
<p>AR50体现了小目标的查全率更好，这也印证上面分析的：相对降采样，膨胀卷积丢失会好点。此下大目标效果虽然提升不大但是也很高了，作者表示DetNet擅长找到更精确的定位目标，在AR85的高指标就能看出。</p>
</li>
<li>
<p>AR85看大目标丢失少，说明能够像 VGG一样对大目标效果优良。关于小目标的效果平平，作者认为没有必要太高，因为FPN结构对小目标已经利用地很充分了，这里即使不高也没事。</p>
</li>
</ul>
<p>3.3 <strong>Discussion</strong></p>
<ul>
<li>关于stage<br>
  为了研究backbone对检测的影响，首先研究stage的作用。前4个还好说，和ResNet一样，但是P5 P6就不同，没有尺度的变化，和传统意义的stage不一样了，需要重新定义。这里DetNet也是类似ResNet的方法，虽然没有尺度变化，但是AB模块的位置还是保持了，B开启一个stage（<s>听上去有点牵强</s>）。如下图，认为新加的仍属于P5。<br>
<img src="DetNet-7.png" alt></li>
</ul>
<p>  验证方法是做了实验，将P6开始的block换成上图所示的A模块对比效果如下图。 发现还是加了B效果更好。（但是这个stage和传统意义很不一样，所以很多性质不能相提并论，只是B模块的改变也不好判定什么）<br>
<img src="DetNet-8.png" alt></p>
<h3 id="8-2-8-CBNet">8.2.8  CBNet</h3>
<p>本部分介绍一篇在COCO数据集达到最高单模型性能——mAP 53.3的网络，论文于2019.9.3发布在ArXiv，全名是<em>CBNet: A Novel Composite Backbone Network Architecture for Object Detection</em></p>
<ol>
<li><strong>Introduction</strong></li>
</ol>
<p>  名义上是单模型，实际是多模型的特征融合，只是和真正的多模型策略略有不同。作者的起点是，设计新的模型往往需要在ImageNet上进行预训练，比较麻烦。因而提出的Composite Backbone Network (CBNet)，采用经典网络的多重组合的方式构建网络，一方面可以提取到更有效的特征，另一方面也能够直接用现成的预训练参数（如ResNet，ResNeXt等）比较简单高效。</p>
<ol start="2">
<li><strong>Proposed method</strong><br>
<img src="CBNet-1.png" alt><br>
2.1  <strong>Architecture of CBNet</strong><br>
<img src="CBNet-2.png" alt></li>
</ol>
<p>  如上图，模型中采用K个（K&gt;1）相同的结构进行紧密联结。其中两个相同backbone的叫Dual-Backbone (DB)，三个叫Triple- Backbone (TB)；L代表backbone的stage数目，这里统一设置为L=5。其中，和前任工作不同的地方在于，这里将不同的stage信息进行复用回传，以便获取更好的特征（为什么work不好说）。</p>
<p>2.2  <strong>Other possible composite styles</strong><br>
<img src="CBNet-3.png" alt></p>
<p>  相关工作的其他类似结构，大同小异。要么是前面backbone的stage往后传播，要么是往前一个传播，每个都有一篇论文，应该都会给出不同的解释；第四个结构不太一样，是类似densnet的结构，但是密集连接+多backbone assemble的内存消耗不出意外会非常大。但是脱离这些体系来看，多backbone的结构类似多模型的assemble，和单模型有点不公平。</p>
<ol start="3">
<li><strong>Experiment</strong></li>
</ol>
<ul>
<li><strong>result</strong><br>
<img src="CBNet-4.png" alt></li>
</ul>
<p>COCO数据集上的结果。看来提升还是有的。但是也能看出，大趋势上，三阶级联效果不如两阶的提升大，也是这部分的特征提升空间有限的缘故，到底哪部分在work不好说。下图的研究就更说明这一点了，斜率逐渐减小。</p>
<ul>
<li><strong>Comparisons of different composite styles</strong><br>
<img src="CBNet-5.png" alt></li>
</ul>
<p>他的级联网络相比，作者的阐述点只落脚于特征的利用情况，但是这个东西本身就很玄乎，不好说到底怎么算利用得好。硬要说这种做法的解释性，大概就是将backbone方向的后面高级语义特征传播回前面进行加强，相当于横向的FPN传播。</p>
<ul>
<li><strong>Number of backbones in CBNet</strong><br>
<img src="CBNet-6.png" alt></li>
</ul>
<p>速度慢是必然的，FPN+ResNeXt为8fps，加上两个backboen后为5.5FPS；如果减去backbone的前两个stage，可以节省部分参数达到6.9FPS，而精度下降不大（整体速度太低，这个实验意义不大）</p>
<ul>
<li><strong>Sharing weights for CBNet</strong><br>
<img src="CBNet-7.png" alt></li>
<li></li>
</ul>
<p>从中可以看出其实权重是否share区别不大， 不到一个点的降幅，参数量减少。</p>
<ul>
<li><strong>Effectiveness of basic feature enhancement by CBNet</strong><br>
<img src="CBNet-8.png" alt></li>
</ul>
<p>从中可以看出激活响应效果更好，确实是能够提取到更为有效的特征，对物体的响应更加敏感。</p>
<h2 id="8-3-One-Stage目标检测算法">8.3 One Stage目标检测算法</h2>
<p>我们将对单次目标检测器（包括SSD系列和YOLO系列等算法）进行综述。我们将分析FPN以理解多尺度特征图如何提高准确率，特别是小目标的检测，其在单次检测器中的检测效果通常很差。然后我们将分析Focal loss和RetinaNet，看看它们是如何解决训练过程中的类别不平衡问题的。</p>
<h3 id="8-3-1-SSD">8.3.1 SSD</h3>
<p><strong>SSD有哪些创新点？</strong></p>
<ol>
<li>基于Faster R-CNN中的Anchor，提出了相似的先验框（Prior box）</li>
<li>从不同比例的特征图（多尺度特征）中产生不同比例的预测，并明确地按长宽比分离预测。</li>
</ol>
<p>不同于前面的R-CNN系列，SSD属于one-stage方法。SSD使用 VGG16 网络作为特征提取器（和 Faster R-CNN 中使用的 CNN 一样），将后面的全连接层替换成卷积层，并在之后添加自定义卷积层，并在最后直接采用卷积进行检测。在多个特征图上设置不同缩放比例和不同宽高比的先验框以融合多尺度特征图进行检测，靠前的大尺度特征图可以捕捉到小物体的信息，而靠后的小尺度特征图能捕捉到大物体的信息，从而提高检测的准确性和定位的准确性。如下图是SSD的网络结构图。</p>
<p><img src="SSD-01.png" alt></p>
<p><strong>1. 怎样设置default boxes？</strong><br>
SSD中default box的概念有点类似于Faster R-CNN中的anchor。不同于Faster R-CNN只在最后一个特征层取anchor, SSD在多个特征层上取default box，可以得到不同尺度的default box。在特征图的每个单元上取不同宽高比的default box,一般宽高比在{1,2,3,1/2,1/3}中选取，有时还会额外增加一个宽高比为1但具有特殊尺度的box。如下图所示，在8x8的feature map和4x4的feature map上的每个单元取4个不同的default box。原文对于300x300的输入，分别在conv4_3, conv7,conv8_2,conv9_2,conv10_2,conv11_2的特征图上的每个单元取4,6,6,6,4,4个default box. 由于以上特征图的大小分别是38x38,19x19,10x10,5x5,3x3,1x1，所以一共得到38x38x4+19x19x6+10x10x6+5x5x6+<br>
3x3x4+1x1x4=8732个default box.对一张300x300的图片输入网络将会针对这8732个default box预测8732个边界框。</p>
<p><img src="SSD-02.png" alt></p>
<p><strong>2. 怎样对先验框进行匹配？</strong><br>
SSD在训练的时候只需要输入图像和图像中每个目标对应的ground truth. 先验框与ground truth 的匹配遵循两个原则：</p>
<p>（1）对图片中的每个ground truth, 在先验框中找到与其IOU最大的先验框，则该先验框对应的预测边界框与ground truth 匹配。</p>
<p>（2）对于（1）中每个剩下的没有与任何ground truth匹配到的先验框，找到与其IOU最大的ground truth，若其与该ground truth的IOU值大于某个阈值（一般设为0.5），则该先验框对应的预测边界框与该ground truth匹配。</p>
<p>按照这两个原则进行匹配，匹配到ground truth的先验框对应的预测边界框作为正样本，没有匹配到ground truth的先验框对应的预测边界框作为负样本。尽管一个ground truth可以与多个先验框匹配，但是ground truth的数量相对先验框还是很少，按照上面的原则进行匹配还是会造成负样本远多于正样本的情况。为了使正负样本尽量均衡（一般保证正负样本比例约为1：3），SSD采用hard negative mining, 即对负样本按照其预测背景类的置信度进行降序排列，选取置信度较小的top-k作为训练的负样本。</p>
<p><strong>3. 怎样得到预测的检测结果？</strong></p>
<p>最后分别在所选的特征层上使用3x3卷积核预测不同default boxes所属的类别分数及其预测的边界框location。由于对于每个box需要预测该box属于每个类别的置信度（假设有c类，包括背景，例如20class的数据集合，c=21）和该box对应的预测边界框的location(包含4个值，即该box的中心坐标和宽高)，则每个box需要预测c+4个值。所以对于某个所选的特征层，该层的卷积核个数为（c+4）x 该层的default box个数.最后将每个层得到的卷积结果进行拼接。对于得到的每个预测框，取其类别置信度的最大值，若该最大值大于置信度阈值，则最大值所对应的类别即为该预测框的类别，否则过滤掉此框。对于保留的预测框根据它对应的先验框进行解码得到其真实的位置参数（这里还需注意要防止预测框位置超出图片），然后根据所属类别置信度进行降序排列，取top-k个预测框，最后进行NMS，过滤掉重叠度较大的预测框，最后得到检测结果。</p>
<p>SSD优势是速度比较快，整个过程只需要一步，首先在图片不同位置按照不同尺度和宽高比进行密集抽样，然后利用CNN提取特征后直接进行分类与回归，所以速度比较快，但均匀密集采样会造成正负样本不均衡的情况使得训练比较困难，导致模型准确度有所降低。另外，SSD对小目标的检测没有大目标好，因为随着网络的加深，在高层特征图中小目标的信息丢失掉了，适当增大输入图片的尺寸可以提升小目标的检测效果。</p>
<h3 id="8-3-2-DSSD">8.3.2 DSSD</h3>
<p><strong>DSSD有哪些创新点？</strong></p>
<ol>
<li>Backbone：将ResNet替换SSD中的VGG网络，增强了特征提取能力</li>
<li>添加了Deconvolution层，增加了大量上下文信息</li>
</ol>
<p>为了解决SSD算法检测小目标困难的问题，DSSD算法将SSD算法基础网络从VGG-16更改为ResNet-101，增强网络特征提取能力，其次参考FPN算法思路利用去Deconvolution结构将图像深层特征从高维空间传递出来，与浅层信息融合，联系不同层级之间的图像语义关系，设计预测模块结构，通过不同层级特征之间融合特征输出预测物体类别信息。</p>
<p>DSSD算法中有两个特殊的结构：Prediction模块；Deconvolution模块。前者利用提升每个子任务的表现来提高准确性，并且防止梯度直接流入ResNet主网络。后者则增加了三个Batch Normalization层和三个3×3卷积层，其中卷积层起到了缓冲的作用，防止梯度对主网络影响太剧烈，保证网络的稳定性。</p>
<p>SSD和DSSD的网络模型如下图所示：</p>
<p><img src="DSSD-01.png" alt></p>
<p><strong>Prediction Module</strong></p>
<p>SSD直接从多个卷积层中单独引出预测函数，预测量多达7000多，梯度计算量也很大。MS-CNN方法指出，改进每个任务的子网可以提高准确性。根据这一思想，DSSD在每一个预测层后增加残差模块，并且对于多种方案进行了对比，如下图所示。结果表明，增加残差预测模块后，高分辨率图片的检测精度比原始SSD提升明显。</p>
<p><img src="DSSD-02.png" alt></p>
<p><strong>Deconvolution模块</strong></p>
<p>为了整合浅层特征图和deconvolution层的信息，作者引入deconvolution模块，如下图所示。作者受到论文Learning to Refine Object Segments的启发，认为用于精细网络的deconvolution模块的分解结构达到的精度可以和复杂网络一样，并且更有效率。作者对其进行了一定的修改：其一，在每个卷积层后添加批归一化（batch normalization）层；其二，使用基于学习的deconvolution层而不是简单地双线性上采样；其三，作者测试了不同的结合方式，元素求和（element-wise sum）与元素点积（element-wise product）方式，实验证明元素点积计算能得到更好的精度。</p>
<p><img src="DSSD-03.png" alt></p>
<h3 id="8-3-3-YOLOv1">8.3.3 YOLOv1</h3>
<p><strong>YOLOv1有哪些创新点？</strong></p>
<ol>
<li>将整张图作为网络的输入，直接在输出层回归bounding box的位置和所属的类别</li>
<li>速度快，one stage detection的开山之作</li>
</ol>
<p><strong>YOLOv1介绍</strong></p>
<p>YOLO（You Only Look Once: Unified, Real-Time Object Detection）是one-stage detection的开山之作。之前的物体检测方法首先需要产生大量可能包含待检测物体的先验框, 然后用分类器判断每个先验框对应的边界框里是否包含待检测物体，以及物体所属类别的概率或者置信度，同时需要后处理修正边界框，最后基于一些准则过滤掉置信度不高和重叠度较高的边界框，进而得到检测结果。这种基于先产生候选区再检测的方法虽然有相对较高的检测准确率，但运行速度较慢。</p>
<p>YOLO创造性的将物体检测任务直接当作回归问题（regression problem）来处理，将候选区和检测两个阶段合二为一。只需一眼就能知道每张图像中有哪些物体以及物体的位置。下图展示了各物体检测系统的流程图。</p>
<p><img src="YOLOv1-01.png" alt></p>
<p>事实上，YOLO也并没有真正的去掉候选区，而是直接将输入图片划分成7x7=49个网格，每个网格预测两个边界框，一共预测49x2=98个边界框。可以近似理解为在输入图片上粗略的选取98个候选区，这98个候选区覆盖了图片的整个区域，进而用回归预测这98个候选框对应的边界框。</p>
<p><strong>1. 网络结构是怎样的？</strong></p>
<p>YOLO网络借鉴了GoogLeNet分类网络结构，不同的是YOLO使用1x1卷积层和3x3卷积层替代inception module。如下图所示，整个检测网络包括24个卷积层和2个全连接层。其中，卷积层用来提取图像特征，全连接层用来预测图像位置和类别概率值。</p>
<p><img src="YOLOv1-02.png" alt></p>
<p><strong>2. YOLO的输入、输出、损失函数分别是什么？</strong></p>
<p>前面说到YOLO将输入图像分成7x7的网格，最后输出是7x7xk的张量。YOLO网络最后接了两个全连接层，全连接层要求输入是固定大小的，所以YOLO要求输入图像有固定大小，论文中作者设计的输入尺寸是448x448。</p>
<p>YOLO将输入图像分成7x7的网格，每个网格预测2个边界框。若某物体的ground truth的中心落在该网格，则该网格中与这个ground truth IOU最大的边界框负责预测该物体。对每个边界框会预测5个值，分别是边界框的中心x,y（相对于所属网格的边界），边界框的宽高w,h（相对于原始输入图像的宽高的比例），以及这些边界框的confidencescores（边界框与ground truth box的IOU值）。同时每个网格还需要预测c个类条件概率 （是一个c维向量，表示某个物体object在这个网格中，且该object分别属于各个类别的概率，这里的c类物体不包含背景）。论文中的c=20，则每个网格需要预测2x5+20=30个值，这些值被映射到一个30维的向量。<br>
为了让边界框坐标损失、分类损失达到很好的平衡，损失函数设计如下图所示。</p>
<p><img src="YOLOv1-03.png" alt></p>
<p>如上图所示，损失函数分为坐标预测（蓝色框）、含有物体的边界框的confidence预测（红色框）、不含有物体的边界框的confidence预测（黄色框）、分类预测（紫色框）四个部分。</p>
<p>由于不同大小的边界框对预测偏差的敏感度不同，小的边界框对预测偏差的敏感度更大。为了均衡不同尺寸边界框对预测偏差的敏感度的差异。作者巧妙的对边界框的w,h取均值再求L2 loss. YOLO中更重视坐标预测，赋予坐标损失更大的权重，记为 coord，在pascal voc训练中coodd=5 ，classification error部分的权重取1。</p>
<p>某边界框的置信度定义为：某边界框的confidence = 该边界框存在某类对象的概率pr(object)*该边界框与该对象的ground truth的IOU值 ，若该边界框存在某个对象pr(object)=1 ，否则pr(object)=0 。由于一幅图中大部分网格中是没有物体的，这些网格中的边界框的confidence置为0，相比于有物体的网格，这些不包含物体的网格更多，对梯度更新的贡献更大，会导致网络不稳定。为了平衡上述问题，YOLO损失函数中对没有物体的边界框的confidence error赋予较小的权重，记为 noobj，对有物体的边界框的confidence error赋予较大的权重。在pascal VOC训练中noobj=0.5 ，有物体的边界框的confidence error的权重设为1.</p>
<p><strong>3. YOLO怎样预测？</strong></p>
<p>YOLO最后采用非极大值抑制（NMS）算法从输出结果中提取最有可能的对象和其对应的边界框。</p>
<p>输入一张图片到YOLO网络将输出一个7<em>7</em>30的张量表示图片中每个网格对应的可能的两个边界框以及每个边界框的置信度和包含的对象属于各个类别的概率。由此可以计算某对象i属于类别 同时在第j个边界框中的得分：</p>
<p><img src="YOLOv1-04.png" alt></p>
<p>每个网格有20个类条件概率，2个边界框置信度，相当于每个网格有40个得分，7x7个网格有1960个得分，每类对象有1960/20=98个得分，即98个候选框。</p>
<p><strong>NMS步骤如下：</strong></p>
<p>1.设置一个Score的阈值，一个IOU的阈值；</p>
<p>2.对于每类对象，遍历属于该类的所有候选框，</p>
<p>①过滤掉Score低于Score阈值的候选框；</p>
<p>②找到剩下的候选框中最大Score对应的候选框，添加到输出列表；</p>
<p>③进一步计算剩下的候选框与②中输出列表中每个候选框的IOU，若该IOU大于设置的IOU阈值，将该候选框过滤掉，否则加入输出列表中；</p>
<p>④最后输出列表中的候选框即为图片中该类对象预测的所有边界框</p>
<p>3.返回步骤2继续处理下一类对象。</p>
<p>YOLO将识别与定位合二为一，结构简便，检测速度快，更快的Fast YOLO可以达到155FPS。相对于R-CNN系列, YOLO的整个流程中都能看到整张图像的信息，因此它在检测物体时能很好的利用上下文信息，从而不容易在背景上预测出错误的物体信息。同时YOLO可以学习到高度泛化的特征，能将一个域上学到的特征迁移到不同但相关的域上，如在自然图像上做训练的YOLO，在艺术图片上可以得到较好的测试结果。</p>
<p>由于YOLO网格设置比较稀疏，且每个网格只预测2个边界框，其总体预测精度不高，略低于Fast RCNN。其对小物体的检测效果较差，尤其是对密集的小物体表现比较差。</p>
<h3 id="8-3-4-YOLOv2">8.3.4 YOLOv2</h3>
<p><strong>YOLOv2 有哪些创新点？</strong></p>
<p>YOLOv1虽然检测速度快，但在定位方面不够准确，并且召回率较低。为了提升定位准确度，改善召回率，YOLOv2在YOLOv1的基础上提出了几种改进策略，如下图所示，可以看到，一些改进方法能有效提高模型的mAP。</p>
<ol>
<li>大尺度预训练分类</li>
<li>New Network：Darknet-19</li>
<li>加入anchor</li>
</ol>
<p><img src="YOLOv2-01.png" alt></p>
<p><strong>YOLOv2 介绍</strong></p>
<p><strong>（1）Batch Normalization</strong></p>
<p>YOLOv2中在每个卷积层后加Batch Normalization(BN)层，去掉dropout. BN层可以起到一定的正则化效果，能提升模型收敛速度，防止模型过拟合。YOLOv2通过使用BN层使得mAP提高了2%。<br>
<strong>（2）High Resolution Classifier</strong></p>
<p>目前的大部分检测模型都会使用主流分类网络（如vgg、resnet）在ImageNet上的预训练模型作为特征提取器,<br>
而这些分类网络大部分都是以小于256x256的图片作为输入进行训练的，低分辨率会影响模型检测能力。YOLOv2将输入图片的分辨率提升至448x448，为了使网络适应新的分辨率，YOLOv2先在ImageNet上以448x448的分辨率对网络进行10个epoch的微调，让网络适应高分辨率的输入。通过使用高分辨率的输入，YOLOv2的mAP提升了约4%。</p>
<p><strong>（3）Convolutional With Anchor Boxes</strong></p>
<p>YOLOv1利用全连接层直接对边界框进行预测，导致丢失较多空间信息，定位不准。YOLOv2去掉了YOLOv1中的全连接层，使用Anchor Boxes预测边界框，同时为了得到更高分辨率的特征图，YOLOv2还去掉了一个池化层。由于图片中的物体都倾向于出现在图片的中心位置，若特征图恰好有一个中心位置，利用这个中心位置预测中心点落入该位置的物体，对这些物体的检测会更容易。所以总希望得到的特征图的宽高都为奇数。YOLOv2通过缩减网络，使用416x416的输入，模型下采样的总步长为32，最后得到13x13的特征图，然后对13x13的特征图的每个cell预测5个anchor boxes，对每个anchor box预测边界框的位置信息、置信度和一套分类概率值。使用anchor<br>
boxes之后，YOLOv2可以预测13x13x5=845个边界框，模型的召回率由原来的81%提升到88%，mAP由原来的69.5%降低到69.2%.召回率提升了7%，准确率下降了0.3%。</p>
<p><strong>（4）Dimension Clusters</strong></p>
<p>在Faster R-CNN和SSD中，先验框都是手动设定的，带有一定的主观性。YOLOv2采用k-means聚类算法对训练集中的边界框做了聚类分析，选用boxes之间的IOU值作为聚类指标。综合考虑模型复杂度和召回率，最终选择5个聚类中心，得到5个先验框，发现其中中扁长的框较少，而瘦高的框更多，更符合行人特征。通过对比实验，发现用聚类分析得到的先验框比手动选择的先验框有更高的平均IOU值，这使得模型更容易训练学习。</p>
<p><strong>（5）New Network：Darknet-19</strong></p>
<p>YOLOv2采用Darknet-19，其网络结构如下图所示，包括19个卷积层和5个max pooling层，主要采用3x3卷积和1x1卷积，这里1x1卷积可以压缩特征图通道数以降低模型计算量和参数，每个卷积层后使用BN层以加快模型收敛同时防止过拟合。最终采用global avg pool 做预测。采用YOLOv2，模型的mAP值没有显著提升，但计算量减少了。</p>
<p><img src="YOLOv2-02.png" alt></p>
<p><strong>（6）Direct location prediction</strong></p>
<p>Faster R-CNN使用anchor boxes预测边界框相对先验框的偏移量，由于没有对偏移量进行约束，每个位置预测的边界框可以落在图片任何位置，会导致模型不稳定，加长训练时间。YOLOv2沿用YOLOv1的方法，根据所在网格单元的位置来预测坐标,则Ground Truth的值介于0到1之间。网络中将得到的网络预测结果再输入sigmoid函数中，让输出结果介于0到1之间。设一个网格相对于图片左上角的偏移量是cx，cy。先验框的宽度和高度分别是pw和ph，则预测的边界框相对于特征图的中心坐标(bx，by)和宽高bw、bh的计算公式如下图所示。</p>
<p><img src="YOLOv2-03.png" alt></p>
<p>YOLOv2结合Dimention Clusters, 通过对边界框的位置预测进行约束，使模型更容易稳定训练，这种方式使得模型的mAP值提升了约5%。</p>
<p><strong>（7）Fine-Grained Features</strong></p>
<p>YOLOv2借鉴SSD使用多尺度的特征图做检测，提出pass through层将高分辨率的特征图与低分辨率的特征图联系在一起，从而实现多尺度检测。YOLOv2提取Darknet-19最后一个max pool层的输入，得到26x26x512的特征图。经过1x1x64的卷积以降低特征图的维度，得到26x26x64的特征图，然后经过pass through层的处理变成13x13x256的特征图（抽取原特征图每个2x2的局部区域组成新的channel，即原特征图大小降低4倍，channel增加4倍），再与13x13x1024大小的特征图连接，变成13x13x1280的特征图，最后在这些特征图上做预测。使用Fine-Grained Features，YOLOv2的性能提升了1%.</p>
<p><strong>（8）Multi-Scale Training</strong></p>
<p>YOLOv2中使用的Darknet-19网络结构中只有卷积层和池化层，所以其对输入图片的大小没有限制。YOLOv2采用多尺度输入的方式训练，在训练过程中每隔10个batches,重新随机选择输入图片的尺寸，由于Darknet-19下采样总步长为32，输入图片的尺寸一般选择32的倍数{320,352,…,608}。采用Multi-Scale Training, 可以适应不同大小的图片输入，当采用低分辨率的图片输入时，mAP值略有下降，但速度更快，当采用高分辨率的图片输入时，能得到较高mAP值，但速度有所下降。</p>
<p>YOLOv2借鉴了很多其它目标检测方法的一些技巧，如Faster R-CNN的anchor boxes, SSD中的多尺度检测。除此之外，YOLOv2在网络设计上做了很多tricks,使它能在保证速度的同时提高检测准确率，Multi-Scale Training更使得同一个模型适应不同大小的输入，从而可以在速度和精度上进行自由权衡。</p>
<p><strong>YOLOv2的训练</strong></p>
<p>YOLOv2的训练主要包括三个阶段。<br>
第一阶段：先在ImageNet分类数据集上预训练Darknet-19，此时模型输入为 $224\times 224$ ,共训练160个epochs。<br>
第二阶段：将网络的输入调整为 $448\times 448$ ,继续在ImageNet数据集上finetune分类模型，训练10个epochs，此时分类模型的top-1准确度为76.5%，而top-5准确度为93.3%。<br>
第三个阶段：修改Darknet-19分类模型为检测模型，并在检测数据集上继续finetune网络。<br>
网络修改包括（网路结构可视化）：移除最后一个卷积层、global avgpooling层以及softmax层，并且新增了三个 $3\times 3 \times 2014$ 卷积层，同时增加了一个passthrough层，最后使用 $1\times 1$ 卷积层输出预测结果。</p>
<h3 id="8-3-5-YOLO9000">8.3.5 YOLO9000</h3>
<p>github：<a href="http://pjreddie.com/yolo9000/">http://pjreddie.com/yolo9000/</a></p>
<p>YOLO9000是在YOLOv2的基础上提出的一种联合训练方法，可以检测超过9000个类别的模型。YOLOv2混合目标检测数据集和分类数据集，用目标检测数据集及其类别标记信息和位置标注信息训练模型学习预测目标定位和分类，用分类数据集及其类别标记信息进一步扩充模型所能识别的物体类别同时能增强模型鲁棒性。</p>
<p><strong>1. YOLO9000是怎么组织数据的？</strong></p>
<p>YOLO9000根据各个类别之间的从属关系建立一种树结WordTree, 将COCO数据集和ImageNet数据集组织起来。</p>
<p>WordTree的生成方式如下：</p>
<p>①首先遍历ImageNet中的类别名词。</p>
<p>②对每个名词，在WordNet(一种结构化概念及概念之间关系的语言数据库)上找到从它所在位置到根节点（设根节点为实体对象physical object）的最短路径，由于在WordNet中大多数同义词只有一个路径，所以先把将该路径上的词全都加到树中。</p>
<p>③迭代地检查剩下的名词，取它到根节点的最短路径，将该最短路径上的还没出现在层次树中的词加入到树中。<br>
混合后的数据集形成一个有9418类的WordTree.生成的WordTree模型如下图所示。另外考虑到COCO数据集相对于ImageNet数据集数据量太少了，为了平衡两个数据集，作者进一步对COCO数据集过采样，使COCO数据集与ImageNet数据集的数据量比例接近1：4。</p>
<p><img src="YOLOv2-04.png" alt></p>
<p>对于物体的标签，采用one-hot编码的形式，数据集中的每个物体的类别标签被组织成1个长度为9418的向量，向量中除在WordTree中从该物体对应的名词到根节点的路径上出现的词对应的类别标号处为1，其余位置为0。</p>
<p><strong>2. YOLO9000是怎么进行联合训练的？</strong></p>
<p>YOLO9000采用YOLOv2的结构，anchorbox由原来的5调整到3，对每个anchorbox预测其对应的边界框的位置信息x,y,w,h和置信度以及所包含的物体分别属于9418类的概率，所以每个anchorbox需要预测4+1+9418=9423个值。每个网格需要预测3x9423=28269个值。在训练的过程中，当网络遇到来自检测数据集的图片时，用完整的YOLOv2loss进行反向传播计算，当网络遇到来自分类数据集的图片时，只用分类部分的loss进行反向传播。</p>
<p><strong>3. YOLO9000是怎么预测的？</strong></p>
<p>WordTree中每个节点的子节点都属于同一个子类，分层次的对每个子类中的节点进行一次softmax处理，以得到同义词集合中的每个词的下义词的概率。当需要预测属于某个类别的概率时，需要预测该类别节点的条件概率。即在WordTree上找到该类别名词到根节点的路径，计算路径上每个节点的概率之积。预测时，YOLOv2得到置信度，同时会给出边界框位置以及一个树状概率图，沿着根节点向下，沿着置信度最高的分支向下，直到达到某个阈值，最后到达的节点类别即为预测物体的类别。</p>
<p>YOLO9000使用WordTree混合目标检测数据集和分类数据集，并在其上进行联合训练，使之能实时检测出超过9000个类别的物体，其强大令人赞叹不已。YOLO9000尤其对动物的识别效果很好，但是对衣服或者设备等类别的识别效果不是很好，可能的原因是与目标检测数据集中的数据偏向有关。</p>
<h3 id="8-3-6-YOLOv3">8.3.6 YOLOv3</h3>
<p>YOLOv3总结了自己在YOLOv2的基础上做的一些尝试性改进，有的尝试取得了成功，而有的尝试并没有提升模型性能。其中有两个值得一提的亮点，一个是使用残差模型，进一步加深了网络结构；另一个是使用FPN架构实现多尺度检测。</p>
<p><strong>YOLOv3有哪些创新点？</strong></p>
<ol>
<li>新网络结构：DarkNet-53</li>
<li>融合FPN</li>
<li>用逻辑回归替代softmax作为分类器</li>
</ol>
<p><strong>1. YOLOv3对网络结构做了哪些改进？</strong></p>
<p>YOLOv3在之前Darknet-19的基础上引入了残差块，并进一步加深了网络，改进后的网络有53个卷积层，取名为Darknet-53，网络结构如下图所示（以256*256的输入为例）。</p>
<p><img src="YOLOv3-01.png" alt></p>
<p>为了比较Darknet-53与其它网络结构的性能，作者在TitanX上，采用相同的实验设置，将256x256的图片分别输入以Darknet-19，ResNet-101，ResNet-152和Darknet-53为基础网络的分类模型中，实验得到的结果如下图所示。可以看到Darknet-53比ResNet-101的性能更好，而且速度是其1.5倍，Darknet-53与ResNet-152性能相似但速度几乎是其2倍。注意到，Darknet-53相比于其它网络结构实现了每秒最高的浮点计算量，说明其网络结构能更好的利用GPU。</p>
<p><img src="YOLOv3-02.png" alt></p>
<p><strong>2.YOLOv3中怎样实现多尺度检测？</strong></p>
<p>YOLOv3借鉴了FPN的思想，从不同尺度提取特征。相比YOLOv2，YOLOv3提取最后3层特征图，不仅在每个特征图上分别独立做预测，同时通过将小特征图上采样到与大的特征图相同大小，然后与大的特征图拼接做进一步预测。用维度聚类的思想聚类出9种尺度的anchor box，将9种尺度的anchor box均匀的分配给3种尺度的特征图.如下图是在网络结构图的基础上加上多尺度特征提取部分的示意图（以在COCO数据集(80类)上256x256的输入为例）：</p>
<p><img src="YOLOv3-03.png" alt></p>
<p>从YOLOv1到YOLOv2再到YOLO9000、YOLOv3, YOLO经历三代变革，在保持速度优势的同时，不断改进网络结构，同时汲取其它优秀的目标检测算法的各种trick，先后引入anchor box机制、引入FPN实现多尺度检测等。</p>
<h3 id="8-3-7-RetinaNet">8.3.7 RetinaNet</h3>
<p><strong>研究背景</strong></p>
<ul>
<li>Two-Stage检测器（如Faster R-CNN、FPN）效果好，但速度相对慢</li>
<li>One-Stage检测器（如YOLO、SSD）速度快，但效果一般</li>
</ul>
<p><img src="RetinaNet-01.png" alt></p>
<p>作者对one-stage检测器准确率不高的问题进行探究，发现主要问题在于正负类别不均衡（简单-难分类别不均衡）。</p>
<blockquote>
<p>We discover that the extreme foreground-background class imbalance encountered during training of dense detectors is the central cause.</p>
</blockquote>
<p>作者建议通过重新设计标准的交叉熵损失（cross entropy loss）来解决这种类别不平衡（class inbalance）问题，即提出Focal Loss。</p>
<blockquote>
<p>We propose to address this class imbalance by reshaping the standard cross entropy loss such that it down-weights the loss assigned to well-classified examples. Our novel Focal Loss focuses training on a sparse set of hard examples and prevents the vast number of easy negatives from overwhelming the detector during training.</p>
</blockquote>
<p>结合Focal Loss的one-stage检测器称为RetinaNet，该检测器在COCO上mAP可以和特征金字塔网络（feature pyramid network，FPN）或者Mask R-CNN接近，</p>
<p><strong>问：什么是类别不均衡（class imbalance）？</strong></p>
<p>答：负样本的数量极大于正样本的数量，比如包含物体的区域（正样本）很少，而不包含物体的区域（负样本）很多。比如检测算法在早期会生成一大波的bbox。而一幅常规的图片中，顶多就那么几个object。这意味着，绝大多数的bbox属于background。</p>
<p><strong>问：样本的类别不均衡会带来什么问题？</strong></p>
<p>答：由于大多数都是简单易分的负样本（属于背景的样本），使得训练过程不能充分学习到属于那些有类别样本的信息；其次简单易分的负样本太多，可能掩盖了其他有类别样本的作用（这些简单易分的负样本仍产生一定幅度的loss，见下图蓝色曲线，数量多会对loss起主要贡献作用，因此就主导了梯度的更新方向，掩盖了重要的信息）</p>
<blockquote>
<p>This imbalance causes two problems: (1) training is inefficient as most locations are easy negatives that contribute no useful learning signal; (2) en masse, the easy negatives can overwhelm training and lead to degenerate models.</p>
</blockquote>
<p>简单来说，因为bbox数量爆炸。 正是因为bbox中属于background的bbox太多了，所以如果分类器无脑地把所有bbox统一归类为background，accuracy也可以刷得很高。于是乎，分类器的训练就失败了。分类器训练失败，检测精度自然就低了。</p>
<p><strong>问：为什么在two-stage检测器中，没有出现类别不均衡（class imbalamce）问题呢？</strong></p>
<p>答：因为通过RPN阶段可以减少候选目标区域，而在分类阶段，可以固定前景与背景比值（foreground-to-background ratio）为1:3，或者使用OHEM（online hard example mining）使得前景和背景的数量达到均衡。</p>
<p><strong>RetinaNet有哪些创新点？</strong></p>
<p><strong>概述：</strong></p>
<ul>
<li>New loss：提出Focal Loss函数解决class imbalance</li>
</ul>
 $$
FL(p_t) = -(1-p_t)^\gamma \log(p_t)FL(pt)=−(1−pt)γlog(pt)
$$ 
<ul>
<li>New detector：RetinaNet = ResNet + FPN + Two sub-networks + Focal Loss</li>
</ul>
<p>Focal Loss更加聚焦在困难样本（hard examples）上的训练。</p>
<p><img src="RetinaNet-02.png" alt></p>
<p>将Focal Loss与ResNet-101-FPN backbone结合提出RetinaNet（one-stage检测器），RetinaNet在COCO test-dev上达到39.1mAP，速度为5FPS。</p>
<p>RetinaNet检测器与当时最佳的其它检测器进行比较，无论是速度上还是准确率上都是最佳：</p>
<p><img src="RetinaNet-03.png" alt></p>
<p><strong>详解：</strong></p>
<p>作者提出一种新的损失函数，思路是希望那些hard examples对损失的贡献变大，使网络更倾向于从这些样本上学习。</p>
<p>作者以二分类为例进行说明：</p>
<p><strong>交叉熵函数CE</strong></p>
<p>首先是我们常使用的交叉熵损失函数：</p>
<p><img src="RetinaNet-04.png" alt></p>
<p>上式中，y=+1或者y=-1。p∈[0,1]是y=+1的估计概率。作者定义pt为：</p>
<p><img src="RetinaNet-05.png" alt></p>
<p><img src="RetinaNet-06.png" alt></p>
<p>注：对交叉熵函数不了解的，可以参考<a href="https://blog.csdn.net/chaipp0607/article/details/73392175">理解交叉熵作为损失函数在神经网络中的作用</a></p>
<p><strong>均衡交叉熵函数</strong></p>
<p>要对类别不均衡问题对loss的贡献进行一个控制，即加上一个控制权重即可，最初作者的想法即如下这样，对于属于少数类别的样本，增大α即可</p>
<p><img src="RetinaNet-07.png" alt></p>
<p>但这样有一个问题，它仅仅解决了正负样本之间的平衡问题，并没有区分易分/难分样本，按作者的话说：</p>
<blockquote>
<p>While α balances the importance of positive/negative examples, it does not differentiate between easy/hard examples. Instead, we propose to reshape the loss function to down-weight easy examples and thus focus training on hard negatives.</p>
</blockquote>
<p>问：为什么公式(3)只解决正负样本不均衡问题？</p>
<p>答：增加了一个系数αt，跟pt的定义类似，当label=1的时候，αt=a；当label=-1的时候，αt=1-a，a的范围也是0到1。因此可以通过设定a的值（一般而言假如1这个类的样本数比-1这个类的样本数多很多，那么a会取0到0.5来增加-1这个类的样本的权重）来控制正负样本对总的loss的共享权重。</p>
<p><strong>Focal Loss</strong></p>
<p>作者一开始给交叉熵损失函数添加modulating factor：</p>
 $$
(1-pt)^γ(1−pt)γ
$$ 
<p><img src="RetinaNet-08.png" alt></p>
<p>显然，样本越易分，pt就越大（pt—&gt;1），modulating factor趋近于0，则贡献的loss就越小，同样地，样本越难分，其pt就越小，modulating factor接近于1，则贡献的loss不受影响。</p>
<p>问：为什么pt越大，FL值越小？</p>
<p>答：根据公式（4）可知，FL与log(pt)中的pt成反比，与1-pt成正比，因此FL与pt的关系成反比。这是交叉熵函数的基本性质。当pt很大时（接近于1），FL值很小；而当pt很小时（接近于0），FL值会很大。</p>
<p>注：这里有个超参数—focusing parameter γ。</p>
<p>γ 放大了modulating factor的作用。</p>
<p>举原文中的一个例子，当pt=0.9时，带有modulating factor的focal loss是CE loss的100分之一，即进一步减小了正确分类的损失。</p>
<blockquote>
<p>For instance, with γ = 2, an example classified with pt = 0.9 would have 100× lower loss compared with CE and with pt ≈ 0.968 it would have 1000× lower loss. This in turn increases the importance of correcting misclassified examples (whose loss is scaled down by at most 4× for pt ≤ .5 and γ = 2).</p>
</blockquote>
<p>在实际中，作者采用如下公式，即综合了公式(3)和公式(4)的形式，这样机能调整正负样本的权重，又能控制难易分类样本的权重：</p>
<p><img src="RetinaNet-09.png" alt></p>
<p>这里的两个参数 α和γ 来控制，在实验中a的选择范围也很广，一般而言当γ增加的时候，a需要减小一点，本文作者采用α=0.25，γ=2效果最好。</p>
<p><strong>RetinaNet Detector</strong></p>
<p>RetinaNet是由backbone网络和两个特殊任务的子网络（subnet）组成（属于one-stage检测器）。Backbone用来计算feature map；第一个子网络用来object classification，第二个子网络用来bounding box regression。</p>
<p><strong>Feature Pyramid Network Backbone</strong></p>
<p><img src="RetinaNet-10.png" alt></p>
<p><strong>Anchor</strong></p>
<p><strong>Classification Subnet</strong></p>
<p><strong>Box Regression Subnet</strong></p>
<p><img src="RetinaNet-11.png" alt></p>
<p><img src="RetinaNet-12.png" alt></p>
<p>RetinaNet结构注意内容：</p>
<ol>
<li>训练时FPN每一级的所有example都被用于计算Focal Loss，loss值加到一起用来训练；</li>
<li>测试时FPN每一级只选取score最大的1000个example来做nms；</li>
<li>整个结构不同层的head部分(上图中的c和d部分)共享参数，但分类和回归分支间的参数不共享；</li>
<li>分类分支的最后一级卷积的bias初始化成前面提到的-log((1-π)/π);</li>
</ol>
<p>作者：张磊_0503 链接：<a href="https://www.jianshu.com/p/204d9ad9507f">https://www.jianshu.com/p/204d9ad9507f</a> 來源：简书 简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>
<p><strong>实验结果</strong></p>
<p>Table1是关于RetinaNet和Focal Loss的一些实验结果。（a）是在交叉熵的基础上加上参数a，a=0.5就表示传统的交叉熵，可以看出当a=0.75的时候效果最好，AP值提升了0.9。（b）是对比不同的参数γ和a的实验结果，可以看出随着γ的增加，AP提升比较明显。（d）通过和OHEM的对比可以看出最好的Focal Loss比最好的OHEM提高了3.2AP。这里OHEM1:3表示在通过OHEM得到的minibatch上强制positive和negative样本的比例为1:3，通过对比可以看出这种强制的操作并没有提升AP。（e）加入了运算时间的对比，可以和前面的Figure2结合起来看，速度方面也有优势！注意这里RetinaNet-101-800的AP是37.8，当把训练时间扩大1.5倍同时采用scale jitter，AP可以提高到39.1，这就是全文和table2中的最高的39.1AP的由来。</p>
<p><img src="RetinaNet-13.png" alt></p>
<p><img src="RetinaNet-14.png" alt></p>
<h3 id="8-3-8-RFBNet">8.3.8 RFBNet</h3>
<p><strong>RFBNet有哪些创新点？</strong></p>
<ol>
<li>提出RF block（RFB）模块</li>
</ol>
<p>RFBNet主要想利用一些技巧使得轻量级模型在速度和精度上达到很好的trade-off的检测器。灵感来自人类视觉的感受野结构Receptive Fields (RFs) ，提出了新奇的RF block（RFB）模块，来验证感受野尺寸和方向性的对提高有鉴别鲁棒特征的关系。RFBNet是以主干网络（backbone）为VGG16的SSD来构建的，主要是在Inception的基础上加入了dilated卷积层（dilated convolution），从而有效增大了感受野（receptive field）。整体上因为是基于SSD网络进行改进，所以检测速度还是比较快，同时精度也有一定的保证。</p>
<p><strong>RFB介绍</strong></p>
<p>RFB是一个类似Inception模块的多分支卷积模块，它的内部结构可分为两个组件：多分支卷积层和dilated卷积层。如下图：</p>
<p><img src="RFBNet-01.png" alt></p>
<p><strong>1.多分支卷积层</strong><br>
​      根据RF的定义，用多种尺寸的卷积核来实现比固定尺寸更好。具体设计：1.瓶颈结构，1x1-s2卷积减少通道特征，然后加上一个nxn卷积。2.替换5x5卷积为两个3x3卷积去减少参数，然后是更深的非线性层。有些例子，使用1xn和nx1代替nxn卷积；shortcut直连设计来自于ResNet和Inception ResNet V2。3.为了输出，卷积经常有stride=2或者是减少通道，所以直连层用一个不带非线性激活的1x1卷积层。</p>
<p><strong>2.Dilated 卷积层</strong></p>
<p>设计灵感来自Deeplab，在保持参数量和同样感受野的情况下，用来获取更高分辨率的特征。下图展示两种RFB结构：RFB和RFB-s。每个分支都是一个正常卷积后面加一个dilated卷积，主要是尺寸和dilated因子不同。（a）RFB。整体结构上借鉴了Inception的思想，主要不同点在于引入3个dilated卷积层（比如3x3conv，rate=1），这也是RFBNet增大感受野的主要方式之一；（b）RFB-s。RFB-s和RFB相比主要有两个改进，一方面用3x3卷积层代替5x5卷积层，另一方面用1x3和3x1卷积层代替3x3卷积层，主要目的应该是为了减少计算量，类似Inception后期版本对Inception结构的改进。</p>
<p><img src="RFBNet-02.png" alt></p>
<p>RFBNet300的整体结构如下图所示，基本上和SSD类似。RFBNet和SSD不同的是：1、主干网上用两个RFB结构替换原来新增的两层。2、conv4_3和conv7_fc在接预测层之前分别接RFB-s和RFB结构。</p>
<p><img src="RFBNet-03.png" alt></p>
<h3 id="8-3-9-M2Det">8.3.9 M2Det</h3>
<p><strong>M2Det有哪些创新点？</strong></p>
<ol>
<li>提出了多层次特征金字塔网络（MLFPN）来构建更有效的特征金字塔，用于检测不同尺度的对象。</li>
</ol>
<p>M2Det的整体架构如下所示。M2Det使用backbone和多级特征金字塔网络（MLFPN）从输入图像中提取特征，然后类似于SSD，根据学习的特征生成密集的边界框和类别分数，最后是非最大抑制（NMS）操作以产生最终结果。 MLFPN由三个模块组成：特征融合模块（FFM），简化的U形模块（TUM）和按基于尺度的特征聚合模块（SFAM）。 FFMv1通过融合骨干网络的特征图，将语义信息丰富为基本特征。每个TUM生成一组多尺度特征，然后交替连接的TUM和FFMv2提取多级多尺度特征。此外，SFAM通过按比例缩放的特征连接操作和自适应注意机制将特征聚合到多级特征金字塔中。下面介绍有关M2Det中三个核心模块和网络配置的更多详细信息。</p>
<p><img src="M2Det-01.png" alt></p>
<p><strong>FFMs</strong></p>
<p>FFM融合了M2Det中不同层次的特征，这对于构建最终的多级特征金字塔至关重要。它们使用1x1卷积层来压缩输入特征的通道，并使用连接操作来聚合这些特征图。特别是，由于FFMv1以backbone中不同比例的两个特征图作为输入，因此它采用一个上采样操作，在连接操作之前将深度特征重新缩放到相同的尺度。同时，FFMv2采用基本特征和前一个TUM的最大输出特征图 - 这两个具有相同的比例 - 作为输入，并产生下一个TUM的融合特征。 FFMv1和FFMv2的结构细节分别如下图（a）和（b）所示。</p>
<p><img src="M2Det-02.png" alt></p>
<p><strong>TUMs</strong></p>
<p>TUM不同于FPN和RetinaNet，TUM采用简化的U形结构，如上图（c）所示。编码器是一系列3x3，步长为2的卷积层.并且解码器将这些层的输出作为其参考特征集，而原始FPN选择ResNet主干网络中每个阶段的最后一层的输出。此外，在解码器分支的上采样层后添加1x1卷积层和按元素求和的操作，以增强学习能力并保持特征的平滑性。每个TUM的解码器中的所有输出形成当前级别的多尺度特征。整体而言，堆叠TUM的输出形成多层次多尺度特征，而前TUM主要提供浅层特征，中间TUM提供中等特征，后TUM提供深层特征。</p>
<p><strong>SFAM</strong></p>
<p>SFAM旨在将由TUM生成的多级多尺度特征聚合成多级特征金字塔，如下图所示。SFAM的第一阶段是沿着信道维度将等效尺度的特征连接在一起。聚合特征金字塔可以表示为 $X = [X_1,X_2,...,X_i,...,X_L]$ ，其中</p>
 $$X_i = Concat(X_{1i}, X_{2i}, ...., X_{Li}) \in R^{W_i \times H_i \times C}$$ 
<p>指的是尺度第i个最大的特征。这里，聚合金字塔中的每个比例都包含来自多级深度的特征。但是，简单的连接操作不太适合。在第二阶段，引入了通道注意模块，以促使特征集中在最有益的通道。在SE区块之后，使用全局平均池化来在挤压步骤中生成通道统计z∈RC。</p>
<p><img src="M2Det-03.png" alt></p>
<h2 id="8-4-人脸检测">8.4 人脸检测</h2>
<p>在目标检测领域可以划分为了人脸检测与通用目标检测，往往人脸这方面会有专门的算法（包括人脸检测、人脸识别、人脸其他属性的识别等等），并且和通用目标检测（识别）会有一定的差别，着主要来源于人脸的特殊性（有时候目标比较小、人脸之间特征不明显、遮挡问题等），下面将从人脸检测和通用目标检测两个方面来讲解目标检测。</p>
<h3 id="8-4-1-目前主要有人脸检测方法分类？">8.4.1 目前主要有人脸检测方法分类？</h3>
<p>目前人脸检测方法主要包含两个区域：传统人脸检测算法和基于深度学习的人脸检测算法。传统人脸检测算法主要可以分为4类：</p>
<p>（1）基于知识的人脸检测方法；</p>
<p>（2）基于模型的人脸检测方法；</p>
<p>（3）基于特征的人脸检测方法；</p>
<p>（4）基于外观的人脸检测方法。</p>
<p>由于本书着重关注深度学习，下面会着重介绍基于深度学习的人脸检测方法。</p>
<p>2006年Hinton首次提出深度学习（Deep Learning）的概念，它是通过组合低层的特征形成更高层的抽象特征。随后研究者将深度学习应用在人脸检测领域，主要集中在基于卷积神经网络（CNN）的人脸检测研究，如基于级联卷积神经网络的人脸检测（cascade cnn）、 基于多任务卷积神经网络的人脸检测（MTCNN）、Facebox等，很大程度上提高了人脸检测的鲁棒性。当然通用目标检测算法像Faster-rcnn、yolo、ssd等也有用在人脸检测领域，也可以实现比较不错的结果，但是和专门人脸检测算法比还是有差别。下面部分主要介绍基于深度学习的的人脸检测算法，基于深度学习的通用目标检测算法将在第二大节介绍。</p>
<h3 id="8-4-2-如何检测图片中不同大小的人脸？">8.4.2 如何检测图片中不同大小的人脸？</h3>
<p>传统人脸检测算法中针对不同大小人脸主要有两个策略：</p>
<p>（1）缩放图片的大小（图像金字塔如图8.4.1所示）；</p>
<p>（2）缩放滑动窗的大小（如图8.4.2所示）。</p>
<p><img src="8.4.1.png" alt></p>
<p>图 8.1 图像金字塔</p>
<p>​      <img src="8.4.2.png" alt></p>
<p>图 8.2 缩放滑动窗口</p>
<p>​	基于深度学习的人脸检测算法中针对不同大小人脸主要也有两个策略，但和传统人脸检测算法有点区别，主要包括:</p>
<p>（1）缩放图片大小。（不过也可以通过缩放滑动窗的方式，基于深度学习的滑动窗人脸检测方式效率会很慢存在多次重复卷积，所以要采用全卷积神经网络（FCN），用FCN将不能用滑动窗的方法。）</p>
<p>（2）通过anchor box的方法（如图8.3所示，不要和图8.2混淆，这里是通过特征图预测原图的anchor box区域，具体在facebox中有描述）。</p>
<p><img src="8.4.3.png" alt></p>
<p>图 8.3 anchor box</p>
<h3 id="8-4-3-如何设定算法检测最小人脸尺寸">8.4.3 如何设定算法检测最小人脸尺寸?</h3>
<p>主要是看滑动窗的最小窗口和anchorbox的最小窗口。</p>
<p>（1）滑动窗的方法</p>
<p>假设通过12×12的滑动窗，不对原图做缩放的话，就可以检测原图中12×12的最小人脸。但是往往通常给定最小人脸a=40、或者a=80，以这么大的输入训练CNN进行人脸检测不太现实，速度会很慢，并且下一次需求最小人脸a=30*30又要去重新训练，通常还会是12×12的输入，为满足最小人脸框a，只需要在检测的时候对原图进行缩放即可：w=w×12/a。</p>
<p>（2）anchorbox的方法</p>
<p>原理类似，这里主要看anchorbox的最小box，通过可以通过缩放输入图片实现最小人脸的设定。</p>
<h3 id="8-4-4-如何定位人脸的位置？">8.4.4 如何定位人脸的位置？</h3>
<p>（1）滑动窗的方式：</p>
<p>滑动窗的方式是基于分类器识别为人脸的框的位置确定最终的人脸，</p>
<p><img src="8.4.4.png" alt></p>
<p>图 8.4 滑动窗</p>
<p>（2）FCN的方式：</p>
<p>​    FCN的方式通过特征图映射到原图的方式确定最终识别为人脸的位置，特征图映射到原图人脸框是要看特征图相比较于原图有多少次缩放（缩放主要查看卷积的步长和池化层），假设特征图上(2,3)的点，可粗略计算缩放比例为8倍，原图中的点应该是(16,24)；如果训练的FCN为12*12的输入，对于原图框位置应该是(16,24,12,12),当然这只是估计位置，具体的再构建网络时要加入回归框的预测，主要是相对于原图框的一个平移与缩放。</p>
<p>（3）通过anchor box的方式：</p>
<p>​    通过特征图映射到图的窗口，通过特征图映射到原图到多个框的方式确定最终识别为人脸的位置。</p>
<h3 id="8-4-5-如何通过一个人脸的多个框确定最终人脸框位置？">8.4.5 如何通过一个人脸的多个框确定最终人脸框位置？</h3>
<p><img src="8.4.5.png" alt></p>
<p>图 8.5 通过NMS得到最终的人脸位置</p>
<p>NMS改进版本有很多，最原始的NMS就是判断两个框的交集，如果交集大于设定的阈值，将删除其中一个框，那么两个框应该怎么选择删除哪一个呢？ 因为模型输出有概率值，一般会优选选择概率小的框删除。</p>
<h3 id="8-4-6-基于级联卷积神经网络的人脸检测（Cascade-CNN）">8.4.6 基于级联卷积神经网络的人脸检测（Cascade CNN）</h3>
<ol>
<li>
<p>cascade cnn的框架结构是什么？</p>
<p><img src="8.4.6.png" alt></p>
</li>
</ol>
<p>级联结构中有6个CNN，3个CNN用于人脸非人脸二分类，另外3个CNN用于人脸区域的边框校正。给定一幅图像，12-net密集扫描整幅图片，拒绝90%以上的窗口。剩余的窗口输入到12-calibration-net中调整大小和位置，以接近真实目标。接着输入到NMS中，消除高度重叠窗口。下面网络与上面类似。</p>
<ol start="2">
<li>cascade cnn人脸校验模块原理是什么？</li>
</ol>
<p>该网络用于窗口校正，使用三个偏移变量：Xn:水平平移量，Yn:垂直平移量，Sn:宽高比缩放。候选框口(x,y,w,h)中，(x,y)表示左上点坐标，(w,h)表示宽和高。</p>
<p>我们要将窗口的控制坐标调整为：</p>
 $$
（x-{x_nw}/{s_n},y-{y_nh}/{s_n},{w}/{s_n},{h}/{s_n}）
$$ 
<p>这项工作中，我们有 $N=5×3×3=45$ 种模式。偏移向量三个参数包括以下值：</p>
 $$
Sn：(0.83,0.91,1.0,1.10,1.21)    
$$ 
 $$
Xn：(-0.17,0,0.17)
$$ 
 $$
Yn：(-0.17,0,0.17)
$$ 
<p>同时对偏移向量三个参数进行校正。</p>
<p><img src="8.4.8.png" alt></p>
<p>3、训练样本应该如何准备？</p>
<p>人脸样本：</p>
<p>非人脸样本：</p>
<ol start="4">
<li>级联的好处</li>
</ol>
<p>级联的工作原理和好处：</p>
<ul>
<li>最初阶段的网络可以比较简单，判别阈值可以设得宽松一点，这样就可以在保持较高召回率的同时排除掉大量的非人脸窗口；</li>
<li>最后阶段网络为了保证足够的性能，因此一般设计的比较复杂，但由于只需要处理前面剩下的窗口，因此可以保证足够的效率；</li>
<li>级联的思想可以帮助我们去组合利用性能较差的分类器，同时又可以获得一定的效率保证。</li>
</ul>
<h3 id="8-4-7-基于多任务卷积神经网络的人脸检测（MTCNN）">8.4.7 基于多任务卷积神经网络的人脸检测（MTCNN）</h3>
<p><img src="8.4.9.png" alt></p>
<p><img src="8.4.10.png" alt></p>
<p><img src="8.4.11.png" alt></p>
<p><img src="8.4.12.png" alt></p>
<p>1.MTCNN模型有三个子网络。分别是P-Net,R-Net,O-Net.我想问一下，1.模型中的三个input size是指的是同一张图resize到不同尺度下喂给不同模型，还是同一张图，依次经过三个模型，然后是不同的输入尺寸？（这部分能给我讲一下吗）2.每个模型它都有对应三个结果（face classification;bounding box;facial landmark）这三个在网络上是如何对应的呢？</p>
<p>为了检测不同大小的人脸，开始需要构建图像金字塔，先经过pNet模型，输出人脸类别和边界框（边界框的预测为了对特征图映射到原图的框平移和缩放得到更准确的框），将识别为人脸的框映射到原图框位置可以获取patch，之后每一个patch通过resize的方式输入到rNet，识别为人脸的框并且预测更准确的人脸框，最后rNet识别为人脸的的每一个patch通过resize的方式输入到oNet，跟rNet类似，关键点是为了在训练集有限情况下使模型更鲁棒。</p>
<p>还要注意一点构建图像金字塔的的缩放比例要保留，为了将边界框映射到最开始原图上的</p>
<p>还要注意一点：如何从featureMap映射回原图</p>
<h3 id="8-4-8-Facebox">8.4.8 Facebox</h3>
<p><img src="8.4.13.png" alt></p>
<p><strong>（1）Rapidly Digested Convolutional Layers(RDCL)</strong></p>
<p>在网络前期，使用RDCL快速的缩小feature map的大小。 主要设计原则如下：</p>
<ul>
<li>Conv1, Pool1, Conv2 和 Pool2 的stride分别是4, 2, 2 和 2。这样整个RDCL的stride就是32，可以很快把feature map的尺寸变小。</li>
<li>卷积(或pooling)核太大速度就慢，太小覆盖信息又不足。文章权衡之后，将Conv1, Pool1, Conv2 和 Pool2 的核大小分别设为7x7,3x3,5x5,3x3</li>
<li>使用CReLU来保证输出维度不变的情况下，减少卷积核数量。</li>
</ul>
<p><strong>（2）Multiple Scale Convolutional Layers(MSCL)</strong></p>
<p>在网络后期，使用MSCL更好地检测不同尺度的人脸。 主要设计原则有：</p>
<ul>
<li>类似于SSD，在网络的不同层进行检测；</li>
<li>采用Inception模块。由于Inception包含多个不同的卷积分支，因此可以进一步使得感受野多样化。</li>
</ul>
<p><strong>（3）Anchor densification strategy</strong></p>
<p>为了anchor密度均衡，可以对密度不足的anchor以中心进行偏移加倍，如下图所示：</p>
<p><img src="8.4.14.png" alt></p>
<h2 id="8-5-目标检测的技巧汇总">8.5 目标检测的技巧汇总</h2>
<h3 id="8-5-1-Data-Augmentation（贡献者：北京理工大学–明奇）">8.5.1 Data Augmentation（贡献者：北京理工大学–明奇）</h3>
<p>介绍一篇发表在Big Data上的数据增强相关的文献综述。</p>
<ol>
<li><strong>Introduction</strong></li>
</ol>
<ul>
<li>数据增强与过拟合<br>
验证是否过拟合的方法：画出loss曲线，如果训练集loss持续减小但是验证集loss增大，就说明是过拟合了。</li>
</ul>
<p><img src="8.5.1-1.png" alt></p>
<ul>
<li>
<p>数据增强目的<br>
通过数据增强实现数据更复杂的表征，从而减小验证集和训练集以及最终测试集的差距，让网络更好地学习迁移数据集上的数据分布。这也说明网络不是真正地理解数据，而是记忆数据分布。</p>
</li>
<li>
<p>数据增强的方法<br>
（1）数据变换增强<br>
包括几何变换、色彩空间变换，随机擦除，对抗训练，神经风格迁移等<br>
（2）重采样增强<br>
主要侧重于新的实例合成。如图像混合（mixup），特征空间的增强，GAN生成图片。一张图看明白：</p>
</li>
</ul>
<p><img src="8.5.1-2.png" alt></p>
<ol start="2">
<li><strong>Image Data Augmentation techniques</strong></li>
</ol>
<p>2.1 <strong>Data Augmentations based on basic image manipulations</strong></p>
<ul>
<li>
<p>Geometric transformations<br>
  如果数据集潜在的表征能够被观察和分离，那么简单的几何变换就能取得很好的效果。对于复杂的数据集如医学影像，数据小而且训练集和测试集的偏差大，几何变换等增强的合理运用就很关键。</p>
<ul>
<li>
<p>Flipping<br>
作者提到了要衡量普遍性的观点。但是这种变换对于数字数据集不具有安全性。</p>
</li>
<li>
<p>Color space<br>
主要提及的识别RGB通道上的变换，将三通道图进行分离，以及直方图变换增强等。（颜色空间更多增强方式可以参考A Preliminary Study on Data Augmentation of Deep Learning for Image Classification）</p>
</li>
<li>
<p>Cropping<br>
通常在输入图片的尺寸不一时会进行按中心的裁剪操作。裁剪某种程度上和平移操作有相似性。根据裁剪幅度变化，该操作具有一定的不安全性。</p>
</li>
<li>
<p>Rotation<br>
大幅度的旋转对数字集会有不安全性的考虑。</p>
</li>
<li>
<p>Translation<br>
平移也需要合理设计。如车站人脸检测，只需要中心检测时，就可以加合适的平移增强。平移后空出部分填0或者255，或用高斯分布噪声。</p>
</li>
<li>
<p>Noise injection<br>
在像素上叠加高斯分布的随机噪声。</p>
</li>
</ul>
</li>
<li>
<p>Color space transformations<br>
  由于实际图像中一定存在光线偏差，所以光线的增强十分有必要（但是IJCV的光流文章指出，3D建模的灯光增强实在是很难学习到，所以对于光线增强的效果不如几何也可能因为<strong>光线的复杂度更高，数据样本远远不够</strong>）。色彩变换十分多样，如像素限制、像素矩阵变换、像素值颠倒等；灰度图和彩图相比，计算时间成本大大较少，但是据实验效果会下降一些，很明显因为特征的维度被降维了；还有尝试将RGB映射到其他的色彩空间进行学习，YUV,CMY.HSV等。<br>
  除了计算大内存消耗和时间长等缺点，色彩变换也面临不安全性，比如识别人脸的关键信息是黄白黑，但是大量增强出红绿蓝，会丢信息。颜色变换的增强方法是从色彩空间角度拟合偏置，效果有限的可能性是多样的：1. 真实几何多样性比颜色更简单  2. 色彩的变化多样性更多，导致增强不够反而学不好，颜色空间的欠拟合 3. <strong>变换不安全</strong></p>
</li>
<li>
<p>Experiment<br>
<img src="8.5.1-3.png" alt></p>
</li>
</ul>
<p><strong>随机裁剪</strong>效果最好。</p>
<p>2.2  <strong>Geometric versus photometric transformations</strong></p>
<ul>
<li>
<p>Kernel filter<br>
滤波器核在图像处理用的比较广，这里提到用这种方法来增强。还提到了一种正则化增强方法PatchShuffle，在一个patch内随机交换像素值，使得对噪声的抵抗更强以及避免过拟合。<br>
文章指出关于应用滤波器增强的工作尚且不多，因为这种方法其实和CNN的机制是一样的，这么做也许还不如直接在原始CNN上加层加深网络。</p>
</li>
<li>
<p>Mixing images<br>
<s>就是那篇被ICLR拒稿的采样方法</s>直接均值相加混合。</p>
</li>
</ul>
<p><img src="8.5.1-4.png" alt></p>
<p>  还有非线性的mixup裁剪如下：</p>
<p><img src="8.5.1-5.png" alt></p>
<p>  以及随机裁剪的图像混合：</p>
<p><img src="8.5.1-6.png" alt></p>
<p>  这些混合方式是十分反人类直觉的，因此可解释性不强。只能说是可能增强了对底层低级特征如线条边缘等的鲁棒性。其实有点没有抓住关键点。</p>
<ul>
<li>Random erasing<br>
随机擦除就是类似cutout的思想，通过mask的遮挡使得网络能够提高遮挡情况的鲁棒性。需要手工设计的部分包括mask的大小以及生成方式。是一种比较有效的方法。这种方式也需要考量增强的安全性，比如MNIST数据集8cutout后可能出问题。</li>
</ul>
<p><img src="8.5.1-7.png" alt></p>
<ul>
<li>A note on combining augmentations<br>
组合的增强方式往往是连续变化的，导致数据集的容量会迅速扩大，这对于小数据集领域来说容易发生过拟合 ，所以需要设计合理的搜索算法设计恰当的训练数据集。</li>
</ul>
<p>2.3  <strong>Data Augmentations based on Deep Learning</strong></p>
<ul>
<li>
<p>Feature space augmentation<br>
之前刚看的基于SMOTE类别不平衡的过采样法来进行特征空间的插值操作进行数据增强，就实验效果而言不算特别出众。</p>
</li>
<li>
<p>Adversarial training<br>
对抗样本训练可以提高鲁棒性，但是实际应用中其实提高不一定明显，因为自然对抗样本的数目没有那么多。而NIPS的对抗攻击大赛很多从神经网络的学习策略下手，进行梯度攻击，更加偏向于人为的攻击了，对于普适的检测性能提高意义反而不大，更强调安全需求高的场合。</p>
</li>
<li>
<p>GAN‑based Data Augmentation</p>
</li>
<li>
<p>Neural Style Transfer</p>
</li>
</ul>
<p>不觉得这个效果会普遍很好，应该来说是针对特定域会有效（如白天黑夜），实际效果应该有限。</p>
<ul>
<li>Meta learning Data Augmentations
<ul>
<li>Neural augmentation</li>
<li>Smart Augmentation<br>
两个东西差不多，就是上次看到SmartAugment方法。随机采样类内图片进行通道叠加然后输出融合图像，学通过梯度下降使得输出图像的类内差距减小（没考虑类间关系，可能也不便处理）。</li>
</ul>
</li>
</ul>
<p><img src="8.5.1-8.png" alt></p>
<ul>
<li>AutoAugment<br>
谷歌最早做的自学习增强方法，走的NAS的思路RL+RNN搜索增强空间，还有后来最近发的检测增强也是大同小异，基本就是换汤不换药，问题在于<strong>搜索空间太大</strong>，复现搜索过于依赖硬件条件（<s>普通实验室玩不起</s>）</li>
</ul>
<ol start="3">
<li><strong>Design considerations for image Data Augmentation</strong></li>
</ol>
<p>3.1  <strong>Test-time augmentation</strong><br>
  许多都论文指出在检测阶段进行同等的数据增强能够获得较好的效果。归结可以认为是训练检测阶段的一致性。当然，这种手段时间成本太高，只在如医学影像等追求精度的关键领域可以使用。</p>
<p>3.2  <strong>Curriculum learning</strong><br>
  Bengio团队早年在ICML提出的观点，确实合理，一开始就进行大量的增强容易导致网络不收敛。<br>
从一个数据集学习到的数据增强也可以迁移到其他数据集。</p>
<p>3.3  <strong>Resolution impact</strong><br>
高清（1920×1080×3）或4K（3840×2160×3）等高分辨率图像需要更多的处理和内存来训练深度CNN。然而下一代模型更倾向于使用这样更高分辨率的图像。因为模型中常用的下采样会造成图像中信息的丢失，使图像识别更困难。<br>
研究人员发现，高分辨率图像和低分辨率图像一起训练的模型集合，比单独的任何一个模型都要好。<br>
某个实验（这里就不注明引用了）在256×256图像和512×512图像上训练的模型分别获得7.96%和7.42%的top-5 error。汇总后，他们的top-5 error变低，为6.97%。<br>
随着超分辨率网络的发展，将图像放大到更高的分辨率后训练模型，能够得到更好更健壮的图像分类器。</p>
<p>3.4  <strong>Final dataset size</strong><br>
  数据增强的形式可以分为在线和离线增强。前者是在加载数据时增强，可能造成额外的内存消耗（现在都是数据容量不变的随机增强）。<br>
  此外作者提到了一个比较有意思的点：当前数据集尤其是进行增广后是十分庞大的，明显能够在一定程度上缩小数据集但是保持性能下降不多的子集效率会高得多。</p>
<p>3.5 <strong>Alleviating class imbalance with Data Augmentation</strong><br>
  这也是值得借鉴的一点。通过增强在一定程度上解决类别不平衡问题。但增强需要仔细设计，否则会面对已经学习较好的类别或者场景造成过拟合等问题。</p>
<h3 id="8-5-2-OHEM">8.5.2  OHEM</h3>
<h3 id="8-5-3-NMS：Soft-NMS-Polygon-NMS-Inclined-NMS-ConvNMS-Yes-Net-NMS-Softer-NMS">8.5.3  NMS：Soft NMS/ Polygon NMS/ Inclined NMS/ ConvNMS/ Yes-Net NMS/ Softer NMS</h3>
<h3 id="8-5-4-Multi-Scale-Training-Testing">8.5.4  Multi Scale Training/Testing</h3>
<h3 id="8-5-5-建立小物体与context的关系">8.5.5  建立小物体与context的关系</h3>
<h3 id="8-5-6-参考relation-network">8.5.6  参考relation network</h3>
<h3 id="8-5-7-结合GAN">8.5.7  结合GAN</h3>
<h3 id="8-5-8-结合attention">8.5.8  结合attention</h3>
<h3 id="8-5-9-训练tricks（贡献者：北京理工大学–明奇）">8.5.9  训练tricks（贡献者：北京理工大学–明奇）</h3>
<p>介绍一篇2019.2.4亚马逊挂在ArXiv的目标检测训练tricks的文章（之前亚马逊发了篇分类的tricks在CVPR上）</p>
<ol>
<li><strong>Introduction</strong></li>
</ol>
<p>  上次亚马逊发了个分类的训练trick在CVPR上，这次是检测的，还没发表。就没什么多说的了，下面直接介绍。先看效果如下，其实摘要声称的5%是单阶段的yolov3的提升，说明：单阶段没有RoIPooling阶段很多性质确实不如两阶段，因此采用trick很有必要；相反，两阶段本身结构优于单阶段所以外加的trick提供的如不变性等网络自身能够学习和适应就不起作用了。</p>
<p><img src="8.5.9-1.png" alt></p>
<ol start="2">
<li><strong>Bag of Freebies</strong></li>
</ol>
<p>  提出了一种基于mixup的视觉联系图像混合方法，以及一些数据处理和训练策略。</p>
<p>2.1  <strong>Visually Coherent Image Mixup for Object Detection</strong><br>
  先介绍图像分类中的mixup方法，作用是提供了训练的正则化，应用到图像上如下图，将图像作简单的像素值输入mixup的凸函数中得到合成图；然后将one-hot编码类似处理得到新的label。</p>
<p><img src="8.5.9-2.png" alt></p>
<p>  技术细节：</p>
<ul>
<li>相比于分类的resize，为了保证检测图像不畸变影响效果，作者选择直接叠加，取最大的宽高，空白进行灰度填充，不进行缩放。</li>
<li>选择ab较大（如1.5,1.5）的Beta分布作为系数来混合图像，作者说是相干性视觉图像的更强；loss是两张图像物体的loss之和，loss计算权重分别是beta分布的系数</li>
</ul>
<p><img src="8.5.9-3.png" alt></p>
<p>2.2  <strong>Classification Head Label Smoothing</strong><br>
  标签平滑在检测的分类任务常有用到，最早是Inceptionv2中提出。<br>
  如果标签中有的是错的，或者不准，会导致网络过分信任标签而一起错下去。为了提高网络泛化能力，避免这种错误，在one-hot的label进行计算loss时，真实类别位置乘以一个系数（1-e），e很小如0.05，以0.95的概率送进去；非标注的类别原来为0，现在改为e=0.05送进去计算loss。网络的优化方向不变，但是相比0-1label会更加平滑。<br>
（标签平滑这个讲的不错：<a href="https://juejin.im/post/5a29fd4051882534af25dc92%EF%BC%89">https://juejin.im/post/5a29fd4051882534af25dc92）</a></p>
<p><img src="8.5.9-4.png" alt></p>
<p>  这里进一步改进了一下label smooth的公式而已，在原来基础上除了个类别数。</p>
<p>2.3  <strong>Data Preprocessing</strong><br>
  就是数据增强，没什么其他的。至于分类也是几何变换和色彩变换。这么分区别其实是是否变换label。但是将真实世界就这么简单地分解过于粗糙了。好不容易谷歌的增强考虑到了如何学习一下检测任务的增强，但是也只是加了bbox_only的增强，就效果而言，一般；而且就实际来说，合理性和有效性有待商榷。<br>
  作者认为，两阶段网络的RPN生成就是对输入的任意裁剪，所以这个增强就够了；这老哥膨胀了，two-stage就不用裁剪的增强，虽然两阶段能提供一些不变性，但是用了一般来说都是更好的。</p>
<p>2.4  <strong>Training Schedule Revamping</strong><br>
训练策略上：余弦学习率调整+warmup</p>
<p>2.5  <strong>Synchronized Batch Normalization</strong><br>
跨多卡同步正则化，土豪专区，穷人退避</p>
<p>2.6  <strong>Random shapes training for single-stage object detection networks</strong><br>
多尺度训练，每经过一定的iteration更换一种尺度。举例是yolov3的尺度范围。</p>
<h2 id="8-6-目标检测的常用数据集">8.6 目标检测的常用数据集</h2>
<h3 id="8-6-1-PASCAL-VOC">8.6.1 PASCAL VOC</h3>
<p>​	VOC数据集是目标检测经常用的一个数据集，自2005年起每年举办一次比赛，最开始只有4类，到2007年扩充为20个类，共有两个常用的版本：2007和2012。学术界常用5k的train/val 2007和16k的train/val 2012作为训练集，test 2007作为测试集，用10k的train/val 2007+test 2007和16k的train/val 2012作为训练集，test2012作为测试集，分别汇报结果。</p>
<h3 id="8-6-2-MS-COCO">8.6.2 MS COCO</h3>
<p>​	COCO数据集是微软团队发布的一个可以用来图像recognition+segmentation+captioning 数据集，该数据集收集了大量包含常见物体的日常场景图片，并提供像素级的实例标注以更精确地评估检测和分割算法的效果，致力于推动场景理解的研究进展。依托这一数据集，每年举办一次比赛，现已涵盖检测、分割、关键点识别、注释等机器视觉的中心任务，是继ImageNet Chanllenge以来最有影响力的学术竞赛之一。</p>
<p>相比ImageNet，COCO更加偏好目标与其场景共同出现的图片，即non-iconic images。这样的图片能够反映视觉上的语义，更符合图像理解的任务要求。而相对的iconic images则更适合浅语义的图像分类等任务。</p>
<p>​	COCO的检测任务共含有80个类，在2014年发布的数据规模分train/val/test分别为80k/40k/40k，学术界较为通用的划分是使用train和35k的val子集作为训练集（trainval35k），使用剩余的val作为测试集（minival），同时向官方的evaluation server提交结果（test-dev）。除此之外，COCO官方也保留一部分test数据作为比赛的评测集。</p>
<h3 id="8-6-3-Google-Open-Image">8.6.3 Google Open Image</h3>
<p>​	Open Image是谷歌团队发布的数据集。最新发布的Open Images V4包含190万图像、600个种类，1540万个bounding-box标注，是当前最大的带物体位置标注信息的数据集。这些边界框大部分都是由专业注释人员手动绘制的，确保了它们的准确性和一致性。另外，这些图像是非常多样化的，并且通常包含有多个对象的复杂场景（平均每个图像 8 个）。</p>
<h3 id="8-6-4-ImageNet">8.6.4 ImageNet</h3>
<p>​	ImageNet是一个计算机视觉系统识别项目， 是目前世界上图像识别最大的数据库。ImageNet是美国斯坦福的计算机科学家，模拟人类的识别系统建立的。能够从图片识别物体。Imagenet数据集文档详细，有专门的团队维护，使用非常方便，在计算机视觉领域研究论文中应用非常广，几乎成为了目前深度学习图像领域算法性能检验的“标准”数据集。Imagenet数据集有1400多万幅图片，涵盖2万多个类别；其中有超过百万的图片有明确的类别标注和图像中物体位置的标注。</p>
<h3 id="8-6-5-DOTA">8.6.5 DOTA</h3>
<p>​	DOTA是遥感航空图像检测的常用数据集，包含2806张航空图像，尺寸大约为4kx4k，包含15个类别共计188282个实例，其中14个主类，small vehicle 和 large vehicle都是vehicle的子类。其标注方式为四点确定的任意形状和方向的四边形。航空图像区别于传统数据集，有其自己的特点，如：尺度变化性更大；密集的小物体检测；检测目标的不确定性。数据划分为1/6验证集，1/3测试集，1/2训练集。目前发布了训练集和验证集，图像尺寸从800x800到4000x4000不等。</p>
<h2 id="8-7-目标检测常用标注工具">8.7 目标检测常用标注工具</h2>
<h3 id="8-7-1-LabelImg">8.7.1 LabelImg</h3>
<p>​	LabelImg 是一款开源的图像标注工具，标签可用于分类和目标检测，它是用 Python 编写的，并使用Qt作为其图形界面，简单好用。注释以 PASCAL VOC 格式保存为 XML 文件，这是 ImageNet 使用的格式。 此外，它还支持 COCO 数据集格式。</p>
<h3 id="8-7-2-labelme">8.7.2 labelme</h3>
<p>​	labelme 是一款开源的图像/视频标注工具，标签可用于目标检测、分割和分类。灵感是来自于 MIT 开源的一款标注工具 LabelMe。labelme 具有的特点是：</p>
<ul>
<li>支持图像的标注的组件有：矩形框，多边形，圆，线，点（rectangle, polygons, circle, lines, points）</li>
<li>支持视频标注</li>
<li>GUI 自定义</li>
<li>支持导出 VOC 格式用于 semantic/instance segmentation</li>
<li>支出导出 COCO 格式用于 instance segmentation</li>
</ul>
<h3 id="8-7-3-Labelbox">8.7.3 Labelbox</h3>
<p>​	Labelbox 是一家为机器学习应用程序创建、管理和维护数据集的服务提供商，其中包含一款部分免费的数据标签工具，包含图像分类和分割，文本，音频和视频注释的接口，其中图像视频标注具有的功能如下：</p>
<ul>
<li>可用于标注的组件有：矩形框，多边形，线，点，画笔，超像素等（bounding box, polygons, lines, points，brush, subpixels）</li>
<li>标签可用于分类，分割，目标检测等</li>
<li>以 JSON / CSV / WKT / COCO / Pascal VOC 等格式导出数据</li>
<li>支持 Tiled Imagery (Maps)</li>
<li>支持视频标注 （快要更新）</li>
</ul>
<h3 id="8-7-4-RectLabel">8.7.4 RectLabel</h3>
<p>​	RectLabel 是一款在线免费图像标注工具，标签可用于目标检测、分割和分类。具有的功能或特点：</p>
<ul>
<li>可用的组件：矩形框，多边形，三次贝塞尔曲线，直线和点，画笔，超像素</li>
<li>可只标记整张图像而不绘制</li>
<li>可使用画笔和超像素</li>
<li>导出为YOLO，KITTI，COCO JSON和CSV格式</li>
<li>以PASCAL VOC XML格式读写</li>
<li>使用Core ML模型自动标记图像</li>
<li>将视频转换为图像帧</li>
</ul>
<h3 id="8-7-5-CVAT">8.7.5 CVAT</h3>
<p>​	CVAT 是一款开源的基于网络的交互式视频/图像标注工具，是对加州视频标注工具（Video Annotation Tool） 项目的重新设计和实现。OpenCV团队正在使用该工具来标注不同属性的数百万个对象，许多 UI 和 UX 的决策都基于专业数据标注团队的反馈。具有的功能</p>
<ul>
<li>关键帧之间的边界框插值</li>
<li>自动标注（使用TensorFlow OD API 和 Intel OpenVINO IR格式的深度学习模型）</li>
</ul>
<h3 id="8-7-6-VIA">8.7.6 VIA</h3>
<p>​	VGG Image Annotator（VIA）是一款简单独立的手动注释软件，适用于图像，音频和视频。 VIA 在 Web 浏览器中运行，不需要任何安装或设置。 页面可在大多数现代Web浏览器中作为离线应用程序运行。</p>
<ul>
<li>支持标注的区域组件有：矩形，圆形，椭圆形，多边形，点和折线</li>
</ul>
<h3 id="8-7-6-其他标注工具">8.7.6 其他标注工具</h3>
<p>​	liblabel，一个用 MATLAB 写的轻量级 语义/示例(semantic/instance) 标注工具。<br>
ImageTagger：一个开源的图像标注平台。<br>
Anno-Mage：一个利用深度学习模型半自动图像标注工具，预训练模型是基于MS COCO数据集，用 RetinaNet 训练的。</p>
<br>
​	当然还有一些数据标注公司，可能包含更多标注功能，例如对三维目标检测的标注（3D Bounding box Labelling），激光雷达点云的标注（LIDAR 3D Point Cloud Labeling）等。
<h2 id="8-8-目标检测工具和框架（贡献者：北京理工大学–明奇）">8.8 目标检测工具和框架（贡献者：北京理工大学–明奇）</h2>
<p>各种不同的算法虽然部分官方会有公布代码，或者github上有人复现，但是囿于安装环境不一，实现的框架（pytorch、C++、Caffee、tensorflow、MXNet等）不同，每次更换算法都需要重新安装环境，并且代码之间的迁移性差，十分不方便。所以为了方便将不同的算法统一在一个代码库中，不同的大厂都提出了自己的解决方案。如facebook的Detectron、商汤科技的mmdetection、SimpleDet等。其中Detectron最早，所以用户量最大，其次是国内近段时间崛起的mmdetection，下面介绍该目标检测工具箱。</p>
<ol>
<li><strong>Introduction</strong><br>
MMdetection的特点：</li>
</ol>
<ul>
<li>模块化设计：将不同网络的部分进行切割，模块之间具有很高的复用性和独立性（十分便利，可以任意组合）</li>
<li>高效的内存使用</li>
<li>SOTA</li>
</ul>
<ol start="2">
<li><strong>Support Frameworks</strong></li>
</ol>
<ul>
<li>
<p>单阶段检测器<br>
SSD、RetinaNet、FCOS、FSAF</p>
</li>
<li>
<p>两阶段检测器<br>
Faster R-CNN、R-FCN、Mask R-CNN、Mask Scoring R-CNN、Grid R-CNN</p>
</li>
<li>
<p>多阶段检测器<br>
Cascade R-CNN、Hybrid Task Cascade</p>
</li>
<li>
<p>通用模块和方法<br>
soft-NMS、DCN、OHEN、Train from Scratch 、M2Det 、GN 、HRNet 、Libra R-CNN</p>
</li>
</ul>
<ol start="3">
<li><strong>Architecture</strong></li>
</ol>
<p>模型表征：划分为以下几个模块：<br>
Backbone（ResNet等）、Neck（FPN）、DenseHead（AnchorHead）、RoIExtractor、RoIHead（BBoxHead/MaskHead）<br>
结构图如下：<br>
<img src="mmdetection.png" alt></p>
<ol start="4">
<li><strong>Notice</strong></li>
</ol>
<ul>
<li>1x代表12epoch的COCO训练，2x类似推导</li>
<li>由于batch-size一般比较小（1/2这样的量级），所以大多数地方默认冻结BN层。可以使用GN代替。</li>
</ul>
<ol start="5">
<li><strong>参考链接</strong><br>
mmdetection代码高度模块化，十分好用和便利，更详细的文档直接参见官方文档：<br>
<a href="https://github.com/open-mmlab/mmdetection">https://github.com/open-mmlab/mmdetection</a></li>
</ol>
<p>注释版的mmdetection代码（更新至v1.0.0）：<a href="https://github.com/ming71/mmdetection-annotated">https://github.com/ming71/mmdetection-annotated</a></p>
<p>使用方法简介：<br>
安装记录（可能过时，以官方文档为准）：<a href="https://ming71.github.io/mmdetection-memo.html">https://ming71.github.io/mmdetection-memo.html</a><br>
使用方法（截止更新日期，如果过时以官方为准）：<a href="https://ming71.github.io/mmdetection-instruction.html">https://ming71.github.io/mmdetection-instruction.html</a></p>
<h2 id="TODO">TODO</h2>
<ul>
<li>[ ] 目标检测基础知识：mAP、IoU和NMS等</li>
<li>[ ] 目标检测评测指标</li>
<li>[ ] 目标检测常见标注工具</li>
<li>[ ] 完善目标检测的技巧汇总</li>
<li>[ ] 目标检测的现在难点和未来发展</li>
</ul>
<h2 id="参考文献">参考文献</h2>
<p><a href="https://github.com/amusi/awesome-object-detection">https://github.com/amusi/awesome-object-detection</a></p>
<p><a href="https://github.com/hoya012/deep_learning_object_detection">https://github.com/hoya012/deep_learning_object_detection</a></p>
<p><a href="https://handong1587.github.io/deep_learning/2015/10/09/object-detection.html">https://handong1587.github.io/deep_learning/2015/10/09/object-detection.html</a></p>
<p><a href="https://www.zhihu.com/question/272322209/answer/482922713">https://www.zhihu.com/question/272322209/answer/482922713</a></p>
<p><a href="http://blog.leanote.com/post/afanti.deng@gmail.com/b5f4f526490b">http://blog.leanote.com/post/afanti.deng@gmail.com/b5f4f526490b</a></p>
<p><a href="https://blog.csdn.net/hw5226349/article/details/78987385">https://blog.csdn.net/hw5226349/article/details/78987385</a></p>
<p>[1] Girshick R, Donahue J, Darrell T, et al. Rich feature hierarchies for accurate object detection and semantic segmentation[C]//Proceedings of the IEEE conference on computer vision and pattern recognition. 2014: 580-587.</p>
<p>[2] Girshick R. Fast r-cnn[C]//Proceedings of the IEEE international conference on computer vision. 2015: 1440-1448.</p>
<p>[3] He K, Zhang X, Ren S, et al. Spatial pyramid pooling in deep convolutional networks for visual recognition[J]. IEEE transactions on pattern analysis and machine intelligence, 2015, 37(9): 1904-1916.</p>
<p>[4] Ren S, He K, Girshick R, et al. Faster r-cnn: Towards real-time object detection with region proposal networks[C]//Advances in neural information processing systems. 2015: 91-99.</p>
<p>[5] Lin T Y, Dollár P, Girshick R, et al. Feature pyramid networks for object detection[C]//Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2017: 2117-2125.</p>
<p>[6] He K, Gkioxari G, Dollár P, et al. Mask r-cnn[C]//Proceedings of the IEEE international conference on computer vision. 2017: 2961-2969.</p>
<p>[7] Liu W, Anguelov D, Erhan D, et al. Ssd: Single shot multibox detector[C]//European conference on computer vision. Springer, Cham, 2016: 21-37.</p>
<p>[8] Fu C Y, Liu W, Ranga A, et al. Dssd: Deconvolutional single shot detector[J]. arXiv preprint arXiv:1701.06659, 2017.</p>
<p>[9] Redmon J, Divvala S, Girshick R, et al. You only look once: Unified, real-time object detection[C]//Proceedings of the IEEE conference on computer vision and pattern recognition. 2016: 779-788.</p>
<p>[10] Redmon J, Farhadi A. YOLO9000: better, faster, stronger[C]//Proceedings of the IEEE conference on computer vision and pattern recognition. 2017: 7263-7271.</p>
<p>[11] Redmon J, Farhadi A. Yolov3: An incremental improvement[J]. arXiv preprint arXiv:1804.02767, 2018.</p>
<p>[12] Lin T Y, Goyal P, Girshick R, et al. Focal loss for dense object detection[C]//Proceedings of the IEEE international conference on computer vision. 2017: 2980-2988.</p>
<p>[13] Liu S, Huang D. Receptive field block net for accurate and fast object detection[C]//Proceedings of the European Conference on Computer Vision (ECCV). 2018: 385-400.</p>
<p>[14] Zhao Q, Sheng T, Wang Y, et al. M2Det: A Single-Shot Object Detector based on Multi-Level Feature Pyramid Network[J]. arXiv preprint arXiv:1811.04533, 2018</p>
]]></content>
      <categories>
        <category>算法面试</category>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>刷八股</tag>
      </tags>
  </entry>
  <entry>
    <title>图像分割面试题</title>
    <url>/2024/03/19/deep_learning/ch9/</url>
    <content><![CDATA[<h1>图像分割</h1>
<h2 id="9-1-图像分割算法分类？">9.1 图像分割算法分类？</h2>
<p>图像分割是预测图像中每一个像素所属的类别或者物体。基于深度学习的图像分割算法主要分为两类：</p>
<p><strong>1.语义分割</strong></p>
<p>为图像中的每个像素分配一个类别，如把画面中的所有物体都指出它们各自的类别。</p>
<p><img src="Semantic-01.png" alt></p>
<p><strong>2.实例分割</strong></p>
<p>与语义分割不同，实例分割只对特定物体进行类别分配，这一点与目标检测有点相似，但目标检测输出的是边界框和类别，而实例分割输出的是掩膜（mask）和类别。</p>
<p><img src="Instance-01.png" alt></p>
<h2 id="9-2-传统的基于CNN的分割方法缺点？">9.2 传统的基于CNN的分割方法缺点？</h2>
<p>传统的基于CNN的分割方法：为了对一个像素分类，使用该像素周围的一个图像块作为CNN的输入，用于训练与预测，这种方法主要有几个缺点：<br>
1）存储开销大，例如，对每个像素使用15 * 15的图像块，然后不断滑动窗口，将图像块输入到CNN中进行类别判断，因此，需要的存储空间随滑动窗口的次数和大小急剧上升；<br>
2）效率低下，相邻像素块基本上是重复的，针对每个像素块逐个计算卷积，这种计算有很大程度上的重复；<br>
3）像素块的大小限制了感受区域的大小，通常像素块的大小比整幅图像的大小小很多，只能提取一些局部特征，从而导致分类性能受到限制。<br>
而全卷积网络(FCN)则是从抽象的特征中恢复出每个像素所属的类别。即从图像级别的分类进一步延伸到像素级别的分类。</p>
<h2 id="9-3-FCN">9.3 FCN</h2>
<h3 id="9-3-1-FCN改变了什么">9.3.1 FCN改变了什么?</h3>
<p>​	对于一般的分类CNN网络，如VGG和Resnet，都会在网络的最后加入一些全连接层，经过softmax后就可以获得类别概率信息。但是这个概率信息是1维的，即只能标识整个图片的类别，不能标识每个像素点的类别，所以这种全连接方法不适用于图像分割。<br>
​	而FCN提出可以把后面几个全连接都换成卷积，这样就可以获得一张2维的feature map，后接softmax层获得每个像素点的分类信息，从而解决了分割问题，如图4。</p>
<p><img src="figure_9.1.1_2.jpg" alt></p>
<center>图 4</center>
### 9.3.2 FCN网络结构？ 
<p>​	FCN对图像进行像素级的分类，从而解决了语义级别的图像分割（semantic segmentation）问题。与经典的CNN在卷积层之后使用全连接层得到固定长度的特征向量进行分类（全联接层＋softmax输出）不同，FCN可以接受任意尺寸的输入图像，采用反卷积层对最后一个卷积层的feature map进行上采样, 使它恢复到输入图像相同的尺寸，从而可以对每个像素都产生了一个预测, 同时保留了原始输入图像中的空间信息, 最后在上采样的特征图上进行逐像素分类。<br>
​	下图是语义分割所采用的全卷积网络(FCN)的结构示意图：</p>
<p><img src="figure_9.1.2_1.jpg" alt></p>
<h3 id="9-3-3-全卷积网络举例？">9.3.3 全卷积网络举例？</h3>
<p>​	通常CNN网络在卷积层之后会接上若干个全连接层, 将卷积层产生的特征图(feature map)映射成一个固定长度的特征向量。以AlexNet为代表的经典CNN结构适合于图像级的分类和回归任务，因为它们最后都得到整个输入图像的一个概率向量。</p>
<p><img src="figure_9.1.3_1.jpg" alt></p>
<p>  <br>
如上图所示：<br>
  <br>
（1）在CNN中, 猫的图片输入到AlexNet, 得到一个长为1000的输出向量, 表示输入图像属于每一类的概率, 其中在“tabby cat”这一类统计概率最高, 用来做分类任务。<br>
  <br>
（2）FCN与CNN的区别在于把CNN最后的全连接层转换成卷积层，输出的是一张已经带有标签的图片, 而这个图片就可以做语义分割。<br>
  <br>
（3）CNN的强大之处在于它的多层结构能自动学习特征，并且可以学习到多个层次的特征: 较浅的卷积层感知域较小，学习到一些局部区域的特征；较深的卷积层具有较大的感知域，能够学习到更加抽象一些的特征。高层的抽象特征对物体的大小、位置和方向等敏感性更低，从而有助于识别性能的提高, 所以我们常常可以将卷积层看作是特征提取器。</p>
<h3 id="9-2-4-全连接层和卷积层如何相互转化？">9.2.4 全连接层和卷积层如何相互转化？</h3>
<p>  <br>
<strong>两者相互转换的可能性：</strong><br>
  <br>
全连接层和卷积层之间唯一的不同就是卷积层中的神经元只与输入数据中的一个局部区域连接，并且在卷积列中的神经元共享参数。然而在两类层中，神经元都是计算点积，所以它们的函数形式是一样的。因此，将此两者相互转化是可能的：<br>
  <br>
（1）对于任一个卷积层，都存在一个能实现和它一样的前向传播函数的全连接层。权重矩阵是一个巨大的矩阵，除了某些特定块，其余部分都是零。而在其中大部分块中，元素都是相等的。<br>
  <br>
（2）任何全连接层都可以被转化为卷积层。比如VGG16中第一个全连接层是25088 * 4096的数据尺寸，将它转化为512 * 7 * 7 * 4096的数据尺寸，即一个K=4096的全连接层，输入数据体的尺寸是7 * 7 * 512，这个全连接层可以被等效地看做一个F=7, P=0, S=1, K=4096 的卷积层。换句话说，就是将滤波器的尺寸设置为和输入数据体的尺寸一致7 * 7, 这样输出就变为1 * 1 * 4096, 本质上和全连接层的输出是一样的。<br>
  <br>
<strong>输出激活数据体深度是由卷积核的数目决定的(K=4096)。</strong><br>
  <br>
在两种变换中，将全连接层转化为卷积层在实际运用中更加有用。假设一个卷积神经网络的输入是227x227x3的图像，一系列的卷积层和下采样层将图像数据变为尺寸为7x7x512的激活数据体, AlexNet的处理方式为使用了两个尺寸为4096的全连接层，最后一个有1000个神经元的全连接层用于计算分类评分。我们可以将这3个全连接层中的任意一个转化为卷积层：<br>
  <br>
（1）第一个连接区域是[7x7x512]的全连接层，令其滤波器尺寸为F=7,K=4096，这样输出数据体就为[1x1x4096]。<br>
  <br>
（2）第二个全连接层，令其滤波器尺寸为F=1,K=4096，这样输出数据体为[1x1x4096]。<br>
  <br>
（3）最后一个全连接层也做类似的，令其F=1,K=1000，最终输出为[1x1x1000]。</p>
<h3 id="9-2-5-为什么传统CNN的输入图片是固定大小？">9.2.5 为什么传统CNN的输入图片是固定大小？</h3>
<p>  <br>
对于CNN，一幅输入图片在经过卷积和pooling层时，这些层是不关心图片大小的。比如对于一个卷积层，outputsize = (inputsize - kernelsize) / stride + 1，它并不关心inputsize多大，对于一个inputsize大小的输入feature map，滑窗卷积，输出outputsize大小的feature map即可。pooling层同理。但是在进入全连接层时，feature map（假设大小为n×n）要拉成一条向量，而向量中每个元素（共n×n个）作为一个结点都要与下一个层的所有结点（假设4096个）全连接，这里的权值个数是4096×n×n，而我们知道神经网络结构一旦确定，它的权值个数都是固定的，所以这个n不能变化，n是conv5的outputsize，所以层层向回看，每个outputsize都要固定，那每个inputsize都要固定，因此输入图片大小要固定。</p>
<h3 id="9-2-6-把全连接层的权重W重塑成卷积层的滤波器有什么好处？">9.2.6 把全连接层的权重W重塑成卷积层的滤波器有什么好处？</h3>
<p>  <br>
这样的转化可以在单个向前传播的过程中, 使得卷积网络在一张更大的输入图片上滑动，从而得到多个输出(可以理解为一个label map)。<br>
  <br>
比如: 我们想让224×224尺寸的浮窗，以步长为32在384×384的图片上滑动，把每个经停的位置都带入卷积网络，最后得到6×6个位置的类别得分, 那么通过将全连接层转化为卷积层之后的运算过程为:<br>
  <br>
如果224×224的输入图片经过卷积层和下采样层之后得到了[7x7x512]的数组，那么，384×384的大图片直接经过同样的卷积层和下采样层之后会得到[12x12x512]的数组, 然后再经过上面由3个全连接层转化得到的3个卷积层，最终得到[6x6x1000]的输出((12 – 7)/1 + 1 = 6), 这个结果正是浮窗在原图经停的6×6个位置的得分。<br>
  <br>
一个确定的CNN网络结构之所以要固定输入图片大小，是因为全连接层权值数固定，而该权值数和feature map大小有关, 但是FCN在CNN的基础上把1000个结点的全连接层改为含有1000个1×1卷积核的卷积层，经过这一层，还是得到二维的feature map，同样我们也不关心这个feature map大小, 所以对于输入图片的size并没有限制。<br>
  <br>
如下图所示，FCN将传统CNN中的全连接层转化成卷积层，对应CNN网络FCN把最后三层全连接层转换成为三层卷积层:</p>
<p><img src="figure_9.1.7_1.png" alt></p>
<center>一个分类网络</center>
![](ch9/figure_9.1.7_2.png)
<center>变为全卷积网络</center>
![](ch9/figure_9.1.7_3.png)
<center>End-to-end, pixels-to pixels网络</center>
![](ch9/figure_9.1.7_4.jpg)
<p>（1）全连接层转化为全卷积层 : 在传统的CNN结构中，前5层是卷积层，第6层和第7层分别是一个长度为4096的一维向量，第8层是长度为1000的一维向量，分别对应1000个不同类别的概率。FCN将这3层表示为卷积层，卷积核的大小 (通道数，宽，高) 分别为 (4096,1,1)、(4096,1,1)、(1000,1,1)。看上去数字上并没有什么差别，但是卷积跟全连接是不一样的概念和计算过程，使用的是之前CNN已经训练好的权值和偏置，但是不一样的在于权值和偏置是有自己的范围，属于自己的一个卷积核。<br>
  <br>
（2）CNN中输入的图像大小是统一固定成227x227大小的图像，第一层pooling后为55x55，第二层pooling后图像大小为27x27，第五层pooling后的图像大小为13x13, 而FCN输入的图像是H * W大小，第一层pooling后变为原图大小的1/2，第二层变为原图大小的1/4，第五层变为原图大小的1/8，第八层变为原图大小的1/16。<br>
  <br>
（3）经过多次卷积和pooling以后，得到的图像越来越小，分辨率越来越低。其中图像到H/32 * W/32的时候图片是最小的一层时，所产生图叫做heatmap热图，热图就是我们最重要的高维特征图，得到高维特征的heatmap之后就是最重要的一步也是最后的一步对原图像进行upsampling，把图像进行放大几次到原图像的大小。<br>
  <br>
相较于使用被转化前的原始卷积神经网络对所有36个位置进行迭代计算优化模型，然后再对36个位置做预测，使用转化后的卷积神经网络进行一次前向传播计算要高效得多，因为36次计算都在共享计算资源。这一技巧在实践中经常使用，通常将一张图像尺寸变得更大，然后使用变换后的卷积神经网络来对空间上很多不同位置进行评价得到分类评分，然后在求这些分值的平均值。</p>
<h3 id="9-2-7-反卷积层理解">9.2.7 反卷积层理解</h3>
<p>  <br>
Upsampling的操作可以看成是反卷积(deconvolutional)，卷积运算的参数和CNN的参数一样是在训练FCN模型的过程中通过bp算法学习得到。反卷积层也是卷积层，不关心input大小，滑窗卷积后输出output。deconv并不是真正的deconvolution（卷积的逆变换），最近比较公认的叫法应该是transposed convolution，deconv的前向传播就是conv的反向传播。<br>
  <br>
反卷积参数: 利用卷积过程filter的转置（实际上就是水平和竖直方向上翻转filter）作为计算卷积前的特征图。<br>
  <br>
反卷积的运算如下所示:<br>
  <br>
蓝色是反卷积层的input，绿色是反卷积层的outputFull padding, transposed Full padding, transposed。</p>
<p><img src="figure_9.1.8_1.png" alt></p>
<center>上图中的反卷积，input是2×2, output是4×4。     Zero padding, non-unit strides, transposed。</center>
![](ch9/figure_9.1.8_2.png)
<center>上图中的反卷积，input feature map是3×3, 转化后是5×5, output是5×5</center>
### 9.2.8 跳级(skip)结构
<p>  <br>
对CNN的结果做处理，得到了dense prediction，而作者在试验中发现，得到的分割结果比较粗糙，所以考虑加入更多前层的细节信息，也就是把倒数第几层的输出和最后的输出做一个fusion，实际上也就是加和：</p>
<p><img src="figure_9.1.9_1.png" alt><br>
  <br>
实验表明，这样的分割结果更细致更准确。在逐层fusion的过程中，做到第三行再往下，结果又会变差，所以作者做到这里就停了。</p>
<h3 id="9-2-9-模型训练">9.2.9 模型训练</h3>
<p>  <br>
（1）用AlexNet，VGG16或者GoogleNet训练好的模型做初始化，在这个基础上做fine-tuning，全部都fine-tuning，只需在末尾加上upsampling，参数的学习还是利用CNN本身的反向传播原理。<br>
  <br>
（2）采用whole image做训练，不进行patchwise sampling。实验证明直接用全图已经很effective and efficient。<br>
  <br>
（3）对class score的卷积层做全零初始化。随机初始化在性能和收敛上没有优势。<br>
<em>举例：</em><br>
  <br>
<em>FCN例子: 输入可为任意尺寸图像彩色图像；输出与输入尺寸相同，深度为：20类目标+背景=21，模型基于AlexNet。</em><br>
  <br>
<em>蓝色：卷积层。</em><br>
  <br>
<em>绿色：Max Pooling层。</em><br>
  <br>
<em>黄色: 求和运算, 使用逐数据相加，把三个不同深度的预测结果进行融合：较浅的结果更为精细，较深的结果更为鲁棒。</em><br>
  <br>
<em>灰色: 裁剪, 在融合之前，使用裁剪层统一两者大小, 最后裁剪成和输入相同尺寸输出。</em><br>
  <br>
<em>对于不同尺寸的输入图像，各层数据的尺寸（height，width）相应变化，深度（channel）不变。</em></p>
<p><img src="figure_9.1.10_1.png" alt><br>
  <br>
（1）全卷积层部分进行特征提取, 提取卷积层（3个蓝色层）的输出来作为预测21个类别的特征。</p>
<p>  <br>
（2）图中虚线内是反卷积层的运算, 反卷积层（3个橙色层）可以把输入数据尺寸放大。和卷积层一样，升采样的具体参数经过训练确定。</p>
<p>    </p>
<ol>
<li>以经典的AlexNet分类网络为初始化。最后两级是全连接（红色），参数弃去不用。</li>
</ol>
<p><img src="figure_9.1.10_2.png" alt><br>
    <br>
2) 从特征小图（）预测分割小图（），之后直接升采样为大图。</p>
<p><img src="figure_9.1.10_3.png" alt></p>
<center>反卷积（橙色）的步长为32，这个网络称为FCN-32s</center>  
&emsp;&emsp;&emsp;&emsp;
3) 升采样分为两次完成（橙色×2）, 在第二次升采样前，把第4个pooling层（绿色）的预测结果（蓝色）融合进来。使用跳级结构提升精确性。
<p><img src="figure_9.1.10_4.png" alt></p>
<center>第二次反卷积步长为16，这个网络称为FCN-16s</center>
&emsp;&emsp;&emsp;&emsp;
4) 升采样分为三次完成（橙色×3）, 进一步融合了第3个pooling层的预测结果。
<p><img src="figure_9.1.10_5.png" alt></p>
<center>第三次反卷积步长为8，记为FCN-8s</center>
其他参数:   
&emsp;&emsp;
minibatch：20张图片。  
&emsp;&emsp;
learning rate：0.001。  
&emsp;&emsp;
初始化：分类网络之外的卷积层参数初始化为0。  
&emsp;&emsp;
反卷积参数初始化为bilinear插值。  
&emsp;&emsp;
最后一层反卷积固定位bilinear插值不做学习。
<p><img src="figure_9.1.10_6.png" alt></p>
<h3 id="9-2-10-FCN缺点">9.2.10 FCN缺点</h3>
<p>  <br>
（1）得到的结果还是不够精细。进行8倍上采样虽然比32倍的效果好了很多，但是上采样的结果还是比较模糊和平滑，对图像中的细节不敏感。<br>
  <br>
（2）对各个像素进行分类，没有充分考虑像素与像素之间的关系。忽略了在通常的基于像素分类的分割方法中使用的空间规整（spatial regularization）步骤，缺乏空间一致性。</p>
<h2 id="9-3-U-Net">9.3 U-Net</h2>
<p>  <br>
卷积网络被大规模应用在分类任务中，输出的结果是整个图像的类标签。然而，在许多视觉任务，尤其是生物医学图像处理领域，目标输出应该包括目标类别的位置，并且每个像素都应该有类标签。另外，在生物医学图像往往缺少训练图片。所以，Ciresan等人训练了一个卷积神经网络，用滑动窗口提供像素的周围区域（patch）作为输入来预测每个像素的类标签。这个网络有两个优点：<br>
第一，输出结果可以定位出目标类别的位置；<br>
第二，由于输入的训练数据是patches，这样就相当于进行了数据增广，解决了生物医学图像数量少的问题。<br>
  <br>
但是，这个方法也有两个很明显缺点。<br>
  <br>
第一，它很慢，因为这个网络必须训练每个patch，并且因为patch间的重叠有很多的冗余(冗余会造成什么影响呢？卷积核里面的W，就是提取特征的权重，两个块如果重叠的部分太多，这个权重会被同一些特征训练两次，造成资源的浪费，减慢训练时间和效率，虽然说会有一些冗余，训练集大了，准确率不就高了吗？可是你这个是相同的图片啊，重叠的东西都是相同的，举个例子，我用一张相同的图片训练20次，按照这个意思也是增大了训练集啊，可是会出现什么结果呢，很显然，会导致过拟合，也就是对你这个图片识别很准，别的图片就不一定了)。<br>
  <br>
第二，定位准确性和获取上下文信息不可兼得。大的patches需要更多的max-pooling层这样减小了定位准确性(为什么？因为你是对以这个像素为中心的点进行分类，如果patch太大，最后经过全连接层的前一层大小肯定是不变的，如果你patch大就需要更多的pooling达到这个大小，而pooling层越多，丢失信息的信息也越多；小的patches只能看到很小的局部信息，包含的背景信息不够。<br>
  <br>
这篇论文建立了一个更好全卷积方法。我们定义和扩展了这个方法它使用更少的训练图片但产生更精确的分割。</p>
<p><img src="figure_9.2_1.png" alt></p>
<p>  <br>
(1)	使用全卷积神经网络。(全卷积神经网络就是卷积取代了全连接层，全连接层必须固定图像大小而卷积不用，所以这个策略使得，你可以输入任意尺寸的图片，而且输出也是图片，所以这是一个端到端的网络。)<br>
  <br>
(2)	左边的网络是收缩路径：使用卷积和maxpooling。<br>
  <br>
(3)	右边的网络是扩张路径:使用上采样产生的特征图与左侧收缩路径对应层产生的特征图进行concatenate操作。（pooling层会丢失图像信息和降低图像分辨率且是不可逆的操作，对图像分割任务有一些影响，对图像分类任务的影响不大，为什么要做上采样？因为上采样可以补足一些图片的信息，但是信息补充的肯定不完全，所以还需要与左边的分辨率比较高的图片相连接起来（直接复制过来再裁剪到与上采样图片一样大小），这就相当于在高分辨率和更抽象特征当中做一个折衷，因为随着卷积次数增多，提取的特征也更加有效，更加抽象，上采样的图片是经历多次卷积后的图片，肯定是比较高效和抽象的图片，然后把它与左边不怎么抽象但更高分辨率的特征图片进行连接）。<br>
  <br>
(4)	最后再经过两次反卷积操作，生成特征图，再用两个1X1的卷积做分类得到最后的两张heatmap,例如第一张表示的是第一类的得分，第二张表示第二类的得分heatmap,然后作为softmax函数的输入，算出概率比较大的softmax类，选择它作为输入给交叉熵进行反向传播训练。</p>
<p>下面是U-Net模型的代码实现：（贡献者：黄钦建－华南理工大学）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def get_unet():</span><br><span class="line">    inputs = Input((img_rows, img_cols, 1))</span><br><span class="line">    conv1 = Conv2D(32, (3, 3), activation=&#x27;relu&#x27;, padding=&#x27;same&#x27;)(inputs)</span><br><span class="line">    conv1 = Conv2D(32, (3, 3), activation=&#x27;relu&#x27;, padding=&#x27;same&#x27;)(conv1)</span><br><span class="line">    pool1 = MaxPooling2D(pool_size=(2, 2))(conv1)</span><br><span class="line">    # pool1 = Dropout(0.25)(pool1)</span><br><span class="line">    # pool1 = BatchNormalization()(pool1)</span><br><span class="line"></span><br><span class="line">    conv2 = Conv2D(64, (3, 3), activation=&#x27;relu&#x27;, padding=&#x27;same&#x27;)(pool1)</span><br><span class="line">    conv2 = Conv2D(64, (3, 3), activation=&#x27;relu&#x27;, padding=&#x27;same&#x27;)(conv2)</span><br><span class="line">    pool2 = MaxPooling2D(pool_size=(2, 2))(conv2)</span><br><span class="line">    # pool2 = Dropout(0.5)(pool2)</span><br><span class="line">    # pool2 = BatchNormalization()(pool2)</span><br><span class="line"></span><br><span class="line">    conv3 = Conv2D(128, (3, 3), activation=&#x27;relu&#x27;, padding=&#x27;same&#x27;)(pool2)</span><br><span class="line">    conv3 = Conv2D(128, (3, 3), activation=&#x27;relu&#x27;, padding=&#x27;same&#x27;)(conv3)</span><br><span class="line">    pool3 = MaxPooling2D(pool_size=(2, 2))(conv3)</span><br><span class="line">    # pool3 = Dropout(0.5)(pool3)</span><br><span class="line">    # pool3 = BatchNormalization()(pool3)</span><br><span class="line"></span><br><span class="line">    conv4 = Conv2D(256, (3, 3), activation=&#x27;relu&#x27;, padding=&#x27;same&#x27;)(pool3)</span><br><span class="line">    conv4 = Conv2D(256, (3, 3), activation=&#x27;relu&#x27;, padding=&#x27;same&#x27;)(conv4)</span><br><span class="line">    pool4 = MaxPooling2D(pool_size=(2, 2))(conv4)</span><br><span class="line">    # pool4 = Dropout(0.5)(pool4)</span><br><span class="line">    # pool4 = BatchNormalization()(pool4)</span><br><span class="line"></span><br><span class="line">    conv5 = Conv2D(512, (3, 3), activation=&#x27;relu&#x27;, padding=&#x27;same&#x27;)(pool4)</span><br><span class="line">    conv5 = Conv2D(512, (3, 3), activation=&#x27;relu&#x27;, padding=&#x27;same&#x27;)(conv5)</span><br><span class="line"></span><br><span class="line">    up6 = concatenate([Conv2DTranspose(256, (2, 2), strides=(</span><br><span class="line">        2, 2), padding=&#x27;same&#x27;)(conv5), conv4], axis=3)</span><br><span class="line">    # up6 = Dropout(0.5)(up6)</span><br><span class="line">    # up6 = BatchNormalization()(up6)</span><br><span class="line">    conv6 = Conv2D(256, (3, 3), activation=&#x27;relu&#x27;, padding=&#x27;same&#x27;)(up6)</span><br><span class="line">    conv6 = Conv2D(256, (3, 3), activation=&#x27;relu&#x27;, padding=&#x27;same&#x27;)(conv6)</span><br><span class="line"></span><br><span class="line">    up7 = concatenate([Conv2DTranspose(128, (2, 2), strides=(</span><br><span class="line">        2, 2), padding=&#x27;same&#x27;)(conv6), conv3], axis=3)</span><br><span class="line">    # up7 = Dropout(0.5)(up7)</span><br><span class="line">    # up7 = BatchNormalization()(up7)</span><br><span class="line">    conv7 = Conv2D(128, (3, 3), activation=&#x27;relu&#x27;, padding=&#x27;same&#x27;)(up7)</span><br><span class="line">    conv7 = Conv2D(128, (3, 3), activation=&#x27;relu&#x27;, padding=&#x27;same&#x27;)(conv7)</span><br><span class="line"></span><br><span class="line">    up8 = concatenate([Conv2DTranspose(64, (2, 2), strides=(</span><br><span class="line">        2, 2), padding=&#x27;same&#x27;)(conv7), conv2], axis=3)</span><br><span class="line">    # up8 = Dropout(0.5)(up8)</span><br><span class="line">    # up8 = BatchNormalization()(up8)</span><br><span class="line">    conv8 = Conv2D(64, (3, 3), activation=&#x27;relu&#x27;, padding=&#x27;same&#x27;)(up8)</span><br><span class="line">    conv8 = Conv2D(64, (3, 3), activation=&#x27;relu&#x27;, padding=&#x27;same&#x27;)(conv8)</span><br><span class="line"></span><br><span class="line">    up9 = concatenate([Conv2DTranspose(32, (2, 2), strides=(</span><br><span class="line">        2, 2), padding=&#x27;same&#x27;)(conv8), conv1], axis=3)</span><br><span class="line">    # up9 = Dropout(0.5)(up9)</span><br><span class="line">    # up9 = BatchNormalization()(up9)</span><br><span class="line">    conv9 = Conv2D(32, (3, 3), activation=&#x27;relu&#x27;, padding=&#x27;same&#x27;)(up9)</span><br><span class="line">    conv9 = Conv2D(32, (3, 3), activation=&#x27;relu&#x27;, padding=&#x27;same&#x27;)(conv9)</span><br><span class="line"></span><br><span class="line">    # conv9 = Dropout(0.5)(conv9)</span><br><span class="line"></span><br><span class="line">    conv10 = Conv2D(1, (1, 1), activation=&#x27;sigmoid&#x27;)(conv9)</span><br><span class="line"></span><br><span class="line">    model = Model(inputs=[inputs], outputs=[conv10])</span><br><span class="line"></span><br><span class="line">    model.compile(optimizer=Adam(lr=1e-5),</span><br><span class="line">                  loss=dice_coef_loss, metrics=[dice_coef])</span><br><span class="line"></span><br><span class="line">    return model</span><br></pre></td></tr></table></figure>
<h2 id="9-4-SegNet">9.4 SegNet</h2>
<p>  <br>
可训练的图像分割引擎，包含一个encoder网络，一个对应的decoder网络，衔接像素级分类层，解码网络与VGG16的13层卷积层相同。解码网络是将低分辨率的编码特征图映射到全分辨率的特征图。解码网络使用最大池化层的池化索引进行非线性上采样，上采样过程就不需要学习。上采样得到的稀疏图与可训练的滤波器卷积得到致密的特征图。<br>
  <br>
使用池化层索引进行上采样的优势：<br>
  <br>
1）提升边缘刻画度；<br>
  <br>
2）减少训练的参数；<br>
  <br>
3）这种上采样模式可以包含到任何编码-解码网络中。<br>
  <br>
SegNet网络的结构如下图所示：</p>
<p><img src="figure_9.3_1.jpg" alt></p>
<p>  <br>
SegNet网络结构如图1所示，Input为输入图片，Output为输出分割的图像，不同颜色代表不同的分类。语义分割的重要性就在于不仅告诉你图片中某个东西是什么，而且告知你他在图片的位置。我们可以看到是一个对称网络，由中间绿色pooling层与红色upsampling层作为分割，左边是卷积提取高维特征，并通过pooling使图片变小，SegNet作者称为Encoder，右边是反卷积（在这里反卷积与卷积没有区别）与upsampling，通过反卷积使得图像分类后特征得以重现，upsampling使图像变大，SegNet作者称为Decoder，最后通过Softmax，输出不同分类的最大值。这就是大致的SegNet过程，下面对这个过程里面使用到的方法进行介绍。<br>
  <br>
编码网络与滤波器族卷积得到特征图，进行BN，ReLU，最大池化。最大池化是为了获得空间小位移的平移不变。最大池化和下采样损失了边缘细节，因此，在编码过程中保存边缘信息很重要。考虑到内存原因，只保存最大池化索引，如最大特征值的位置。<br>
  <br>
SegNet解码技术如下图所示：</p>
<p><img src="figure_9.3_2.jpg" alt></p>
<p>  <br>
解码网络使用保存的最大池化索引上采样，得到稀疏的特征图，将特征图与可训练的解码滤波器族卷积得到致密的特征图。之后进行BN。高维的特征图输入soft-max层，对每个像素进行分类，得到每个像素属于K类的概率。  图3中右边是FCN的解码技术，FCN对编码的特征图进行降维，降维后输入到解码网络，解码网络中，上采样使用反卷积实现，上采样的特征图与降维的编码图进行element-wise add得到最终的解码特征图。FCN解码模型需要存储编码特征图，在嵌入式设备中内存紧张。<br>
  <br>
SegNet的Encoder过程中，卷积的作用是提取特征，SegNet使用的卷积为same卷积（详见卷积神经网络CNN（1）)，即卷积后不改变图片大小；在Decoder过程中，同样使用same卷积，不过卷积的作用是为upsampling变大的图像丰富信息，使得在Pooling过程丢失的信息可以通过学习在Decoder得到。SegNet中的卷积与传统CNN的卷积并没有区别。</p>
<h2 id="9-5-空洞卷积-Dilated-Convolutions">9.5 空洞卷积(Dilated Convolutions)</h2>
<p>  <br>
在图像分割领域，图像输入到CNN（典型的网络比如FCN[3]）中，FCN先像传统的CNN那样对图像做卷积再pooling，降低图像尺寸的同时增大感受野，但是由于图像分割预测是pixel-wise的输出，所以要将pooling后较小的图像尺寸upsampling到原始的图像尺寸进行预测（upsampling一般采用deconv反卷积操作，deconv可参见知乎答案如何理解深度学习中的deconvolution networks？），之前的pooling操作使得每个pixel预测都能看到较大感受野信息。因此图像分割FCN中有两个关键，一个是pooling减小图像尺寸增大感受野，另一个是upsampling扩大图像尺寸。在先减小再增大尺寸的过程中，肯定有一些信息损失掉了，那么能不能设计一种新的操作，不通过pooling也能有较大的感受野看到更多的信息呢？答案就是dilated conv。<br>
  <br>
以前的CNN主要问题总结：<br>
  <br>
（1）Up-sampling / pooling layer<br>
  <br>
（2）内部数据结构丢失；空间层级化信息丢失。<br>
  <br>
（3）小物体信息无法重建 (假设有四个pooling layer 则 任何小于 2^4 = 16 pixel 的物体信息将理论上无法重建。)<br>
  <br>
举例如下：</p>
<p><img src="figure_9.3_3.png" alt></p>
<center>Dilated Convolution with a 3 x 3 kernel and dilation rate 2</center>  
&emsp;&emsp;
下面看一下dilated conv原始论文[4]中的示意图
<p><img src="figure_9.3_4.jpg" alt></p>
<p>  <br>
(a)	图对应3x3的1-dilated conv，和普通的卷积操作一样，(b)图对应3x3的2-dilated conv，实际的卷积kernel size还是3x3，但是空洞为1，也就是对于一个7x7的图像patch，只有9个红色的点和3x3的kernel发生卷积操作，其余的点略过。也可以理解为kernel的size为7x7，但是只有图中的9个点的权重不为0，其余都为0。 可以看到虽然kernel size只有3x3，但是这个卷积的感受野已经增大到了7x7（如果考虑到这个2-dilated conv的前一层是一个1-dilated conv的话，那么每个红点就是1-dilated的卷积输出，所以感受野为3x3，所以1-dilated和2-dilated合起来就能达到7x7的conv）,©图是4-dilated conv操作，同理跟在两个1-dilated和2-dilated conv的后面，能达到15x15的感受野。对比传统的conv操作，3层3x3的卷积加起来，stride为1的话，只能达到(kernel-1) * layer+1=7的感受野，也就是和层数layer成线性关系，而dilated conv的感受野是指数级的增长。<br>
  <br>
dilated的好处是不做pooling损失信息的情况下，加大了感受野，让每个卷积输出都包含较大范围的信息。在图像需要全局信息或者语音文本需要较长的sequence信息依赖的问题中，都能很好的应用dilated conv，比如图像分割、语音合成WaveNet、机器翻译ByteNet中。</p>
<h2 id="9-6-RefineNet">9.6 RefineNet</h2>
<p>  <br>
网络结构：<br>
  <br>
RefineNet block的作用就是把不同resolution level的feature map进行融合。网络结构如下：</p>
<p><img src="figure_9.4_1.png" alt><br>
  <br>
最左边一栏就是FCN的encoder部分(文中是用的ResNet)，先把pretrained ResNet按feature map的分辨率分成四个ResNet blocks，然后向右把四个blocks分别作为4个path通过RefineNet block进行融合refine，最后得到一个refined feature map(接softmax再双线性插值输出)。<br>
注意除了RefineNet-4，所有的RefineNet block都是二输入的，用于融合不同level做refine，而单输入的RefineNet-4可以看作是先对ResNet的一个task adaptation。</p>
<p>  <br>
<strong>RefineNet Block</strong><br>
  <br>
接下来仔细看一下RefineNet block，可以看到主要组成部分是Residual convolution unit, Multi-resolution fusion, Chained residual pooling, Output convolutions. 切记这个block作用是融合多个level的feature map输出单个level的feature map，但具体的实现应该是和输入个数、shape无关的。</p>
<p><img src="figure_9.4_2.png" alt></p>
<p>  <br>
Residual convolution unit就是普通的去除了BN的residual unit；</p>
<p>  <br>
Multi-resolution fusion是先对多输入的feature map都用一个卷积层进行adaptation(都化到最小的feature map的shape)，再上采样再做element-wise的相加。注意如果是像RefineNet-4那样的单输入block这一部分就直接pass了；</p>
<p>  <br>
Chained residual pooling中的ReLU对接下来池化的有效性很重要，还可以使模型对学习率的变化没这么敏感。这个链式结构能从很大范围区域上获取背景context。另外，这个结构中大量使用了identity mapping这样的连接，无论长距离或者短距离的，这样的结构允许梯度从一个block直接向其他任一block传播。</p>
<p>  <br>
Output convolutions就是输出前再加一个RCU。</p>
<h2 id="9-7-PSPNet">9.7 PSPNet</h2>
<p>  <br>
场景解析对于无限制的开放词汇和不同场景来说是具有挑战性的.本文使用文中的pyramid pooling module实现基于不同区域的上下文集成，提出了PSPNet，实现利用上下文信息的能力进行场景解析。<br>
  <br>
作者认为，FCN存在的主要问题是没有采取合适的策略来用全局的信息，本文的做法就是借鉴SPPNet来设计了PSPNet解决这个问题。<br>
  <br>
很多State-of-the-art的场景解析框架都是基于FCN的.基于CNN的方法能够增强动态物体的理解，但是在无限制词汇和不同场景中仍然面临挑战.举个例子，如下图.</p>
<p><img src="figure_9.6_1.png" alt><br>
  <br>
FCN认为右侧框中是汽车，但是实际上是船，如果参考上下文的先验知识，就会发现左边是一个船屋，进而推断是框中是船.FCN存在的主要问题就是不能利用好全局的场景线索。</p>
<p>  <br>
对于尤其复杂的场景理解，之前都是采用空间金字塔池化来做的，和之前方法不同（为什么不同，需要参考一下经典的金字塔算法），本文提出了pyramid scene parsing network(PSPNet)。<br>
  <br>
本文的主要贡献如下:<br>
  <br>
(1)	提出了PSPNet在基于FCN的框架中集成困难的上下文特征<br>
  <br>
(2)	通过基于深度监督误差开发了针对ResNet的高效优化策略<br>
  <br>
(3)	构建了一个用于state-of-the-art的场景解析和语义分割的实践系统（具体是什么？）<br>
  <br>
通过观察FCN的结果，发现了如下问题：<br>
  <br>
(1)	关系不匹配（Mismatched Relationship）<br>
  <br>
(2)	易混淆的类别（Confusion Categories）<br>
  <br>
(3)	不显眼的类别（Inconspicuous Classes）<br>
  <br>
总结以上结果发现，以上问题部分或者全部与上下文关系和全局信息有关系，因此本文提出了PSPNet.框架如下:</p>
<p><img src="figure_9.6_2.png" alt><br>
  <br>
并且加入额外的深度监督 Loss</p>
<p><img src="figure_9.6_3.png" alt></p>
<h2 id="9-8-DeepLab系列">9.8 DeepLab系列</h2>
<h3 id="9-8-1-DeepLabv1">9.8.1 DeepLabv1</h3>
<p>  <br>
DeepLab 是结合了深度卷积神经网络（DCNNs）和概率图模型（DenseCRFs）的方法。<br>
  <br>
在实验中发现 DCNNs 做语义分割时精准度不够的问题，根本原因是 DCNNs 的高级特征的平移不变性，即高层次特征映射，根源于重复的池化和下采样。<br>
  <br>
针对信号下采样或池化降低分辨率，DeepLab 是采用的 atrous（带孔）算法扩展感受野，获取更多的上下文信息。<br>
  <br>
分类器获取以对象中心的决策是需要空间变换的不变性，这天然地限制了 DCNN 的定位精度，DeepLab 采用完全连接的条件随机场（CRF）提高模型捕获细节的能力。<br>
  <br>
除空洞卷积和 CRFs 之外，论文使用的 tricks 还有 Multi-Scale features。其实就是 U-Net 和 FPN 的思想，在输入图像和前四个最大池化层的输出上附加了两层的 MLP，第一层是 128 个 3×3 卷积，第二层是 128 个 1×1 卷积。最终输出的特征与主干网的最后一层特征图融合，特征图增加 5×128=640 个通道。<br>
  <br>
实验表示多尺度有助于提升预测结果，但是效果不如 CRF 明显。<br>
  <br>
论文模型基于 VGG16，在 Titan GPU 上运行速度达到了 8FPS，全连接 CRF 平均推断需要 0.5s ，在 PASCAL VOC-2012 达到 71.6% IOU accuracy。</p>
<h3 id="9-8-2-DeepLabv2">9.8.2 DeepLabv2</h3>
<p>  <br>
DeepLabv2 是相对于 DeepLabv1 基础上的优化。DeepLabv1 在三个方向努力解决，但是问题依然存在：特征分辨率的降低、物体存在多尺度，DCNN 的平移不变性。<br>
  <br>
因 DCNN 连续池化和下采样造成分辨率降低，DeepLabv2 在最后几个最大池化层中去除下采样，取而代之的是使用空洞卷积，以更高的采样密度计算特征映射。<br>
  <br>
物体存在多尺度的问题，DeepLabv1 中是用多个 MLP 结合多尺度特征解决，虽然可以提供系统的性能，但是增加特征计算量和存储空间。<br>
  <br>
论文受到 Spatial Pyramid Pooling (SPP) 的启发，提出了一个类似的结构，在给定的输入上以不同采样率的空洞卷积并行采样，相当于以多个比例捕捉图像的上下文，称为 ASPP (atrous spatial pyramid pooling) 模块。<br>
  <br>
DCNN 的分类不变形影响空间精度。DeepLabv2 是采样全连接的 CRF 在增强模型捕捉细节的能力。<br>
  <br>
论文模型基于 ResNet，在 NVidia Titan X GPU 上运行速度达到了 8FPS，全连接 CRF 平均推断需要 0.5s ，在耗时方面和 DeepLabv1 无差异，但在 PASCAL VOC-2012 达到 79.7 mIOU。</p>
<h3 id="9-8-3-DeepLabv3">9.8.3 DeepLabv3</h3>
<p>  <br>
好的论文不止说明怎么做，还告诉为什么。DeepLab 延续到 DeepLabv3 系列，依然是在空洞卷积做文章，但是探讨不同结构的方向。<br>
  <br>
DeepLabv3 论文比较了多种捕获多尺度信息的方式：</p>
<p><img src="figure_9.6_4.png" alt></p>
<p>  <br>
1.Image Pyramid：将输入图片放缩成不同比例，分别应用在 DCNN 上，将预测结果融合得到最终输出。<br>
  <br>
2.Encoder-Decoder：利用 Encoder 阶段的多尺度特征，运用到 Decoder 阶段上恢复空间分辨率，代表工作有 FCN、SegNet、PSPNet 等工。<br>
  <br>
3.Deeper w. Atrous Convolution：在原始模型的顶端增加额外的模块，例如 DenseCRF，捕捉像素间长距离信息。<br>
  <br>
4.Spatial Pyramid Pooling：空间金字塔池化具有不同采样率和多种视野的卷积核，能够以多尺度捕捉对象。<br>
  <br>
DeepLabv1-v2 都是使用带孔卷积提取密集特征来进行语义分割。但是为了解决分割对象的多尺度问题，DeepLabv3 设计采用多比例的带孔卷积级联或并行来捕获多尺度背景。<br>
  <br>
此外，DeepLabv3 将修改之前提出的带孔空间金字塔池化模块，该模块用于探索多尺度卷积特征，将全局背景基于图像层次进行编码获得特征，取得 state-of-art 性能，在 PASCAL VOC-2012 达到 86.9 mIOU。</p>
<h3 id="9-8-4-DeepLabv3">9.8.4 DeepLabv3+</h3>
<p>  <br>
语义分割关注的问题:<br>
  <br>
1、 实例对象多尺度问题。<br>
  <br>
2、 因为深度网络存在stride=2的层，会导致feature分辨率下降，从而导致预测精度降低，而造成的边界信息丢失问题。<br>
  <br>
deeplab V3新设计的aspp结构解决了问题1，deeplab v3+主要目的在于解决问题2。<br>
  <br>
问题2 可以使用空洞卷积替代更多的pooling层来获取分辨率更高的feature。但是feature分辨率更高会极大增加运算量。以deeplab v3使用的resnet101为例，stride=16将造成后面9层feature变大，后面9层的计算量变为原来的2*2=4倍大。stride=8则更为恐怖，后面78层的计算量都会变大很多。<br>
  <br>
解决方案：1、编解码器结构；2 Modified Aligned Xception</p>
<p><img src="figure_9.6_5.png" alt></p>
<p>  <br>
在deeplabv3基础上加入解码器。A是aspp结构，其中8x的上采样可以看做是一个解码器。B是编解码结构，它集合了高层和底层的特征。C就是本文采取的结构。<br>
  <br>
方法：<br>
  <br>
（1）Encoder-Decoder with Atrous Convolution</p>
<p><img src="figure_9.6_6.png" alt></p>
<p>  <br>
编码器采用deeplabv3。<br>
  <br>
解码器部分：先从低层级选一个feature，将低层级的feature用1 * 1的卷积进行通道压缩（原本为256通道，或者512通道），目的在于减少低层级的比重。作者认为编码器得到的feature具有更丰富的信息，所以编码器的feature应该有更高的比重。 这样做有利于训练。<br>
  <br>
再将编码器的输出上采样，使其分辨率与低层级feature一致。举个例子，如果采用resnet conv2 输出的feature，则这里要* 4上采样。将两种feature连接后，再进行一次3 * 3的卷积（细化作用），然后再次上采样就得到了像素级的预测。后面的实验结果表明这种结构在 stride=16 时既有很高的精度速度又很快。stride=8相对来说只获得了一点点精度的提升，但增加了很多的计算量。<br>
  <br>
（2）Modified Aligned Xception<br>
  <br>
Xception主要采用了deepwish seperable convolution来替换原来的卷积层。简单的说就是这种结构能在更少参数更少计算量的情况下学到同样的信息。这边则是考虑将原来的resnet-101骨架网换成xception。</p>
<p><img src="figure_9.6_7.png" alt></p>
<p>  <br>
<strong>红色部分为修改</strong><br>
  <br>
更多层：重复8次改为16次（基于MSRA目标检测的工作）。<br>
  <br>
将原来简单的pool层改成了stride为2的deepwish seperable convolution。<br>
  <br>
额外的RELU层和归一化操作添加在每个 3 × 3 depthwise convolution之后（原来只在1 * 1卷积之后）</p>
<h2 id="9-9-Mask-R-CNN">9.9 Mask-R-CNN</h2>
<h3 id="9-9-1-Mask-RCNN-的网络结构示意图">9.9.1 Mask-RCNN 的网络结构示意图</h3>
<p><img src="figure_9.8_1.png" alt></p>
<p>  <br>
其中黑色部分为原来的Faster-RCNN，红色部分为在Faster网络上的修改：<br>
  <br>
1）将ROI Pooling层替换成了ROIAlign；<br>
  <br>
2）添加并列的FCN层（Mask层）；<br>
  <br>
先来概述一下Mask-RCNN的几个特点（来自于Paper<a href="https://arxiv.org/pdf/1703.06870.pdf">Mask R-CNN</a>的Abstract）：<br>
  <br>
1）在边框识别的基础上添加分支网络，用于语义Mask识别；<br>
  <br>
2）训练简单，相对于Faster仅增加一个小的Overhead，可以跑到5FPS；<br>
  <br>
3）可以方便的扩展到其他任务，比如人的姿态估计等；<br>
  <br>
4）不借助Trick，在每个任务上，效果优于目前所有的 single-model entries；包括 COCO 2016 的Winners。</p>
<h3 id="9-9-2-RCNN行人检测框架">9.9.2 RCNN行人检测框架</h3>
<p>  <br>
来看下后面两种RCNN方法与Mask结合的示意图:</p>
<p><img src="figure_9.8_2.png" alt><br>
  <br>
图中灰色部分是原来的RCNN结合ResNet or FPN的网络，下面黑色部分为新添加的并联Mask层，这个图本身与上面的图也没有什么区别，旨在说明作者所提出的Mask RCNN方法的泛化适应能力：可以和多种RCNN框架结合，表现都不错。</p>
<h3 id="9-9-3-Mask-RCNN-技术要点">9.9.3 Mask-RCNN 技术要点</h3>
<p>  <br>
<strong>1.技术要点1 - 强化的基础网络</strong><br>
  <br>
通过ResNeXt-101+FPN用作特征提取网络，达到state-of-the-art的效果。<br>
  <br>
<strong>2.技术要点2 - ROIAlign</strong><br>
  <br>
采用ROIAlign替代RoiPooling（改进池化操作）。引入了一个插值过程，先通过双线性插值到14<em>14，再pooling到7</em>7，很大程度上解决了仅通过Pooling直接采样带来的Misalignment对齐问题。<br>
  <br>
PS： 虽然 Misalignment 在分类问题上影响并不大，但在 Pixel 级别的 Mask 上会存在较大误差。<br>
  <br>
后面我们把结果对比贴出来（Table2 c &amp; d），能够看到 ROIAlign 带来较大的改进，可以看到，Stride 越大改进越明显。<br>
  <br>
<strong>3.技术要点3 - Loss Function</strong><br>
  <br>
每个ROIAlign对应K * m^2维度的输出。K对应类别个数，即输出K个mask，m对应池化分辨率（7 * 7）。Loss函数定义：</p>
 $$
Lmask(Cls_k)=Sigmoid(Cls_k)
$$ 
<p>  </p>
 $Lmask(Cls_k) = Sigmoid (Cls_k)$ ，平均二值交叉熵 （average binary cross-entropy）Loss，通过逐像素的 Sigmoid 计算得到。  
<p>  <br>
Why K个mask？通过对每个 Class 对应一个Mask可以有效避免类间竞争（其他Class不贡献Loss）。</p>
<p><img src="figure_9.8_3.png" alt><br>
  <br>
通过结果对比来看（Table2 b），也就是作者所说的 Decouple 解耦，要比多分类的Softmax效果好很多。<br>
  <br>
另外，作者给出了很多实验分割效果，就不都列了，只贴一张和FCIS的对比图（FCIS出现了Overlap的问题）</p>
<p><img src="figure_9.8_4.png" alt></p>
<h2 id="9-10-CNN在基于弱监督学习的图像分割中的应用">9.10 CNN在基于弱监督学习的图像分割中的应用</h2>
<p>  <br>
答案来源：<a href="https://zhuanlan.zhihu.com/p/23811946">CNN在基于弱监督学习的图像分割中的应用</a></p>
<p>  <br>
最近基于深度学习的图像分割技术一般依赖于卷积神经网络CNN的训练，训练过程中需要非常大量的标记图像，即一般要求训练图像中都要有精确的分割结果。<br>
  <br>
对于图像分割而言，要得到大量的完整标记过的图像非常困难，比如在ImageNet数据集上，有1400万张图有类别标记，有50万张图给出了bounding box,但是只有4460张图像有像素级别的分割结果。对训练图像中的每个像素做标记非常耗时，特别是对医学图像而言，完成对一个三维的CT或者MRI图像中各组织的标记过程需要数小时。<br>
  <br>
如果学习算法能通过对一些初略标记过的数据集的学习就能完成好的分割结果，那么对训练数据的标记过程就很简单，这可以大大降低花在训练数据标记上的时间。这些初略标记可以是：<br>
  <br>
1、只给出一张图像里面包含哪些物体，<br>
  <br>
2、给出某个物体的边界框，<br>
  <br>
3、对图像中的物体区域做部分像素的标记，例如画一些线条、涂鸦等（scribbles)。</p>
<h3 id="9-10-1-Scribble标记">9.10.1 Scribble标记</h3>
<p>  <br>
论文地址：<a href="https://www.cv-foundation.org/openaccess/content_cvpr_2016/papers/Lin_ScribbleSup_Scribble-Supervised_Convolutional_CVPR_2016_paper.pdf">ScribbleSup: Scribble-Supervised Convolutional Networks for Semantic Segmentation (CVPR 2016)</a><br>
  <br>
香港中文大学的Di Lin提出了一个基于Scribble标记的弱监督学习方法。Scribble是一个很方便使用的标记方法，因此被用得比较广泛。如下图，只需要画五条线就能完成对一副图像的标记工作。</p>
<p><img src="figure_9.9_1.png" alt><br>
  <br>
ScribbleSup分为两步，第一步将像素的类别信息从scribbles传播到其他未标记的像素，自动完成所有的训练图像的标记工作； 第二步使用这些标记图像训练CNN。在第一步中，该方法先生成super-pxels, 然后基于graph cut的方法对所有的super-pixel进行标记。</p>
<p><img src="figure_9.9_2.png" alt></p>
<p>  <br>
Graph Cut的能量函数为：</p>
 $$
\sum_{i}\psi _i\left(y_i|X,S\right)+\sum_{i,j}\psi_{ij}\left(y_i,y_j,X\right)
$$ 
<p>  <br>
在这个graph中，每个super-pixel是graph中的一个节点，相接壤的super-pixel之间有一条连接的边。这个能量函数中的一元项包括两种情况，一个是来自于scribble的，一个是来自CNN对该super-pixel预测的概率。整个最优化过程实际上是求graph cut能量函数和CNN参数联合最优值的过程：</p>
 $$
\sum_{i}\psi _i^{scr}\left(y_i|X,S\right)+\sum _i-logP\left(y_i| X,\theta\right)+\sum_{i,j}\psi _{ij}\left(y_i,y_j|X\right)
$$ 
<p>  <br>
上式的最优化是通过交替求  $Y$  和  $\theta$  的最优值来实现的。文章中发现通过三次迭代就能得到比较好的结果。</p>
<p><img src="figure_9.9_3.png" alt></p>
<h3 id="9-10-2-图像级别标记">9.10.2 图像级别标记</h3>
<p>  <br>
论文地址：<a href="https://www.cv-foundation.org/openaccess/content_iccv_2015/papers/Pathak_Constrained_Convolutional_Neural_ICCV_2015_paper.pdf">Constrained Convolutional Neural Networks for Weakly Supervised Segmentation （ICCV 2015）</a><br>
  <br>
UC Berkeley的Deepak Pathak使用了一个具有图像级别标记的训练数据来做弱监督学习。训练数据中只给出图像中包含某种物体，但是没有其位置信息和所包含的像素信息。该文章的方法将image tags转化为对CNN输出的label分布的限制条件，因此称为 Constrained convolutional neural network (CCNN).</p>
<p><img src="figure_9.9_4.png" alt><br>
  </p>
<p>该方法把训练过程看作是有线性限制条件的最优化过程：</p>
 $$
\underset{\theta ,P}{minimize}\qquad D(P(X)||Q(X|\theta ))\\
subject\to\qquad A\overrightarrow{P} \geqslant \overrightarrow{b},\sum_{X}^{ }P(X)=1
$$ 
<p>  </p>
<p>其中的线性限制条件来自于训练数据上的标记，例如一幅图像中前景类别像素个数期望值的上界或者下界（物体大小）、某个类别的像素个数在某图像中为0，或者至少为1等。该目标函数可以转化为为一个loss function，然后通过SGD进行训练。</p>
<p><img src="figure_9.9_5.png" alt><br>
  <br>
实验中发现单纯使用Image tags作为限制条件得到的分割结果还比较差，在PASCAL VOC 2012 test数据集上得到的mIoU为35.6%，加上物体大小的限制条件后能达到45.1%，如果再使用bounding box做限制，可以达到54%。FCN-8s可以达到62.2%，可见弱监督学习要取得好的结果还是比较难。</p>
<h3 id="9-10-3-DeepLab-bounding-box-image-level-labels">9.10.3 DeepLab+bounding box+image-level labels**</h3>
<p>  <br>
论文地址：<a href="https://arxiv.org/pdf/1502.02734.pdf">Weakly-and Semi-Supervised Learning of a DCNN for Semantic Image Segmentation</a><br>
  <br>
Google的George Papandreou 和UCLA的Liang-Chieh Chen等在DeepLab的基础上进一步研究了使用bounding box和image-level labels作为标记的训练数据。使用了期望值最大化算法（EM）来估计未标记的像素的类别和CNN的参数。</p>
<p><img src="figure_9.9_6.png" alt><br>
  <br>
对于image-level标记的数据，我们可以观测到图像的像素值和图像级别的标记 ,但是不知道每个像素的标号,因此把 $y$ 当做隐变量。使用如下的概率图模式：</p>
 $$
P\left ( x,y,z;\theta \right ) = P\left ( x \right )\left (\prod_{m=1}^{M} P\left ( y_m|x;\theta \right )\right )P\left ( z|y \right )
$$ 
<p>  <br>
这篇论文是通过EM算法来学习模型的参数 $\theta$ ，具体推导过程可参考原论文。</p>
<p><img src="figure_9.9_7.png" alt><br>
  <br>
对于给出bounding box标记的训练图像，该方法先使用CRF对该训练图像做自动分割，然后在分割的基础上做全监督学习。通过实验发现，单纯使用图像级别的标记得到的分割效果较差，但是使用bounding box的训练数据可以得到较好的结果，在VOC2012 test数据集上得到mIoU 62.2%。另外如果使用少量的全标记图像和大量的弱标记图像进行结合，可以得到与全监督学习(70.3%)接近的分割结果(69.0%)。</p>
<h3 id="9-10-4-统一的框架">9.10.4 统一的框架</h3>
<p>  <br>
论文地址：<a href="https://www.cv-foundation.org/openaccess/content_cvpr_2015/papers/Xu_Learning_to_Segment_2015_CVPR_paper.pdf">Learning to Segment Under Various Forms of Weak Supervision (CVPR 2015)</a></p>
<p>  <br>
Wisconsin-Madison大学的Jia Xu提出了一个统一的框架来处理各种不同类型的弱标记：图像级别的标记、bounding box和部分像素标记如scribbles。该方法把所有的训练图像分成共计 $n$ 个super-pixel，对每个super-pixel提取一个 $d$ 维特征向量。因为不知道每个super-pixel所属的类别，相当于无监督学习，因此该方法对所有的super-pixel做聚类，使用的是最大间隔聚类方法(max-margin clustering, MMC),该过程的最优化目标函数是：</p>
 $$
\underset{W,H}{min} \qquad  \frac{1}{2}tr\left ( W^TW \right ) + \lambda\sum_{p=1}^{n}\sum_{c=1}^{C}\xi \left ( w_c;x_p;h_p^c \right)
$$ 
<p>  <br>
在这个目标函数的基础上，根据不同的弱标记方式，可以给出不同的限制条件，因此该方法就是在相应的限制条件下求最大间隔聚类。</p>
<p><img src="figure_9.9_8.png" alt></p>
<p>  <br>
该方法在Siftflow数据集上得到了比较好的结果，比state-of-the-art的结果提高了10%以上。</p>
<p>  <br>
小结：在弱标记的数据集上训练图像分割算法可以减少对大量全标记数据的依赖，在大多数应用中会更加贴合实际情况。弱标记可以是图像级别的标记、边框和部分像素的标记等。训练的方法一般看做是限制条件下的最优化方法。另外EM算法可以用于CNN参数和像素类别的联合求优。</p>
<h3 id="9-10-5-弱监督分割最新进展（贡献者：明奇-北京理工大学）">9.10.5 弱监督分割最新进展（贡献者：明奇-北京理工大学）</h3>
<ul>
<li><strong>bbox监督</strong></li>
</ul>
<ol>
<li>
<p>Learning to Segment via Cut-and-Paste（ECCV 2018）</p>
<p>利用GAN对抗学习的思想，在cut-paste思想指导下利用bbox弱监督进行实例分割。<br>
<img src="9.10.5-1.png" alt><br>
采用对抗学习的思想，网络主体分为两大部分：mask生成器和合成图像判别器。具体过程为：（1）在图像上截取gt，经过特征提取后预测一个bbox内gt的mask；（2）在原图上随机cut一个背景图像，将bbox内按照生成的mask提取出物体分割结果，然后paste到原图裁剪的背景上去；（3）合成的图像经过判别器进行真假判断。<br>
通过生成器生成更好mask来使得判别器更难判别，在对抗学习中提升两者的性能，逐渐获得更好的结果 .</p>
</li>
<li>
<p>Simple Does It: Weakly Supervised Instance and Semantic Segmentation（CVPR2017）<br>
本文做的是bbox弱监督语义/实例分割任务，能达到全监督分割效果(DeepLabv1)的95%。主要工作为：讨论了使用弱监督语义标签进行迭代训练的方法，以及其限制和不足之处；证明了通过类似GrabCut的算法能通过bbox生成分割训练标签方法的可行性，可以避免像上面的迭代方法重新调整网络训练策略；在VOC数据集上逼近监督学习的分割任务效果。<br>
作者的启发是：将bbox level的mask送入网络训练后得到分割mask的比输入的bbox mask要好（这是很好的insight）。因此启发的操作是：将bbox level标注作为初始mask输入优化，每次得到的标注作为gt进行下一轮的迭代，从而不断获得更好的效果。效果图如下：<br>
<img src="9.10.5-3.png" alt><br>
在此基础上，再加上优化的GrabCut+算法，以及部分区域的筛选，以及BSDS500的边界预测信息整合到一起，能够达到很好的弱监督迭代分割效果。</p>
</li>
</ol>
<ul>
<li><strong>分类监督</strong></li>
</ul>
<ol>
<li>
<p>Weakly Supervised Learning of Instance Segmentation with Inter-pixel Relations(CVPR2019)<br>
使用分类标注作为弱监督信息，在CAM提取到特征的基础上，进一步设计IRNet学习额外的特征约束，从而到达更好的弱监督实例分割效果。为了解决CAM应用到实例分割的上述局限，设计IRNet。其组成为两部分：（1）不分类别的实例响应图  （2）pairwise semantic affinitie。其中通过不分类别的实例响应图和CAM结合，约束后得到instance-wise CAMS；另一个分支预先预测物体的边界然后得到pairwise semantic affinitie（关于这个的论文参考Related Work的对应部分，有相应的方法，暂时不深究）进行融合和处理得到最终的分割。整体流程如下：<br>
<img src="9.10.5-2.png" alt></p>
</li>
<li>
<p>Weakly Supervised Instance Segmentation using Class Peak Response（CVPR2018）<br>
本文使用图像级的类别标注监督信息，通过探索类别响应峰值使分类网络能够很好地提取实例分割mask。本工作是使用图像级标注进行弱监督实例分割的首个工作。<br>
在分类监督信息之下，CNN网络会产生一个类别响应图，每个位置是类别置信度分数。其局部极大值往往具有实例很强视觉语义线索。首先将类别峰值响应图的信息进行整合，然后反向传播将其映射到物体实例信息量较大的区域如边界。上述从类别极值响应图产生的映射图称为Peak Response Maps (PRMs)，该图提供了实例物体的详细表征，可以很好地用作分割监督信息。<br>
具体流程如图：<br>
<img src="9.10.5-4.png" alt><br>
首先将图片经过正常的分类网络训练，其中在类别预测响应图上提取出局部响应极值点，进行增强卷积后预测出PRM。然后结合多种信息进行推断生成mask。</p>
</li>
<li>
<p>Weakly Supervised Semantic Segmentation Using Superpixel Pooling Network（AAAI 2017）<br>
本文介绍通过类别标注的标签实现弱监督语义分割的方法。该方法在语义分割mask生成和使用生成mask学习分割生成网络之间反复交替。要实现这种交替迭代学习，关键点就是如何利用类别标注得到较准确的初始分割。为了解决这一问题,提出了Superpixel Pooling Network (SPN)，将输入图像的超像素分割结果作为低阶结构的表征，辅助语义分割的推断。<br>
<img src="9.10.5-5.png" alt><br>
首先是SPN生成初始mask，然后用另一个网络DecoupledNet来学习每个像素的mask标注。其中，该分割网络将语义分割任务解耦为分类和分割两个子任务，并且能够从类别标注中学习形状先验知识用于辅助分割。</p>
</li>
</ol>
<h2 id="9-11-DenseNet（贡献者：黄钦建－华南理工大学）">9.11 DenseNet（贡献者：黄钦建－华南理工大学）</h2>
<p>  <br>
这篇论文是CVPR2017年的最佳论文。</p>
<p>  <br>
卷积神经网络结构的设计主要朝着两个方向发展，一个是更宽的网络（代表：GoogleNet、VGG），一个是更深的网络（代表：ResNet）。但是随着层数的加深会出现一个问题——梯度消失，这将会导致网络停止训练。到目前为止解决这个问题的思路基本都是在前后层之间加一个identity connections(short path)。</p>
<p><img src="9-10-3.png" alt></p>
<p>  <br>
由上图中可知Resnet是做值的相加（也就是add操作），通道数是不变的。而DenseNet是做通道的合并（也就是Concatenation操作），就像Inception那样。从这两个公式就可以看出这两个网络的本质不同。此外DensetNet的前面一层输出也是后面所有层的输入，这也不同于ResNet残差网络。</p>
<p><img src="9-10-1.png" alt></p>
<p>  <br>
DenseNet的Block结构如上图所示。</p>
<p>  <br>
1*1卷积核的目的：减少输入的特征图数量，这样既能降维减少计算量，又能融合各个通道的特征。我们将使用BottleNeck Layers的DenseNet表示为DenseNet-B。(在论文的实验里，将1×1×n小卷积里的n设置为4k，k为每个H产生的特征图数量)</p>
<p><img src="9-10-2.png" alt></p>
<p>  <br>
上图是DenseNet网络的整体网络结构示意图。其中1*1卷积核的目的是进一步压缩参数，并且在Transition Layer层有个参数Reduction（范围是0到1），表示将这些输出缩小到原来的多少倍，默认是0.5，这样传给下一个Dense Block的时候channel数量就会减少一半。当Reduction的值小于1的时候，我们就把带有这种层的网络称为DenseNet-C。</p>
<p>  <br>
DenseNet网络的优点包括：</p>
<ul>
<li>减轻了梯度消失</li>
<li>加强了feature的传递</li>
<li>更有效地利用了feature</li>
<li>一定程度上较少了参数数量</li>
<li>一定程度上减轻了过拟合</li>
</ul>
<h2 id="9-12-图像分割的常用数据集">9.12 图像分割的常用数据集</h2>
<h3 id="9-12-1-PASCAL-VOC">9.12.1 PASCAL VOC</h3>
<p>VOC 数据集分为20类，包括背景为21类，分别如下：</p>
<ul>
<li>Person: person</li>
<li>Animal: bird, cat, cow, dog, horse, sheep</li>
<li>Vehicle: aeroplane, bicycle, boat, bus, car, motorbike, train</li>
<li>Indoor: bottle, chair, dining table, potted plant, sofa, tv/monitor</li>
</ul>
<p>VOC 数据集中用于分割比赛的图片实例如下，包含原图以及图像分类分割和图像物体分割两种图（PNG格式）。图像分类分割是在20种物体中，ground-turth图片上每个物体的轮廓填充都有一个特定的颜色，一共20种颜色。</p>
<p><img src="VOC-01.png" alt></p>
<h3 id="9-12-2-MS-COCO">9.12.2 MS COCO</h3>
<p>MS COCO 是最大图像分割数据集，提供的类别有 80 类，有超过 33 万张图片，其中 20 万张有标注，整个数据集中个体的数目超过 150 万个。MS COCO是目前难度最大，挑战最高的图像分割数据集。</p>
<p><img src="COCO-01.png" alt></p>
<h3 id="9-12-3-Cityscapes">9.12.3 Cityscapes</h3>
<p>Cityscapes 是驾驶领域进行效果和性能测试的图像分割数据集，它包含了5000张精细标注的图像和20000张粗略标注的图像，这些图像包含50个城市的不同场景、不同背景、不同街景，以及30类涵盖地面、建筑、交通标志、自然、天空、人和车辆等的物体标注。Cityscapes评测集有两项任务：像素级（Pixel-level）图像场景分割（以下简称语义分割）与实例级（Instance-level）图像场景分割（以下简称实例分割）。</p>
<p><img src="Cityscapes-01.png" alt></p>
<h2 id="9-13-全景分割（贡献者：北京理工大学–明奇）">9.13 全景分割（贡献者：北京理工大学–明奇）</h2>
<p>全景分割的开山之作：何恺明的<em>Panoptic Segmentation</em></p>
<ol>
<li><strong>Introduction</strong></li>
</ol>
<p>  语义分割通过带孔全卷积网络，根据不同的stuff进行划分；实例分割则是在目标检测的基础上基于检测框进行物体的分割。缺少一种框架可以将两者进行融合实现既能分割背景又能分割实例，而这在自动驾驶和AR技术中大有作为。由此提出的全景分割任务能将两者进行结合。</p>
<p>  全景分割的思路很直观：为图像的每个像素分配语义label和类内实例id，前者用于区分语义信息，后者用于分割实例（因此stuff不具有实例id）。提出全景分割时，只是启发式地将语意分割和实例分割两种任务的输出进行后处理的融合（如NMS），并以此建立PS任务的baseline。为了评价全景分割的质量，提出panoptic quality (PQ) 标准，将背景和物体的评价纳入一个完整的框架下。示意图如下：<br>
<img src="9.13-1.png" alt></p>
<ol start="2">
<li><strong>Panoptic Segmentation</strong></li>
</ol>
<ul>
<li>
<p><strong>Task format</strong><br>
全景分割的标注方法：<br>
像素级的标注，标出类别label和类内实例id。如果某像素的这两个信息都能匹配，则可以将该像素匹配到某个类别和实例中去；类外的像素可以分配空标签，即并不是所有的像素都要有语义类别。</p>
</li>
<li>
<p><strong>Stuff and thing labels</strong><br>
对于stuff和thing（背景填充和物体实例）的标签，交集是空集，并集是所有可能的label空间。这两者是互相独立不相关的（很好理解，像素属于那个类和它属于哪个物体不具有相关性）。</p>
</li>
<li>
<p><strong>Relationship</strong><br>
都是像素级的label，需要为每个像素分配对应的标签。但是实例分割基于region的，允许重叠的segmentation，而全景分割和语义分割一样是像素级的label，不允许重叠标签的出现。</p>
</li>
<li>
<p><strong>Confidence scores</strong><br>
这一点上更像语义分割而不是实例分割，对于PS不需要置信分数评价分割质量。提到这个，作者认为语义分割和全景分割可以直接利用人工标注的label进行对比从而评价当前mask的质量；而实例分割在选择mask时评价的是分类置信度，这个并没有人工标注进行参考，因此难以把握。</p>
</li>
</ul>
<ol start="3">
<li><strong>Panoptic Segmentation Metric</strong><br>
  用于衡量全景分割效果的指标应具有：完备性；可解释性；简洁性。由是提出了PQ指标，可分为两步：分割匹配、在匹配上进行计算PQ。</li>
</ol>
<p>3.1  <strong>Segment Matching</strong><br>
  定义match：预测的segmentation和gt的iou大于0.5，说明两者can match。再结合全景分割的不可重叠性，不难得到：最多只有一个预测的segmentation可以match gt。</p>
<p>3.2  <strong>PQ Computation</strong><br>
  PQ的计算类似mAP，也是类内求取，然后求类间的平均值，以便不敏感类别不平衡。对于每一类，可以根据gt与预测的segmentation分为三类（下图描述）：<br>
<img src="9.13-2.png" alt></p>
<p>TP: 预测为正，实际为正，描述match较好的<br>
FP: 预测为正，实际为负，描述match错的<br>
FN: 预测为负，实际为正，描述没match出来的gt<br>
  通过上述三类可以计算得到PQ值公式：<br>
<img src="9.13-3.png" alt></p>
<p>式中出去FP与FN后，剩下的式子描述的是match的segmentation的平均IoU，加上FP与FN是为了惩罚match失败的分割实例。<br>
有意思的是，对上述式子进行简单的恒等变化：<br>
<img src="9.13-4.png" alt></p>
<p>第一项评价的是match分割的质量，第二项类似于F1得分。因此可以PQ分解为：</p>
 $$PQ=SQ*RQ$$ 
<ul>
<li>
<p><strong>Void labels</strong><br>
gt中可能出现两种像素标注为空的情况：超出类别的像素和模糊不清的像素（难以分类）。在评估结果时，这些空的标签不予以评估。具体而言：<br>
（1）在matching部分，预测出为void的像素会被移出prediction并不参与IoU计算；<br>
（2）matching后，unmatched prediction按照一般情况会计算FP FN，但是对于空标签情况，如果该prediction含有的void像素块超过一定匹配阈值就会被移除，并不算作FP计算得分。</p>
</li>
<li>
<p><strong>Group labels</strong><br>
有时区分相同语义类别的实例个体标注比较困难，因此有提出组标签的标注方法。但对于PQ计算而言：<br>
（1）matching部分不使用组标签，而是严格区分实例<br>
（2）matching后，对于包含一部分相同类别像素点的unmatched predicted segments，这一部分将被去除并不视作false positives</p>
</li>
</ul>
<p>3.3  <strong>Comparison to Existing Metrics</strong></p>
<ul>
<li>
<p><strong>Semantic segmentation metrics</strong><br>
衡量语义分割的标准有像素级精度，平均精度，IoU。但是其只专注于像素级的划分，不能反映物体实例级别的分割性能。</p>
</li>
<li>
<p><strong>Instance segmentation metrics</strong><br>
度量为AP，主要是引入了置信度分数confidence score对检测目标进行打分。（两者不是完全的隔绝，实例分割也有用IoU监督的，而confidence score是否能够反映mask的真实质量也有存疑过，这个标准也不是固定的）</p>
</li>
<li>
<p><strong>Panoptic quality</strong><br>
PQ的度量可以分解成SQ和RQ，SQ反映了语义分割的像素级IoU性能，RQ专注于检测识别的效果，因此将两者统一到一个框架下。</p>
</li>
</ul>
<p>分割效果：<br>
<img src="9.13-5.png" alt></p>
<br>
<br>
<hr>
TODO
<ul>
<li>[ ] 图像分割数据集标注工具</li>
<li>[ ] 图像分割评价标准</li>
<li>[x] 全景分割</li>
<li>[ ] UNet++</li>
</ul>
]]></content>
      <categories>
        <category>算法面试</category>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>刷八股</tag>
      </tags>
  </entry>
  <entry>
    <title>数组与数学</title>
    <url>/2024/03/19/leetcode/array_and_math/</url>
    <content><![CDATA[<h1>螺旋矩阵系列</h1>
<h2 id="螺旋矩阵">螺旋矩阵</h2>
<p>题号为54，位于<a href="https://leetcode.cn/problems/spiral-matrix/description/">https://leetcode.cn/problems/spiral-matrix/description/</a> 题解如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">spiralOrder</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(matrix)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> matrix[<span class="number">0</span>]</span><br><span class="line">        directions = [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, -<span class="number">1</span>), (-<span class="number">1</span>, <span class="number">0</span>)]</span><br><span class="line">        row, col, direction_index = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        res = []</span><br><span class="line">        m = <span class="built_in">len</span>(matrix)</span><br><span class="line">        n = <span class="built_in">len</span>(matrix[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m * n):</span><br><span class="line">            res.append(matrix[row][col])</span><br><span class="line">            matrix[row][col] = -<span class="number">999999999</span></span><br><span class="line">            next_row = row + directions[direction_index % <span class="number">4</span>][<span class="number">0</span>]</span><br><span class="line">            next_col = col + directions[direction_index % <span class="number">4</span>][<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> next_row &lt; <span class="number">0</span> <span class="keyword">or</span> next_row &gt;= m <span class="keyword">or</span> next_col &lt; <span class="number">0</span> <span class="keyword">or</span> next_col &gt;= n <span class="keyword">or</span> matrix[next_row][next_col] == -<span class="number">999999999</span>:</span><br><span class="line">                direction_index = direction_index + <span class="number">1</span></span><br><span class="line">                next_row = row + directions[direction_index % <span class="number">4</span>][<span class="number">0</span>]</span><br><span class="line">                next_col = col + directions[direction_index % <span class="number">4</span>][<span class="number">1</span>]</span><br><span class="line">            row, col = next_row, next_col</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>上下两道题用的是同样的思路，这样比较好统一</p>
<h2 id="螺旋矩阵II">螺旋矩阵II</h2>
<p>题号为59，位于 <a href="https://leetcode.cn/problems/spiral-matrix-ii/description/">https://leetcode.cn/problems/spiral-matrix-ii/description/</a>  题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateMatrix</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        directions = [(<span class="number">0</span>,<span class="number">1</span>),(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,-<span class="number">1</span>),(-<span class="number">1</span>,<span class="number">0</span>)]</span><br><span class="line">        matrix = [[-<span class="number">1</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        row, col, direc_index = <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n*n):</span><br><span class="line">            matrix[row][col] = i + <span class="number">1</span></span><br><span class="line">            next_row = row + directions[direc_index%<span class="number">4</span>][<span class="number">0</span>]</span><br><span class="line">            next_col = row + directions[direc_index%<span class="number">4</span>][<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> next_row &lt; <span class="number">0</span> <span class="keyword">or</span> next_row &gt;= n <span class="keyword">or</span> next_col &lt; <span class="number">0</span> <span class="keyword">or</span> next_row &gt;= n <span class="keyword">or</span> matrix[next_row][next_col] &gt; -<span class="number">1</span>:</span><br><span class="line">                direc_index = direc_index + <span class="number">1</span></span><br><span class="line">                next_row = row + directions[direc_index%<span class="number">4</span>][<span class="number">0</span>]</span><br><span class="line">                next_col = row + directions[direc_index%<span class="number">4</span>][<span class="number">1</span>]</span><br><span class="line">            row, col = next_row, next_col</span><br><span class="line">        <span class="keyword">return</span> matrix</span><br></pre></td></tr></table></figure>
<p>注意具体的思路是先便利，然后换方向</p>
<h2 id="螺旋矩阵III">螺旋矩阵III</h2>
<p>题号为885，位于 <a href="https://leetcode.cn/problems/spiral-matrix-iii/description/">https://leetcode.cn/problems/spiral-matrix-iii/description/</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">spiralMatrixIII</span>(<span class="params">self, rows: <span class="built_in">int</span>, cols: <span class="built_in">int</span>, rStart: <span class="built_in">int</span>, cStart: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]: </span><br><span class="line">        visited_flag = [[<span class="literal">False</span>] * cols <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(rows)]</span><br><span class="line">        directions = [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, -<span class="number">1</span>), (-<span class="number">1</span>, <span class="number">0</span>)]</span><br><span class="line">        direction_index = -<span class="number">1</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        init_lens = <span class="number">0</span></span><br><span class="line">        res = []</span><br><span class="line">        res.append([rStart, cStart])</span><br><span class="line">        <span class="keyword">while</span> cnt + <span class="number">1</span> &lt; rows * cols:</span><br><span class="line">            init_lens = init_lens + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            direction_index = direction_index + <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j1 <span class="keyword">in</span> <span class="built_in">range</span>(init_lens):</span><br><span class="line">                next_r = rStart + directions[direction_index % <span class="number">4</span>][<span class="number">0</span>]</span><br><span class="line">                next_c = cStart + directions[direction_index % <span class="number">4</span>][<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> next_r &lt; <span class="number">0</span> <span class="keyword">or</span> next_r &gt;= rows <span class="keyword">or</span> next_c &lt; <span class="number">0</span> <span class="keyword">or</span> next_c &gt;= cols <span class="keyword">or</span> visited_flag[next_r][next_c]:</span><br><span class="line">                    rStart = next_r</span><br><span class="line">                    cStart = next_c</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res.append([next_r, next_c])</span><br><span class="line">                    rStart = next_r</span><br><span class="line">                    cStart = next_c</span><br><span class="line">                    visited_flag[next_r][next_c] = <span class="literal">True</span></span><br><span class="line">                    cnt = cnt + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            direction_index = direction_index + <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j2 <span class="keyword">in</span> <span class="built_in">range</span>(init_lens):</span><br><span class="line">                next_r = rStart + directions[direction_index % <span class="number">4</span>][<span class="number">0</span>]</span><br><span class="line">                next_c = cStart + directions[direction_index % <span class="number">4</span>][<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> next_r &lt; <span class="number">0</span> <span class="keyword">or</span> next_r &gt;= rows <span class="keyword">or</span> next_c &lt; <span class="number">0</span> <span class="keyword">or</span> next_c &gt;= cols <span class="keyword">or</span> visited_flag[next_r][next_c]:</span><br><span class="line">                    rStart = next_r</span><br><span class="line">                    cStart = next_c</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res.append([next_r, next_c])</span><br><span class="line">                    rStart = next_r</span><br><span class="line">                    cStart = next_c</span><br><span class="line">                    visited_flag[next_r][next_c] = <span class="literal">True</span></span><br><span class="line">                    cnt = cnt + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>主要思路就是分析题目，其实每个固定的长度比如走1格子，其实是分为两个角度来走的，那么整体上就是1步往右，1步往下，2步往左，2步往上。依次这样来再结合判断条件。</p>
<h2 id="螺旋矩阵-IV">螺旋矩阵 IV</h2>
<p>和,2一样，题目2326，位于 <a href="https://leetcode.cn/problems/spiral-matrix-iv/">https://leetcode.cn/problems/spiral-matrix-iv/</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">spiralMatrix</span>(<span class="params">self, m: <span class="built_in">int</span>, n: <span class="built_in">int</span>, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            res.append(head.val)</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        matrix = [[-<span class="number">1</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        visited = [[<span class="literal">False</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        x, y, dirrection_index = <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        directions = [(<span class="number">0</span>,<span class="number">1</span>),(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,-<span class="number">1</span>),(-<span class="number">1</span>,<span class="number">0</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m*n):</span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(res):</span><br><span class="line">                matrix[x][y] = res[i]</span><br><span class="line">            visited[x][y] = <span class="literal">True</span></span><br><span class="line">            next_x = x + directions[dirrection_index%<span class="number">4</span>][<span class="number">0</span>]</span><br><span class="line">            next_y = y + directions[dirrection_index%<span class="number">4</span>][<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> next_x&lt;<span class="number">0</span> <span class="keyword">or</span> next_x&gt;=m <span class="keyword">or</span> next_y&lt;<span class="number">0</span> <span class="keyword">or</span> next_y&gt;=n <span class="keyword">or</span> visited[next_x][next_y]:</span><br><span class="line">                dirrection_index = dirrection_index + <span class="number">1</span></span><br><span class="line">                next_x = x + directions[dirrection_index%<span class="number">4</span>][<span class="number">0</span>]</span><br><span class="line">                next_y = y + directions[dirrection_index%<span class="number">4</span>][<span class="number">1</span>]</span><br><span class="line">            x, y = next_x, next_y</span><br><span class="line">        <span class="keyword">return</span> matrix</span><br></pre></td></tr></table></figure>
<h1>数组类</h1>
<h2 id="摆动排序II-324">摆动排序II[324]</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自己解法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wiggleSort</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        mid = (<span class="built_in">len</span>(nums) + <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        left = nums[<span class="number">0</span>:mid][::-<span class="number">1</span>]</span><br><span class="line">        right = nums[mid:][::-<span class="number">1</span>]</span><br><span class="line">        all_combine = []</span><br><span class="line">        n1 = mid</span><br><span class="line">        n2 = <span class="built_in">len</span>(nums) - n1</span><br><span class="line">        index1 = <span class="number">0</span></span><br><span class="line">        index2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> index1 &lt; n1 <span class="keyword">and</span> index2 &lt; n2:</span><br><span class="line">            all_combine.append(left[index1])</span><br><span class="line">            all_combine.append(right[index2])</span><br><span class="line">            index1 += <span class="number">1</span></span><br><span class="line">            index2 += <span class="number">1</span></span><br><span class="line">        all_combine.extend(left[index1:])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            nums[i] = all_combine[i]</span><br><span class="line"><span class="comment"># 简单解法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wiggleSort</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        temp = [<span class="number">0</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">        j = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums), <span class="number">2</span>):</span><br><span class="line">            temp[i] = nums[j]</span><br><span class="line">            j = j - <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(nums), <span class="number">2</span>):</span><br><span class="line">            temp[i] = nums[j]</span><br><span class="line">            j = j - <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            nums[i] = temp[i]</span><br></pre></td></tr></table></figure>
<p>奇数索引上规律是从大到小，偶数索引上规律也是从大到小，再次发现先对奇数索引进行填充，再对偶数索引填充</p>
<h2 id="数学类">数学类</h2>
<h3 id="幂类">幂类</h3>
<h4 id="获取2进制">获取2进制</h4>
<p>如何获取一个数的2进制表示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="number">10</span></span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">    n = n + <span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">32</span>)</span><br><span class="line"><span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">    n, m = <span class="built_in">divmod</span>(n, <span class="number">2</span>)</span><br><span class="line">    res.append(m)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;</span>.join([<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> res[::-<span class="number">1</span>]))</span><br></pre></td></tr></table></figure>
<p>小数的二进制结果如下：<br>
题目在这里 <a href="https://leetcode-cn.com/problems/bianry-number-to-string-lcci/">https://leetcode-cn.com/problems/bianry-number-to-string-lcci/</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">printBin</span>(<span class="params">self, num: <span class="built_in">float</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">50</span>):</span><br><span class="line">            <span class="keyword">if</span> num - <span class="number">1</span>/(<span class="number">2</span>**i) &gt;= <span class="number">0</span>:</span><br><span class="line">                num = num - <span class="number">1</span>/(<span class="number">2</span>**i)</span><br><span class="line">                res.append(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(<span class="number">0</span>)</span><br><span class="line">        index2 = <span class="built_in">len</span>(res) - res[::-<span class="number">1</span>].index(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> index2&gt;=<span class="number">32</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;ERROR&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;0.&#x27;</span> + <span class="string">&quot;&quot;</span>.join([<span class="built_in">str</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> res[:index2]])</span><br></pre></td></tr></table></figure>
<h4 id="获取16进制">获取16进制</h4>
<p>题目见 <a href="https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/">https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/</a> 题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">toHex</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        num_lst = <span class="built_in">list</span>(<span class="string">&quot;0123456789abcdef&quot;</span>)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> num &lt; <span class="number">0</span>:</span><br><span class="line">            num = num + <span class="number">2</span>**<span class="number">32</span></span><br><span class="line">        <span class="keyword">while</span> num &gt; <span class="number">0</span>:</span><br><span class="line">            num, n = <span class="built_in">divmod</span>(num, <span class="number">16</span>)</span><br><span class="line">            res.append(n)</span><br><span class="line">        res2 = [num_lst[i] <span class="keyword">for</span> i <span class="keyword">in</span> res[::-<span class="number">1</span>]]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(res2)</span><br></pre></td></tr></table></figure>
<h4 id="计算pow">计算pow</h4>
<p>这道题有两个方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># v1 使用递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">myPow</span>(<span class="params">self, x: <span class="built_in">float</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">quickMul</span>(<span class="params">N</span>):</span><br><span class="line">            <span class="keyword">if</span> N == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1.0</span></span><br><span class="line">            y = quickMul(N // <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> y * y <span class="keyword">if</span> N % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> y * y * x</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> quickMul(n) <span class="keyword">if</span> n &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">1.0</span> / quickMul(-n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># v2 使用快读幂指数算法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">myPow</span>(<span class="params">self, x: <span class="built_in">float</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0.0</span>: <span class="keyword">return</span> <span class="number">0.0</span></span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>: x, n = <span class="number">1</span> / x, -n</span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            <span class="keyword">if</span> n &amp; <span class="number">1</span>: res *= x</span><br><span class="line">            x *= x</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h4 id="数值的整数次方">数值的整数次方</h4>
<p>题目见 <a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/</a> 题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">myPow</span>(<span class="params">self, x: <span class="built_in">float</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            n = -n</span><br><span class="line">            flag = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            <span class="keyword">if</span> n&amp;<span class="number">1</span>:</span><br><span class="line">               res *= x</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span></span><br><span class="line">            x = x * x</span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> <span class="keyword">not</span> flag <span class="keyword">else</span> <span class="number">1</span>/res</span><br></pre></td></tr></table></figure>
<h4 id="计算sqrt">计算sqrt</h4>
<p>题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过log</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mySqrt</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ans = <span class="built_in">int</span>(math.exp(<span class="number">0.5</span> * math.log(x)))</span><br><span class="line">        <span class="keyword">return</span> ans + <span class="number">1</span> <span class="keyword">if</span> (ans + <span class="number">1</span>) ** <span class="number">2</span> &lt;= x <span class="keyword">else</span> ans</span><br><span class="line"><span class="comment"># 通过二分</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mySqrt</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        l, r, ans = <span class="number">0</span>, x, -<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            mid = (l + r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mid * mid &lt;= x:</span><br><span class="line">                ans = mid</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"><span class="comment"># 通过牛顿</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mySqrt</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        C, x0 = <span class="built_in">float</span>(x), <span class="built_in">float</span>(x)</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            xi = <span class="number">0.5</span> * (x0 + C / x0)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">abs</span>(x0 - xi) &lt; <span class="number">1e-7</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            x0 = xi</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(x0)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="计算是否是2的幂">计算是否是2的幂</h4>
<p>题目见 <a href="https://leetcode-cn.com/problems/power-of-two/">https://leetcode-cn.com/problems/power-of-two/</a>  题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 普通方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPowerOfTwo</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        num = n</span><br><span class="line">        <span class="keyword">while</span> num!=<span class="number">1</span>:</span><br><span class="line">            ys = num%<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> ys==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            num = num//<span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="comment"># 技巧</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPowerOfTwo</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> <span class="keyword">and</span> (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span></span><br><span class="line"><span class="comment"># 框架</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPowerOfTwo</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">while</span> n <span class="keyword">and</span> n % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            n //= <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h4 id="重新排序得到-2-的幂">重新排序得到 2 的幂</h4>
<p>题目见 <a href="https://leetcode-cn.com/problems/reordered-power-of-2/">https://leetcode-cn.com/problems/reordered-power-of-2/</a> 题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># TL了</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reorderedPowerOf2</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">back</span>(<span class="params">state, s</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(s)==<span class="number">0</span>:</span><br><span class="line">                res.append(state[:])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">                    state.append(s[i])</span><br><span class="line">                    back(state, s[<span class="number">0</span>:i]+s[i+<span class="number">1</span>:])</span><br><span class="line">                    state.pop()</span><br><span class="line">        back([],<span class="built_in">str</span>(n))</span><br><span class="line"></span><br><span class="line">        res2 = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">int</span>(i[-<span class="number">1</span>])%<span class="number">2</span>:</span><br><span class="line">                res2.append(<span class="built_in">int</span>(<span class="string">&quot;&quot;</span>.join(i)))</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">isPow</span>(<span class="params">n</span>):</span><br><span class="line">            <span class="keyword">return</span> n &gt; <span class="number">0</span> <span class="keyword">and</span> (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> res2:</span><br><span class="line">            <span class="keyword">if</span> isPow(i):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先算好每个结果，然后去查一下是不是在其中</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reorderedPowerOf2</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">targ: <span class="built_in">int</span>, num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            a = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">            b = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">            <span class="keyword">while</span> targ:</span><br><span class="line">                x = targ % <span class="number">10</span> </span><br><span class="line">                a[x] += <span class="number">1</span></span><br><span class="line">                targ //= <span class="number">10</span></span><br><span class="line">            <span class="keyword">while</span> num:</span><br><span class="line">                x = num % <span class="number">10</span></span><br><span class="line">                b[x] += <span class="number">1</span></span><br><span class="line">                num //= <span class="number">10</span></span><br><span class="line">            <span class="keyword">return</span> a == b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">31</span>):</span><br><span class="line">            targ = <span class="number">2</span> ** i</span><br><span class="line">            <span class="keyword">if</span> check(targ, n) == <span class="literal">True</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h4 id="计算是否是3的幂">计算是否是3的幂</h4>
<p>题目见 <a href="https://leetcode-cn.com/problems/power-of-three/">https://leetcode-cn.com/problems/power-of-three/</a> 题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPowerOfThree</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">while</span> n <span class="keyword">and</span> n % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">            n //= <span class="number">3</span></span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h4 id="计算是否是4的幂">计算是否是4的幂</h4>
<p>题目见 <a href="https://leetcode-cn.com/problems/power-of-four/%EF%BC%8C%E9%A2%98%E8%A7%A3%E5%A6%82%E4%B8%8B%EF%BC%9A">https://leetcode-cn.com/problems/power-of-four/，题解如下：</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPowerOfFour</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">while</span> n <span class="keyword">and</span> n % <span class="number">4</span> == <span class="number">0</span>:</span><br><span class="line">            n //= <span class="number">4</span></span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h4 id="幂集">幂集</h4>
<p>题目在 <a href="https://leetcode-cn.com/problems/power-set-lcci/">https://leetcode-cn.com/problems/power-set-lcci/</a> 题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 错误</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsets</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">back</span>(<span class="params">state,s</span>):</span><br><span class="line">            res.append(state[:])</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">                state.append(s[i])</span><br><span class="line">                back(state, s[i:])</span><br><span class="line">                state.pop()</span><br><span class="line">        back([],nums)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"><span class="comment"># 正确</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsets</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">back</span>(<span class="params">state,s</span>):</span><br><span class="line">            res.append(state[:])</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">                state.append(s[i])</span><br><span class="line">                back(state, s[i+<span class="number">1</span>:])</span><br><span class="line">                state.pop()</span><br><span class="line">        back([],nums)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h4 id="判断一个数字是否可以表示成三的幂的和">判断一个数字是否可以表示成三的幂的和</h4>
<p>题目见 <a href="https://leetcode-cn.com/problems/check-if-number-is-a-sum-of-powers-of-three/">https://leetcode-cn.com/problems/check-if-number-is-a-sum-of-powers-of-three/</a>  题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">checkPowersOfThree</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">31</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> n - <span class="number">3</span>**i &gt;= <span class="number">0</span>:</span><br><span class="line">                n = n - <span class="number">3</span>**i</span><br><span class="line">                <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h4 id="大餐计数">大餐计数</h4>
<p>题目见 <a href="https://leetcode-cn.com/problems/count-good-meals/">https://leetcode-cn.com/problems/count-good-meals/</a> 题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 时间不够</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countPairs</span>(<span class="params">self, deliciousness: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        nums = deliciousness</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">ispow</span>(<span class="params">x</span>):</span><br><span class="line">            <span class="keyword">return</span> x&gt;<span class="number">0</span> <span class="keyword">and</span> x &amp; (x-<span class="number">1</span>)==<span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">                v = nums[i] + nums[j]</span><br><span class="line">                <span class="keyword">if</span> ispow(v):</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cnt</span><br><span class="line"><span class="comment"># 错误</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countPairs</span>(<span class="params">self, deliciousness: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        cnt = Counter(deliciousness)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="built_in">print</span>(cnt.keys())</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> cnt.keys():</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">                <span class="keyword">if</span> key == <span class="number">2</span> **i:</span><br><span class="line">                    res = res + cnt[key] * (cnt[key] - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res = res + cnt[key] * (cnt[<span class="number">2</span> ** i - key])</span><br><span class="line">        <span class="keyword">return</span> res//<span class="number">2</span></span><br><span class="line"><span class="comment"># 好</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countPairs</span>(<span class="params">self, deliciousness: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        cnt = Counter(deliciousness)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="built_in">print</span>(cnt.keys())</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> cnt.keys():</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">                <span class="keyword">if</span> key == <span class="number">2</span> ** (i-<span class="number">1</span>): <span class="comment"># 改动</span></span><br><span class="line">                    res = res + cnt[key] * (cnt[key] - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res = res + cnt[key] * (cnt[<span class="number">2</span> ** i - key])</span><br><span class="line">        <span class="keyword">return</span> res//<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>注意这里需要考虑 pow(2,i) 和key的关系，避免1+1=2这种，或者你在else里面加上 pow(2,i)-key!=key的判断才可以的.</p>
<h3 id="除法类">除法类</h3>
<h4 id="快速求余">快速求余</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">remainder</span>(<span class="params">x, a, p</span>):</span><br><span class="line">    rem = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(a):</span><br><span class="line">        rem = (rem * x) % p</span><br><span class="line">    <span class="keyword">return</span> rem</span><br><span class="line"></span><br><span class="line"><span class="comment"># 求 (x^a) % p —— 快速幂求余</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">remainder</span>(<span class="params">x, a, p</span>):</span><br><span class="line">    rem = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> a &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> a % <span class="number">2</span>: rem = (rem * x) % p</span><br><span class="line">        x = x ** <span class="number">2</span> % p</span><br><span class="line">        a //= <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> rem</span><br></pre></td></tr></table></figure>
<p>参考 <a href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/solution/mian-shi-ti-14-ii-jian-sheng-zi-iitan-xin-er-fen-f/">https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/solution/mian-shi-ti-14-ii-jian-sheng-zi-iitan-xin-er-fen-f/</a></p>
<h4 id="两数相除">两数相除</h4>
<p>题目见 <a href="https://leetcode-cn.com/problems/divide-two-integers/%EF%BC%8C">https://leetcode-cn.com/problems/divide-two-integers/，</a> 这里我做了很多次代码，每次都是在边界条件那里出了问题，看下详细的过程如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 提交次数1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">self, dividend: <span class="built_in">int</span>, divisor: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        flag = <span class="number">1</span> <span class="keyword">if</span> dividend * divisor &gt; <span class="number">0</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">        dividend = <span class="built_in">abs</span>(dividend)</span><br><span class="line">        divisor = <span class="built_in">abs</span>(divisor)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> divisor == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> divisor == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> dividend</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> divisor * i &lt; dividend:</span><br><span class="line">            i *= <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        l = i // <span class="number">2</span></span><br><span class="line">        r = i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> r - l &gt; <span class="number">1</span>:</span><br><span class="line">            mid = (r + l) / <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mid * divisor &gt; dividend:</span><br><span class="line">                r = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = mid</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(l * flag)</span><br></pre></td></tr></table></figure>
<p>错误原因，对于1 -1这样的输入是会有问题的，接下来第二版</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 提交次数2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">self, dividend: <span class="built_in">int</span>, divisor: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        flag = <span class="number">1</span> <span class="keyword">if</span> dividend * divisor &gt; <span class="number">0</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">        dividend = <span class="built_in">abs</span>(dividend)</span><br><span class="line">        divisor = <span class="built_in">abs</span>(divisor)</span><br><span class="line">        <span class="keyword">if</span> divisor == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> divisor == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> dividend*flag</span><br><span class="line">        <span class="keyword">if</span> divisor==dividend:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>*flag</span><br><span class="line"></span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> divisor * i &lt; dividend:</span><br><span class="line">            i *= <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        l = i // <span class="number">2</span></span><br><span class="line">        r = i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> r - l &gt; <span class="number">1</span>:</span><br><span class="line">            mid = (r + l) / <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mid * divisor &gt; dividend:</span><br><span class="line">                r = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = mid</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(l * flag)</span><br></pre></td></tr></table></figure>
<p>错误的原因在于没有考虑到2^31这种，接下来第三版</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">self, dividend: <span class="built_in">int</span>, divisor: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        flag = <span class="number">1</span> <span class="keyword">if</span> dividend * divisor &gt; <span class="number">0</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">        dividend = <span class="built_in">abs</span>(dividend)</span><br><span class="line">        divisor = <span class="built_in">abs</span>(divisor)</span><br><span class="line">        <span class="keyword">if</span> divisor == <span class="number">0</span>:</span><br><span class="line">            c = <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> divisor == <span class="number">1</span>:</span><br><span class="line">            c = dividend</span><br><span class="line">        <span class="keyword">elif</span> divisor == dividend:</span><br><span class="line">            c = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> divisor * i &lt; dividend:</span><br><span class="line">                i *= <span class="number">2</span></span><br><span class="line"></span><br><span class="line">            l = i // <span class="number">2</span></span><br><span class="line">            r = i</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> r - l &gt; <span class="number">1</span>:</span><br><span class="line">                mid = (r + l) / <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> mid * divisor &gt; dividend:</span><br><span class="line">                    r = mid</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    l = mid</span><br><span class="line">            c = l</span><br><span class="line">        c = c * flag</span><br><span class="line">        <span class="keyword">if</span> c &gt;= <span class="number">2147483647</span>:</span><br><span class="line">            c = <span class="number">2147483647</span></span><br><span class="line">        <span class="keyword">if</span> c &lt;= -<span class="number">1</span> * math.<span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">31</span>):</span><br><span class="line">            c = -<span class="number">1</span> * math.<span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">31</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(c)</span><br></pre></td></tr></table></figure>
<p>这里改变了之前的逻辑结构，把所有的if改变了。但是还是会标错，原因在于while那里。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">self, dividend: <span class="built_in">int</span>, divisor: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        flag = <span class="number">1</span> <span class="keyword">if</span> dividend * divisor &gt; <span class="number">0</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">        dividend = <span class="built_in">abs</span>(dividend)</span><br><span class="line">        divisor = <span class="built_in">abs</span>(divisor)</span><br><span class="line">        <span class="keyword">if</span> divisor == <span class="number">0</span>:</span><br><span class="line">            c = <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> divisor == <span class="number">1</span>:</span><br><span class="line">            c = dividend</span><br><span class="line">        <span class="keyword">elif</span> divisor == dividend:</span><br><span class="line">            c = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> divisor * i &lt;= dividend:</span><br><span class="line">                i *= <span class="number">2</span></span><br><span class="line"></span><br><span class="line">            l = i // <span class="number">2</span></span><br><span class="line">            r = i</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> r - l &gt; <span class="number">1</span>:</span><br><span class="line">                mid = (r + l) / <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> mid * divisor &gt; dividend:</span><br><span class="line">                    r = mid</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    l = mid</span><br><span class="line">            c = l</span><br><span class="line">        c = c * flag</span><br><span class="line">        <span class="keyword">if</span> c &gt;= <span class="number">2147483647</span>:</span><br><span class="line">            c = <span class="number">2147483647</span></span><br><span class="line">        <span class="keyword">if</span> c &lt;= -<span class="number">1</span> * math.<span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">31</span>):</span><br><span class="line">            c = -<span class="number">1</span> * math.<span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">31</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(c)</span><br></pre></td></tr></table></figure>
<p>这是可以通过的代码。</p>
<p>高级的结算结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">a, b</span>):</span><br><span class="line">    INT_MIN, INT_MAX = -<span class="number">2</span> ** <span class="number">31</span>, <span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> a == INT_MIN <span class="keyword">and</span> b == -<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> INT_MAX</span><br><span class="line"></span><br><span class="line">    sign = -<span class="number">1</span> <span class="keyword">if</span> (a &gt; <span class="number">0</span>) ^ (b &gt; <span class="number">0</span>) <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    a, b = <span class="built_in">abs</span>(a), <span class="built_in">abs</span>(b)</span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">31</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> (a &gt;&gt; i) - b &gt;= <span class="number">0</span>:</span><br><span class="line">            a = a - (b &lt;&lt; i)</span><br><span class="line">            ans += <span class="number">1</span> &lt;&lt; i</span><br><span class="line"></span><br><span class="line">    <span class="comment"># bug 修复：因为不能使用乘号，所以将乘号换成三目运算符</span></span><br><span class="line">    <span class="keyword">return</span> ans <span class="keyword">if</span> sign == <span class="number">1</span> <span class="keyword">else</span> -ans</span><br></pre></td></tr></table></figure>
<p>我模仿写的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">self, a: <span class="built_in">int</span>, b: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        INT_MIN, INT_MAX = -<span class="number">2</span> ** <span class="number">31</span>, <span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> a == INT_MIN <span class="keyword">and</span> b == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> INT_MAX</span><br><span class="line">        <span class="keyword">if</span> b == <span class="number">0</span> <span class="keyword">or</span> a == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        flag = <span class="number">1</span> <span class="keyword">if</span> a*b&gt;<span class="number">0</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">        a,b = <span class="built_in">abs</span>(a),<span class="built_in">abs</span>(b)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">31</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> (a&gt;&gt;i) - b &gt;= <span class="number">0</span>:</span><br><span class="line">                a = a - (b&lt;&lt;i)</span><br><span class="line">                ans+= <span class="number">1</span>&lt;&lt;i</span><br><span class="line">        <span class="keyword">return</span> ans*flag</span><br></pre></td></tr></table></figure>
<h4 id="剑指-Offer-II-001-整数除法">剑指 Offer II 001. 整数除法</h4>
<p>题目见 <a href="https://leetcode-cn.com/problems/xoh6Oh/%EF%BC%8C">https://leetcode-cn.com/problems/xoh6Oh/，</a> 和上面是一样的，解法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">a, b</span>):</span><br><span class="line">    INT_MIN, INT_MAX = -<span class="number">2</span> ** <span class="number">31</span>, <span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> a == INT_MIN <span class="keyword">and</span> b == -<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> INT_MAX</span><br><span class="line"></span><br><span class="line">    sign = -<span class="number">1</span> <span class="keyword">if</span> (a &gt; <span class="number">0</span>) ^ (b &gt; <span class="number">0</span>) <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    a, b = <span class="built_in">abs</span>(a), <span class="built_in">abs</span>(b)</span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">31</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> (a &gt;&gt; i) - b &gt;= <span class="number">0</span>:</span><br><span class="line">            a = a - (b &lt;&lt; i)</span><br><span class="line">            ans += <span class="number">1</span> &lt;&lt; i</span><br><span class="line"></span><br><span class="line">    <span class="comment"># bug 修复：因为不能使用乘号，所以将乘号换成三目运算符</span></span><br><span class="line">    <span class="keyword">return</span> ans <span class="keyword">if</span> sign == <span class="number">1</span> <span class="keyword">else</span> -ans</span><br></pre></td></tr></table></figure>
<h4 id="Excel表列名称">Excel表列名称</h4>
<p>题目见 <a href="https://leetcode-cn.com/problems/excel-sheet-column-title/">https://leetcode-cn.com/problems/excel-sheet-column-title/</a> 题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 错误</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">convertToTitle</span>(<span class="params">self, columnNumber: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> columnNumber &gt; <span class="number">0</span>:</span><br><span class="line">            a0 = (columnNumber-<span class="number">1</span>)%<span class="number">26</span> + <span class="number">1</span></span><br><span class="line">            res.append(<span class="built_in">chr</span>(a0 - <span class="number">1</span> + <span class="built_in">ord</span>(<span class="string">&quot;A&quot;</span>)))</span><br><span class="line">            columnNumber = columnNumber - a0</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(res[::-<span class="number">1</span>] )</span><br><span class="line"><span class="comment"># 通过</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">convertToTitle</span>(<span class="params">self, columnNumber: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> columnNumber &gt; <span class="number">0</span>:</span><br><span class="line">            a0 = (columnNumber-<span class="number">1</span>)%<span class="number">26</span> + <span class="number">1</span></span><br><span class="line">            res.append(<span class="built_in">chr</span>(a0 - <span class="number">1</span> + <span class="built_in">ord</span>(<span class="string">&quot;A&quot;</span>)))</span><br><span class="line">            columnNumber = (columnNumber - a0)//<span class="number">26</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(res[::-<span class="number">1</span>] )</span><br></pre></td></tr></table></figure>
<p>这道题的做法有点饶的，还是需要结合题解进一步理解<br>
<img src="https://img-blog.csdnimg.cn/4f94ab595ef146c895509add17805ad2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ICX5a2Q5p2l5ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="image"></p>
<h4 id="Excel-表列序号">Excel 表列序号</h4>
<p>题目见 <a href="https://leetcode-cn.com/problems/excel-sheet-column-number/">https://leetcode-cn.com/problems/excel-sheet-column-number/</a> 题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">titleToNumber</span>(<span class="params">self, columnTitle: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        multipy = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> columnTitle[::-<span class="number">1</span>]:</span><br><span class="line">            v = <span class="built_in">ord</span>(i) - <span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>) + <span class="number">1</span></span><br><span class="line">            num += v * multipy</span><br><span class="line">            multipy *= <span class="number">26</span></span><br><span class="line">        <span class="keyword">return</span> num</span><br></pre></td></tr></table></figure>
<p>这道题中的最后的累乘和 数字序列中某一位的数字 这道题有点类似，可以看下</p>
<h4 id="水壶问题（最大公约数）">水壶问题（最大公约数）</h4>
<p>题目见 <a href="https://leetcode-cn.com/problems/water-and-jug-problem/">https://leetcode-cn.com/problems/water-and-jug-problem/</a> 解法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canMeasureWater</span>(<span class="params">self, x: <span class="built_in">int</span>, y: <span class="built_in">int</span>, z: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> x + y &lt; z:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span> <span class="keyword">or</span> y == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> z == <span class="number">0</span> <span class="keyword">or</span> x + y == z</span><br><span class="line">        <span class="keyword">return</span> z % math.gcd(x, y) == <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>其实就是求最大公约数的问题</p>
<h4 id="完美数">完美数</h4>
<p>题目见 <a href="https://leetcode-cn.com/problems/perfect-number/">https://leetcode-cn.com/problems/perfect-number/</a> 题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 超时</span></span><br><span class="line">直接循环来做的话，会超时，因此需要熊<span class="number">2</span>到sqrt进行遍历，这样会少了一部分的计算量</span><br><span class="line"><span class="comment"># 通过</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">checkPerfectNumber</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> num==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        res = [<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="built_in">int</span>(num**<span class="number">0.5</span>)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> num % i == <span class="number">0</span>:</span><br><span class="line">                res.append(i)</span><br><span class="line">                res.append(num//i)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">sum</span>(res)==num:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h4 id="分数到小数">分数到小数</h4>
<p>题目见 <a href="https://leetcode-cn.com/problems/fraction-to-recurring-decimal/">https://leetcode-cn.com/problems/fraction-to-recurring-decimal/</a> 题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fractionToDecimal</span>(<span class="params">self, numerator: <span class="built_in">int</span>, denominator: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">if</span> numerator == <span class="number">0</span>: <span class="keyword">return</span> <span class="string">&quot;0&quot;</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># 首先判断结果正负, 异或作用就是 两个数不同 为 True 即 1 ^ 0 = 1 或者 0 ^ 1 = 1</span></span><br><span class="line">        <span class="keyword">if</span> (numerator &gt; <span class="number">0</span>) ^ (denominator &gt; <span class="number">0</span>):</span><br><span class="line">            res.append(<span class="string">&quot;-&quot;</span>)</span><br><span class="line">        numerator, denominator = <span class="built_in">abs</span>(numerator), <span class="built_in">abs</span>(denominator)</span><br><span class="line">        <span class="comment"># 判读到底有没有小数</span></span><br><span class="line">        a, b = <span class="built_in">divmod</span>(numerator, denominator)</span><br><span class="line">        res.append(<span class="built_in">str</span>(a))</span><br><span class="line">        <span class="comment"># 无小数</span></span><br><span class="line">        <span class="keyword">if</span> b == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(res)</span><br><span class="line">        res.append(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">        <span class="comment"># 处理余数</span></span><br><span class="line">        <span class="comment"># 把所有出现过的余数记录下来</span></span><br><span class="line">        loc = &#123;b: <span class="built_in">len</span>(res)&#125;</span><br><span class="line">        <span class="keyword">while</span> b:</span><br><span class="line">            b *= <span class="number">10</span></span><br><span class="line">            a, b = <span class="built_in">divmod</span>(b, denominator)</span><br><span class="line">            res.append(<span class="built_in">str</span>(a))</span><br><span class="line">            <span class="comment"># 余数前面出现过,说明开始循环了,加括号</span></span><br><span class="line">            <span class="keyword">if</span> b <span class="keyword">in</span> loc:</span><br><span class="line">                res.insert(loc[b], <span class="string">&quot;(&quot;</span>)</span><br><span class="line">                res.append(<span class="string">&quot;)&quot;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 在把该位置的记录下来</span></span><br><span class="line">            loc[b] = <span class="built_in">len</span>(res)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(res)</span><br></pre></td></tr></table></figure>
<p>参考如下：<a href="https://leetcode-cn.com/problems/fraction-to-recurring-decimal/solution/ji-lu-yu-shu-by-powcai/">https://leetcode-cn.com/problems/fraction-to-recurring-decimal/solution/ji-lu-yu-shu-by-powcai/</a></p>
<p>其实主要玩的思路是这样的，比如2/3这个数，逻辑如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = 2</span><br><span class="line">y = 3</span><br><span class="line">a, b = divmod(x, y)</span><br><span class="line">while b:</span><br><span class="line">    b *= 10</span><br><span class="line">    a, b = divmod(b, y)</span><br></pre></td></tr></table></figure>
<h3 id="计算器">计算器</h3>
<p>实现计算器的代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">代码如下</span><br><span class="line">pri = &#123;<span class="string">&quot;(&quot;</span>: <span class="number">1</span>, <span class="string">&quot;+&quot;</span>: <span class="number">2</span>, <span class="string">&quot;-&quot;</span>: <span class="number">2</span>, <span class="string">&quot;*&quot;</span>: <span class="number">3</span>, <span class="string">&quot;/&quot;</span>: <span class="number">3</span>&#125;</span><br><span class="line">ops_stack = []</span><br><span class="line">post_stack = []</span><br><span class="line">s = <span class="string">&quot;(1+2)/3-4*2-(3-4)&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">    <span class="keyword">if</span> i == <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> i.isdigit():</span><br><span class="line">        post_stack.append(i)</span><br><span class="line">    <span class="keyword">elif</span> i == <span class="string">&quot;(&quot;</span>:</span><br><span class="line">        ops_stack.append(i)</span><br><span class="line">    <span class="keyword">elif</span> i == <span class="string">&quot;)&quot;</span>:</span><br><span class="line">        <span class="keyword">while</span> ops_stack[-<span class="number">1</span>] != <span class="string">&quot;(&quot;</span>:</span><br><span class="line">            post_stack.append(ops_stack.pop())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">while</span> ops_stack <span class="keyword">and</span> pri[ops_stack[-<span class="number">1</span>]] &gt;= pri[i]:</span><br><span class="line">            post_stack.append(ops_stack.pop())</span><br><span class="line">        ops_stack.append(i)</span><br><span class="line">post_stack.extend([i <span class="keyword">for</span> i <span class="keyword">in</span> ops_stack[::-<span class="number">1</span>] <span class="keyword">if</span> i != <span class="string">&quot;(&quot;</span>])</span><br><span class="line"></span><br><span class="line">s1 = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> post_stack:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> i.isdigit():</span><br><span class="line">        a = <span class="built_in">int</span>(s1.pop())</span><br><span class="line">        b = <span class="built_in">int</span>(s1.pop())</span><br><span class="line">        s1.append(do_math(i, a, b))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        s1.append(i)</span><br><span class="line"><span class="built_in">sum</span>(s1)</span><br></pre></td></tr></table></figure>
<h4 id="基本计算器">基本计算器</h4>
<p>题目见 <a href="https://leetcode-cn.com/problems/basic-calculator/%EF%BC%8C">https://leetcode-cn.com/problems/basic-calculator/，</a> 题解如下：</p>
<p>更一般的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&quot;1+(2+6/1+2)&quot;</span></span><br><span class="line"><span class="comment"># a = &quot;2+9/3-5&quot;</span></span><br><span class="line"><span class="comment"># 可能出现的符号</span></span><br><span class="line">symbol_1 = [<span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;/&#x27;</span>]</span><br><span class="line">symbol_2 = [<span class="string">&#x27;(&#x27;</span>]</span><br><span class="line">symbol_3 = [<span class="string">&#x27;)&#x27;</span>]</span><br><span class="line"><span class="comment"># 符号的优先级</span></span><br><span class="line">priority = &#123;<span class="string">&#x27;#&#x27;</span>: -<span class="number">1</span>, <span class="string">&#x27;(&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;+&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;-&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;*&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;/&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line">match_2 = &#123;<span class="string">&#x27;)&#x27;</span>: <span class="string">&#x27;(&#x27;</span>&#125;</span><br><span class="line"><span class="comment"># 存储符号的栈</span></span><br><span class="line">stack = []</span><br><span class="line">stack.append(<span class="string">&quot;#&quot;</span>)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">result = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面通过将中缀表达式转换为后缀表达式，并进行运算</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_operation</span>(<span class="params">symbol, a, b</span>):</span><br><span class="line">    a, b = <span class="built_in">int</span>(a), <span class="built_in">int</span>(b)</span><br><span class="line">    <span class="keyword">if</span> symbol == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line">    <span class="keyword">elif</span> symbol == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> a - b</span><br><span class="line">    <span class="keyword">elif</span> symbol == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> a * b</span><br><span class="line">    <span class="keyword">elif</span> symbol == <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> a / b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">to_operation</span>(<span class="params">result, stack</span>):</span><br><span class="line">    two = result.pop()</span><br><span class="line">    one = result.pop()</span><br><span class="line">    symbol = stack.pop()</span><br><span class="line">    ret = my_operation(symbol, one, two)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;one&#125;</span><span class="subst">&#123;symbol&#125;</span><span class="subst">&#123;two&#125;</span> = <span class="subst">&#123;ret&#125;</span>&quot;</span>)</span><br><span class="line">    result.append(ret)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 在表达式转换的时候就一边进行了运算</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    <span class="comment"># 如果是数字直接添加到结果</span></span><br><span class="line">    <span class="keyword">if</span> i.isdigit():</span><br><span class="line">        result.append(i)</span><br><span class="line">    <span class="comment"># 如果是 + - * / 运算，则先出栈更低优先级的，然后入栈</span></span><br><span class="line">    <span class="keyword">elif</span> i <span class="keyword">in</span> symbol_1:</span><br><span class="line">        <span class="comment"># 如果优先级低，则出栈所有优先级&gt;=的符号</span></span><br><span class="line">        <span class="keyword">while</span> priority[i] &lt;= priority[stack[-<span class="number">1</span>]]:</span><br><span class="line">            to_operation(result, stack)</span><br><span class="line">        <span class="comment"># 压入符号</span></span><br><span class="line">        stack.append(i)</span><br><span class="line">    <span class="comment"># 如果是左括号，直接压入</span></span><br><span class="line">    <span class="keyword">elif</span> i <span class="keyword">in</span> symbol_2:</span><br><span class="line">        stack.append(i)</span><br><span class="line">    <span class="comment"># 如果是右括号，则出栈，直到遇到了匹配的左括号，然后吧左括号也出栈</span></span><br><span class="line">    <span class="keyword">elif</span> i <span class="keyword">in</span> symbol_3:</span><br><span class="line">        <span class="keyword">while</span> stack[-<span class="number">1</span>] != match_2[i]:</span><br><span class="line">            to_operation(result, stack)</span><br><span class="line">        stack.pop()</span><br><span class="line"></span><br><span class="line">to_operation(result, stack)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="基本计算器-II">基本计算器 II</h4>
<p>题目见 <a href="https://leetcode-cn.com/problems/basic-calculator-ii/%EF%BC%8C%E9%A2%98%E8%A7%A3%E5%A6%82%E4%B8%8B%EF%BC%9A">https://leetcode-cn.com/problems/basic-calculator-ii/，题解如下：</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calculate</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        stack = []</span><br><span class="line">        nums = <span class="number">0</span></span><br><span class="line">        pre_flag = <span class="string">&quot;+&quot;</span> <span class="comment"># 注意</span></span><br><span class="line">        s = s + <span class="string">&quot;$&quot;</span> <span class="comment"># 注意</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i.isdigit():</span><br><span class="line">                nums = nums*<span class="number">10</span> + <span class="built_in">int</span>(i)</span><br><span class="line">            <span class="keyword">elif</span> i==<span class="string">&#x27; &#x27;</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> pre_flag == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                    stack.append(nums)</span><br><span class="line">                <span class="keyword">if</span> pre_flag == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                    stack.append(-nums)</span><br><span class="line">                <span class="keyword">if</span> pre_flag == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    stack.append(stack.pop()*nums)</span><br><span class="line">                <span class="keyword">if</span> pre_flag == <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                    stack.append(<span class="built_in">int</span>(stack.pop()/nums))</span><br><span class="line">                pre_flag = i <span class="comment">#注意</span></span><br><span class="line">                nums = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(stack)</span><br></pre></td></tr></table></figure>
<h3 id="字典序类">字典序类</h3>
<h4 id="数字序列中某一位的数字">数字序列中某一位的数字</h4>
<p>题目见 <a href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/">https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/</a> 和之前的字典序的题目不太一样，和数学是有关系的，主要是要自减。<br>
解法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 简洁做法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">findNthDigit</span>(<span class="params">n</span>):</span><br><span class="line">    digit, start, count = <span class="number">1</span>, <span class="number">1</span>, <span class="number">9</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; count:  <span class="comment"># 1.</span></span><br><span class="line">        n -= count</span><br><span class="line">        start *= <span class="number">10</span></span><br><span class="line">        digit += <span class="number">1</span></span><br><span class="line">        count = <span class="number">9</span> * start * digit</span><br><span class="line">    num = start + (n - <span class="number">1</span>) // digit  <span class="comment"># 2.获取数字</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(<span class="built_in">str</span>(num)[(n - <span class="number">1</span>) % digit])  <span class="comment"># 3. 获取对应的位数</span></span><br><span class="line"><span class="comment"># 我的解法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">findNthDigit</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type n: int</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    digit = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        start = digit * <span class="number">9</span> * (<span class="number">10</span>**(digit-<span class="number">1</span>))</span><br><span class="line">        n -= start</span><br><span class="line">        digit += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    last_nums = n + start</span><br><span class="line">    digit -= <span class="number">1</span></span><br><span class="line">    begin = <span class="number">10</span> **(digit-<span class="number">1</span>)</span><br><span class="line">    word = begin + last_nums//digit - <span class="number">1</span></span><br><span class="line">    index = last_nums % digit</span><br><span class="line">    <span class="keyword">if</span> index==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(<span class="built_in">str</span>(word)[-<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(<span class="built_in">str</span>(word+<span class="number">1</span>)[index-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<h3 id="加法类">加法类</h3>
<h4 id="二进制求和">二进制求和</h4>
<p>题解见 <a href="https://leetcode-cn.com/problems/add-binary/">https://leetcode-cn.com/problems/add-binary/</a> 题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addBinary</span>(<span class="params">self, a: <span class="built_in">str</span>, b: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        n1 = <span class="built_in">len</span>(a)</span><br><span class="line">        n2 = <span class="built_in">len</span>(b)</span><br><span class="line">        <span class="keyword">if</span> n1 &lt; n2:</span><br><span class="line">            a = <span class="string">&#x27;0&#x27;</span>*(n2-n1)+a</span><br><span class="line">        <span class="keyword">if</span> n2 &lt; n1:</span><br><span class="line">            b = <span class="string">&#x27;0&#x27;</span>*(n1-n2)+b</span><br><span class="line">    </span><br><span class="line">        res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        div = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            h = <span class="built_in">int</span>(a[i]) + <span class="built_in">int</span>(b[i]) + div</span><br><span class="line">            div, remain = <span class="built_in">divmod</span>(h + div, <span class="number">2</span>)</span><br><span class="line">            res+=<span class="built_in">str</span>(remain)</span><br><span class="line">        <span class="keyword">if</span> div:</span><br><span class="line">            res+=<span class="built_in">str</span>(div) <span class="comment"># 注意</span></span><br><span class="line">        <span class="keyword">return</span> res[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h4 id="字符串相加">字符串相加</h4>
<p>题目见 <a href="https://leetcode-cn.com/problems/add-strings/">https://leetcode-cn.com/problems/add-strings/</a> 题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addStrings</span>(<span class="params">self, num1: <span class="built_in">str</span>, num2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        n1 = <span class="built_in">len</span>(num1)</span><br><span class="line">        n2 = <span class="built_in">len</span>(num2)</span><br><span class="line">        <span class="keyword">if</span> n1 &lt; n2:</span><br><span class="line">            num1 = <span class="string">&#x27;0&#x27;</span>*(n2-n1)+num1</span><br><span class="line">        <span class="keyword">if</span> n2 &lt; n1:</span><br><span class="line">            num2 = <span class="string">&#x27;0&#x27;</span>*(n1-n2)+num2</span><br><span class="line">    </span><br><span class="line">        res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        div = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(num1)-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            h = <span class="built_in">int</span>(num1[i])+<span class="built_in">int</span>(num2[i])+div</span><br><span class="line">            div, remind = <span class="built_in">divmod</span>(h, <span class="number">10</span>)</span><br><span class="line">            res+=<span class="built_in">str</span>(zhi)</span><br><span class="line">        <span class="keyword">if</span> div:</span><br><span class="line">            res+=<span class="built_in">str</span>(div) <span class="comment"># 注意</span></span><br><span class="line">        <span class="keyword">return</span> res[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h4 id="加一">加一</h4>
<p>题目见 <a href="https://leetcode-cn.com/problems/plus-one/">https://leetcode-cn.com/problems/plus-one/</a> 题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 错误</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">plusOne</span>(<span class="params">self, digits: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        y = <span class="number">0</span></span><br><span class="line">        y = <span class="number">0</span></span><br><span class="line">        digits2 = digits[::-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(digits2)):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                v = (digits2[i] + y + <span class="number">1</span>) % <span class="number">10</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                v = (digits2[i] + y) % <span class="number">10</span></span><br><span class="line">            y = (digits2[i] + <span class="number">1</span>) // <span class="number">10</span></span><br><span class="line">            res.append(v)</span><br><span class="line">        <span class="keyword">if</span> y &gt; <span class="number">0</span>:</span><br><span class="line">            res.append(y)</span><br><span class="line">        <span class="keyword">return</span> res[::-<span class="number">1</span>]</span><br><span class="line"><span class="comment">#正确</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">plusOne</span>(<span class="params">self, digits: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        y = <span class="number">0</span></span><br><span class="line">        y = <span class="number">0</span></span><br><span class="line">        digits2 = digits[::-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(digits2)):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                v = (digits2[i] + y + <span class="number">1</span>) % <span class="number">10</span></span><br><span class="line">                y = (digits2[i] + y + <span class="number">1</span>) // <span class="number">10</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                v = (digits2[i] + y) % <span class="number">10</span></span><br><span class="line">                y = (digits2[i] + y) // <span class="number">10</span></span><br><span class="line">            res.append(v)</span><br><span class="line">        <span class="keyword">if</span> y &gt; <span class="number">0</span>:</span><br><span class="line">            res.append(y)</span><br><span class="line">        <span class="keyword">return</span> res[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="乘法类">乘法类</h3>
<h4 id="递归乘法">递归乘法</h4>
<p>题目见 <a href="https://leetcode-cn.com/problems/recursive-mulitply-lcci/">https://leetcode-cn.com/problems/recursive-mulitply-lcci/</a> 题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># v1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">multiply</span>(<span class="params">self, A: <span class="built_in">int</span>, B: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> A*B</span><br><span class="line"><span class="comment"># v2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">multiply</span>(<span class="params">self, A: <span class="built_in">int</span>, B: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> B:</span><br><span class="line">            <span class="keyword">if</span> B&amp;<span class="number">1</span>: res = res + A</span><br><span class="line">            A = A + A</span><br><span class="line">            B&gt;&gt;=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"><span class="comment"># v3 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">multiply</span>(<span class="params">self, A: <span class="built_in">int</span>, B: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">A,B</span>):</span><br><span class="line">            <span class="keyword">if</span> B==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> A</span><br><span class="line">            s = dfs(A,B//<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> s+s <span class="keyword">if</span> B%<span class="number">2</span>==<span class="number">0</span> <span class="keyword">else</span> s+s+A</span><br><span class="line">        <span class="keyword">return</span> dfs(A,B)</span><br></pre></td></tr></table></figure>
<h3 id="位运算">位运算</h3>
<h4 id="不用加减乘除做加法">不用加减乘除做加法</h4>
<p>题目见 <a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/">https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/</a> 题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, a: <span class="built_in">int</span>, b: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        x = <span class="number">0xffffffff</span></span><br><span class="line">        a,b = a&amp;x,b&amp;x</span><br><span class="line">        <span class="keyword">while</span> b!=<span class="number">0</span>:</span><br><span class="line">            a,b = a^b, (a&amp;b)&lt;&lt;<span class="number">1</span>&amp;x</span><br><span class="line">        <span class="keyword">return</span> a <span class="keyword">if</span> a &lt;= <span class="number">0x7fffffff</span> <span class="keyword">else</span> ~(a ^ x)</span><br></pre></td></tr></table></figure>
<h4 id="消失的数字">消失的数字</h4>
<p>题目见 <a href="https://leetcode-cn.com/problems/missing-number-lcci/">https://leetcode-cn.com/problems/missing-number-lcci/</a> 题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">missingNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            res = res ^ i ^ nums[i]</span><br><span class="line">        res ^= n</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">missingNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        r = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            r ^= i</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)+<span class="number">1</span>):</span><br><span class="line">            r ^= i</span><br><span class="line">        <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>
<h4 id="数组中数字出现的次数">数组中数字出现的次数</h4>
<p>题目见 <a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/</a> 题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">singleNumbers</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            res ^= i</span><br><span class="line">        m = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> res &amp; m==<span class="number">0</span>:</span><br><span class="line">            m &lt;&lt;=<span class="number">1</span></span><br><span class="line">        x = <span class="number">0</span></span><br><span class="line">        y = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i &amp; m:</span><br><span class="line">                x^=i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                y^=i</span><br><span class="line">        <span class="keyword">return</span> [x,y]</span><br></pre></td></tr></table></figure>
<h3 id="单数字操作">单数字操作</h3>
<h4 id="最大交换">最大交换</h4>
<p>题目见 <a href="https://leetcode-cn.com/problems/maximum-swap/%EF%BC%8C">https://leetcode-cn.com/problems/maximum-swap/，</a> 题解如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumSwap</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> num:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 倒序之后的数字列表</span></span><br><span class="line">        sorted_num = <span class="built_in">sorted</span>(<span class="built_in">list</span>(<span class="built_in">str</span>(num)), reverse=<span class="literal">True</span>)</span><br><span class="line">        <span class="comment"># 原数字列表</span></span><br><span class="line">        num_list = <span class="built_in">list</span>(<span class="built_in">str</span>(num))</span><br><span class="line">        <span class="keyword">if</span> sorted_num == num_list:</span><br><span class="line">            <span class="comment"># 本来就是降序的，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        change_num = -<span class="number">1</span></span><br><span class="line">        <span class="comment"># 一一对比原列表和排序列表</span></span><br><span class="line">        <span class="keyword">while</span> index &lt; <span class="built_in">len</span>(num_list):</span><br><span class="line">            <span class="keyword">if</span> num_list[index] == sorted_num[index]:</span><br><span class="line">                <span class="comment"># 如果相同位置的数字相同，继续</span></span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 找到不同的数字了，此时index就是需要交换的左边索引</span></span><br><span class="line">            <span class="comment"># change_num就是需要交换的数字</span></span><br><span class="line">            change_num = sorted_num[index]</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 需要将最右边的大数跟最左边的小数交换</span></span><br><span class="line">        num_list.reverse()</span><br><span class="line">        <span class="comment"># 找到最右边的大数索引</span></span><br><span class="line">        change_index = <span class="built_in">len</span>(num_list) - <span class="number">1</span> - num_list.index(change_num)</span><br><span class="line">        num_list.reverse()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 交换</span></span><br><span class="line">        num_list[index], num_list[change_index] = num_list[change_index], \</span><br><span class="line">                                                  num_list[index]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(<span class="string">&#x27;&#x27;</span>.join(num_list))</span><br></pre></td></tr></table></figure>
<h4 id="下一个排列">下一个排列</h4>
<h4 id="下一个更大元素-I">下一个更大元素 I</h4>
<h4 id="下一个更大元素-II">下一个更大元素 II</h4>
<h4 id="下一个更大元素-III">下一个更大元素 III</h4>
<h3 id="其他">其他</h3>
<h4 id="剪绳子">剪绳子</h4>
<p>题目见 <a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/">https://leetcode-cn.com/problems/jian-sheng-zi-lcof/</a> 题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cuttingRope</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> n - <span class="number">1</span></span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">4</span>:</span><br><span class="line">            res *=<span class="number">3</span></span><br><span class="line">            n -= <span class="number">3</span></span><br><span class="line">        <span class="keyword">return</span> res * n</span><br></pre></td></tr></table></figure>
<h4 id="分糖果-II">分糖果 II</h4>
<p>题目见 <a href="https://leetcode-cn.com/problems/distribute-candies-to-people/">https://leetcode-cn.com/problems/distribute-candies-to-people/</a> 题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 复杂点的做法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">distributeCandies</span>(<span class="params">self, candies: <span class="built_in">int</span>, num_people: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = [<span class="number">0</span>] * num_people</span><br><span class="line">        start = <span class="number">1</span></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> candies - start&gt; <span class="number">0</span>:</span><br><span class="line">            candies -= start</span><br><span class="line">            res[index] = res[index] + start</span><br><span class="line">            start += <span class="number">1</span></span><br><span class="line">            index = (index + <span class="number">1</span>)%num_people</span><br><span class="line">        <span class="keyword">if</span> candies &gt; <span class="number">0</span>:</span><br><span class="line">            res[index] = res[index] + candies</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">distributeCandies</span>(<span class="params">self, candies: <span class="built_in">int</span>, num_people: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = [<span class="number">0</span>] * num_people</span><br><span class="line">        start = <span class="number">1</span></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> candies - start&gt; <span class="number">0</span>:</span><br><span class="line">            candies -= start</span><br><span class="line">            res[index%num_people] = res[index%num_people] + start</span><br><span class="line">            start += <span class="number">1</span></span><br><span class="line">            index = index + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> candies &gt; <span class="number">0</span>:</span><br><span class="line">            res[index%num_people] = res[index%num_people] + candies</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"><span class="comment"># 简洁做法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">distributeCandies</span>(<span class="params">self, candies: <span class="built_in">int</span>, num_people: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = [<span class="number">0</span>]*num_people</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> candies!=<span class="number">0</span>:</span><br><span class="line">            res[i%num_people] += <span class="built_in">min</span>(i+<span class="number">1</span>, candies)</span><br><span class="line">            candies = candies - <span class="built_in">min</span>(i+<span class="number">1</span>, candies) <span class="comment"># 保证不为负数</span></span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h4 id="排列序列">排列序列</h4>
<p>题目见 <a href="https://leetcode-cn.com/problems/permutation-sequence/">https://leetcode-cn.com/problems/permutation-sequence/</a> 题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getPermutation</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">import</span> math</span><br><span class="line">        toeken = [<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>)]</span><br><span class="line">        k -= <span class="number">1</span></span><br><span class="line">        res = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">            a, k = <span class="built_in">divmod</span>(k,math.factorial(n))</span><br><span class="line">            res += toeken.pop(a)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h4 id="三个数的最大乘积">三个数的最大乘积</h4>
<p>题目见 <a href="https://leetcode-cn.com/problems/maximum-product-of-three-numbers/">https://leetcode-cn.com/problems/maximum-product-of-three-numbers/</a> 题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumProduct</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        nums.sort()</span><br><span class="line">        a = nums[-<span class="number">1</span>]*nums[-<span class="number">2</span>]*nums[-<span class="number">3</span>]</span><br><span class="line">        b = nums[-<span class="number">1</span>]*nums[<span class="number">0</span>]*nums[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(a,b)</span><br></pre></td></tr></table></figure>
<p>其实很简单的，只是我们在写的时候弄的复杂了，主要判断最后一个数字和倒数两个以及前两个的大小。</p>
<h4 id="最小操作次数使数组元素相等">最小操作次数使数组元素相等</h4>
<p>题目见 <a href="https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements/">https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements/</a> 题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minMoves</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        min_num = <span class="built_in">min</span>(nums)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            res += num - min_num</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h4 id="换酒问题">换酒问题</h4>
<p>题目见 <a href="https://leetcode-cn.com/problems/water-bottles/">https://leetcode-cn.com/problems/water-bottles/</a> 题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numWaterBottles</span>(<span class="params">self, numBottles: <span class="built_in">int</span>, numExchange: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        res = numBottles</span><br><span class="line">        <span class="keyword">while</span> numBottles &gt;= numExchange:</span><br><span class="line">            bear, numBottles = <span class="built_in">divmod</span>(numBottles, numExchange)</span><br><span class="line">            res += bear</span><br><span class="line">            numBottles = numBottles + bear</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>注意上面的while的条件哈</p>
<h4 id="矩形重叠">矩形重叠</h4>
<p>题目见 <a href="https://leetcode-cn.com/problems/rectangle-overlap/">https://leetcode-cn.com/problems/rectangle-overlap/</a>  题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 错误</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isRectangleOverlap</span>(<span class="params">self, rec1: <span class="type">List</span>[<span class="built_in">int</span>], rec2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        x1, y1 = rec2[<span class="number">0</span>], rec2[<span class="number">1</span>]</span><br><span class="line">        x3, y3 = rec2[<span class="number">2</span>], rec2[<span class="number">3</span>]</span><br><span class="line">        x2, y2 = x1, y3</span><br><span class="line">        x4, y4 = x3, y1</span><br><span class="line"></span><br><span class="line">        x, y = rec1[<span class="number">0</span>], rec1[<span class="number">1</span>]</span><br><span class="line">        x5, y5 = rec1[<span class="number">2</span>], rec1[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> k,f <span class="keyword">in</span> [(x1,y1),(x2,y2),(x3,y3),(x4,y4)]:</span><br><span class="line">            <span class="keyword">if</span> k&gt;x <span class="keyword">and</span> k&lt;x5 <span class="keyword">and</span> f&gt;y <span class="keyword">and</span> f&lt;y5:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="comment"># 可以</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isRectangleOverlap</span>(<span class="params">self, rec1: <span class="type">List</span>[<span class="built_in">int</span>], rec2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        x_overlap = <span class="keyword">not</span>(rec1[<span class="number">2</span>]&lt;=rec2[<span class="number">0</span>] <span class="keyword">or</span> rec2[<span class="number">2</span>]&lt;=rec1[<span class="number">0</span>])</span><br><span class="line">        y_overlap = <span class="keyword">not</span>(rec1[<span class="number">3</span>]&lt;=rec2[<span class="number">1</span>] <span class="keyword">or</span> rec2[<span class="number">3</span>]&lt;=rec1[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> x_overlap <span class="keyword">and</span> y_overlap</span><br></pre></td></tr></table></figure>
<h4 id="矩阵面积">矩阵面积</h4>
<p>题目见</p>
<h4 id="单调递增的数字">单调递增的数字</h4>
<p>题目见 <a href="https://leetcode-cn.com/problems/monotone-increasing-digits/">https://leetcode-cn.com/problems/monotone-increasing-digits/</a> 题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自己写的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">monotoneIncreasingDigits</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:      </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">get_p_n</span>(<span class="params">n</span>):</span><br><span class="line">            res = []</span><br><span class="line">            <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">                n, m = <span class="built_in">divmod</span>(n, <span class="number">10</span>)</span><br><span class="line">                res.append(m)</span><br><span class="line">            <span class="keyword">return</span> res[::-<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">get_index</span>(<span class="params">res</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(res)-<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> res[i+<span class="number">1</span>] &lt; res[i]:</span><br><span class="line">                    <span class="keyword">return</span> i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">res</span>):</span><br><span class="line">            idx = get_index(res)</span><br><span class="line">            <span class="keyword">if</span> idx==-<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                font = res[<span class="number">0</span>:idx+<span class="number">1</span>]</span><br><span class="line">                font[-<span class="number">1</span>] = font[-<span class="number">1</span>]-<span class="number">1</span> <span class="keyword">if</span> font[-<span class="number">1</span>]-<span class="number">1</span>&gt;=<span class="number">0</span> <span class="keyword">else</span> <span class="number">9</span></span><br><span class="line">                <span class="keyword">return</span> dfs(font) + [<span class="number">9</span>]*(<span class="built_in">len</span>(res)-idx-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        res = get_p_n(n)</span><br><span class="line">        res2 = dfs(res)</span><br><span class="line">        res3 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> res2:</span><br><span class="line">            res3 = res3*<span class="number">10</span> + i</span><br><span class="line">        <span class="keyword">return</span> res3</span><br><span class="line"><span class="comment"># 贪心做法</span></span><br><span class="line">lass Solution:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">monotoneIncreasingDigits</span>(<span class="params">self, N</span>):</span><br><span class="line">        n = <span class="built_in">str</span>(N)</span><br><span class="line">        num = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> n:</span><br><span class="line">            num.append(i)</span><br><span class="line"></span><br><span class="line">        nine = <span class="built_in">len</span>(num)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(num) - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>): <span class="comment"># 注意之类的操作</span></span><br><span class="line">            <span class="keyword">if</span> num[i - <span class="number">1</span>] &gt; num[i]:</span><br><span class="line">                num[i - <span class="number">1</span>] = <span class="built_in">str</span>(<span class="built_in">int</span>(num[i - <span class="number">1</span>]) - <span class="number">1</span>)</span><br><span class="line">                nine = i</span><br><span class="line"></span><br><span class="line">        num = <span class="string">&#x27;&#x27;</span>.join(num)</span><br><span class="line">        num = <span class="built_in">int</span>(num[:nine] + <span class="string">&#x27;9&#x27;</span> * (<span class="built_in">len</span>(num) - nine))</span><br><span class="line">        <span class="keyword">return</span> num</span><br></pre></td></tr></table></figure>
<p>注意上面的操作，如果换成下面的代码会出错的，因此塔一边从后往前，一边会修改值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i in range(len(num) - 1):</span><br><span class="line">	if num[i + 1] &gt; num[i]:</span><br><span class="line">		num[i] = str(int(num[i]) - 1)</span><br><span class="line">		nine = i</span><br></pre></td></tr></table></figure>
<h4 id="1～n-整数中-1-出现的次数">1～n 整数中 1 出现的次数</h4>
<p>题目见 <a href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/">https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/</a> 题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countDigitOne</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt;  <span class="built_in">int</span>:</span><br><span class="line">        a, b, one_count = <span class="number">1</span>, <span class="number">10</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n &gt;= a:</span><br><span class="line">            x, y = <span class="built_in">divmod</span>(n, b)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> y &gt;= a * <span class="number">2</span>:</span><br><span class="line">                one_count += (x + <span class="number">1</span>) * a</span><br><span class="line">            <span class="keyword">elif</span> y &gt;= a:</span><br><span class="line">                one_count += y + <span class="number">1</span> + (x - <span class="number">1</span>) * a</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                one_count += x * a </span><br><span class="line"></span><br><span class="line">            a, b = b, b*<span class="number">10</span> </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> one_count</span><br></pre></td></tr></table></figure>
<h4 id="三角形的最大周长">三角形的最大周长</h4>
<p>题目见 <a href="https://leetcode-cn.com/problems/largest-perimeter-triangle/%EF%BC%8C">https://leetcode-cn.com/problems/largest-perimeter-triangle/，</a> 题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 超时</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">largestPerimeter</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        max_triangle_length = <span class="number">0</span></span><br><span class="line">        nums.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">                p = j + <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> p &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">abs</span>(nums[i] - nums[j]) &lt; nums[p]:</span><br><span class="line">                        <span class="keyword">return</span> nums[i]+nums[j]+nums[p]</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="comment"># 通过</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">largestPerimeter</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i-<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>):</span><br><span class="line">                diff = <span class="built_in">abs</span>(nums[i] - nums[j])</span><br><span class="line">                index = bisect.bisect_left(nums, diff)</span><br><span class="line">                <span class="keyword">if</span> index &lt; j <span class="keyword">and</span> nums[j-<span class="number">1</span>]&gt;diff: <span class="comment"># 注意条件哈</span></span><br><span class="line">                    <span class="keyword">return</span> nums[i]+nums[j]+nums[j-<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            </span><br></pre></td></tr></table></figure>
<h4 id="计算各个位数不同的数字个数">计算各个位数不同的数字个数</h4>
<p>题目见 <a href="https://leetcode-cn.com/problems/count-numbers-with-unique-digits/">https://leetcode-cn.com/problems/count-numbers-with-unique-digits/</a>  题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countNumbersWithUniqueDigits</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">pending_sum</span>(<span class="params">x</span>):</span><br><span class="line">            res = <span class="number">1</span></span><br><span class="line">            j = <span class="number">10</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(x):</span><br><span class="line">                res = res * <span class="built_in">min</span>(<span class="number">9</span>, j)</span><br><span class="line">                j = j - <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> </span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line">        dp = [<span class="number">0</span>] * (n+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">10</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>] + pending_sum(i)</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
<h4 id="圆圈中最后剩下的数字">圆圈中最后剩下的数字</h4>
<p>题目见 <a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/">https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/</a>  题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lastRemaining</span>(<span class="params">self, n: <span class="built_in">int</span>, m: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        x = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n+<span class="number">1</span>): <span class="comment"># 注意起始不是1</span></span><br><span class="line">            x = (x+m)%i</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"><span class="comment"># https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/huan-ge-jiao-du-ju-li-jie-jue-yue-se-fu-huan-by-as/</span></span><br></pre></td></tr></table></figure>
<p><img src="https://pic.leetcode-cn.com/d7768194055df1c3d3f6b503468704606134231de62b4ea4b9bdeda7c58232f4-%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF1.png" alt="image"></p>
<p>类似的题目还有 找出游戏的获胜者，题目在<a href="https://leetcode-cn.com/problems/find-the-winner-of-the-circular-game/%EF%BC%8C">https://leetcode-cn.com/problems/find-the-winner-of-the-circular-game/，</a> 但是注意这个不是从0开始了，是从1开始的，因此解法会有些不一样</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findTheWinner</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        x = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            x = (x + k) % i</span><br><span class="line">        <span class="keyword">return</span> x + <span class="number">1</span>  <span class="comment"># 不一样</span></span><br></pre></td></tr></table></figure>
<h4 id="消除游戏">消除游戏</h4>
<p>题目见 <a href="https://leetcode-cn.com/problems/elimination-game/">https://leetcode-cn.com/problems/elimination-game/</a> 题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方法一：迭代做法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lastRemaining</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        head = <span class="number">1</span></span><br><span class="line">        step = <span class="number">1</span></span><br><span class="line">        left = <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="comment"># 从左边开始移除 or（从右边开始移除，数列总数为奇数）</span></span><br><span class="line">            <span class="keyword">if</span> left <span class="keyword">or</span> n % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">                head += step</span><br><span class="line">            </span><br><span class="line">            step &lt;&lt;= <span class="number">1</span> <span class="comment"># 步长 * 2</span></span><br><span class="line">            n &gt;&gt;= <span class="number">1</span> <span class="comment"># 总数 / 2</span></span><br><span class="line">            left = <span class="keyword">not</span> left <span class="comment">#取反移除方向</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line"><span class="comment"># 方法二：递归做法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lastRemaining</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">n,direction</span>):</span><br><span class="line">            <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> direction:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">2</span>*dfs(n//<span class="number">2</span>,  <span class="keyword">not</span> direction)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> n&amp;<span class="number">1</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">2</span>*dfs(n//<span class="number">2</span>, <span class="keyword">not</span> direction)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">2</span>*dfs(n//<span class="number">2</span>,<span class="keyword">not</span> direction) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dfs(n, <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>用递归来做的话，是比较快的</p>
<h4 id="最大数值">最大数值</h4>
<p>题目见 <a href="https://leetcode-cn.com/problems/maximum-lcci/">https://leetcode-cn.com/problems/maximum-lcci/</a> 题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximum</span>(<span class="params">self, a: <span class="built_in">int</span>, b: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> (a+b+<span class="built_in">abs</span>(a-b))//<span class="number">2</span></span><br></pre></td></tr></table></figure>
<h4 id="求解方程">求解方程</h4>
<p>题目见 <a href="https://leetcode-cn.com/problems/solve-the-equation/">https://leetcode-cn.com/problems/solve-the-equation/</a> 题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">solveEquation</span>(<span class="params">self, equation: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        low, high = equation.replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;+-&quot;</span>).split(<span class="string">&quot;=&quot;</span>)</span><br><span class="line">        a, b = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="comment"># 处理左边</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> low.split(<span class="string">&quot;+&quot;</span>):</span><br><span class="line">            <span class="keyword">if</span> i==<span class="string">&#x27;&#x27;</span>:<span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> i.endswith(<span class="string">&#x27;x&#x27;</span>):</span><br><span class="line">                <span class="keyword">if</span> i[:-<span class="number">1</span>] == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">                    a = a + <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> i[:-<span class="number">1</span>] == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                    a = a - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    a = a + <span class="built_in">int</span>(i[:-<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                b = b + <span class="built_in">int</span>(i)</span><br><span class="line">        <span class="comment"># 处理右边</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> high.split(<span class="string">&quot;+&quot;</span>):</span><br><span class="line">            <span class="keyword">if</span> i==<span class="string">&#x27;&#x27;</span>:<span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> i.endswith(<span class="string">&#x27;x&#x27;</span>):</span><br><span class="line">                <span class="keyword">if</span> i[:-<span class="number">1</span>] == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">                    a = a - <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> i[:-<span class="number">1</span>] == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                    a = a + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    a = a - <span class="built_in">int</span>(i[:-<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                b = b - <span class="built_in">int</span>(i)</span><br><span class="line">        <span class="keyword">if</span> a == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;Infinite solutions&#x27;</span> <span class="keyword">if</span> b == <span class="number">0</span> <span class="keyword">else</span> <span class="string">&#x27;No solution&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;x=%d&#x27;</span> % (-b / a)</span><br></pre></td></tr></table></figure>
<h3 id="质数和因数">质数和因数</h3>
<h4 id="计算质数">计算质数</h4>
<p>题目见 <a href="https://leetcode-cn.com/problems/count-primes/">https://leetcode-cn.com/problems/count-primes/</a> 题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count_primes_py</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    求n以内的所有质数个数（纯python代码）</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 最小的质数是 2</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    isPrime = [<span class="number">1</span>] * n</span><br><span class="line">    isPrime[<span class="number">0</span>] = isPrime[<span class="number">1</span>] = <span class="number">0</span>   <span class="comment"># 0和1不是质数，先排除掉</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 埃式筛，把不大于根号 n 的所有质数的倍数剔除</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">int</span>(n ** <span class="number">0.5</span>) + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> isPrime[i]:</span><br><span class="line">            isPrime[i * i:n:i] = [<span class="number">0</span>] * ((n - <span class="number">1</span> - i * i) // i + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(isPrime)</span><br></pre></td></tr></table></figure>
<p>注意上面的快速间隔的选中数值，也就是[1:100:3]每隔3个数</p>
<h4 id="丑数">丑数</h4>
<p>就是查看是否是2 3 5的乘积</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isUgly</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>]:</span><br><span class="line">            <span class="keyword">while</span> n %i == <span class="number">0</span>:</span><br><span class="line">                n = n // i</span><br><span class="line">        <span class="keyword">return</span> n==<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h4 id="丑数-II">丑数 II</h4>
<p>题目见 <a href="https://leetcode-cn.com/problems/ugly-number-ii/">https://leetcode-cn.com/problems/ugly-number-ii/</a> 题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nthUglyNumber</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        seen = <span class="built_in">set</span>()</span><br><span class="line">        res = [<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>):</span><br><span class="line">            v = heapq.heappop(res)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>]:</span><br><span class="line">                <span class="keyword">if</span> v*j <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                    seen.add(v*j)</span><br><span class="line">                    heapq.heappush(res,v*j)</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h4 id="超级丑数">超级丑数</h4>
<p>题目见 <a href="https://leetcode-cn.com/problems/super-ugly-number/">https://leetcode-cn.com/problems/super-ugly-number/</a> 题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nthSuperUglyNumber</span>(<span class="params">self, n: <span class="built_in">int</span>, primes: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        m = <span class="built_in">len</span>(primes)</span><br><span class="line">        pointers = [<span class="number">0</span>] * m</span><br><span class="line">        nums = [<span class="number">1</span>] * m</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            min_num = <span class="built_in">min</span>(nums)</span><br><span class="line">            dp[i] = min_num</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                <span class="keyword">if</span> nums[j] == min_num:</span><br><span class="line">                    pointers[j] += <span class="number">1</span> <span class="comment"># 把之前最小的dp的位置的存下来，后面* 然后得到新的数值</span></span><br><span class="line">                    nums[j] = dp[pointers[j]] * primes[j]</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
<h4 id="好子集的数目">好子集的数目</h4>
<p>题目见 <a href="https://leetcode-cn.com/problems/the-number-of-good-subsets/">https://leetcode-cn.com/problems/the-number-of-good-subsets/</a>  题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numberOfGoodSubsets</span>(<span class="params">self, nums</span>):</span><br><span class="line">        num_map = collections.Counter(nums)</span><br><span class="line">        res = collections.defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        primes = <span class="built_in">set</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x*x,[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>]))</span><br><span class="line">        <span class="comment"># 初始化 res[1] 的个数，但是后续结果需要减去</span></span><br><span class="line">        res[<span class="number">1</span>] = <span class="number">2</span>**num_map[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> num_map:</span><br><span class="line">            <span class="comment"># 去除1</span></span><br><span class="line">            <span class="keyword">if</span> num == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> key <span class="keyword">in</span> res.copy():</span><br><span class="line">                <span class="comment"># 暴力循环 构建数字</span></span><br><span class="line">                good_num = key * num</span><br><span class="line">                </span><br><span class="line">                <span class="comment">#  判断是否为好子集</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">all</span>( good_num % p <span class="keyword">for</span> p <span class="keyword">in</span> primes):</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 计算good_num的好子集的个数，初始 res[good_num] = 0 </span></span><br><span class="line">                res[good_num] += res[key] * num_map[num]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">sum</span>(res.values()) - res[<span class="number">1</span>]) % (<span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span>)  </span><br></pre></td></tr></table></figure>
<h4 id="只有两个键的键盘">只有两个键的键盘</h4>
<p>题目见 <a href="https://leetcode-cn.com/problems/2-keys-keyboard/">https://leetcode-cn.com/problems/2-keys-keyboard/</a> 这道题就是分解质因素的思路，一毛一样</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.cnt = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minSteps</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">n,c,s,t</span>):</span><br><span class="line">            <span class="keyword">if</span> s&gt;=n:</span><br><span class="line">                <span class="keyword">if</span> s==n:</span><br><span class="line">                    self.cnt = <span class="built_in">min</span>(self.cnt, t)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dfs(n, c, c+s, t+<span class="number">1</span>)</span><br><span class="line">            dfs(n, s, s+s, t+<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dfs(n,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.cnt</span><br><span class="line"><span class="comment"># 分解</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minSteps</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">1</span>: <span class="comment"># 注意</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n):</span><br><span class="line">            <span class="keyword">while</span> n%i ==<span class="number">0</span>:</span><br><span class="line">                res+=i</span><br><span class="line">                n//=i</span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> res <span class="keyword">else</span> n <span class="comment"># 如果为0说明为质数，直接返回n即可</span></span><br><span class="line"><span class="comment"># 动态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minSteps</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="number">0</span>] * (n+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">            j = <span class="number">1</span></span><br><span class="line">            dp[i] = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">            <span class="keyword">while</span> j * j &lt;= n:</span><br><span class="line">                <span class="keyword">if</span> i%j==<span class="number">0</span>:</span><br><span class="line">                    dp[i] = <span class="built_in">min</span>(dp[i], dp[i//j]+j)</span><br><span class="line">                    dp[i] = <span class="built_in">min</span>(dp[i], dp[j]+i//j)</span><br><span class="line">                j = j + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
<h2 id="数组类">数组类</h2>
<h3 id="翻转类">翻转类</h3>
<h4 id="轮转数组">轮转数组</h4>
<p>题目见 <a href="https://leetcode-cn.com/problems/rotate-array/">https://leetcode-cn.com/problems/rotate-array/</a> ，题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方法1</span></span><br><span class="line">使用了额外的空间</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n  =  <span class="built_in">len</span>(nums)</span><br><span class="line">        yushu = k % n</span><br><span class="line">        start = n - yushu</span><br><span class="line">        <span class="built_in">print</span>(nums[start:])</span><br><span class="line">        <span class="built_in">print</span>(nums[:start])</span><br><span class="line">        v = nums[start:] + nums[:start]</span><br><span class="line">        nums[:] = v[:]</span><br><span class="line"><span class="comment"># 方法2</span></span><br><span class="line">直接进行翻转即可</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">nums,start,end</span>):</span><br><span class="line">            <span class="keyword">while</span> start &lt; end:</span><br><span class="line">                nums[start], nums[end] = nums[end], nums[start]</span><br><span class="line">                start+=<span class="number">1</span></span><br><span class="line">                end-=<span class="number">1</span></span><br><span class="line">        yushu = k % <span class="built_in">len</span>(nums)</span><br><span class="line">        reverse(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span>)</span><br><span class="line">        reverse(nums, <span class="number">0</span>, yushu-<span class="number">1</span>)</span><br><span class="line">        reverse(nums,yushu,<span class="built_in">len</span>(nums)-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="原地哈希">原地哈希</h3>
<h4 id="缺失的第一个正数">缺失的第一个正数</h4>
<p><strong>考点：交换</strong><br>
因为需要找到值，而不是索引，所以需要交换，不然会丢失值。</p>
<p>建议先看下面的题目，从 <strong>数组中重复的数据</strong>开始看起，这样会加速理解，这道题其实按照我们在 找到所有数组中消失的数字 中的结论来看，不太好做的，主要是没有对数组中的值有范围，比如对于[7,8,-1,10]这种，数组的长度是4，但是里面的值都大于的，因此没法直接做value作为index的这样映射，这么一想其实很难做的。<br>
不过，如果找不到索引的话，我们就不去动不就可以了吗，对于7这个值，对应的索引的地址是6，找不到6的地址的话，我们就不交换了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 3 应该放在索引为 2 的地方</span></span><br><span class="line">    <span class="comment"># 4 应该放在索引为 3 的地方</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">firstMissingPositive</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            <span class="comment"># 先判断这个数字是不是索引，然后判断这个数字是不是放在了正确的地方</span></span><br><span class="line">            <span class="keyword">while</span> <span class="number">1</span> &lt;= nums[i] &lt;= size <span class="keyword">and</span> nums[i] != nums[nums[i] - <span class="number">1</span>]:</span><br><span class="line">                self.__swap(nums, i, nums[i] - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            <span class="keyword">if</span> i + <span class="number">1</span> != nums[i]:</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> size + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__swap</span>(<span class="params">self, nums, index1, index2</span>):</span><br><span class="line">        nums[index1], nums[index2] = nums[index2], nums[index1]</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是，程序的中的while不能换成if，不然会报错的。上面的代码可以换成如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def firstMissingPositive(self, nums: List[int]) -&gt; int:</span><br><span class="line">        size = len(nums)</span><br><span class="line">        for i in range(size):</span><br><span class="line">            # 先判断这个数字是不是索引，然后判断这个数字是不是放在了正确的地方</span><br><span class="line">            while 1 &lt;= nums[i] &lt;= size and i != nums[i] - 1:</span><br><span class="line">                nums[nums[i]-1],nums[i] = nums[i], nums[nums[i]-1]</span><br><span class="line">        for i in range(size):</span><br><span class="line">            if i + 1 != nums[i]:</span><br><span class="line">                return i + 1</span><br><span class="line">        return size + 1</span><br></pre></td></tr></table></figure>
<p>会报错的，不可以写成i!=nums[i]-1。还有一点<br>
nums[nums[i]-1],nums[i] = nums[i], nums[nums[i]-1]不能写成nums[i], nums[nums[i]-1]=nums[nums[i]-1],nums[i]这种格式。<br>
如果不这么写的话，就得像上面的答案一样，定义一个swap函数，这样就可以了。</p>
<p>最后真确的如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def firstMissingPositive(self, nums: List[int]) -&gt; int:</span><br><span class="line">        size = len(nums)</span><br><span class="line">        for i in range(size):</span><br><span class="line">            # 先判断这个数字是不是索引，然后判断这个数字是不是放在了正确的地方</span><br><span class="line">            while 1 &lt;= nums[i] &lt;= size and nums[i] != nums[nums[i] - 1]:</span><br><span class="line">                nums[nums[i]-1],nums[i] = nums[i], nums[nums[i]-1]</span><br><span class="line">        for i in range(size):</span><br><span class="line">            if i + 1 != nums[i]:</span><br><span class="line">                return i + 1</span><br><span class="line">        return size + 1</span><br></pre></td></tr></table></figure>
<h4 id="剑指-Offer-03-数组中重复的数字">剑指 Offer 03. 数组中重复的数字</h4>
<p><strong>考点：交换</strong><br>
因为需要找到旧数组值，而不是索引，所以需要交换，不然会丢失值。</p>
<p>题目见 <a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/%EF%BC%8C">https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/，</a> 题解如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findRepeatNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == i:</span><br><span class="line">                i = i + <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> nums[nums[i]] == nums[i]:</span><br><span class="line">                <span class="keyword">return</span> nums[i]</span><br><span class="line">            nums[nums[i]], nums[i] = nums[i], nums[nums[i]]</span><br></pre></td></tr></table></figure>
<p>这个解法不是很好理解，且不是很好的能够和上面的进行对应起来，下面的代码就可以和上面对应起来，建议用下面的代码，这样统一下，会好点便于后面进行快速写出来</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findRepeatNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            <span class="keyword">while</span> <span class="number">0</span>&lt;=nums[i]&lt;=size-<span class="number">1</span> <span class="keyword">and</span> nums[i]!=nums[nums[i]]:</span><br><span class="line">                nums[nums[i]],nums[i] = nums[i],nums[nums[i]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            <span class="keyword">if</span> i!=nums[i]:</span><br><span class="line">                <span class="keyword">return</span> nums[i]</span><br></pre></td></tr></table></figure>
<p>还是要注意的是代码中的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">    <span class="keyword">while</span> <span class="number">0</span>&lt;=nums[i]&lt;=size-<span class="number">1</span> <span class="keyword">and</span> nums[i]!=nums[nums[i]]:</span><br><span class="line">        nums[nums[i]],nums[i] = nums[i],nums[nums[i]]</span><br><span class="line"><span class="comment">#不能写成如下的形式</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">    <span class="keyword">while</span> <span class="number">0</span>&lt;=nums[i]&lt;=size-<span class="number">1</span> <span class="keyword">and</span> nums[i]!=nums[nums[i]]:</span><br><span class="line">        nums[i],nums[nums[i]] = nums[nums[i]],nums[i]</span><br></pre></td></tr></table></figure>
<p>如果要写的话也是可以的，只要在外面定义一个swap函数，就可以了。</p>
<h4 id="丢失的数字">丢失的数字</h4>
<p>这道题可以使用^来做，解法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">missingNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        r = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            r ^= i</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)+<span class="number">1</span>):</span><br><span class="line">            r ^= i</span><br><span class="line">        <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>
<p>使用交换来做得话，结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">missingNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            <span class="keyword">while</span> nums[i] &lt;= size - <span class="number">1</span> <span class="keyword">and</span> nums[i]!=nums[nums[i]]:</span><br><span class="line">                nums[nums[i]], nums[i] = nums[i], nums[nums[i]]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            <span class="keyword">if</span> i != nums[i]:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> size</span><br></pre></td></tr></table></figure>
<h4 id="数组中重复的数据">数组中重复的数据</h4>
<p><strong>考点：不是交换，而是直接赋值</strong><br>
因为需要找到数组中的值，其实也就是新数组的索引，直接在新数组上得到的索引就是原来的值。</p>
<p>题目见 <a href="https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/%EF%BC%8C">https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/，</a> 题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findDuplicates</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            index = (i - <span class="number">1</span>)%n</span><br><span class="line">            nums[index] += n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; <span class="number">2</span>*n:</span><br><span class="line">                res.append(i+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>其实就是将这个数组中的值，作为新的list的index， 这个数组的值是从1开始的，但是index的值是从0开始的，因此需要-1才可以。<br>
如果题目改成至少出现3次，那就要将2改成3。</p>
<h4 id="找到所有数组中消失的数字">找到所有数组中消失的数字</h4>
<p><strong>考点：不是交换，而是直接赋值</strong><br>
理由和上面类似。</p>
<p>题目见 <a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/%EF%BC%8C">https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/，</a> 这道题和上面的 <strong>数组中重复的元素</strong>基本上算是一样的，思路还是那个思路，就是把当前数组的值作为新数组的index，这里的做法和上面的类似，首先得到每个数组中的值，然后作为index，然后+n,那么那些缺失的值，如果以他们作为索引的话，对应的地方的值肯定是 &lt; n的。这样就算出来的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一版-错的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findDisappearedNumbers</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            index = nums[i] - <span class="number">1</span></span><br><span class="line">            nums[index] += n</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; n:</span><br><span class="line">               res.append(i)</span><br><span class="line">        <span class="keyword">return</span> res </span><br></pre></td></tr></table></figure>
<p>错误原因在于</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findDisappearedNumbers</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            index = (nums[i] - <span class="number">1</span>)%n <span class="comment"># 改动1</span></span><br><span class="line">            nums[index] += n</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt;= n: <span class="comment"># 改动2</span></span><br><span class="line">               res.append(i+<span class="number">1</span>) <span class="comment"># 改动3</span></span><br><span class="line">        <span class="keyword">return</span> res </span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findDisappearedNumbers</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            index = (nums[i] - <span class="number">1</span>)%n</span><br><span class="line">            nums[index] += n</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt;= n:</span><br><span class="line">               res.append(i+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>为什么要用%这个，主要是为了防止index超出了数组的大小，这类题目中数字额值都会在数组的长度的范围，[4,3,2,7,8,2,3,1]这个数组，其中的值都是小于数组长度8的，不这么做的话，没法算啊，不然index也会超的。</p>
<h3 id="重复数">重复数</h3>
<h4 id="寻找重复数">寻找重复数</h4>
<h4 id="数组中重复的数字">数组中重复的数字</h4>
<h2 id="下一个排列-2">下一个排列</h2>
<p>题目见 <a href="https://leetcode-cn.com/problems/next-permutation/">https://leetcode-cn.com/problems/next-permutation/</a>  题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextPermutation</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        i = <span class="built_in">len</span>(nums) -<span class="number">2</span> </span><br><span class="line">        <span class="keyword">while</span> i&gt;=<span class="number">0</span> <span class="keyword">and</span> nums[i]&gt;=nums[i+<span class="number">1</span>]:</span><br><span class="line">            i = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;= <span class="number">0</span>:</span><br><span class="line">            j = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j&gt;=<span class="number">0</span> <span class="keyword">and</span> nums[i] &gt;= nums[j]:</span><br><span class="line">                j = j -<span class="number">1</span> </span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        left = i + <span class="number">1</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            nums[left], nums[right] = nums[right], nums[left]</span><br><span class="line">            left = left + <span class="number">1</span></span><br><span class="line">            right = right - <span class="number">1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>题目汇总</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>二分和查找</title>
    <url>/2024/03/19/leetcode/binary_and_find/</url>
    <content><![CDATA[<h1>二分和查找类</h1>
<h2 id="基础思路">基础思路</h2>
<p>在二分查找中，需要注意的是边界的问题，其中很多小的点，很容易出现问题，一般的解法如下所示：注意哈，写的时候，要hihg = len(nums) - 1, 不要忘了写成len(nums)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查找具体的数值</span></span><br><span class="line"><span class="comment"># 方案1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search</span>(<span class="params">nums, target</span>):</span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = <span class="built_in">len</span>(nums) - <span class="number">1</span> </span><br><span class="line">    <span class="keyword">while</span> low &lt;= high: <span class="comment">#注意</span></span><br><span class="line">        mid = low + (high - low) // <span class="number">2</span> <span class="comment"># 注意</span></span><br><span class="line">        <span class="comment"># 不要使用else,要使用elif，不然有些情况会报错</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">            low = mid + <span class="number">1</span> <span class="comment"># 注意</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">            high = mid - <span class="number">1</span> <span class="comment"># 这里</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] == target: </span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line"> <span class="comment"># 方案2</span></span><br><span class="line"> <span class="keyword">def</span> <span class="title function_">binary_search</span>(<span class="params">nums, target</span>):</span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = <span class="built_in">len</span>(nums)  <span class="comment"># 这里不能改成-1，不然有些值查不到</span></span><br><span class="line">    <span class="keyword">while</span> low &lt; high: <span class="comment">#注意</span></span><br><span class="line">        mid = low + (high - low) // <span class="number">2</span> <span class="comment"># 注意</span></span><br><span class="line">        <span class="comment"># 不要使用else,要使用elif，不然有些情况会报错</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">            low = mid + <span class="number">1</span> <span class="comment"># 注意</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">            high = mid <span class="comment"># 这里</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] == target: </span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找左边界</span></span><br><span class="line"><span class="comment"># 方案1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">left_bound</span>(<span class="params">nums, target</span>):</span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    ans = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">        mid = low + (high - low) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target: <span class="comment"># 右边界往里</span></span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid]==target:</span><br><span class="line">            ans = mid</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 方案2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">left_bound</span>(<span class="params">nums, target</span>):</span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">while</span> low &lt; high:</span><br><span class="line">        mid = low + (high - low) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target: <span class="comment"># 右边界往里</span></span><br><span class="line">            high = mid</span><br><span class="line">        <span class="keyword">elif</span> nums[mid]==target:</span><br><span class="line">            ans = mid</span><br><span class="line">            high = mid</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找右边界</span></span><br><span class="line"><span class="comment"># 方案1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">right_bound</span>(<span class="params">nums, target</span>):</span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    ans = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">        mid = low + (high - low) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt;  target: <span class="comment"># 左边界往里</span></span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target: </span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] == target:</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">            ans = mid</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"><span class="comment"># 方案2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">right_bound</span>(<span class="params">nums, target</span>):</span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = <span class="built_in">len</span>(nums)</span><br><span class="line">    ans = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> low &lt; high:</span><br><span class="line">        mid = low + (high - low) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt; target: <span class="comment"># 左边界往里</span></span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">            high = mid</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] == target:</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">            ans = mid</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">target = <span class="number">4</span></span><br><span class="line"><span class="built_in">print</span>(binary_search(nums, <span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(left_bound(nums, target))</span><br><span class="line"><span class="built_in">print</span>(left_bound2(nums, target))</span><br><span class="line"><span class="built_in">print</span>(right_bound(nums, target))</span><br><span class="line"><span class="built_in">print</span>(right_bound2(nums, target))</span><br></pre></td></tr></table></figure>
<p>建议方案1，另外看如下的两个例子，明确下为啥low不能=mid，而需要=mid+1.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">search_correct</span>(<span class="params">nums, target</span>):</span><br><span class="line">    low, high = <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">while</span> low &lt; high:</span><br><span class="line">        mid = low + (high - low) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            high = mid</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">search_error</span>(<span class="params">nums, target</span>):</span><br><span class="line">    low, high = <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">while</span> low &lt; high:</span><br><span class="line">        mid = low + (high - low) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">            low = mid <span class="comment"># 这里不更新会导致mid在经过（low+high）取值后，一直停留在mid</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">target = <span class="number">8</span></span><br><span class="line"><span class="built_in">print</span>(search_correct(nums, target))  <span class="comment"># None</span></span><br><span class="line"><span class="built_in">print</span>(search_error(nums, target))  <span class="comment"># 循环</span></span><br><span class="line">target = -<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(search_correct(nums, target))  <span class="comment"># None</span></span><br><span class="line"><span class="built_in">print</span>(search_error(nums, target))  <span class="comment"># None</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到不同的参数设置，会导致不同的运行结果。</p>
<p>为什么二分查找中用一些特别的+1或者&lt;=,看个例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search</span>(<span class="params">nums, target</span>):</span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = <span class="built_in">len</span>(nums) </span><br><span class="line">    <span class="keyword">while</span> low &lt;= high: <span class="comment">#注意</span></span><br><span class="line">        mid = low + (high - low) // <span class="number">2</span> <span class="comment"># 注意</span></span><br><span class="line">        <span class="comment"># 不要使用else,要使用elif，不然有些情况会报错</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">            low = mid  <span class="comment"># 注意</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">            high = mid <span class="comment"># 这里</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] == target: </span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">binary_search(【<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>】, <span class="number">9</span>)</span><br></pre></td></tr></table></figure>
<p>上面自己调一下就知道了，  从参考的文献来看的话，建议使用左闭右闭的的方式，也就是《=的基础方式的。但是对于一些需要旋转数组这些题，因为不知道要找的数最终是什么，所以一般用low&lt;high，  然后结合low=mid+1, high=mid来 实现。对于一些寻找旋转数组中值的情况，因为是确切找值的，所以的话，一般用while low&lt;=high, 然后结合 low=mid+1, high=mid-1 来实现。</p>
<p>参考如下：<br>
[1] <a href="https://blog.csdn.net/qq_38235017/article/details/115177238?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.pc_relevant_paycolumn_v2&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.pc_relevant_paycolumn_v2&amp;utm_relevant_index=1">https://blog.csdn.net/qq_38235017/article/details/115177238?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1.pc_relevant_paycolumn_v2&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1.pc_relevant_paycolumn_v2&amp;utm_relevant_index=1</a><br>
[2] <a href="https://www.cnblogs.com/mxj961116/p/11945444.html">https://www.cnblogs.com/mxj961116/p/11945444.html</a><br>
[3] <a href="https://leetcode.cn/circle/discuss/ooxfo8/">https://leetcode.cn/circle/discuss/ooxfo8/</a> 这里说的很好，说道了上面讲述的为何要&lt;问题，以及循环的问题。</p>
<h2 id="单数组">单数组</h2>
<h3 id="排序数组中查找元素的第一个和最后一个位置-34">排序数组中查找元素的第一个和最后一个位置[34]</h3>
<p>位于 <a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/">https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchRange</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">lower_bound</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>  <span class="comment"># 闭区间 [left, right]</span></span><br><span class="line">            <span class="keyword">while</span> left &lt;= right:  <span class="comment"># 区间不为空</span></span><br><span class="line">                mid = (left + right) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">                    left = mid + <span class="number">1</span>  <span class="comment"># 范围缩小到 [mid+1, right]</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid - <span class="number">1</span>  <span class="comment"># 范围缩小到 [left, mid-1]</span></span><br><span class="line">            <span class="keyword">return</span> left  <span class="comment"># 或者 right+1</span></span><br><span class="line"></span><br><span class="line">        start = lower_bound(nums, target)  <span class="comment"># 选择其中一种写法即可</span></span><br><span class="line">        <span class="keyword">if</span> start == <span class="built_in">len</span>(nums) <span class="keyword">or</span> nums[start] != target:</span><br><span class="line">            <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]        </span><br><span class="line">        end = lower_bound(nums, target + <span class="number">1</span>) - <span class="number">1</span> <span class="comment"># 如果 start 存在，那么 end 必定存在</span></span><br><span class="line">        <span class="keyword">return</span> [start, end]</span><br></pre></td></tr></table></figure>
<h3 id="H-指数-274">H 指数[274]</h3>
<p>位于 <a href="https://leetcode.cn/problems/h-index/description/?envType=study-plan-v2&amp;envId=top-interview-150">https://leetcode.cn/problems/h-index/description/?envType=study-plan-v2&amp;envId=top-interview-150</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hIndex</span>(<span class="params">self, citations: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">import</span> bisect</span><br><span class="line">        citations.sort()</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(citations)+<span class="number">1</span>):</span><br><span class="line">            index = bisect.bisect_left(citations, i)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(citations) - index &gt;= i:</span><br><span class="line">                res = <span class="built_in">max</span>(res, i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="山脉数组的峰顶索引">山脉数组的峰顶索引</h3>
<p>题目见 <a href="https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/%EF%BC%8C">https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/，</a> 题解入下面的那道题</p>
<h3 id="寻找峰值">寻找峰值</h3>
<p>题目见 <a href="https://leetcode-cn.com/problems/find-peak-element/">https://leetcode-cn.com/problems/find-peak-element/</a> ，题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不知道确切的值是啥，所以用low&lt;high，当然这里也可以用都闭合的方式。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findPeakElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        nums = [-<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)] + nums + [-<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)] <span class="comment"># 这里加一下，方便操作</span></span><br><span class="line">        low = <span class="number">0</span></span><br><span class="line">        high = <span class="built_in">len</span>(nums) - <span class="number">1</span> <span class="comment"># attention</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; high:</span><br><span class="line">            mid = low + (high - low)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid+<span class="number">1</span>] &gt;= nums[mid]: <span class="comment"># attention</span></span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high = mid</span><br><span class="line">        <span class="keyword">return</span> low - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="有序数组中的单一元素-540">有序数组中的单一元素[540]</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不知道这个数是啥，用low&lt;high</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">singleNonDuplicate</span>(<span class="params">nums</span>):</span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> low &lt; high:</span><br><span class="line">        mid = (high + low) &gt;&gt; <span class="number">1</span></span><br><span class="line">        halvesAreEven = (high - mid) % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == nums[mid + <span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">if</span> halvesAreEven:</span><br><span class="line">                low = low + <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high = mid - <span class="number">1</span> <span class="comment"># 注意不是high=mid</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] == nums[mid - <span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">if</span> halvesAreEven:</span><br><span class="line">                high = mid - <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[mid]</span><br><span class="line">    <span class="keyword">return</span> nums[low]</span><br></pre></td></tr></table></figure>
<h3 id="寻找旋转排序数组中的最小值-153">寻找旋转排序数组中的最小值[153]</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  不知道最小数是啥，用low&lt;high</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMin</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        low, high = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; high:</span><br><span class="line">            pivot = low + (high - low) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[pivot] &lt; nums[high]:<span class="comment"># 这里high改为len(nums)-1也可以</span></span><br><span class="line">                high = pivot</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                low = pivot + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums[low]</span><br></pre></td></tr></table></figure>
<h3 id="寻找旋转排序数组中的最小值-II-154">寻找旋转排序数组中的最小值 II[154]</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  不知道最小数是啥，用low&lt;high</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMin</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(nums)&gt;<span class="number">1</span> <span class="keyword">and</span> nums[<span class="number">0</span>]==nums[-<span class="number">1</span>]: <span class="comment"># 注意</span></span><br><span class="line">            nums.pop()</span><br><span class="line">        low, high = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; high:</span><br><span class="line">            pivot = low + (high - low) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[pivot] &lt; nums[high]:</span><br><span class="line">                high = pivot</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                low = pivot + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums[low]</span><br></pre></td></tr></table></figure>
<h3 id="搜索旋转排序数组-33">搜索旋转排序数组[33]</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 知道搜的是啥，用low&lt;=high</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            mid = (l + r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">if</span> nums[<span class="number">0</span>] &lt;= nums[mid]: <span class="comment"># 这里是&gt;= 不是&gt;</span></span><br><span class="line">                <span class="keyword">if</span> nums[<span class="number">0</span>] &lt;= target &lt; nums[mid]: <span class="comment"># 注意：是小于不是小于等于</span></span><br><span class="line">                    r = mid - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    l = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt; target &lt;= nums[<span class="built_in">len</span>(nums) - <span class="number">1</span>]: <span class="comment"># 左边是开，右边是闭</span></span><br><span class="line">                    l = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r = mid -<span class="number">1</span> </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="搜索旋转排序数组II-81">搜索旋转排序数组II[81]</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 知道搜的是啥，用low&lt;=high</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(nums)&gt;<span class="number">1</span> <span class="keyword">and</span> nums[<span class="number">0</span>]==nums[-<span class="number">1</span>]: <span class="comment"># 加这段代码处理一下重复的问题</span></span><br><span class="line">            nums.pop()</span><br><span class="line">        low = <span class="number">0</span></span><br><span class="line">        high = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">            mid = low + (high -low)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid]==target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span>           </span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt;= nums[<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">if</span> nums[<span class="number">0</span>]&lt;=target&lt;nums[mid]:</span><br><span class="line">                    high = mid - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    low = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid]&lt;nums[<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">if</span> nums[mid]&lt;target&lt;=nums[-<span class="number">1</span>]:</span><br><span class="line">                    low =mid+<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    high=mid-<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="数组中的k-diff数对-532">数组中的k-diff数对[532]</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findPairs</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">import</span> bisect</span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">        nums_set = Counter(nums)</span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">sum</span>([i&gt;<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> nums_set.values()]) <span class="comment"># 注意这里</span></span><br><span class="line"></span><br><span class="line">        nums.sort()</span><br><span class="line">        diff_min, diff_max = nums[<span class="number">0</span>], nums[-<span class="number">1</span>]</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> nums_set.keys():</span><br><span class="line">            index = bisect.bisect_left(nums, j+k)</span><br><span class="line">            <span class="keyword">if</span> index &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">                <span class="keyword">if</span> nums[index] == j+k:</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure>
<p>注意，对于k=0是需要单独计算的，因此需要分开。</p>
<h3 id="数组中的逆序对-LCR-170">数组中的逆序对[LCR 170]</h3>
<p>题目见 <a href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reversePairs</span>(<span class="params">self, record: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">import</span> bisect</span><br><span class="line">        record = record[::-<span class="number">1</span>] <span class="comment"># 这步很重要</span></span><br><span class="line">        res = []</span><br><span class="line">        s = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> record:</span><br><span class="line">            index = bisect.bisect_left(res, i)</span><br><span class="line">            res[index:index] = [i] <span class="comment"># bisect.insort(res, i)也可以</span></span><br><span class="line">            s = s + index</span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>
<p>通过二分查找排序的方法来做的话，更快。看下面这道题是一样的</p>
<h3 id="翻转对-493">翻转对[493]</h3>
<p>题目见 <a href="https://leetcode-cn.com/problems/reverse-pairs/">https://leetcode-cn.com/problems/reverse-pairs/</a> 和上面的题目是一样的，题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reversePairs</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">import</span> bisect</span><br><span class="line">        nums = nums[::-<span class="number">1</span>]</span><br><span class="line">        res = []</span><br><span class="line">        sums = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            index = bisect.bisect_left(res, i) <span class="comment"># 查看插入的位置，就是数量</span></span><br><span class="line">            sums = sums + index <span class="comment"># 累加</span></span><br><span class="line">            index2 = bisect.bisect_left(res, <span class="number">2</span>*i) <span class="comment"># 实际要对res进行处理，加入2*i这个数</span></span><br><span class="line">            res[index2:index2] = [<span class="number">2</span>*i] <span class="comment"># 加入数</span></span><br><span class="line">        <span class="keyword">return</span> sums</span><br></pre></td></tr></table></figure>
<h3 id="计算右侧小于当前元素的个数-315">计算右侧小于当前元素的个数[315]</h3>
<p>题目见 <a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/">https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/</a> 一看题目是没法使用二分查找的，但是只要转换下思路就可以了。<br>
题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countSmaller</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">import</span> bisect</span><br><span class="line">        data = []</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums[::-<span class="number">1</span>]:</span><br><span class="line">            index = bisect.bisect_left(data, i)</span><br><span class="line">            data[index:index] = [i] <span class="comment">#bisect.insort(data, i)也行</span></span><br><span class="line">            res.append(index)</span><br><span class="line">        <span class="keyword">return</span> res[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="马戏团人塔-面试题-17-08">马戏团人塔[面试题 17.08]</h3>
<p>这道题其实就是求最长上升子序列而已，题目见 <a href="https://leetcode-cn.com/problems/circus-tower-lcci/">https://leetcode-cn.com/problems/circus-tower-lcci/</a>  题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 解法1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">import</span> bisect</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bestSeqAtIndex</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>], weight: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:       </span><br><span class="line">       dp=[]</span><br><span class="line">       <span class="keyword">for</span> a,b <span class="keyword">in</span> <span class="built_in">sorted</span>(<span class="built_in">zip</span>(height,weight),key = <span class="keyword">lambda</span> x:[x[<span class="number">0</span>],-x[<span class="number">1</span>]]):</span><br><span class="line">           pos = bisect.bisect_left(dp,b)</span><br><span class="line">           dp[pos:pos+<span class="number">1</span>] = [b]</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">len</span>(dp)</span><br><span class="line"><span class="comment"># 解法2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bestSeqAtIndex</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>], weight: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        hw = <span class="built_in">list</span>(<span class="built_in">zip</span>(height, weight))</span><br><span class="line">        hw.sort(key=<span class="keyword">lambda</span> x:(x[<span class="number">0</span>],-x[<span class="number">1</span>]))</span><br><span class="line">        v = [j[<span class="number">1</span>] <span class="keyword">for</span> j <span class="keyword">in</span> hw]</span><br><span class="line">        stk = []</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> v:</span><br><span class="line">            <span class="keyword">if</span> stk <span class="keyword">and</span> x &lt;= stk[-<span class="number">1</span>]:</span><br><span class="line">                idx = bisect_left(stk, x)</span><br><span class="line">                stk[idx] = x</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stk.append(x)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(stk)</span><br><span class="line"><span class="comment"># 解法3，DP</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">import</span> bisect</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bestSeqAtIndex</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>], weight: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:       </span><br><span class="line">        t = <span class="built_in">sorted</span>(<span class="built_in">zip</span>(height, weight),key=<span class="keyword">lambda</span> x:(x[<span class="number">0</span>],-x[<span class="number">1</span>]))</span><br><span class="line">        new_height = [x[<span class="number">0</span>] <span class="keyword">for</span> x <span class="keyword">in</span> t]</span><br><span class="line">        new_weight = [x[<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> t]</span><br><span class="line">        dp = [<span class="number">1</span>] * <span class="built_in">len</span>(new_weight)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(dp)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                <span class="keyword">if</span> new_weight[i] &gt; new_weight[j]:</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure>
<p>注意这里是[pos:pos+1]和上面的是不一样的</p>
<h3 id="绝对差值和-1818">绝对差值和[1818]</h3>
<p>位于 <a href="https://leetcode.cn/problems/minimum-absolute-sum-difference/description/">https://leetcode.cn/problems/minimum-absolute-sum-difference/description/</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minAbsoluteSumDiff</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        diff = <span class="built_in">sum</span>(<span class="built_in">abs</span>(nums1[i] - nums2[i]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums1)))</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> diff: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ans = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">        nums1_sort = <span class="built_in">sorted</span>(nums1)</span><br><span class="line">        <span class="keyword">import</span> bisect</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums2):</span><br><span class="line">            idx = bisect.bisect_left(nums1_sort, num)</span><br><span class="line">            <span class="keyword">if</span> idx == <span class="built_in">len</span>(nums1):</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, diff - <span class="built_in">abs</span>(nums1[i] - nums2[i]) + <span class="built_in">abs</span>(nums1_sort[idx-<span class="number">1</span>] - nums2[i]))</span><br><span class="line">            <span class="keyword">if</span> idx == <span class="number">0</span>:</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, diff - <span class="built_in">abs</span>(nums1[i] - nums2[i]) + <span class="built_in">abs</span>(nums1_sort[idx] - nums2[i]))</span><br><span class="line">            <span class="keyword">if</span> idx&lt;<span class="built_in">len</span>(nums1) <span class="keyword">and</span> idx&gt;<span class="number">0</span>:</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, diff - <span class="built_in">abs</span>(nums1[i] - nums2[i]) + <span class="built_in">abs</span>(nums1_sort[idx-<span class="number">1</span>] - nums2[i]))</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, diff - <span class="built_in">abs</span>(nums1[i] - nums2[i]) + <span class="built_in">abs</span>(nums1_sort[idx] - nums2[i]))</span><br><span class="line">        <span class="keyword">return</span> ans%(<span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span>)</span><br></pre></td></tr></table></figure>
<p>简化为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minAbsoluteSumDiff</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        diff = <span class="built_in">sum</span>(<span class="built_in">abs</span>(nums1[i] - nums2[i]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums1)))</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> diff: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ans = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">        nums1_sort = <span class="built_in">sorted</span>(nums1)</span><br><span class="line">        <span class="keyword">import</span> bisect</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums2):</span><br><span class="line">            idx = bisect.bisect_left(nums1_sort, num)</span><br><span class="line">            <span class="keyword">if</span> idx:</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, diff - <span class="built_in">abs</span>(nums1[i] - nums2[i]) + <span class="built_in">abs</span>(nums1_sort[idx-<span class="number">1</span>] - nums2[i]))</span><br><span class="line">            <span class="keyword">if</span> idx&lt;<span class="built_in">len</span>(nums1):</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, diff - <span class="built_in">abs</span>(nums1[i] - nums2[i]) + <span class="built_in">abs</span>(nums1_sort[idx] - nums2[i]))</span><br><span class="line">        <span class="keyword">return</span> ans%(<span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span>)</span><br></pre></td></tr></table></figure>
<h3 id="最小差-面试题-16-06">最小差[面试题 16.06]</h3>
<p>题目见 <a href="https://leetcode-cn.com/problems/smallest-difference-lcci/">https://leetcode-cn.com/problems/smallest-difference-lcci/</a> 这道题和<br>
绝对差值和 一样，需要判断插入点的位置，然后再进行判断。<br>
题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自己解法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">smallestDifference</span>(<span class="params">self, a, b</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type a: List[int]</span></span><br><span class="line"><span class="string">        :type b: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">import</span> bisect</span><br><span class="line">        a.sort()</span><br><span class="line">        b.sort()</span><br><span class="line"></span><br><span class="line">        res = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">            index = bisect.bisect_left(b, i)</span><br><span class="line">            <span class="keyword">if</span> index==<span class="built_in">len</span>(b):</span><br><span class="line">                diff = <span class="built_in">abs</span>(i-b[index-<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">elif</span> index == <span class="number">0</span>:</span><br><span class="line">                diff = <span class="built_in">abs</span>(i - b[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">elif</span> index&gt;<span class="number">0</span>:</span><br><span class="line">                diff = <span class="built_in">min</span>(<span class="built_in">abs</span>(i-b[index-<span class="number">1</span>]), <span class="built_in">abs</span>(i-b[index]))</span><br><span class="line">            res = <span class="built_in">min</span>(diff, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="两球之间的磁力-1552-SKIP">两球之间的磁力[1552][SKIP]</h3>
<p>这道题看起来没啥意思，但是却考差了基本的问题的分析能力，以及对二分的应用的能力，题目见 <a href="https://leetcode-cn.com/problems/magnetic-force-between-two-balls/">https://leetcode-cn.com/problems/magnetic-force-between-two-balls/</a> 题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 错误</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDistance</span>(<span class="params">self, position: <span class="type">List</span>[<span class="built_in">int</span>], m: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        position.sort()</span><br><span class="line">        low, high = <span class="number">1</span>, position[-<span class="number">1</span>]- position[<span class="number">0</span>]</span><br><span class="line">        ans = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">mid</span>):</span><br><span class="line">            pre = position[<span class="number">0</span>]</span><br><span class="line">            cnt = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(position)):</span><br><span class="line">                <span class="keyword">if</span> position[i] - pre &gt;= mid:</span><br><span class="line">                    pre = position[i]</span><br><span class="line">                    cnt = cnt + <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> cnt &gt;= m</span><br><span class="line">        <span class="keyword">while</span> low &lt; high:</span><br><span class="line">            mid = low + (high - low) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> check(mid):</span><br><span class="line">                ans = mid</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high = mid</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"><span class="comment"># 正确</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDistance</span>(<span class="params">self, position: <span class="type">List</span>[<span class="built_in">int</span>], m: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        position.sort()</span><br><span class="line">        low, high = <span class="number">1</span>, position[-<span class="number">1</span>]- position[<span class="number">0</span>]</span><br><span class="line">        ans = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">mid</span>):</span><br><span class="line">            pre = position[<span class="number">0</span>]</span><br><span class="line">            cnt = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(position)):</span><br><span class="line">                <span class="keyword">if</span> position[i] - pre &gt;= mid:</span><br><span class="line">                    pre = position[i]</span><br><span class="line">                    cnt = cnt + <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> cnt &gt;= m</span><br><span class="line">        <span class="keyword">while</span> low &lt;= high: <span class="comment">#这里</span></span><br><span class="line">            mid = low + (high - low) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> check(mid):</span><br><span class="line">                ans = mid</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high = mid - <span class="number">1</span> <span class="comment"># 这类</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"><span class="comment"># 或者将错误的那个地方换一下</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDistance</span>(<span class="params">self, position: <span class="type">List</span>[<span class="built_in">int</span>], m: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        position.sort()</span><br><span class="line">        low, high = <span class="number">1</span>, position[-<span class="number">1</span>]- position[<span class="number">0</span>] + <span class="number">1</span> <span class="comment"># 这里</span></span><br><span class="line"></span><br><span class="line">        ans = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">mid</span>):</span><br><span class="line">            pre = position[<span class="number">0</span>]</span><br><span class="line">            cnt = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(position)):</span><br><span class="line">                <span class="keyword">if</span> position[i] - pre &gt;= mid:</span><br><span class="line">                    pre = position[i]</span><br><span class="line">                    cnt = cnt + <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> cnt &gt;= m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> low &lt; high:</span><br><span class="line">            mid = low + (high - low) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> check(mid):</span><br><span class="line">                ans = mid</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high = mid</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>主要的思路就是一个一个试试，看看哪个间隔比较适合，最大的间隔就是position[-1] -position[0],最小的是0，我们一个一个来试一下就可以了。</p>
<h2 id="单数组前缀和">单数组前缀和</h2>
<h3 id="在-D-天内送达包裹的能力-1011">在 D 天内送达包裹的能力[1011]</h3>
<p>这道题相当给一个数组划分为k份，每份的和加起来最小数，题目见 <a href="https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/">https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/</a> ，题目是很好理解的，题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">shipWithinDays</span>(<span class="params">self, weights: <span class="type">List</span>[<span class="built_in">int</span>], days: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">get_shop_times</span>(<span class="params">weights, v</span>):</span><br><span class="line">            need = <span class="number">1</span></span><br><span class="line">            cur = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> weights:</span><br><span class="line">                <span class="keyword">if</span> cur + i &gt; v:</span><br><span class="line">                    need += <span class="number">1</span></span><br><span class="line">                    cur = <span class="number">0</span></span><br><span class="line">                cur += i</span><br><span class="line">            <span class="keyword">return</span> need</span><br><span class="line"></span><br><span class="line">        low = <span class="built_in">max</span>(weights)</span><br><span class="line">        high = <span class="built_in">sum</span>(weights)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> low &lt; high: <span class="comment"># 注意的</span></span><br><span class="line">            mid = (high+low)//<span class="number">2</span></span><br><span class="line">            t = get_shop_times(weights, mid)</span><br><span class="line">            <span class="keyword">if</span> t &lt;= days: <span class="comment"># 压缩右边的</span></span><br><span class="line">                high = mid <span class="comment"># 注意的</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> low</span><br><span class="line">        或者 low&lt;=high 然后 high=mid-<span class="number">1</span>也可以的</span><br></pre></td></tr></table></figure>
<h3 id="最高频元素的频数-1838">最高频元素的频数[1838]</h3>
<p>题目在这里 <a href="https://leetcode-cn.com/problems/frequency-of-the-most-frequent-element/">https://leetcode-cn.com/problems/frequency-of-the-most-frequent-element/</a> 这里我自己做了一种基于二分的，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxFrequency</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        nums.sort()</span><br><span class="line">        low = <span class="number">0</span></span><br><span class="line">        high = <span class="built_in">len</span>(nums)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        prefix = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            prefix.append(prefix[-<span class="number">1</span>] + i)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            low = <span class="number">0</span></span><br><span class="line">            high = i</span><br><span class="line">            <span class="keyword">while</span> low &lt; high:</span><br><span class="line">                mid = (low + high) &gt;&gt; <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> nums[i] * (i - mid + <span class="number">1</span>) - prefix[i + <span class="number">1</span>] + prefix[mid] &lt;= k:</span><br><span class="line">                    high = mid</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    low = mid + <span class="number">1</span></span><br><span class="line">            res = <span class="built_in">max</span>(res, i - low + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>还有双指针的做法，具体如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxFrequency</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        nums.sort()</span><br><span class="line">        i = ans = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 问题转化一下，排序后 nums[j] * (j - i + 1) &lt;= k + presum[j + 1] - presum[i]</span></span><br><span class="line">        <span class="keyword">for</span> j, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            k += num</span><br><span class="line">            <span class="keyword">while</span> k &lt; num * (j - i + <span class="number">1</span>):</span><br><span class="line">                k -= nums[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 对于当前j最远的i</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, j - i + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>其中就是老的思路而已，没有新的变化的，还是注意端点移动的条件。</p>
<h3 id="转变数组后最接近目标值的数组和-1300">转变数组后最接近目标值的数组和[1300]</h3>
<p>题目见 <a href="https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/">https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/</a> 主要的思路是用二分来做，其实主要是找到一个值，让插入后后值全部变成这个值，比如[1,2,3,4,8,9], 我们设置为7，那么在后面的8和9就变成7。还需要注意的是，这里的prefix开始的值要为0，然后进行append才可以。<br>
题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findBestValue</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">import</span> bisect</span><br><span class="line">        n = <span class="built_in">len</span>(arr)</span><br><span class="line">        arr.sort()</span><br><span class="line">        prefix = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">            prefix.append(prefix[-<span class="number">1</span>] + i)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        min_diff = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(arr[-<span class="number">1</span>]+<span class="number">1</span>):</span><br><span class="line">            index = bisect.bisect_left(arr, i)</span><br><span class="line">            sums = prefix[index] + (n-index)*i</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">abs</span>(sums - target) &lt; min_diff:</span><br><span class="line">                min_diff = <span class="built_in">abs</span>(sums - target)</span><br><span class="line">                res = i</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="区间和的个数-327-SKIP">区间和的个数[327][SKIP]</h3>
<p>题目见 <a href="https://leetcode-cn.com/problems/count-of-range-sum/">https://leetcode-cn.com/problems/count-of-range-sum/</a> 题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 暴力</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countRangeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], lower: <span class="built_in">int</span>, upper: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">import</span> bisect</span><br><span class="line">        prefix = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            prefix.append(i + prefix[-<span class="number">1</span>])</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> (prefix[j + <span class="number">1</span>] - prefix[i]) &gt;= lower <span class="keyword">and</span> (prefix[j + <span class="number">1</span>] - prefix[i]) &lt;= upper:</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cnt</span><br><span class="line"><span class="comment"># 通过</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countRangeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], lower: <span class="built_in">int</span>, upper: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        res, pre, now = <span class="number">0</span>, [<span class="number">0</span>], <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            now += n</span><br><span class="line">            res += bisect.bisect_right(pre, now - lower) - bisect.bisect_left(pre, now - upper)</span><br><span class="line">            bisect.insort(pre, now)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"><span class="comment"># AC [通俗版]</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countRangeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], lower: <span class="built_in">int</span>, upper: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        sl = []</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        pre_sum = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            pre_sum.append(pre_sum[-<span class="number">1</span>] + i)</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> pre_sum:</span><br><span class="line">            res += bisect.bisect_right(sl, x - lower) - bisect.bisect_left(sl, x - upper)</span><br><span class="line">            bisect.insort(sl, x)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>乍一想前缀和不是单调的，没法进行插入排序，但这里的思路在于每个循环考虑以该index为结尾的符合条件的数量。这里的解法非常 <a href="https://leetcode.cn/problems/count-of-range-sum/solutions/2417725/sortedlist-da-fa-hao-a-bu-dao-shi-xing-d-7yyh/">https://leetcode.cn/problems/count-of-range-sum/solutions/2417725/sortedlist-da-fa-hao-a-bu-dao-shi-xing-d-7yyh/</a></p>
<h3 id="将-x-减到-0-的最小操作数-1658">将 x 减到 0 的最小操作数[1658]</h3>
<p>题目见 <a href="https://leetcode-cn.com/problems/minimum-operations-to-reduce-x-to-zero/">https://leetcode-cn.com/problems/minimum-operations-to-reduce-x-to-zero/</a> ，解法如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 我的解法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minOperations</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">get_prefix_sum</span>(<span class="params">nums</span>):</span><br><span class="line">            prefix = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">                val = prefix[-<span class="number">1</span>] <span class="keyword">if</span> prefix <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">                prefix.append(i+val)</span><br><span class="line">            <span class="keyword">return</span> prefix</span><br><span class="line"></span><br><span class="line">        res = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            nums2 = nums[<span class="number">0</span>:i][::-<span class="number">1</span>] + nums[i:][::-<span class="number">1</span>]</span><br><span class="line">            prefix = get_prefix_sum(nums2)</span><br><span class="line">            <span class="built_in">print</span>(prefix)</span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">in</span> prefix:</span><br><span class="line">                res = <span class="built_in">min</span>(res, prefix.index(x)+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span> <span class="keyword">if</span> res==<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>) <span class="keyword">else</span> res</span><br><span class="line"><span class="comment"># 正确的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minOperations</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        diff = <span class="built_in">sum</span>(nums) - x</span><br><span class="line">        <span class="keyword">if</span> diff &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="number">0</span></span><br><span class="line">        sm = <span class="number">0</span></span><br><span class="line">        res = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            sm += nums[right]</span><br><span class="line">            <span class="keyword">while</span> sm &gt; diff:</span><br><span class="line">                sm -= nums[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> sm == diff:</span><br><span class="line">                res = <span class="built_in">max</span>(res,right - left + <span class="number">1</span>)</span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span> <span class="keyword">if</span> res==-<span class="number">1</span> <span class="keyword">else</span> <span class="built_in">len</span>(nums)-res</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="和大于等于-target-的最短子数组-LCR-008">和大于等于 target 的最短子数组[LCR 008]</h3>
<p>链接为：<a href="https://leetcode.cn/problems/2VG8Kg/description/">https://leetcode.cn/problems/2VG8Kg/description/</a> 题解如下，注意一下边界的条件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minSubArrayLen</span>(<span class="params">self, target: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">import</span> bisect</span><br><span class="line">        prefix = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            prefix.append(prefix[-<span class="number">1</span>] + i)</span><br><span class="line">        <span class="keyword">if</span> prefix[-<span class="number">1</span>]&lt;target:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        res = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prefix)):</span><br><span class="line">            index = bisect.bisect_left(prefix, prefix[i] + target)</span><br><span class="line">            <span class="keyword">if</span> index != <span class="built_in">len</span>(prefix):           </span><br><span class="line">                res = <span class="built_in">min</span>(index - i, res)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> res==<span class="built_in">len</span>(prefix) <span class="keyword">else</span> res</span><br></pre></td></tr></table></figure>
<p>也可以使用滑窗解法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minSubArrayLen</span>(<span class="params">self, s: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        ans = n + <span class="number">1</span></span><br><span class="line">        start, end = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> end &lt; n:</span><br><span class="line">            total += nums[end]</span><br><span class="line">            <span class="keyword">while</span> total &gt;= s:</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, end - start + <span class="number">1</span>)</span><br><span class="line">                total -= nums[start]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">            end += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> ans == n + <span class="number">1</span> <span class="keyword">else</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="和至少为k的最短子数组-862">和至少为k的最短子数组[862]</h3>
<p>题目见 <a href="https://leetcode-cn.com/problems/shortest-subarray-with-sum-at-least-k/">https://leetcode-cn.com/problems/shortest-subarray-with-sum-at-least-k/</a> 题解用滑窗如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 超时</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">shortestSubarray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        res = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> left <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            right = left</span><br><span class="line">            sm =<span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> right &lt; n:</span><br><span class="line">                sm += nums[right]</span><br><span class="line">                <span class="keyword">while</span> sm &gt;= k:</span><br><span class="line">                    res = <span class="built_in">min</span>(res, right - left + <span class="number">1</span>)</span><br><span class="line">                    sm -= nums[left] </span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span> <span class="keyword">if</span> res==<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>) <span class="keyword">else</span> res</span><br><span class="line"><span class="comment"># 超时2：这个思路要弄懂 模仿区间和的个数区间和的个数来的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">shortestSubarray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">import</span> bisect</span><br><span class="line">        res = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        pre_sum = [[<span class="number">0</span>, cnt]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums) + <span class="number">1</span>):</span><br><span class="line">            pre_sum.append([pre_sum[-<span class="number">1</span>][<span class="number">0</span>] + nums[i - <span class="number">1</span>], i])</span><br><span class="line">        pre_sum.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> pre_sum:</span><br><span class="line">            cur_val = i[<span class="number">0</span>]</span><br><span class="line">            index = bisect.bisect_left(pre_sum, [cur_val + k, <span class="number">0</span>])</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(index, <span class="built_in">len</span>(pre_sum)):</span><br><span class="line">                <span class="keyword">if</span> j &lt;= <span class="built_in">len</span>(nums) <span class="keyword">and</span> pre_sum[j][<span class="number">0</span>] &gt;= cur_val + k <span class="keyword">and</span> pre_sum[j][<span class="number">1</span>] - i[<span class="number">1</span>] &gt;= <span class="number">0</span>:</span><br><span class="line">                    res = <span class="built_in">min</span>(res, pre_sum[j][<span class="number">1</span>] - i[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span> res==<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>):</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"><span class="comment"># 超时的原因在于有多个循环，其实看下面的结果也是有多个循环，  也就是1个for里面加了两个while, 不过计算的时候，是通过单调队列来做的，减少了滑窗计算的时间而已。这里和滑窗窗口的最大值是一样的。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">shortestSubarray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">import</span> collections</span><br><span class="line">        prefix = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            prefix.append(prefix[-<span class="number">1</span>] + i)</span><br><span class="line">        stack = collections.deque()</span><br><span class="line">        ans = <span class="built_in">len</span>(nums) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">enumerate</span>(prefix):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> y &lt;= prefix[stack[-<span class="number">1</span>]]:</span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> y - prefix[stack[<span class="number">0</span>]] &gt;= k:</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, x - stack.popleft()) </span><br><span class="line">            stack.append(x)</span><br><span class="line">        <span class="keyword">return</span> ans <span class="keyword">if</span> ans &lt; <span class="built_in">len</span>(nums) + <span class="number">1</span> <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>这道题和上面的那道题不一样，在于这道题有负数，导致前缀和非单调，无法用滑窗以及直接用二分来做。</p>
<h2 id="双数组">双数组</h2>
<h3 id="寻找两个正序数组的中位数-4">寻找两个正序数组的中位数[4]</h3>
<p>题目见 <a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">https://leetcode-cn.com/problems/median-of-two-sorted-arrays/</a> ，题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 解法1，使用双指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMedianSortedArrays</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        m = <span class="built_in">len</span>(nums1)</span><br><span class="line">        n = <span class="built_in">len</span>(nums2)</span><br><span class="line">        lens = m + n</span><br><span class="line">        prev = -<span class="number">1</span></span><br><span class="line">        now = -<span class="number">1</span></span><br><span class="line">        num1_index = <span class="number">0</span></span><br><span class="line">        num2_index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(lens//<span class="number">2</span>+<span class="number">1</span>):</span><br><span class="line">            prev = now</span><br><span class="line">            <span class="keyword">if</span> num1_index&lt;m <span class="keyword">and</span> (num2_index&gt;=n <span class="keyword">or</span> nums1[num1_index]&lt;nums2[num2_index]):</span><br><span class="line">                now = nums1[num1_index]</span><br><span class="line">                num1_index += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                now = nums2[num2_index]</span><br><span class="line">                num2_index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> lens &amp; <span class="number">1</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> (prev + now)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> now</span><br><span class="line"><span class="comment"># 解法2：使用二分查找</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMedianSortedArrays</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        n1 = <span class="built_in">len</span>(nums1)</span><br><span class="line">        n2 = <span class="built_in">len</span>(nums2)</span><br><span class="line">        <span class="keyword">if</span> n1 &gt; n2:</span><br><span class="line">            <span class="keyword">return</span> self.findMedianSortedArrays(nums2, nums1)</span><br><span class="line"></span><br><span class="line">        k = (n1 + n2 + <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = n1</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            m1 = left + (right - left) // <span class="number">2</span>    </span><br><span class="line">            m2 = k - m1                        <span class="comment"># </span></span><br><span class="line">            <span class="keyword">if</span> nums1[m1] &lt; nums2[m2 - <span class="number">1</span>]:      <span class="comment"># 注意</span></span><br><span class="line">                left = m1 + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = m1</span><br><span class="line"></span><br><span class="line">        m1 = left <span class="comment"># 算出的m是第2个数，如果是&amp;1=1的话，直接取m-1，不是的话，取m-1和m的均值</span></span><br><span class="line">        m2 = k - m1</span><br><span class="line">        </span><br><span class="line">        c1 = <span class="built_in">max</span>(<span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>) <span class="keyword">if</span> m1 &lt;= <span class="number">0</span> <span class="keyword">else</span> nums1[m1 - <span class="number">1</span>], <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>) <span class="keyword">if</span> m2 &lt;= <span class="number">0</span> <span class="keyword">else</span> nums2[m2 - <span class="number">1</span>]) <span class="comment"># 情况1,容易写错为m1</span></span><br><span class="line">        <span class="keyword">if</span> (n1 + n2) % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> c1</span><br><span class="line"></span><br><span class="line">        c2 = <span class="built_in">min</span>(<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">if</span> m1 &gt;= n1 <span class="keyword">else</span> nums1[m1], <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">if</span> m2 &gt;= n2 <span class="keyword">else</span> nums2[m2]) <span class="comment"># 情况2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (c1 + c2) / <span class="number">2</span></span><br><span class="line"><span class="comment"># 自己做法</span></span><br><span class="line">A = [<span class="number">1</span>]</span><br><span class="line">B = [<span class="number">2</span>]</span><br><span class="line">nums = []</span><br><span class="line">left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> left &lt; <span class="built_in">len</span>(A) <span class="keyword">and</span> right &lt; <span class="built_in">len</span>(B):</span><br><span class="line">    <span class="keyword">if</span> A[left] &lt; B[right]:</span><br><span class="line">        nums.append(A[left])</span><br><span class="line">        left += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        nums.append(B[right])</span><br><span class="line">        right += <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> left &gt;= <span class="built_in">len</span>(A):</span><br><span class="line">    nums.extend(B[right:])</span><br><span class="line"><span class="keyword">if</span> right &gt;= <span class="built_in">len</span>(B):</span><br><span class="line">    nums.extend(A[left:])</span><br><span class="line"><span class="built_in">print</span>(nums)</span><br></pre></td></tr></table></figure>
<p>可以从 <a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/solutions/8999/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/">https://leetcode.cn/problems/median-of-two-sorted-arrays/solutions/8999/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/</a> 查看。二分的思路在 <a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/solutions/3983/shuang-zhi-zhen-by-powcai/">https://leetcode.cn/problems/median-of-two-sorted-arrays/solutions/3983/shuang-zhi-zhen-by-powcai/</a></p>
<h3 id="尽可能使字符串相等-1208">尽可能使字符串相等[1208]</h3>
<p>题目见 <a href="https://leetcode-cn.com/problems/get-equal-substrings-within-budget/%EF%BC%8C">https://leetcode-cn.com/problems/get-equal-substrings-within-budget/，</a> 题解如下，建议使用双指针啊，比较快的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">equalSubstring</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span>, maxCost: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        diff = [<span class="built_in">abs</span>(<span class="built_in">ord</span>(i)-<span class="built_in">ord</span>(j)) <span class="keyword">for</span> i,j <span class="keyword">in</span> <span class="built_in">zip</span>(s,t)]</span><br><span class="line">        start = end = res = <span class="number">0</span></span><br><span class="line">        ds = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> end &lt; <span class="built_in">len</span>(diff):</span><br><span class="line">            ds += diff[end]</span><br><span class="line">            <span class="keyword">while</span> ds &gt; maxCost:</span><br><span class="line">                ds -= diff[start]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">            res = <span class="built_in">max</span>(res, end - start + <span class="number">1</span>)</span><br><span class="line">            end += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>二分查找的思路也是比较简单的，主要如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">equalSubstring</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span>, maxCost: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        accDiff = [<span class="number">0</span>] + <span class="built_in">list</span>(accumulate(<span class="built_in">abs</span>(<span class="built_in">ord</span>(sc) - <span class="built_in">ord</span>(tc)) <span class="keyword">for</span> sc, tc <span class="keyword">in</span> <span class="built_in">zip</span>(s, t)))</span><br><span class="line">        maxLength = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            start = bisect.bisect_left(accDiff, accDiff[i] - maxCost)</span><br><span class="line">            maxLength = <span class="built_in">max</span>(maxLength, i - start)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxLength</span><br></pre></td></tr></table></figure>
<h3 id="水位上升的泳池中游泳-778">水位上升的泳池中游泳[778]</h3>
<p>题目见 <a href="https://leetcode-cn.com/problems/swim-in-rising-water/">https://leetcode-cn.com/problems/swim-in-rising-water/</a> 主要的思路就是找一个值，小于这个值的地方可以连通起来，最后能连通到最后的点的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">swimInWater</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">temp, x,y</span>):</span><br><span class="line">            <span class="keyword">if</span> x&lt;<span class="number">0</span> <span class="keyword">or</span> x&gt;=<span class="built_in">len</span>(temp) <span class="keyword">or</span> y&lt;<span class="number">0</span> <span class="keyword">or</span> y&gt;=<span class="built_in">len</span>(temp[<span class="number">0</span>]):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> temp[x][y]==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> x==<span class="built_in">len</span>(temp)-<span class="number">1</span> <span class="keyword">and</span> y==<span class="built_in">len</span>(temp[<span class="number">0</span>])-<span class="number">1</span> <span class="keyword">and</span> temp[x][y]==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            temp[x][y] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i,j <span class="keyword">in</span> [[x+<span class="number">1</span>,y],[x,y+<span class="number">1</span>],[x-<span class="number">1</span>,y],[x,y-<span class="number">1</span>]]:</span><br><span class="line">                <span class="keyword">if</span> dfs(temp,i,j):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="comment">#  dfs(temp,i,j): 直接这么写的话是错误的</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        grid_list = <span class="built_in">sum</span>(grid, [])</span><br><span class="line">        grid_list = <span class="built_in">sum</span>(grid, [])</span><br><span class="line">        low = <span class="built_in">min</span>(grid_list)</span><br><span class="line">        high = <span class="built_in">max</span>(grid_list)</span><br><span class="line">        <span class="keyword">while</span> low &lt; high:</span><br><span class="line">            mid = (low + high) &gt;&gt; <span class="number">1</span></span><br><span class="line">            temp = [[<span class="number">1</span> <span class="keyword">if</span> j &lt;= mid <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> i] <span class="keyword">for</span> i <span class="keyword">in</span> grid]</span><br><span class="line">            <span class="keyword">if</span> dfs(temp, <span class="number">0</span>, <span class="number">0</span>):</span><br><span class="line">                high = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> low</span><br></pre></td></tr></table></figure>
<h3 id="绝对差值和">绝对差值和</h3>
<p>题目见 <a href="https://leetcode-cn.com/problems/minimum-absolute-sum-difference/submissions/">https://leetcode-cn.com/problems/minimum-absolute-sum-difference/submissions/</a> 题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minAbsoluteSumDiff</span>(<span class="params">self, nums1, nums2</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">import</span> bisect</span><br><span class="line">        temp = [<span class="built_in">abs</span>(nums1[i] - nums2[i]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums1))]</span><br><span class="line">        abs_sum = <span class="built_in">sum</span>(temp)</span><br><span class="line"></span><br><span class="line">        nums11 = <span class="built_in">sorted</span>(nums1)</span><br><span class="line"></span><br><span class="line">        res = abs_sum</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums2):</span><br><span class="line">            index = bisect.bisect(nums11, j)</span><br><span class="line">            <span class="keyword">if</span> index &lt; <span class="built_in">len</span>(nums11):</span><br><span class="line">                res = <span class="built_in">min</span>(res, abs_sum - <span class="built_in">abs</span>(nums1[i]-nums2[i]) + <span class="built_in">abs</span>(nums11[index]-nums2[i]))</span><br><span class="line">            <span class="keyword">if</span> index &gt; <span class="number">0</span>:</span><br><span class="line">                res = <span class="built_in">min</span>(res, abs_sum - <span class="built_in">abs</span>(nums1[i]-nums2[i]) + <span class="built_in">abs</span>(nums11[index-<span class="number">1</span>]-nums2[i]))</span><br><span class="line">        <span class="keyword">return</span> res% (<span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里需要注意的是，要查看需要插入数值的位置，查看其前后的位置，是不是有让绝对值更小的值。</p>
<h3 id="交换和-面试题-16-21">交换和[面试题 16.21]</h3>
<p>这道题和上面的是类似的，在得到index后需要判断位置，是不行越界了。题目在 <a href="https://leetcode-cn.com/problems/sum-swap-lcci/">https://leetcode-cn.com/problems/sum-swap-lcci/</a> 题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findSwapValues</span>(<span class="params">self, array1, array2</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type array1: List[int]</span></span><br><span class="line"><span class="string">        :type array2: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">import</span> bisect</span><br><span class="line">        array1.sort()</span><br><span class="line">        array2.sort()</span><br><span class="line"></span><br><span class="line">        sum1 = <span class="built_in">sum</span>(array1)</span><br><span class="line">        sum2 = <span class="built_in">sum</span>(array2)</span><br><span class="line"></span><br><span class="line">        diff = sum2 - sum1</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> diff % <span class="number">2</span> !=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> array1:</span><br><span class="line">            index = bisect.bisect_left(array2, i + diff // <span class="number">2</span>)</span><br><span class="line">            index = <span class="built_in">min</span>(<span class="built_in">len</span>(array2)-<span class="number">1</span>, index) <span class="comment">#dasdsdsa</span></span><br><span class="line">            <span class="keyword">if</span> array2[index] == i + diff // <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> [i, i + diff // <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>
<h3 id="得到子序列的最少操作次数-1713">得到子序列的最少操作次数[1713]</h3>
<p>题目见 <a href="https://leetcode-cn.com/problems/minimum-operations-to-make-a-subsequence/">https://leetcode-cn.com/problems/minimum-operations-to-make-a-subsequence/</a> 这里的题目和最长上升子序列的思路基本上是一样的，可以看 <a href="https://leetcode-cn.com/problems/minimum-operations-to-make-a-subsequence/solution/mo-gu-qie-cha-cong-lcswen-ti-dao-liswen-xist8/">https://leetcode-cn.com/problems/minimum-operations-to-make-a-subsequence/solution/mo-gu-qie-cha-cong-lcswen-ti-dao-liswen-xist8/</a> 的讲解，说的很清楚，总结来说就是一个如下的思路</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minOperations</span>(<span class="params">self, target: <span class="type">List</span>[<span class="built_in">int</span>], arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        posTa = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, t <span class="keyword">in</span> <span class="built_in">enumerate</span>(target):</span><br><span class="line">            posTa[t] = i</span><br><span class="line">        posAr = []</span><br><span class="line">        <span class="keyword">for</span> i, a <span class="keyword">in</span> <span class="built_in">enumerate</span>(arr):</span><br><span class="line">            <span class="keyword">if</span> a <span class="keyword">in</span> posTa:</span><br><span class="line">                posAr.append(posTa[a])</span><br><span class="line">        <span class="comment"># 算出来出现的索引就可以了，然后就是求解了</span></span><br><span class="line">        stk = []</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> posAr:</span><br><span class="line">            <span class="keyword">if</span> stk <span class="keyword">and</span> x &lt;= stk[-<span class="number">1</span>]:</span><br><span class="line">                idx = bisect_left(stk, x)</span><br><span class="line">                stk[idx] = x</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stk.append(x)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(target) - <span class="built_in">len</span>(stk)</span><br></pre></td></tr></table></figure>
<h2 id="矩阵">矩阵</h2>
<h3 id="二维数组中的查找-LCR-121">二维数组中的查找[LCR.121]</h3>
<p>题目见 <a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/</a> 题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findNumberIn2DArray</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        i, j = <span class="built_in">len</span>(matrix) - <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(matrix[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j] &gt; target: i -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> matrix[i][j] &lt; target: j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>有个人总结的比较好，题解在 <a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/solution/yu-niang-niang-04er-wei-shu-zu-zhong-de-vpcs9/">https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/solution/yu-niang-niang-04er-wei-shu-zu-zhong-de-vpcs9/</a> 讲解了多个方法</p>
<h3 id="搜索二维矩阵-74">搜索二维矩阵[74]</h3>
<p>题目见 <a href="https://leetcode-cn.com/problems/search-a-2d-matrix/">https://leetcode-cn.com/problems/search-a-2d-matrix/</a> 和上面的不一样，这个矩阵的展开收拾递增的，因此可以使用查找的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchMatrix</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        low = <span class="number">0</span></span><br><span class="line">        m = <span class="built_in">len</span>(matrix)</span><br><span class="line">        n = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        high = m * n - <span class="number">1</span> <span class="comment"># 如果这里改成了m*n的话，那么后面的最好用low&lt;high</span></span><br><span class="line">        <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">            mid = low + (high-low)//<span class="number">2</span></span><br><span class="line">            row = mid//n</span><br><span class="line">            col = mid%n</span><br><span class="line">            <span class="keyword">if</span> matrix[row][col] &gt; target:</span><br><span class="line">                high = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> matrix[row][col] &lt; target:</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="统计有序矩阵中的负数-1351">统计有序矩阵中的负数[1351]</h3>
<p>题目见 <a href="https://leetcode-cn.com/problems/count-negative-numbers-in-a-sorted-matrix/">https://leetcode-cn.com/problems/count-negative-numbers-in-a-sorted-matrix/</a> 题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countNegatives</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        end = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(grid):</span><br><span class="line">            <span class="keyword">if</span> grid[i][-<span class="number">1</span>]&lt;<span class="number">0</span>:</span><br><span class="line">                index = bisect.bisect_right([-j <span class="keyword">for</span> j <span class="keyword">in</span> grid[i]],<span class="number">0</span>)</span><br><span class="line">                res += <span class="built_in">len</span>(grid[<span class="number">0</span>]) - index</span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="螺旋矩阵-54">螺旋矩阵[54]</h3>
<p>题号为54，位于<a href="https://leetcode.cn/problems/spiral-matrix/description/">https://leetcode.cn/problems/spiral-matrix/description/</a> 题解如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">spiralOrder</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(matrix)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> matrix[<span class="number">0</span>]</span><br><span class="line">        directions = [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, -<span class="number">1</span>), (-<span class="number">1</span>, <span class="number">0</span>)]</span><br><span class="line">        row, col, direction_index = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        res = []</span><br><span class="line">        m = <span class="built_in">len</span>(matrix)</span><br><span class="line">        n = <span class="built_in">len</span>(matrix[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m * n):</span><br><span class="line">            res.append(matrix[row][col])</span><br><span class="line">            matrix[row][col] = -<span class="number">999999999</span></span><br><span class="line">            next_row = row + directions[direction_index % <span class="number">4</span>][<span class="number">0</span>]</span><br><span class="line">            next_col = col + directions[direction_index % <span class="number">4</span>][<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> next_row &lt; <span class="number">0</span> <span class="keyword">or</span> next_row &gt;= m <span class="keyword">or</span> next_col &lt; <span class="number">0</span> <span class="keyword">or</span> next_col &gt;= n <span class="keyword">or</span> matrix[next_row][next_col] == -<span class="number">999999999</span>:</span><br><span class="line">                direction_index = direction_index + <span class="number">1</span></span><br><span class="line">                next_row = row + directions[direction_index % <span class="number">4</span>][<span class="number">0</span>]</span><br><span class="line">                next_col = col + directions[direction_index % <span class="number">4</span>][<span class="number">1</span>]</span><br><span class="line">            row, col = next_row, next_col</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>上下两道题用的是同样的思路，这样比较好统一</p>
<h3 id="螺旋矩阵II-59">螺旋矩阵II[59]</h3>
<p>题号为59，位于 <a href="https://leetcode.cn/problems/spiral-matrix-ii/description/">https://leetcode.cn/problems/spiral-matrix-ii/description/</a>  题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateMatrix</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        directions = [(<span class="number">0</span>,<span class="number">1</span>),(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,-<span class="number">1</span>),(-<span class="number">1</span>,<span class="number">0</span>)]</span><br><span class="line">        matrix = [[-<span class="number">1</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        row, col, direc_index = <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n*n):</span><br><span class="line">            matrix[row][col] = i + <span class="number">1</span></span><br><span class="line">            next_row = row + directions[direc_index%<span class="number">4</span>][<span class="number">0</span>]</span><br><span class="line">            next_col = row + directions[direc_index%<span class="number">4</span>][<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> next_row &lt; <span class="number">0</span> <span class="keyword">or</span> next_row &gt;= n <span class="keyword">or</span> next_col &lt; <span class="number">0</span> <span class="keyword">or</span> next_row &gt;= n <span class="keyword">or</span> matrix[next_row][next_col] &gt; -<span class="number">1</span>:</span><br><span class="line">                direc_index = direc_index + <span class="number">1</span></span><br><span class="line">                next_row = row + directions[direc_index%<span class="number">4</span>][<span class="number">0</span>]</span><br><span class="line">                next_col = row + directions[direc_index%<span class="number">4</span>][<span class="number">1</span>]</span><br><span class="line">            row, col = next_row, next_col</span><br><span class="line">        <span class="keyword">return</span> matrix</span><br></pre></td></tr></table></figure>
<p>注意具体的思路是先便利，然后换方向</p>
<h3 id="螺旋矩阵III-885">螺旋矩阵III[885]</h3>
<p>题号为885，位于 <a href="https://leetcode.cn/problems/spiral-matrix-iii/description/">https://leetcode.cn/problems/spiral-matrix-iii/description/</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">spiralMatrixIII</span>(<span class="params">self, rows: <span class="built_in">int</span>, cols: <span class="built_in">int</span>, rStart: <span class="built_in">int</span>, cStart: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]: </span><br><span class="line">        visited_flag = [[<span class="literal">False</span>] * cols <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(rows)]</span><br><span class="line">        directions = [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, -<span class="number">1</span>), (-<span class="number">1</span>, <span class="number">0</span>)]</span><br><span class="line">        direction_index = -<span class="number">1</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        init_lens = <span class="number">0</span></span><br><span class="line">        res = []</span><br><span class="line">        res.append([rStart, cStart])</span><br><span class="line">        <span class="keyword">while</span> cnt + <span class="number">1</span> &lt; rows * cols:</span><br><span class="line">            init_lens = init_lens + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            direction_index = direction_index + <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j1 <span class="keyword">in</span> <span class="built_in">range</span>(init_lens):</span><br><span class="line">                next_r = rStart + directions[direction_index % <span class="number">4</span>][<span class="number">0</span>]</span><br><span class="line">                next_c = cStart + directions[direction_index % <span class="number">4</span>][<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> next_r &lt; <span class="number">0</span> <span class="keyword">or</span> next_r &gt;= rows <span class="keyword">or</span> next_c &lt; <span class="number">0</span> <span class="keyword">or</span> next_c &gt;= cols <span class="keyword">or</span> visited_flag[next_r][next_c]:</span><br><span class="line">                    rStart = next_r</span><br><span class="line">                    cStart = next_c</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res.append([next_r, next_c])</span><br><span class="line">                    rStart = next_r</span><br><span class="line">                    cStart = next_c</span><br><span class="line">                    visited_flag[next_r][next_c] = <span class="literal">True</span></span><br><span class="line">                    cnt = cnt + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            direction_index = direction_index + <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j2 <span class="keyword">in</span> <span class="built_in">range</span>(init_lens):</span><br><span class="line">                next_r = rStart + directions[direction_index % <span class="number">4</span>][<span class="number">0</span>]</span><br><span class="line">                next_c = cStart + directions[direction_index % <span class="number">4</span>][<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> next_r &lt; <span class="number">0</span> <span class="keyword">or</span> next_r &gt;= rows <span class="keyword">or</span> next_c &lt; <span class="number">0</span> <span class="keyword">or</span> next_c &gt;= cols <span class="keyword">or</span> visited_flag[next_r][next_c]:</span><br><span class="line">                    rStart = next_r</span><br><span class="line">                    cStart = next_c</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res.append([next_r, next_c])</span><br><span class="line">                    rStart = next_r</span><br><span class="line">                    cStart = next_c</span><br><span class="line">                    visited_flag[next_r][next_c] = <span class="literal">True</span></span><br><span class="line">                    cnt = cnt + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>主要思路就是分析题目，其实每个固定的长度比如走1格子，其实是分为两个角度来走的，那么整体上就是1步往右，1步往下，2步往左，2步往上。依次这样来再结合判断条件。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>题目汇总</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2024/03/19/leetcode/binary_tree/</url>
    <content><![CDATA[<h1>总结</h1>
<h2 id="大纲">大纲</h2>
<p><img src="https://note.youdao.com/yws/res/9196/WEBRESOURCE074bd40e4844194049d30d776bac9322" alt="微信截图_20231210121917.png"></p>
<h2 id="相关细节">相关细节</h2>
<ol>
<li>夹在state.append和dfs(root, state)中间的判断是否target_sum正确的时候，不需要加return，不然会导致运行结果的问题。</li>
</ol>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">binaryTreePaths</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root, state</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            state.append(root.val)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                res.append(state[:]) <span class="comment"># 这里不要return</span></span><br><span class="line">            dfs(root.left, state)</span><br><span class="line">            dfs(root.right, state)</span><br><span class="line">            state.pop()</span><br><span class="line">        dfs(root, [])</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&quot;-&gt;&quot;</span>.join([<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> s]) <span class="keyword">for</span> s <span class="keyword">in</span> res]</span><br></pre></td></tr></table></figure>
<h1>遍历操作</h1>
<h2 id="介绍">介绍</h2>
<p>树结构如下<br>
<img src="https://upload-images.jianshu.io/upload_images/2405011-5f5b0b136713f744.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" width="50%" height="auto"></p>
<p>先序：1 2 4 6 7 8 3 5<br>
中序：4 7 6 8 2 1 3 5<br>
后序：7 8 6 4 2 5 3 1</p>
<h2 id="递归">递归</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root = TreeNode(<span class="number">1</span>, left=TreeNode(<span class="number">2</span>, left=TreeNode(<span class="number">3</span>), right=TreeNode(<span class="number">4</span>)),</span><br><span class="line">                right=TreeNode(<span class="number">5</span>, left=TreeNode(<span class="number">6</span>), right=TreeNode(<span class="number">7</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 前序遍历</span></span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">preOrder</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    res.append(root.val)</span><br><span class="line">    preOrder(root.left)</span><br><span class="line">    preOrder(root.right)</span><br><span class="line">preOrder(root)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;前序结果是：&quot;</span>, res)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 中序遍历</span></span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inOrder</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    inOrder(root.left)</span><br><span class="line">    res.append(root.val)</span><br><span class="line">    inOrder(root.right)</span><br><span class="line">inOrder(root)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;中序结果是：&quot;</span>, res)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 后序遍历</span></span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">postOrder</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    postOrder(root.left)</span><br><span class="line">    postOrder(root.right)</span><br><span class="line">    res.append(root.val)</span><br><span class="line">postOrder(root)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;后序结果是：&quot;</span>, res)</span><br></pre></td></tr></table></figure>
<h2 id="迭代">迭代</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root = TreeNode(<span class="number">1</span>, left=TreeNode(<span class="number">2</span>, left=TreeNode(<span class="number">3</span>), right=TreeNode(<span class="number">4</span>)),</span><br><span class="line">                right=TreeNode(<span class="number">5</span>, left=TreeNode(<span class="number">6</span>), right=TreeNode(<span class="number">7</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 前序</span></span><br><span class="line">stack = [root]</span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">while</span> stack:</span><br><span class="line">    node = stack.pop()</span><br><span class="line">    res.append(node.val)</span><br><span class="line">    <span class="keyword">if</span> node.right:</span><br><span class="line">        stack.append(node.right)</span><br><span class="line">    <span class="keyword">if</span> node.left:</span><br><span class="line">        stack.append(node.left)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;前序结果是：&quot;</span>, res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后序</span></span><br><span class="line">stack = [root]</span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">while</span> stack:</span><br><span class="line">    node = stack.pop()</span><br><span class="line">    res.append(node.val)</span><br><span class="line">    <span class="keyword">if</span> node.left:</span><br><span class="line">        stack.append(node.left)</span><br><span class="line">    <span class="keyword">if</span> node.right:</span><br><span class="line">        stack.append(node.right)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;后序结果是：&quot;</span>, res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 中序,注意这里不能直接将root加入进去</span></span><br><span class="line">stack = []</span><br><span class="line">cur = root</span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">while</span> stack <span class="keyword">or</span> cur: </span><br><span class="line">    <span class="keyword">if</span> cur:</span><br><span class="line">        stack.append(cur)</span><br><span class="line">        cur = cur.left</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        cur = stack.pop()</span><br><span class="line">        res.append(cur.val)</span><br><span class="line">        cur = cur.right</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;中序结果是：&quot;</span>, res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 层序遍历</span></span><br><span class="line"><span class="keyword">from</span> _collections <span class="keyword">import</span> deque</span><br><span class="line">queue = deque([root])</span><br><span class="line"><span class="keyword">while</span> queue:</span><br><span class="line">    temp = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">        node = queue.popleft()</span><br><span class="line">        temp.append(node.val)</span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            queue.append(node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            queue.append(node.right)</span><br><span class="line">    <span class="built_in">print</span>(temp)</span><br><span class="line"><span class="comment"># 层序遍历2</span></span><br><span class="line"><span class="keyword">from</span> _collections <span class="keyword">import</span> deque</span><br><span class="line">queue = deque([root])</span><br><span class="line"><span class="keyword">while</span> queue:</span><br><span class="line">    temp = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">        node = queue.popleft()</span><br><span class="line">        <span class="keyword">if</span> node:</span><br><span class="line">            temp.append(node.val)</span><br><span class="line">            queue.append(node.left)</span><br><span class="line">            queue.append(node.right)</span><br><span class="line">    <span class="built_in">print</span>(temp)</span><br></pre></td></tr></table></figure>
<p>需要注意层序遍历1和层序遍历2的区别，层序遍历1中的queue只添加一些非None的节点，而层序遍历2中的话，连一些为None的节点也会添加，这点在对称二叉树中会用到第二种方法。</p>
<h1>结构操作</h1>
<h2 id="翻转二叉树-226">翻转二叉树[226]</h2>
<p>迭代题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">invertTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        queue = deque([root])</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">                node.left, node.right = node.right, node.left</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p>递归解法如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">invertTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        root.left, root.right = root.right, root.left</span><br><span class="line">        self.invertTree(root.left)</span><br><span class="line">        self.invertTree(root.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h2 id="对称二叉树-101">对称二叉树[101]</h2>
<p>迭代解法如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSymmetric</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">from</span> _collections <span class="keyword">import</span> deque</span><br><span class="line">        queue = deque([root])</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            res = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> node:</span><br><span class="line">                    res.append(node.val)</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res.append(<span class="literal">None</span>)</span><br><span class="line">            <span class="keyword">if</span> res != res[::-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>递归解法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSymmetric</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">p,q</span>):</span><br><span class="line">            <span class="keyword">if</span> p <span class="keyword">and</span> <span class="keyword">not</span> q:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">and</span> q:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">and</span> <span class="keyword">not</span> q:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> p.val != q.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> check(p.left, q.right) <span class="keyword">and</span> check(p.right, q.left)       </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> check(root, root)</span><br></pre></td></tr></table></figure>
<p>这题主要要单独开一个sub-function出来操作。</p>
<h2 id="平衡二叉树-110">平衡二叉树[110]</h2>
<p>递归解法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isBalanced</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">get_height</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(get_height(root.left), get_height(root.right))</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(get_height(root.left) - get_height(root.right)) &lt;=<span class="number">1</span> <span class="keyword">and</span> self.isBalanced(root.left) <span class="keyword">and</span> self.isBalanced(root.right)</span><br></pre></td></tr></table></figure>
<p>优化完后的递归的解法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isBalanced</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">recu</span>(<span class="params">root</span>):</span><br><span class="line">          <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">          left = recu(root.left)</span><br><span class="line">          <span class="keyword">if</span> left==-<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">          right = recu(root.right)</span><br><span class="line">          <span class="keyword">if</span> right==-<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">max</span>(left, right) + <span class="number">1</span> <span class="keyword">if</span> <span class="built_in">abs</span>(left-right)&lt;=<span class="number">1</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> recu(root)!=-<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h1>深度和高度</h1>
<h2 id="完全二叉树的节点个数-222">完全二叉树的节点个数[222]</h2>
<p>迭代解法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countNodes</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">      <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">      queue = deque([root])</span><br><span class="line">      cnt = <span class="number">0</span></span><br><span class="line">      <span class="keyword">while</span> queue:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">              queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">              queue.append(node.right)</span><br><span class="line">      <span class="keyword">return</span> cnt        </span><br></pre></td></tr></table></figure>
<p>递归解法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.cnt = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countNodes</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        self.cnt += <span class="number">1</span></span><br><span class="line">        self.countNodes(root.left)</span><br><span class="line">        self.countNodes(root.right)</span><br><span class="line">        <span class="keyword">return</span> self.cnt</span><br></pre></td></tr></table></figure>
<h2 id="二叉树最大高度-104">二叉树最大高度[104]</h2>
<p>迭代解法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        queue = deque([root])</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            temp = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                temp.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">            res.append(temp)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(res)</span><br></pre></td></tr></table></figure>
<p>递归法如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(self.maxDepth(root.left), self.maxDepth(root.right))</span><br></pre></td></tr></table></figure>
<h2 id="二叉树最小深度-111">二叉树最小深度[111]</h2>
<p>迭代法如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        queue = deque([root])</span><br><span class="line">        min_depth = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            min_depth += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> node.left==<span class="literal">None</span> <span class="keyword">and</span> node.right==<span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">return</span> min_depth</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> minDepth</span><br></pre></td></tr></table></figure>
<p>递归法如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + self.minDepth(root.right) <span class="comment"># 容易写成不加1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.right <span class="keyword">and</span> root.left:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + self.minDepth(root.left)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">min</span>(self.minDepth(root.left), self.minDepth(root.right))</span><br></pre></td></tr></table></figure>
<h1>路径问题</h1>
<h2 id="二叉树的所有路径-257">二叉树的所有路径[257]</h2>
<p>迭代解法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">binaryTreePaths</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">          <span class="keyword">return</span> [<span class="built_in">str</span>(root.val)]</span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        queue = deque([root])</span><br><span class="line">        queue2 = [<span class="built_in">str</span>(root.val)]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">              node = queue.popleft()</span><br><span class="line">              node_value = queue2.pop(<span class="number">0</span>)</span><br><span class="line">              <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                  res.append(node_value)</span><br><span class="line">              <span class="keyword">if</span> node.left:</span><br><span class="line">                  queue.append(node.left)</span><br><span class="line">                  queue2.append(<span class="built_in">str</span>(node_value) + <span class="string">&quot;-&gt;&quot;</span> + <span class="built_in">str</span>(node.left.val))</span><br><span class="line">              <span class="keyword">if</span> node.right:</span><br><span class="line">                  queue.append(node.right)</span><br><span class="line">                  queue2.append(<span class="built_in">str</span>(node_value) + <span class="string">&quot;-&gt;&quot;</span> + <span class="built_in">str</span>(node.right.val))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>递归解法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用回溯1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">binaryTreePaths</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root, state</span>):</span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                state.append(root.val)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                    res.append(<span class="string">&quot;-&gt;&quot;</span>.join([<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> state[:]]))</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">if</span> root.left:</span><br><span class="line">                    dfs(root.left, state)</span><br><span class="line">                    state.pop()</span><br><span class="line">                <span class="keyword">if</span> root.right:</span><br><span class="line">                    dfs(root.right, state)</span><br><span class="line">                    state.pop()</span><br><span class="line">        dfs(root, [])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line"><span class="comment"># [推荐写法] 回溯2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">binaryTreePaths</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root, state</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            state.append(root.val)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                res.append(state[:])</span><br><span class="line">            dfs(root.left, state)</span><br><span class="line">            dfs(root.right, state)</span><br><span class="line">            state.pop()</span><br><span class="line">        dfs(root, [])</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&quot;-&gt;&quot;</span>.join([<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> s]) <span class="keyword">for</span> s <span class="keyword">in</span> res]</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 还有一种回溯的写法，不需要显示的调用pop函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">binaryTreePaths</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">construct_paths</span>(<span class="params">root, path</span>):</span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                path += <span class="built_in">str</span>(root.val)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:  <span class="comment"># 当前节点是叶子节点</span></span><br><span class="line">                    paths.append(path)  <span class="comment"># 把路径加入到答案中</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    path += <span class="string">&#x27;-&gt;&#x27;</span>  <span class="comment"># 当前节点不是叶子节点，继续递归遍历</span></span><br><span class="line">                    construct_paths(root.left, path)</span><br><span class="line">                    construct_paths(root.right, path)</span><br><span class="line"></span><br><span class="line">        paths = []</span><br><span class="line">        construct_paths(root, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> paths</span><br></pre></td></tr></table></figure>
<h2 id="路径总和-112">路径总和[112]</h2>
<p>迭代解法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasPathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">      <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">      queue = deque([root]) <span class="comment"># 使用了两个deque</span></span><br><span class="line">      queue2 = deque([root.val])</span><br><span class="line">      <span class="keyword">while</span> queue:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">          node = queue.popleft()</span><br><span class="line">          node_value = queue2.popleft()</span><br><span class="line">          <span class="keyword">if</span> node.left==<span class="literal">None</span> <span class="keyword">and</span> node.right==<span class="literal">None</span> <span class="keyword">and</span> node_value==targetSum:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">          <span class="keyword">if</span> node.left:</span><br><span class="line">            queue.append(node.left)</span><br><span class="line">            queue2.append(node_value+node.left.val)</span><br><span class="line">          <span class="keyword">if</span> node.right:</span><br><span class="line">            queue.append(node.right)</span><br><span class="line">            queue2.append(node_value+node.right.val)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>递归解法如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 正确解答1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasPathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> targetSum == root.val</span><br><span class="line">        <span class="keyword">return</span> self.hasPathSum(root.left, targetSum - root.val) <span class="keyword">or</span> self.hasPathSum(root.right, targetSum - root.val)</span><br><span class="line"><span class="comment"># [推荐写法]正确解答2【为了和后面的112保持一致，使用该解法】</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasPathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        targetSum = targetSum - root.val</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right <span class="keyword">and</span> targetSum==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> self.hasPathSum(root.left, targetSum) <span class="keyword">or</span> self.hasPathSum(root.right, targetSum)</span><br><span class="line"><span class="comment"># 错写</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasPathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right <span class="keyword">and</span> targetSum==<span class="number">0</span>: <span class="comment"># 注意</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span> <span class="comment"># 注意</span></span><br><span class="line">        <span class="keyword">return</span> self.hasPathSum(root.left, targetSum - root.val) <span class="keyword">or</span> self.hasPathSum(root.right, targetSum - root.val)</span><br></pre></td></tr></table></figure>
<h2 id="路径总和-II-113">路径总和 II[113]</h2>
<p>递归解法如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 回溯解法1，按照标准的回溯来写的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root, state</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            state.append(root.val)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">sum</span>(state[:])==targetSum:</span><br><span class="line">                    res.append(state[:])</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                dfs(root.left, state)</span><br><span class="line">                state.pop()</span><br><span class="line">            <span class="keyword">if</span> root.right:</span><br><span class="line">                dfs(root.right, state)</span><br><span class="line">                state.pop()</span><br><span class="line">        dfs(root, [])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line"><span class="comment"># [推荐写法]回溯解法2， 按照标准回溯来</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        ret = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root, state</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            state.append(root.val)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right <span class="keyword">and</span> <span class="built_in">sum</span>(state[:]) == targetSum:</span><br><span class="line">                ret.append(state[:])</span><br><span class="line">            dfs(root.left, state)</span><br><span class="line">            dfs(root.right, state)</span><br><span class="line">            state.pop()</span><br><span class="line">        dfs(root, [])</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 回溯解法2，使用非标准的回溯来写的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pathSum</span>(<span class="params">self, root: TreeNode, targetSum: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        ret = <span class="built_in">list</span>()</span><br><span class="line">        path = <span class="built_in">list</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root: TreeNode, targetSum: <span class="built_in">int</span></span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            path.append(root.val)</span><br><span class="line">            targetSum -= root.val</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right <span class="keyword">and</span> targetSum == <span class="number">0</span>:</span><br><span class="line">                ret.append(path[:])</span><br><span class="line">            dfs(root.left, targetSum)</span><br><span class="line">            dfs(root.right, targetSum)</span><br><span class="line">            path.pop()</span><br><span class="line">        </span><br><span class="line">        dfs(root, targetSum)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 回溯解法3，使用非标准回溯来</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pathSum</span>(<span class="params">self, root, targetSum</span>):</span><br><span class="line">        ret = <span class="built_in">list</span>()</span><br><span class="line">        path = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root: TreeNode</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            path.append(root.val)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right <span class="keyword">and</span> <span class="built_in">sum</span>(path[:]) == targetSum:</span><br><span class="line">                ret.append(path[:])</span><br><span class="line">            dfs(root.left)</span><br><span class="line">            dfs(root.right)</span><br><span class="line">            path.pop()</span><br><span class="line"></span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<p>非标准的意思是，这里的path是一个不在dfs中传进去的值</p>
<h2 id="路径总和III-437">路径总和III[437]</h2>
<p>我的解法如下，超时了,妈的不打算改了就这样吧</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root, state</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            state.append(root.val)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span>(state[:])==targetSum:</span><br><span class="line">                res.append(state[:])</span><br><span class="line">            dfs(root.left, state)</span><br><span class="line">            dfs(root.right, state)</span><br><span class="line">            state.pop()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs2</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dfs(root,[])</span><br><span class="line">            dfs2(root.left)</span><br><span class="line">            dfs2(root.right)</span><br><span class="line"></span><br><span class="line">        dfs2(root)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(res)</span><br></pre></td></tr></table></figure>
<h2 id="二叉树中的最大路径和-124">二叉树中的最大路径和[124]</h2>
<p>位于 <a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/">https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.max_sum = -<span class="number">88</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxPathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">maxGain</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            leftGain = <span class="built_in">max</span>(maxGain(root.left), <span class="number">0</span>)</span><br><span class="line">            rightGrain = <span class="built_in">max</span>(maxGain(root.right), <span class="number">0</span>)</span><br><span class="line">            cur_root_gain = root.val + leftGain + rightGrain</span><br><span class="line">            <span class="keyword">if</span> cur_root_gain &gt; self.max_sum:</span><br><span class="line">                self.max_sum = cur_root_gain</span><br><span class="line">            <span class="keyword">return</span> root.val + <span class="built_in">max</span>(rightGrain,leftGain) <span class="comment">#写错为root.val + rightGrain + leftGain</span></span><br><span class="line">        maxGain(root)</span><br><span class="line">        <span class="keyword">return</span> self.max_sum</span><br></pre></td></tr></table></figure>
<p>注意这里的maxGain是需要定义好的，返回的值是以当前节点为开始或者结束的收益值，因此需要写成root.val+max(rightGain, leftGain)</p>
<h2 id="二叉树的最近公共祖先-236">二叉树的最近公共祖先[236]</h2>
<p>递归法如下，最主要的点在代码中已经说了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 错误解法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root, p, q</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type p: TreeNode</span></span><br><span class="line"><span class="string">        :type q: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.right <span class="keyword">and</span> root.left:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        left = self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        right = self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left:</span><br><span class="line">            <span class="keyword">return</span> right</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> right:</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">if</span> left <span class="keyword">and</span> right:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"><span class="comment"># 正确解法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="string">&#x27;TreeNode&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> root==p <span class="keyword">or</span> root==q: <span class="comment"># 最重要的点</span></span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        left = self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        right = self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left:</span><br><span class="line">            <span class="keyword">return</span> right</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> right:</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h1>构造二叉树</h1>
<h2 id="最大二叉树-654">最大二叉树[654]</h2>
<p>迭代法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">constructMaximumBinaryTree</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        max_index = nums.index(<span class="built_in">max</span>(nums))</span><br><span class="line">        root = TreeNode(val=nums[max_index])</span><br><span class="line">        root.left = self.constructMaximumBinaryTree(nums[:max_index])</span><br><span class="line">        root.right = self.constructMaximumBinaryTree(nums[max_index+<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h2 id="合并二叉树-617">合并二叉树[617]</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTrees</span>(<span class="params">self, root1: <span class="type">Optional</span>[TreeNode], root2: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root1 <span class="keyword">and</span> <span class="keyword">not</span> root2:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root1 <span class="keyword">and</span> root2:</span><br><span class="line">            <span class="keyword">return</span> root2</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root2 <span class="keyword">and</span> root1:</span><br><span class="line">            <span class="keyword">return</span> root1</span><br><span class="line">        root = TreeNode(root1.val + root2.val)</span><br><span class="line">        root.left = self.mergeTrees(root1.left, root2.left)</span><br><span class="line">        root.right = self.mergeTrees(root1.right, root2.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h2 id="从前序与中序遍历序列构造二叉树-105">从前序与中序遍历序列构造二叉树[105]</h2>
<p>递归方法如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, preorder: <span class="type">List</span>[<span class="built_in">int</span>], inorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> preorder:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> inorder:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        root = TreeNode(preorder[<span class="number">0</span>])</span><br><span class="line">        inorder_index = inorder.index(preorder[<span class="number">0</span>])</span><br><span class="line">        root.left = self.buildTree(preorder[<span class="number">1</span>:inorder_index+<span class="number">1</span>], inorder[:inorder_index])</span><br><span class="line">        root.right = self.buildTree(preorder[inorder_index+<span class="number">1</span>:], inorder[inorder_index+<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h2 id="从中序与后序遍历序列构造二叉树-106">从中序与后序遍历序列构造二叉树[106]</h2>
<p>递归解法如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, inorder: <span class="type">List</span>[<span class="built_in">int</span>], postorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> inorder:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> postorder:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        root = TreeNode(postorder[-<span class="number">1</span>])</span><br><span class="line">        inorder_index = inorder.index(postorder[-<span class="number">1</span>])</span><br><span class="line">        root.left = self.buildTree(inorder[:inorder_index], postorder[:inorder_index])</span><br><span class="line">        root.right = self.buildTree(inorder[inorder_index+<span class="number">1</span>:], postorder[inorder_index:-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h1>二叉搜索树</h1>
<h2 id="将有序数组转换为二叉搜索树-108">将有序数组转换为二叉搜索树[108]</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortedArrayToBST</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        mid = <span class="built_in">int</span>(<span class="built_in">len</span>(nums)/<span class="number">2</span>)</span><br><span class="line">        root = TreeNode(nums[mid])</span><br><span class="line">        root.left = self.sortedArrayToBST(nums[:mid])</span><br><span class="line">        root.right = self.sortedArrayToBST(nums[mid+<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h2 id="二叉搜索树中的搜索-700">二叉搜索树中的搜索[700]</h2>
<p>迭代法，就是类似链表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            f = cur.val</span><br><span class="line">            <span class="keyword">if</span> f &lt; val:</span><br><span class="line">                cur = cur.right</span><br><span class="line">            <span class="keyword">elif</span> f &gt; val:</span><br><span class="line">                cur = cur.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> cur</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p>递归法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> root.val == val:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">elif</span> root.val &gt; val:</span><br><span class="line">            <span class="keyword">return</span> self.searchBST(root.left, val)</span><br><span class="line">        <span class="keyword">elif</span> root.val &lt; val:</span><br><span class="line">            <span class="keyword">return</span> self.searchBST(root.right, val)</span><br></pre></td></tr></table></figure>
<h2 id="验证二叉搜索树-98">验证二叉搜索树[98]</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValidBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">inOrder</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            inOrder(root.left)</span><br><span class="line">            res.append(root.val)</span><br><span class="line">            inOrder(root.right)</span><br><span class="line">        inOrder(root)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(res)-<span class="number">1</span>):</span><br><span class="line">          <span class="keyword">if</span> res[i+<span class="number">1</span>] &lt;= res[i]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h2 id="二叉搜索树的最小绝对差-530">二叉搜索树的最小绝对差[530]</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getMinimumDifference</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">inorder</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            inorder(root.left)</span><br><span class="line">            res.append(root.val)</span><br><span class="line">            inorder(root.right)</span><br><span class="line">        inorder(root)</span><br><span class="line">        mins = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(res)-<span class="number">1</span>):</span><br><span class="line">            mins = <span class="built_in">min</span>(mins, <span class="built_in">abs</span>(res[i+<span class="number">1</span>] - res[i]))</span><br><span class="line">        <span class="keyword">return</span> mins</span><br></pre></td></tr></table></figure>
<h2 id="二叉搜索树中的众数-501">二叉搜索树中的众数[501]</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMode</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">inorder</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            inorder(root.left)</span><br><span class="line">            res.append(root.val)</span><br><span class="line">            inorder(root.right)</span><br><span class="line">        inorder(root)</span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">        cnt = Counter(res)</span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">        new_d = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> cnt.items():</span><br><span class="line">            new_d[v].append(k)</span><br><span class="line">        new_d = <span class="built_in">sorted</span>(new_d.items(),key=<span class="keyword">lambda</span> x:-x[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> new_d[<span class="number">0</span>][<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h2 id="二叉搜索树的最近公共祖先-235">二叉搜索树的最近公共祖先[235]</h2>
<p>递归解法如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="string">&#x27;TreeNode&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> root == p <span class="keyword">or</span> root == q:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> root.val &lt; <span class="built_in">min</span>(p.val, q.val):</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">if</span> root.val &gt; <span class="built_in">max</span>(p.val, q.val):</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的最近公共祖先-236-2">二叉树的最近公共祖先[236]</h2>
<p>递归法如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 正确解法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="string">&#x27;TreeNode&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> root==p <span class="keyword">or</span> root==q:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        left = self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        right = self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left:</span><br><span class="line">            <span class="keyword">return</span> right</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> right:</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h2 id="二叉搜索树中的插入操作-701">二叉搜索树中的插入操作[701]</h2>
<p>迭代法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insertIntoBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        res_trees = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">inorder</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            inorder(root.left)</span><br><span class="line">            res_trees.append(root)</span><br><span class="line">            inorder(root.right)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(val)</span><br><span class="line">        inorder(root)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> val &lt; res_trees[<span class="number">0</span>].val:</span><br><span class="line">            res_trees[<span class="number">0</span>].left = TreeNode(val)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> val &gt; res_trees[-<span class="number">1</span>].val:</span><br><span class="line">            res_trees[-<span class="number">1</span>].right = TreeNode(val)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(res_trees)-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> val&gt;res_trees[i].val <span class="keyword">and</span> val&lt;res_trees[i+<span class="number">1</span>].val:</span><br><span class="line">                left = res_trees[i]</span><br><span class="line">                right = res_trees[i+<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> left.right==<span class="literal">None</span>:</span><br><span class="line">                    left.right = TreeNode(val)</span><br><span class="line">                <span class="keyword">elif</span> right.left==<span class="literal">None</span>:</span><br><span class="line">                    right.left = TreeNode(val)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p>官方迭代法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insertIntoBST</span>(<span class="params">self, root: TreeNode, val: <span class="built_in">int</span></span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(val)</span><br><span class="line">        </span><br><span class="line">        pos = root</span><br><span class="line">        <span class="keyword">while</span> pos:</span><br><span class="line">            <span class="keyword">if</span> val &lt; pos.val:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> pos.left:</span><br><span class="line">                    pos.left = TreeNode(val)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    pos = pos.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> pos.right:</span><br><span class="line">                    pos.right = TreeNode(val)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    pos = pos.right</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h2 id="删除二叉搜索树中的节点-450">删除二叉搜索树中的节点[450]</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteNode</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], key: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> root.val &gt; key:</span><br><span class="line">            root.left = self.deleteNode(root.left, key)</span><br><span class="line">        <span class="keyword">elif</span> root.val &lt; key:</span><br><span class="line">            root.right = self.deleteNode(root.right, key)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 判断root点的情况</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> root.right:</span><br><span class="line">                <span class="keyword">return</span> root.right</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.right <span class="keyword">and</span> root.left:</span><br><span class="line">                <span class="keyword">return</span> root.left           </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span>    </span><br><span class="line">            <span class="keyword">if</span> root.left <span class="keyword">and</span> root.right:</span><br><span class="line">                <span class="comment"># 找到最左边的节点</span></span><br><span class="line">                t = node = root.right</span><br><span class="line">                <span class="keyword">while</span> node.left:</span><br><span class="line">                    node = node.left</span><br><span class="line">                node.left = root.left</span><br><span class="line">                <span class="keyword">return</span> t</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h2 id="修剪二叉搜索树-669">修剪二叉搜索树[669]</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 错误解法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trimBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], low: <span class="built_in">int</span>, high: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">and</span> root.val &lt; low:</span><br><span class="line">            root = root.right</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">and</span> root.val &gt; high:</span><br><span class="line">            root = root.left</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">and</span> root.left <span class="keyword">and</span> root.left.val &lt; low:</span><br><span class="line">            root.left = root.left.right</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">and</span> root.right <span class="keyword">and</span> root.right.val &gt; high:</span><br><span class="line">            root.right = root.right.left</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">and</span> root.left:</span><br><span class="line">            self.trimBST(root.left, low, high)</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">and</span> root.right:</span><br><span class="line">            self.trimBST(root.right, low, high)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"><span class="comment"># 【推荐解法】</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trimBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], low: <span class="built_in">int</span>, high: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> root.val &lt; low:</span><br><span class="line">            <span class="keyword">return</span> self.trimBST(root.right, low, high)</span><br><span class="line">        <span class="keyword">elif</span> root.val &gt; high:</span><br><span class="line">            <span class="keyword">return</span> self.trimBST(root.left, low, high)</span><br><span class="line">        root.left = self.trimBST(root.left, low, high)</span><br><span class="line">        root.right = self.trimBST(root.right, low, high)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h2 id="把二叉搜索树转换为累加树-538">把二叉搜索树转换为累加树[538]</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">convertBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">inorder</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            inorder(root.left)</span><br><span class="line">            res.append(root)</span><br><span class="line">            inorder(root.right)</span><br><span class="line">        inorder(root)</span><br><span class="line">        res=res[::-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(res)):</span><br><span class="line">            res[i].val = res[i].val + res[i-<span class="number">1</span>].val</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h2 id="把二叉搜索树转换为累加树-538-2">把二叉搜索树转换为累加树[538]</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">convertBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">inorder</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            inorder(root.left)</span><br><span class="line">            res.append(root)</span><br><span class="line">            inorder(root.right)</span><br><span class="line">        inorder(root)</span><br><span class="line">        res=res[::-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(res)):</span><br><span class="line">            res[i].val = res[i].val + res[i-<span class="number">1</span>].val</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>题目汇总</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2024/03/19/leetcode/dp_problem/</url>
    <content><![CDATA[<h1>总结</h1>
<h2 id="大纲">大纲</h2>
<h2 id="相关细节">相关细节</h2>
<ol>
<li>如果题目求最大值，则dp初始化为[-float(“inf”)]*n的数据</li>
<li>循环比较一般使用dp[i] = max(dp[i], dp[j] + nums[i])，而不是dp[i] = max(dp[i], dp[j]) + nums[i]</li>
</ol>
<h1>序列</h1>
<h2 id="单序列">单序列</h2>
<h3 id="模板">模板</h3>
<ul>
<li>一般初始化的时候，都会dp = [0] * len(str),而不是dp = [0] * (len(str)+1)</li>
<li>注意有的时候不是输出dp[n-1]而是max(dp)</li>
<li>其他点</li>
</ul>
<h3 id="最长递增子序列-300">最长递增子序列[300]</h3>
<p>位于 <a href="https://leetcode.cn/problems/longest-increasing-subsequence">https://leetcode.cn/problems/longest-increasing-subsequence</a><br>
dp表达式如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (nums[i] &gt; nums[j]) dp[i] = max(dp[i], dp[j] + 1);</span><br></pre></td></tr></table></figure>
<p>代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLIS</span>(<span class="params">self, nums</span>):</span><br><span class="line">        dp = [<span class="number">1</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure>
<h3 id="最长连续递增序列-674">最长连续递增序列[674]</h3>
<p>位于 <a href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence">https://leetcode.cn/problems/longest-continuous-increasing-subsequence</a><br>
dp表达式如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (nums[i] &gt; nums[i-1]) dp[i] = max(dp[i], dp[i-1] + 1);</span><br></pre></td></tr></table></figure>
<p>代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findLengthOfLCIS</span>(<span class="params">self, nums</span>):</span><br><span class="line">        dp = [<span class="number">1</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[i-<span class="number">1</span>]:</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], dp[i-<span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure>
<h3 id="最大子数组和-53">最大子数组和[53]</h3>
<p>位于 <a href="https://leetcode.cn/problems/maximum-subarray">https://leetcode.cn/problems/maximum-subarray</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSubArray</span>(<span class="params">self, nums</span>):</span><br><span class="line">        dp = [<span class="number">0</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>]+nums[i], nums[i])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure>
<h3 id="回文子串-647">回文子串[647]</h3>
<p>位于 <a href="https://leetcode.cn/problems/palindromic-substrings/description/">https://leetcode.cn/problems/palindromic-substrings/description/</a><br>
动规表达式如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][i] = 1</span><br><span class="line">if s[i]==s[j] and j-i==1: dp[i][j]=1</span><br><span class="line">if j-i&gt;1 and dp[i+1][j-1] and s[i]==s[j]:dp[i][j]=1</span><br></pre></td></tr></table></figure>
<p>题解如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countSubstrings</span>(<span class="params">self, s</span>):</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        dp = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            dp[i][i] = <span class="number">1</span></span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(j):</span><br><span class="line">                <span class="keyword">if</span> j-i==<span class="number">1</span> <span class="keyword">and</span> s[i]==s[j]:</span><br><span class="line">                    dp[i][j] = <span class="number">1</span></span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> j -i &gt; <span class="number">1</span> <span class="keyword">and</span> dp[i+<span class="number">1</span>][j-<span class="number">1</span>] <span class="keyword">and</span> s[i]==s[j]:</span><br><span class="line">                    dp[i][j] = <span class="number">1</span></span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure>
<p>遍历顺序是这样的<br>
<img src="https://pic.leetcode-cn.com/17dc7e2a1d0cb9916917e2121ec59d838bc453a4c83df1f60b2f28f10a1f986e-image.png" alt="image"></p>
<h3 id="最长回文子串-5">最长回文子串[5]</h3>
<p>位于 <a href="https://leetcode.cn/problems/longest-palindromic-substring">https://leetcode.cn/problems/longest-palindromic-substring</a><br>
子串是连续的，子序列不是，这里要注意，和上面解法一样，代码没变</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestPalindrome</span>(<span class="params">self, s</span>):</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        dp = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        m = <span class="number">0</span></span><br><span class="line">        res = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            dp[i][i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i-i+<span class="number">1</span>&gt;m:</span><br><span class="line">                m = i-i+<span class="number">1</span></span><br><span class="line">                res = [i,i]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(j):</span><br><span class="line">                <span class="keyword">if</span> j-i==<span class="number">1</span> <span class="keyword">and</span> s[i]==s[j]:</span><br><span class="line">                    dp[i][j] = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> j-i+<span class="number">1</span>&gt;m:</span><br><span class="line">                        m = j-i+<span class="number">1</span></span><br><span class="line">                        res = [i,j]</span><br><span class="line">                <span class="keyword">elif</span> j-i&gt;<span class="number">1</span> <span class="keyword">and</span> s[i]==s[j] <span class="keyword">and</span> dp[i+<span class="number">1</span>][j-<span class="number">1</span>]==<span class="number">1</span>:</span><br><span class="line">                    dp[i][j] = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> j-i+<span class="number">1</span>&gt;m: <span class="comment"># 要在里面写不能算完dp后再比较</span></span><br><span class="line">                        m = j-i+<span class="number">1</span></span><br><span class="line">                        res = [i,j]</span><br><span class="line">        <span class="keyword">return</span> s[res[<span class="number">0</span>]:res[<span class="number">1</span>]+<span class="number">1</span>]</span><br><span class="line"><span class="comment"># 推荐代码，如果按照上面写法做最长回文子序列会报错，因为循环的时候方向不对的，可以推导一下</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        dp = [[<span class="literal">False</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        max_flag = <span class="number">0</span></span><br><span class="line">        ind = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            dp[i][i] = <span class="literal">True</span></span><br><span class="line">            ind = (i, i)  </span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - l):</span><br><span class="line">                j = i + l</span><br><span class="line">                <span class="keyword">if</span> j-i==<span class="number">1</span> <span class="keyword">and</span> s[i]==s[j]:</span><br><span class="line">                    dp[i][j] = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">if</span> j - i &gt; max_flag: </span><br><span class="line">                        max_flag = j - i</span><br><span class="line">                        ind = (i, j)</span><br><span class="line">                <span class="keyword">if</span> j-i&gt;<span class="number">1</span> <span class="keyword">and</span> s[i] == s[j]:</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                    <span class="keyword">if</span> dp[i][j] <span class="keyword">and</span> j - i &gt; max_flag:</span><br><span class="line">                        max_flag = j - i</span><br><span class="line">                        ind = (i, j)</span><br><span class="line">        <span class="keyword">return</span> (s[ind[<span class="number">0</span>]:ind[<span class="number">1</span>] + <span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<h3 id="环形子数组的最大和-918">环形子数组的最大和[918]</h3>
<p>位于 <a href="https://leetcode.cn/problems/maximum-sum-circular-subarray/description/">https://leetcode.cn/problems/maximum-sum-circular-subarray/description/</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSubarraySumCircular</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">        max_ = -<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">        dp_max = [<span class="number">0</span>] * n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            dp_max[i] = <span class="built_in">max</span>(<span class="number">0</span>, dp_max[i-<span class="number">1</span>]) + nums[i]</span><br><span class="line">            <span class="keyword">if</span> dp_max[i] &gt; max_:</span><br><span class="line">                max_ = dp_max[i]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">max</span>(dp_max) &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(nums)</span><br><span class="line">        </span><br><span class="line">        min_ = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">        dp_min = [<span class="number">0</span>] * n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            dp_min[i] = <span class="built_in">min</span>(<span class="number">0</span>, dp_min[i-<span class="number">1</span>]) + nums[i]</span><br><span class="line">            <span class="keyword">if</span> dp_min[i] &lt; min_:</span><br><span class="line">                min_ = dp_min[i]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(max_, <span class="built_in">sum</span>(nums) - min_)        </span><br></pre></td></tr></table></figure>
<h3 id="最长回文子序列-516">最长回文子序列[516]</h3>
<p>位于 <a href="https://leetcode.cn/problems/longest-palindromic-subsequence">https://leetcode.cn/problems/longest-palindromic-subsequence</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestPalindromeSubseq</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [[<span class="number">0</span>] * <span class="built_in">len</span>(s) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s))]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            dp[i][i] = <span class="number">1</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - l):</span><br><span class="line">                j = i + l</span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="戳气球-312">戳气球[312]</h3>
<p>位于 <a href="https://leetcode.cn/problems/burst-balloons">https://leetcode.cn/problems/burst-balloons</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxCoins</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        val = [<span class="number">1</span>] + nums + [<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line"><span class="meta">        @lru_cache(<span class="params"><span class="literal">None</span></span>)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="keyword">if</span> left &gt;= right - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            best = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left + <span class="number">1</span>, right):</span><br><span class="line">                total = val[left] * val[i] * val[right]</span><br><span class="line">                total += solve(left, i) + solve(i, right)</span><br><span class="line">                best = <span class="built_in">max</span>(best, total)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> best</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> solve(<span class="number">0</span>, n + <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 动规</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxCoins</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        rec = [[<span class="number">0</span>] * (n + <span class="number">2</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">2</span>)]</span><br><span class="line">        val = [<span class="number">1</span>] + nums + [<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">2</span>, n + <span class="number">2</span>):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, j):</span><br><span class="line">                    total = val[i] * val[k] * val[j]</span><br><span class="line">                    total += rec[i][k] + rec[k][j]</span><br><span class="line">                    rec[i][j] = <span class="built_in">max</span>(rec[i][j], total)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> rec[<span class="number">0</span>][n + <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://leetcode.cn/problems/burst-balloons/solutions/337630/zhe-ge-cai-pu-zi-ji-zai-jia-ye-neng-zuo-guan-jian-/">https://leetcode.cn/problems/burst-balloons/solutions/337630/zhe-ge-cai-pu-zi-ji-zai-jia-ye-neng-zuo-guan-jian-/</a></p>
</blockquote>
<h3 id="鸡蛋掉落-887">鸡蛋掉落[887]</h3>
<p>位于 <a href="https://leetcode.cn/problems/super-egg-drop">https://leetcode.cn/problems/super-egg-drop</a>  本题需要反过来想，如果我们可以做 t 次操作，而且有 k 个鸡蛋，那么我们能找到答案的最高的 n 是多少</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">superEggDrop</span>(<span class="params">self, k: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># k鸡蛋，n是楼层</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        dp = [[<span class="number">0</span>]*(k+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)] <span class="comment"># t次操作，k个鸡蛋，最高的n</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,k+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">1</span>][i] = <span class="number">1</span></span><br><span class="line">        ans = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,k+<span class="number">1</span>):</span><br><span class="line">                dp[i][j] = <span class="number">1</span> + dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + dp[i-<span class="number">1</span>][j] <span class="comment"># 鸡蛋碎和没碎</span></span><br><span class="line">            <span class="keyword">if</span> dp[i][k] &gt;=n: <span class="comment"># 注意这里是k</span></span><br><span class="line">                ans = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>建议还是记下来吧，不然很容易忘</p>
<h2 id="双序列">双序列</h2>
<h3 id="模板-2">模板</h3>
<ul>
<li>初始化dp为dp=[[0]*(n+1) for _ in range(m+1)],要多一位</li>
<li>在判断的时候要少一位，比如num[i-1]就是对应到dp[i]这里来</li>
<li>初始化一般都是0</li>
<li>注意判断好条件</li>
</ul>
<p>简单代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n1 = <span class="built_in">len</span>(text1)</span><br><span class="line">n2 = <span class="built_in">len</span>(text2)</span><br><span class="line">dp = [[<span class="number">0</span>]*(n2+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n1+<span class="number">1</span>)] <span class="comment"># 注意点1，都为0，且行列为n1+1啊</span></span><br><span class="line">result = -<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n1+<span class="number">1</span>): <span class="comment"># 注意点2，是从1开始</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n2+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> text1[i-<span class="number">1</span>] == text2[j-<span class="number">1</span>]: <span class="comment"># 注意点3，这里判断i-1是否对的</span></span><br><span class="line">            dp[i][j] = func(dp[i][j], dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>) </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dp[i][j] = func(..)</span><br></pre></td></tr></table></figure>
<h3 id="最长重复子数组-718">最长重复子数组[718]</h3>
<p>位于 <a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray">https://leetcode.cn/problems/maximum-length-of-repeated-subarray</a><br>
注意题目中说的子数组，其实就是连续子序列。和最长连续递增序列[674]有点类似，下面的最长公共子序列和最长递增子序列[300]有点像。</p>
<p>dp表达式如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A[i - 1] 和B[j - 1]相等的时候，dp[i][j] = dp[i - 1][j - 1] + 1;;</span><br></pre></td></tr></table></figure>
<p>代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findLength</span>(<span class="params">self, nums1, nums2</span>):</span><br><span class="line">        n1 = <span class="built_in">len</span>(nums1)</span><br><span class="line">        n2 = <span class="built_in">len</span>(nums2)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(n2+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n1+<span class="number">1</span>)] <span class="comment"># 注意1：这里多了一位</span></span><br><span class="line">        max_res = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n1+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n2+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> nums1[i-<span class="number">1</span>] == nums2[j-<span class="number">1</span>]: <span class="comment"># 这里判断i-1,就是       对应dp的i,主要是为了判断方便</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">                max_res = <span class="built_in">max</span>(max_res, dp[i][j])</span><br><span class="line">        <span class="keyword">return</span> max_res</span><br></pre></td></tr></table></figure>
<h3 id="最长公共子序列-1143">最长公共子序列[1143]</h3>
<p>位于 <a href="https://leetcode.cn/problems/longest-common-subsequence">https://leetcode.cn/problems/longest-common-subsequence</a><br>
和 最长重复子数组[718] 不一样，这道题不需要连续的数组。</p>
<p>p表达式如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A[i - 1] 和B[j - 1]相等的时候，dp[i][j] = dp[i - 1][j - 1] + 1;</span><br><span class="line">不等的时候dp[i][j] = max(dp[i-1][j], dp[i][j-1])</span><br></pre></td></tr></table></figure>
<p>代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestCommonSubsequence</span>(<span class="params">self, text1, text2</span>):</span><br><span class="line">        n1 = <span class="built_in">len</span>(text1)</span><br><span class="line">        n2 = <span class="built_in">len</span>(text2)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(n2+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n1+<span class="number">1</span>)]</span><br><span class="line">        result = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n1+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n2+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> text1[i-<span class="number">1</span>] == text2[j-<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>) </span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>])</span><br><span class="line">                result = <span class="built_in">max</span>(result, dp[i][j])</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h3 id="不相交的线-1035">不相交的线[1035]</h3>
<p>位于 <a href="https://leetcode.cn/problems/uncrossed-lines">https://leetcode.cn/problems/uncrossed-lines</a><br>
和最长公共子序列一样，代码也是一样的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxUncrossedLines</span>(<span class="params">self, nums1, nums2</span>):</span><br><span class="line">        n1 = <span class="built_in">len</span>(nums1)</span><br><span class="line">        n2 = <span class="built_in">len</span>(nums2)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(n2+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n1+<span class="number">1</span>)]</span><br><span class="line">        result = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n1+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n2+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> nums1[i-<span class="number">1</span>] == nums2[j-<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>) </span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>])</span><br><span class="line">                result = <span class="built_in">max</span>(result, dp[i][j])</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h3 id="判断子序列-392">判断子序列[392]</h3>
<p>位于 <a href="https://leetcode.cn/problems/is-subsequence">https://leetcode.cn/problems/is-subsequence</a><br>
dp[i][j] 表示以下标i-1为结尾的字符串s，和以下标j-1为结尾的字符串t，相同子序列的长度为dp[i][j]。</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编辑距离的基础题衍生的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSubsequence</span>(<span class="params">self, s, t</span>):</span><br><span class="line">        n1 = <span class="built_in">len</span>(s)</span><br><span class="line">        n2 = <span class="built_in">len</span>(t)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(n2+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n1+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n1+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n2+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> s[i-<span class="number">1</span>]==t[j-<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j],dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]==<span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="编辑距离-72">编辑距离[72]</h3>
<p>位于 <a href="https://leetcode.cn/problems/edit-distance">https://leetcode.cn/problems/edit-distance</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDistance</span>(<span class="params">self, word1: <span class="built_in">str</span>, word2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n1 = <span class="built_in">len</span>(word1)</span><br><span class="line">        n2 = <span class="built_in">len</span>(word2)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(n2+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n1+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n1+<span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n2+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][j] = j</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n1+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n2+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> word1[i-<span class="number">1</span>]==word2[j-<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i-<span class="number">1</span>][j-<span class="number">1</span>],dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp[n1][n2]            </span><br></pre></td></tr></table></figure>
<h3 id="不同的子序列-115">不同的子序列[115]</h3>
<p>位于 <a href="https://leetcode.cn/problems/distinct-subsequences">https://leetcode.cn/problems/distinct-subsequences</a><br>
困难题动态规划方程不易想到</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numDistinct</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n1 = <span class="built_in">len</span>(s)</span><br><span class="line">        n2 = <span class="built_in">len</span>(t)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(n2+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n1+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n1+<span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n2+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n1+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n2+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> s[i-<span class="number">1</span>]==t[j-<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + dp[i-<span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="两个字符串的删除操作-583">两个字符串的删除操作[583]</h3>
<p>位于 <a href="https://leetcode.cn/problems/delete-operation-for-two-strings">https://leetcode.cn/problems/delete-operation-for-two-strings</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDistance</span>(<span class="params">self, word1: <span class="built_in">str</span>, word2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [[<span class="number">0</span>] * (<span class="built_in">len</span>(word2)+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(word1)+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(word1)+<span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(word2)+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][j] = j</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(word1)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(word2)+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> word1[i-<span class="number">1</span>] == word2[j-<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">2</span>, dp[i-<span class="number">1</span>][j] + <span class="number">1</span>, dp[i][j-<span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h1>爬楼梯类</h1>
<h2 id="斐波那契数-509">斐波那契数[509]</h2>
<p>位于 <a href="https://leetcode.cn/problems/fibonacci-number">https://leetcode.cn/problems/fibonacci-number</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        dp = [<span class="number">0</span>]*(n+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        dp[<span class="number">1</span>]= <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
<h2 id="爬楼梯-70">爬楼梯[70]</h2>
<p>位于 <a href="https://leetcode.cn/problems/climbing-stairs">https://leetcode.cn/problems/climbing-stairs</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (n+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">            dp[i] = dp[i-<span class="number">2</span>] + dp[i-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h2 id="爬楼梯2-三步问题">爬楼梯2[三步问题]</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">waysToStep</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        run_maps = &#123;<span class="number">1</span>:<span class="number">1</span>,<span class="number">2</span>:<span class="number">2</span>,<span class="number">3</span>:<span class="number">4</span>&#125;</span><br><span class="line">        <span class="keyword">if</span> n <span class="keyword">in</span> run_maps:</span><br><span class="line">            <span class="keyword">return</span> run_maps[n]</span><br><span class="line">        dp = [<span class="number">0</span>] * (n+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">        dp[<span class="number">3</span>] = <span class="number">4</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>, n+<span class="number">1</span>):</span><br><span class="line">            dp[i] = (dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>] + dp[i-<span class="number">3</span>])%<span class="number">1000000007</span></span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
<h2 id="爬楼梯3使用最小花费爬楼梯-LCR-088">爬楼梯3使用最小花费爬楼梯[LCR 088]</h2>
<p>位于 <a href="https://leetcode.cn/problems/min-cost-climbing-stairs">https://leetcode.cn/problems/min-cost-climbing-stairs</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minCostClimbingStairs</span>(<span class="params">self, cost: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="number">0</span>] * <span class="built_in">len</span>(cost)</span><br><span class="line">        dp[<span class="number">0</span>] = cost[<span class="number">0</span>]</span><br><span class="line">        dp[<span class="number">1</span>] = cost[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">len</span>(cost)):</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i-<span class="number">1</span>], dp[i-<span class="number">2</span>]) + cost[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(dp[<span class="built_in">len</span>(cost)-<span class="number">1</span>],dp[<span class="built_in">len</span>(cost)-<span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<h2 id="完全平方数-279">完全平方数[279]</h2>
<p>位于 <a href="https://leetcode.cn/problems/perfect-squares">https://leetcode.cn/problems/perfect-squares</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numSquares</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)] * (n+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span> <span class="comment"># 注意</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(i**<span class="number">0.5</span>)+<span class="number">1</span>):</span><br><span class="line">                dp[i] = <span class="built_in">min</span>(dp[i], dp[i-j*j]+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h2 id="跳跃游戏-55">跳跃游戏[55]</h2>
<p>位于 <a href="https://leetcode.cn/problems/jump-game">https://leetcode.cn/problems/jump-game</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canJump</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        dp = [<span class="number">0</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> dp[j] <span class="keyword">and</span> nums[j] + j &gt;= i:</span><br><span class="line">                    dp[i] = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> dp[<span class="built_in">len</span>(nums)-<span class="number">1</span>] <span class="keyword">else</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h2 id="跳跃游戏II-45">跳跃游戏II[45]</h2>
<p>位于 <a href="https://leetcode.cn/problems/jump-game-ii">https://leetcode.cn/problems/jump-game-ii</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">jump</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)] * <span class="built_in">len</span>(nums)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                <span class="keyword">if</span> nums[j] + j &gt;= i:</span><br><span class="line">                    dp[i] = <span class="built_in">min</span>(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h2 id="跳跃游戏-III-1306">跳跃游戏 III[1306]</h2>
<p>位于 <a href="https://leetcode.cn/problems/jump-game-iii">https://leetcode.cn/problems/jump-game-iii</a><br>
代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># BFS</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canReach</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>], start: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        used = &#123;&#125;</span><br><span class="line">        queue = deque([start])</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> arr[node]==<span class="number">0</span>: <span class="comment"># 容易写到2出</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">in</span> used:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            used[node] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> [node-arr[node], node+arr[node]]:</span><br><span class="line">                <span class="keyword">if</span> v &gt;= <span class="number">0</span> <span class="keyword">and</span> v&lt;<span class="built_in">len</span>(arr):</span><br><span class="line">                    <span class="keyword">if</span> v <span class="keyword">in</span> used:</span><br><span class="line">                        <span class="keyword">continue</span> <span class="comment"># 2</span></span><br><span class="line">                    queue.append(v)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="comment"># DFS</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canReach</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>], start: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        s = &#123;&#125;</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">arr, st</span>):</span><br><span class="line">            <span class="keyword">if</span> st <span class="keyword">not</span> <span class="keyword">in</span> s <span class="keyword">and</span> arr[st]==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            s[st] = <span class="number">1</span></span><br><span class="line">            current_step = arr[st]</span><br><span class="line">            <span class="keyword">for</span> step <span class="keyword">in</span> [st+current_step, st-current_step]:</span><br><span class="line">                <span class="keyword">if</span> step&gt;=<span class="number">0</span> <span class="keyword">and</span> step&lt; <span class="built_in">len</span>(arr) <span class="keyword">and</span> step <span class="keyword">not</span> <span class="keyword">in</span> s <span class="keyword">and</span> dfs(arr, step):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> dfs(arr, start)</span><br></pre></td></tr></table></figure>
<h2 id="跳跃游戏-VI-1696">跳跃游戏 VI[1696]</h2>
<p>位于 <a href="https://leetcode.cn/problems/jump-game-vi">https://leetcode.cn/problems/jump-game-vi</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxResult</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [-<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)] * <span class="built_in">len</span>(nums) <span class="comment"># 容易写错</span></span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">max</span>(<span class="number">0</span>, i - k), i):</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + nums[i]) </span><br><span class="line">                <span class="comment"># 这里错写为max(dp[i], dp[j] + nums[i])</span></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h2 id="青蛙过河-403">青蛙过河[403]</h2>
<p>位于 <a href="https://leetcode.cn/problems/frog-jump">https://leetcode.cn/problems/frog-jump</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canCross</span>(<span class="params">self, stones: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(stones)):</span><br><span class="line">            <span class="keyword">if</span> stones[i] &gt; i + stones[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        end = stones[-<span class="number">1</span>]</span><br><span class="line">        stones = <span class="built_in">set</span>(stones)</span><br><span class="line"></span><br><span class="line"><span class="meta">        @functools.lru_cache(<span class="params"><span class="literal">None</span></span>)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">location, step</span>):</span><br><span class="line">            <span class="keyword">if</span> location == end: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">for</span> step <span class="keyword">in</span> [step-<span class="number">1</span>, step, step+<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">if</span> step &gt; <span class="number">0</span> <span class="keyword">and</span> location+step <span class="keyword">in</span> stones <span class="keyword">and</span> dfs(location+step, step):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># DP</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canCross</span>(<span class="params">self, stones: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(stones)</span><br><span class="line">        dp = [[<span class="literal">False</span>]* n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">                k = stones[i] - stones[j]</span><br><span class="line">                <span class="keyword">if</span> k&gt;j+<span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                dp[i][k] = dp[j][k] <span class="keyword">or</span> dp[j][k-<span class="number">1</span>] <span class="keyword">or</span> dp[j][k+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> dp[n-<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">if</span> i:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>不懂看这里 <a href="https://www.ai2news.com/blog/2980406/">https://www.ai2news.com/blog/2980406/</a></p>
<h2 id="打家劫舍-198">打家劫舍[198]</h2>
<p>位于 <a href="https://leetcode.cn/problems/house-robber">https://leetcode.cn/problems/house-robber</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums)==<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(nums)</span><br><span class="line">        dp = [<span class="number">0</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        dp[<span class="number">1</span>] = nums[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i-<span class="number">1</span>):</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], dp[j]+nums[i])</span><br><span class="line">                <span class="comment"># 容易写错为dp[i] = max(dp[i], dp[j]+nums[j])</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure>
<h2 id="打家劫舍-II-213">打家劫舍 II[213]</h2>
<p>位于 <a href="https://leetcode.cn/problems/house-robber-ii">https://leetcode.cn/problems/house-robber-ii</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dp_f</span>(<span class="params">nums</span>):</span><br><span class="line">            dp = [<span class="number">0</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">            dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">            dp[<span class="number">1</span>] = nums[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i-<span class="number">1</span>):</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j]+nums[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums)==<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(nums)</span><br><span class="line">        max_dp1 = dp_f(nums[<span class="number">0</span>:<span class="built_in">len</span>(nums)-<span class="number">1</span>])</span><br><span class="line">        max_dp2 = dp_f(nums[<span class="number">1</span>:<span class="built_in">len</span>(nums)])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(max_dp1, max_dp2)</span><br></pre></td></tr></table></figure>
<p>分开来做就好</p>
<h2 id="打家劫舍-III-337">打家劫舍 III[337]</h2>
<p>位于 <a href="https://leetcode.cn/problems/house-robber-iii">https://leetcode.cn/problems/house-robber-iii</a><br>
递归法，实现思路：用root点和不用root点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 用root点</span></span><br><span class="line">        money = root.val</span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            money = money + self.rob(root.left.left) + self.rob(root.left.right)</span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            money = money + self.rob(root.right.left) + self.rob(root.right.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(money, self.rob(root.left)+self.rob(root.right)) <span class="comment">#不用root点</span></span><br></pre></td></tr></table></figure>
<p>递归优化法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.d = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">in</span> self.d:</span><br><span class="line">            <span class="keyword">return</span> self.d[root]</span><br><span class="line">        money = root.val</span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            money = money + self.rob(root.left.left) + self.rob(root.left.right)</span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            money = money + self.rob(root.right.left) + self.rob(root.right.right)</span><br><span class="line">        result = <span class="built_in">max</span>(money, self.rob(root.left)+self.rob(root.right))</span><br><span class="line">        self.d[root] = result</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h1>背包零钱</h1>
<h2 id="背包问题介绍">背包问题介绍</h2>
<p>可以看如下几个连接，增加对某些点的理解</p>
<ul>
<li>
<p><a href="https://leetcode.cn/problems/coin-change-ii/solutions/1412584/by-flix-e1vv/">https://leetcode.cn/problems/coin-change-ii/solutions/1412584/by-flix-e1vv/</a><br>
这个说的挺好的，总结的题目都有，后面的题解也是围绕这个来的</p>
</li>
<li>
<p><a href="https://labuladong.github.io/algo/di-er-zhan-a01c6/bei-bao-le-34bd4/jing-dian--28f3c">https://labuladong.github.io/algo/di-er-zhan-a01c6/bei-bao-le-34bd4/jing-dian--28f3c</a><br>
这个是labuladong的算法笔记，说的也挺好的</p>
</li>
</ul>
<p>整体上，背包问题的动态规划写成如下的形式：</p>
<p>0-1背包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][j]=max(dp[i-1][j],dp[i-1][j-w_i]+v_i, 0&lt;=w_i&lt;=j)</span><br></pre></td></tr></table></figure>
<p>完全背包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][j]=max(dp[i-1][j],dp[i][j-w_i]+v_i, 0&lt;=w_i&lt;=j)</span><br></pre></td></tr></table></figure>
<p>注意：在使用的时候，大部分组合问题，因此for两层循环的话，外层是N个物件或者N种币，内层是背包的容量W或者是要凑的零钱大小W。关于组合还有排序的问题可以看 <a href="https://leetcode.cn/problems/coin-change-ii/solutions/143948/ling-qian-dui-huan-iihe-pa-lou-ti-wen-ti-dao-di-yo/">https://leetcode.cn/problems/coin-change-ii/solutions/143948/ling-qian-dui-huan-iihe-pa-lou-ti-wen-ti-dao-di-yo/</a></p>
<h2 id="逻辑分开">逻辑分开</h2>
<p>做题的逻辑哈<br>
<img src="https://note.youdao.com/yws/res/9439/WEBRESOURCE355ec888043d505907a9f4cfb7a1c279" alt="图片1.png"></p>
<h2 id="模板-3">模板</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 二维</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = x</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):<span class="comment">#注意加1</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(amount+<span class="number">1</span>): <span class="comment">#注意加1</span></span><br><span class="line">        <span class="keyword">if</span> xx:</span><br><span class="line">            dp[i][j] = <span class="built_in">min</span>(dp[i-<span class="number">1</span>][j] , dp[i][j-coins[i-<span class="number">1</span>]]+<span class="number">1</span>) <span class="comment"># 注意i-1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ...</span><br><span class="line"><span class="comment"># 一维</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> coins: <span class="comment"># 1. 遍历硬币</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(amount,i-<span class="number">1</span>, -<span class="number">1</span>): <span class="comment"># 2.遍历金额，逆序，注意最小值</span></span><br><span class="line">        dp[j] = <span class="built_in">min</span>,<span class="built_in">max</span>,..., dp[j], dp[j-i] <span class="comment"># 3. 写动态函数</span></span><br></pre></td></tr></table></figure>
<h2 id="0-1背包">0-1背包</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 二维</span></span><br><span class="line">N = <span class="number">3</span>  <span class="comment"># 物品数量</span></span><br><span class="line">W = <span class="number">4</span>  <span class="comment"># 背包容量</span></span><br><span class="line">Wt = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>]  <span class="comment"># 所占用的容量</span></span><br><span class="line">val = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>]  <span class="comment"># 价值</span></span><br><span class="line">dp = [[<span class="number">0</span>] * (W + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N + <span class="number">1</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N + <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, W + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> w - Wt[i - <span class="number">1</span>] &lt; <span class="number">0</span>:</span><br><span class="line">            dp[i][w] = dp[i - <span class="number">1</span>][w]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dp[i][w] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][w], dp[i - <span class="number">1</span>][w - Wt[i - <span class="number">1</span>]] + val[i - <span class="number">1</span>])</span><br><span class="line"><span class="comment"># 【推荐写法】一维</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_1_wei_bag_problem</span>():</span><br><span class="line">    weight = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">    value = [<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line">    bagWeight = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化</span></span><br><span class="line">    dp = [<span class="number">0</span>] * (bagWeight + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(weight)):  <span class="comment"># 遍历物品</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(bagWeight, weight[i] - <span class="number">1</span>, -<span class="number">1</span>):  <span class="comment"># 遍历背包容量</span></span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i])</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(dp[bagWeight])</span><br></pre></td></tr></table></figure>
<h3 id="目标和-494">目标和[494]</h3>
<p>位于 <a href="https://leetcode.cn/problems/target-sum">https://leetcode.cn/problems/target-sum</a></p>
<p>分析：0-1背包，外循环硬币，内循环金额，内循环逆序，注意内循环最小值</p>
<p>dp累加dp[i] = dp[i] + dp[j-i]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 二维</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findTargetSumWays</span>(<span class="params">self, nums, target</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        total = <span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(target) &gt; total:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (total+target)%<span class="number">2</span>==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        pos = (total + target) // <span class="number">2</span></span><br><span class="line">        neg = (total - target) // <span class="number">2</span></span><br><span class="line">        C = <span class="built_in">min</span>(pos,  neg) <span class="comment"># 金额</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums) <span class="comment"># 硬币数量</span></span><br><span class="line"></span><br><span class="line">        dp = [[<span class="number">0</span>]*(C+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(C+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j &gt;= nums[i-<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i-<span class="number">1</span>][j-nums[i-<span class="number">1</span>]] <span class="comment"># 0-1背包</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> dp[n][C]</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 【推荐写法】一维</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findTargetSumWays</span>(<span class="params">self, nums, target</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        total = <span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(target) &gt; total:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (total+target)%<span class="number">2</span>==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        pos = (total + target) // <span class="number">2</span></span><br><span class="line">        neg = (total - target) // <span class="number">2</span></span><br><span class="line">        C = <span class="built_in">min</span>(pos,  neg) <span class="comment"># 金额</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums) <span class="comment"># 硬币数量</span></span><br><span class="line"></span><br><span class="line">        dp = [<span class="number">0</span>] * (C+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums: <span class="comment"># 1. 外循环：遍历硬币 </span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(C, i-<span class="number">1</span>, -<span class="number">1</span>): <span class="comment"># 2. 内循环 逆序：遍历目标金额，最小为i-1一定</span></span><br><span class="line">                dp[j] = dp[j] + dp[j-i]</span><br><span class="line">        <span class="keyword">return</span> dp[C]</span><br></pre></td></tr></table></figure>
<h3 id="分割等和子集-416">分割等和子集[416]</h3>
<p>位于 <a href="https://leetcode.cn/problems/partition-equal-subset-sum">https://leetcode.cn/problems/partition-equal-subset-sum</a></p>
<p>分析：0-1背包，外循环硬币，内循环金额，内循环逆序，注意内循环最小值</p>
<p>dp累求|即可，为dp[i] = dp[i] | dp[j-i]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一维动态规划</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canPartition</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="comment"># 边界</span></span><br><span class="line">        total = <span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> total % <span class="number">2</span>==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        target = total // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">max</span>(nums) &gt; target:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># dp</span></span><br><span class="line">        dp = [<span class="literal">False</span>] * (target+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums: <span class="comment"># 1.遍历物品即硬币</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(target, num-<span class="number">1</span>, -<span class="number">1</span>): <span class="comment"># 2. 遍历目标（金额），逆序，最小为num-1</span></span><br><span class="line">                dp[j] |= dp[j-num] <span class="comment"># 3. 动规表达式</span></span><br><span class="line">        <span class="keyword">return</span> dp[target]</span><br></pre></td></tr></table></figure>
<h3 id="最后一块石头的重量-II-1049">最后一块石头的重量 II[1049]</h3>
<p>位于 <a href="https://leetcode.cn/problems/last-stone-weight-ii">https://leetcode.cn/problems/last-stone-weight-ii</a></p>
<p>分析：0-1背包，外循环硬币，内循环金额，内循环逆序，注意内循环最小值</p>
<p>dp为 dp[j] = max(dp[j], dp[j - stone] + stone)</p>
<p>分析：本题其实就是尽量让石头分成重量相同的两堆，相撞之后剩下的石头最小，这样就化解成01背包问题了。分析到物品的重量为stones[i]，物品的价值也为stones[i]。</p>
<p>dp数组含义，表示前i个stone得到不超过taget的最大重量，这里是最大，不是刚刚好。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一维动态规划</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lastStoneWeightII</span>(<span class="params">self, stones: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="number">0</span>] * <span class="number">15001</span></span><br><span class="line">        total_sum = <span class="built_in">sum</span>(stones)</span><br><span class="line">        target = total_sum // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> stone <span class="keyword">in</span> stones:  <span class="comment"># 1. 遍历物品</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(target, stone - <span class="number">1</span>, -<span class="number">1</span>):  <span class="comment"># 2. 遍历背包，逆序，最小为stone-1</span></span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], dp[j - stone] + stone)</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> total_sum - dp[target] - dp[target]</span><br></pre></td></tr></table></figure>
<h3 id="一和零-474">一和零[474]</h3>
<p>位于 <a href="https://leetcode.cn/problems/ones-and-zeroes">https://leetcode.cn/problems/ones-and-zeroes</a><br>
分析：0-1背包，外循环硬币，内循环金额，内循环逆序，注意内循环最小值</p>
<p>dp表达式为 dp[m][n] = max(dp[m][n], dp[m-neg][n-pos]+1)</p>
<p>分析：从一个list的字符串中选择一些数，使得1的数不超过m,0的数不超过n.<br>
dp[i][j]表示不超过i和j的最大集合的长度，和上面类似，这是这里二维。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMaxForm</span>(<span class="params">self, strs, m, n</span>):</span><br><span class="line">        dp = [[<span class="number">0</span>]*(n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> strs: <span class="comment"># 1. 遍历硬币</span></span><br><span class="line">            pos = s.count(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            neg = <span class="built_in">len</span>(s) - pos</span><br><span class="line">            <span class="keyword">for</span> m1 <span class="keyword">in</span> <span class="built_in">range</span>(m,neg-<span class="number">1</span>,-<span class="number">1</span>): <span class="comment"># 2. 遍历金额，逆序，最小值</span></span><br><span class="line">                <span class="keyword">for</span> n1 <span class="keyword">in</span> <span class="built_in">range</span>(n,pos-<span class="number">1</span>,-<span class="number">1</span>):<span class="comment"># 3. 遍历金额，逆序，最小值</span></span><br><span class="line">                    dp[m1][n1] = <span class="built_in">max</span>(dp[m1][n1], dp[m1-neg][n1-pos]+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure>
<h2 id="完全背包">完全背包</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">N = <span class="number">3</span>  <span class="comment"># 物品数量</span></span><br><span class="line">W = <span class="number">4</span>  <span class="comment"># 背包容量</span></span><br><span class="line">Wt = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>]  <span class="comment"># 所占用的容量</span></span><br><span class="line">val = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>]  <span class="comment"># 价值</span></span><br><span class="line">dp = [[<span class="number">0</span>] * (W + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N + <span class="number">1</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N + <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, W + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> w - Wt[i - <span class="number">1</span>] &lt; <span class="number">0</span>:</span><br><span class="line">            dp[i][w] = dp[i - <span class="number">1</span>][w]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dp[i][w] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][w], dp[i][w - Wt[i - <span class="number">1</span>]] + val[i - <span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<h3 id="零钱兑换-322">零钱兑换[322]</h3>
<p>位于 <a href="https://leetcode.cn/problems/coin-change">https://leetcode.cn/problems/coin-change</a></p>
<p>分析：完全背包，外循环硬币，内循环金额，内循环顺序</p>
<p>dp公式dp[j] = min(dp[j],dp[j-i]+1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 二维解法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">coinChange</span>(<span class="params">self, coins, amount</span>):</span><br><span class="line">        <span class="comment"># 1. 初始化</span></span><br><span class="line">        N = <span class="built_in">len</span>(coins)</span><br><span class="line">        dp = [[<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)]*(amount+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 2. 循环</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,N+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(amount+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j &gt;= coins[i-<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i-<span class="number">1</span>][j] , dp[i][j-coins[i-<span class="number">1</span>]]+<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j]</span><br><span class="line">        ans = dp[N][amount]</span><br><span class="line">        <span class="keyword">return</span> ans <span class="keyword">if</span> ans!=<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>) <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line"><span class="comment"># 一维解法I</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">coinChange</span>(<span class="params">self, coins, amount</span>):</span><br><span class="line">        <span class="comment"># 1. 初始化</span></span><br><span class="line">        N = <span class="built_in">len</span>(coins)</span><br><span class="line">        dp = [<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)]*(amount+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 2. 循环</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(amount+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j &gt;= coins[i]:</span><br><span class="line">                    dp[j] = <span class="built_in">min</span>(dp[j], dp[j-coins[i]]+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[amount] <span class="keyword">if</span> dp[amount]!=<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>) <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line"><span class="comment"># 一维解法II</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">coinChange</span>(<span class="params">self, coins, amount</span>):</span><br><span class="line">        <span class="keyword">if</span> amount==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * (amount+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, amount+<span class="number">1</span>):</span><br><span class="line">                dp[j] = <span class="built_in">min</span>(dp[j],dp[j-i]+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[amount] <span class="keyword">if</span> dp[amount]!=<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>注意一维和二维中，在二维初始化的时候长度是amount+1, 一维也是，但是在N这个地方，二维是N+1，一维是N。</p>
<p>解法 <a href="https://leetcode.cn/problems/coin-change/solutions/1412324/by-flix-su7s/">https://leetcode.cn/problems/coin-change/solutions/1412324/by-flix-su7s/</a></p>
<h3 id="零钱兑换II-518">零钱兑换II[518]</h3>
<p>位于 <a href="https://leetcode.cn/problems/coin-change-ii">https://leetcode.cn/problems/coin-change-ii</a></p>
<p>分析：完全背包，外循环硬币，内循环金额，内循环顺序</p>
<p>dp公式dp[j] = dp[j] + dp[j-i]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 二维</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">self, amount, coins</span>):</span><br><span class="line">        <span class="comment"># 1. 初始化</span></span><br><span class="line">        N = <span class="built_in">len</span>(coins)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(amount+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N+<span class="number">1</span>)] <span class="comment"># 方便后面取数</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 2. 循环</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(amount+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> coins[i-<span class="number">1</span>] &gt; j:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-coins[i-<span class="number">1</span>]]</span><br><span class="line">        <span class="keyword">return</span> dp[N][amount]</span><br></pre></td></tr></table></figure>
<p>当然，官方简单的方法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 压缩为1维</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">self, amount, coins</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> amount:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>      </span><br><span class="line">        <span class="comment"># 1. 初始化</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (amount+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 2. 循环</span></span><br><span class="line">        N = <span class="built_in">len</span>(coins)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N): </span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(amount+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j &gt;= coins[i]:                    </span><br><span class="line">                    dp[j] = dp[j] + dp[j-coins[i]]</span><br><span class="line">        <span class="keyword">return</span> dp[amount]</span><br><span class="line"><span class="comment"># 2.再简化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">self, amount: <span class="built_in">int</span>, coins: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> amount:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>      </span><br><span class="line">        dp = [<span class="number">0</span>] * (amount+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> coins: </span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, amount+<span class="number">1</span>):</span><br><span class="line">                dp[j] = dp[j] + dp[j-i]</span><br><span class="line">        <span class="keyword">return</span> dp[amount]</span><br></pre></td></tr></table></figure>
<h3 id="硬币问题-面试题-08-11">硬币问题[面试题 08.11]</h3>
<p>题目见 <a href="https://leetcode-cn.com/problems/coin-lcci">https://leetcode-cn.com/problems/coin-lcci</a> 题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">waysToChange</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        mod = <span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        coins = [<span class="number">25</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        f = [<span class="number">1</span>] + [<span class="number">0</span>] * n</span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(coin, n + <span class="number">1</span>):</span><br><span class="line">                f[i] += f[i - coin]</span><br><span class="line">        <span class="keyword">return</span> f[n] % mod</span><br></pre></td></tr></table></figure>
<h3 id="分割数组的最大值-410">分割数组的最大值[410]</h3>
<p>位于 <a href="https://leetcode.cn/problems/split-array-largest-sum">https://leetcode.cn/problems/split-array-largest-sum</a><br>
分析：完全背包，外循环硬币，内循环金额，内循环顺序</p>
<p>dp公式f[i][j] = min(f[i][j], max(f[k][j - 1], sub[i] - sub[k]))</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">splitArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], m: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        f = [[<span class="number">10</span>**<span class="number">18</span>] * (m + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">        sub = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> elem <span class="keyword">in</span> nums:</span><br><span class="line">            sub.append(sub[-<span class="number">1</span>] + elem)</span><br><span class="line">        </span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">min</span>(i, m) + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                    f[i][j] = <span class="built_in">min</span>(f[i][j], <span class="built_in">max</span>(f[k][j - <span class="number">1</span>], sub[i] - sub[k]))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> f[n][m]</span><br></pre></td></tr></table></figure>
<h3 id="组数总和Ⅳ">组数总和Ⅳ</h3>
<p>位于 <a href="https://leetcode.cn/problems/combination-sum-iv">https://leetcode.cn/problems/combination-sum-iv</a><br>
分析：完全背包，外循环金额【排列问题】，内循环硬币，内循环顺序</p>
<p>dp公式dp[i] = dp[i] + dp[i-j]</p>
<p>题目见 <a href="https://leetcode-cn.com/problems/combination-sum-iv/">https://leetcode-cn.com/problems/combination-sum-iv/</a>  这道题和爬楼梯的问题有点类似，但是解法不太一样。动态规划的方程是<br>
dp[i] = sum(dp[i-j]) j&lt;=i.解法如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum4</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="number">0</span>] * (target+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,target+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> i &gt;= j:</span><br><span class="line">                    dp[i] = dp[i] + dp[i-j]</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="爬楼梯-70-2">爬楼梯[70]</h3>
<p>位于 <a href="https://leetcode.cn/problems/climbing-stairs">https://leetcode.cn/problems/climbing-stairs</a><br>
分析：完全背包，外循环金额【排列问题】，内循环硬币，内循环顺序</p>
<p>dp公式dp[i] = dp[i] + dp[i-j]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">target = <span class="number">10</span> <span class="comment"># 爬到阶梯数</span></span><br><span class="line">w = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment"># 每次可以爬多少</span></span><br><span class="line">dp = [<span class="number">0</span>] * (target + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(target + <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(w)):</span><br><span class="line">        <span class="keyword">if</span> i - j &gt;= <span class="number">0</span>:</span><br><span class="line">            dp[i] = dp[i] + dp[i - j]</span><br><span class="line"><span class="built_in">print</span>(dp[<span class="number">10</span>])</span><br></pre></td></tr></table></figure>
<h3 id="剪绳子">剪绳子</h3>
<p>题目见</p>
<h1>股票买卖问题</h1>
<h2 id="模板-4">模板</h2>
<p>这里主要说一下DP的思路，按照labuladong的做法，基本上上可以在一个模板上丝毫不动，就可以得到结果</p>
<p>统一的动态规划方程如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"># 初始化</span><br><span class="line">dp = [[<span class="number">0</span>]*<span class="number">2</span> <span class="keyword">for</span> _ in <span class="keyword">range</span>(<span class="built_in">len</span>(prics))]</span><br><span class="line"><span class="keyword">for</span> i in <span class="keyword">range</span>(<span class="built_in">len</span>(prices)):</span><br><span class="line">    dp[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    dp[i][<span class="number">1</span>] = -float(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> i==<span class="number">0</span>:</span><br><span class="line">    dp[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    dp[i][<span class="number">1</span>] = -prics[<span class="number">0</span>] - 手续费</span><br><span class="line"># <span class="keyword">for</span>一下</span><br><span class="line">dp[i][k][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][k][<span class="number">0</span>], dp[i<span class="number">-1</span>][k][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][k][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][k][<span class="number">1</span>], dp[i<span class="number">-1</span>][k<span class="number">-1</span>][<span class="number">0</span>] - prices[i] - 手续费) </span><br></pre></td></tr></table></figure>
<p>i表示第几天，k表示最多交易次数，0表示手里没股票了，1表示手里还有股票。</p>
<blockquote>
<p><a href="https://labuladong.github.io/algo/di-er-zhan-a01c6/yong-dong--63ceb/yi-ge-fang-3b01b/">https://labuladong.github.io/algo/di-er-zhan-a01c6/yong-dong--63ceb/yi-ge-fang-3b01b/</a></p>
</blockquote>
<h2 id="买卖股票的最佳时机-121">买卖股票的最佳时机[121]</h2>
<p>题目：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模板解法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices</span>):</span><br><span class="line">        <span class="comment"># dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])</span></span><br><span class="line">        <span class="comment"># dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) </span></span><br><span class="line">        <span class="comment"># k=1简化为</span></span><br><span class="line">        <span class="comment"># dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</span></span><br><span class="line">        <span class="comment"># dp[i][1] = max(dp[i-1][1], -prices[i])</span></span><br><span class="line">        dp = [[<span class="number">0</span>]*<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices))]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices)):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">                dp[i][<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>], -prices[i])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="built_in">len</span>(prices)-<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 更简单做法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices</span>):</span><br><span class="line">        mins = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">        profit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> prices:</span><br><span class="line">            <span class="keyword">if</span> i &lt; mins:</span><br><span class="line">                mins = i</span><br><span class="line">            profit = <span class="built_in">max</span>(profit, i - mins)</span><br><span class="line">        <span class="keyword">return</span> profit</span><br></pre></td></tr></table></figure>
<h2 id="买卖股票的最佳时机II-122">买卖股票的最佳时机II[122]</h2>
<p>题目：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模板做法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices</span>):</span><br><span class="line">        <span class="comment"># dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])</span></span><br><span class="line">        <span class="comment"># dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) </span></span><br><span class="line">        <span class="comment"># k=1简化为</span></span><br><span class="line">        <span class="comment"># dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</span></span><br><span class="line">        <span class="comment"># dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices[i]) #改动点1</span></span><br><span class="line">        dp = [[<span class="number">0</span>]*<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices))]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices)):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">                dp[i][<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>], dp[i-<span class="number">1</span>][<span class="number">0</span>]-prices[i])<span class="comment">#改动点2</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="built_in">len</span>(prices)-<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 更简单做法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices</span>):</span><br><span class="line">        profit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(prices)):</span><br><span class="line">            <span class="keyword">if</span> prices[i] - prices[i-<span class="number">1</span>] &gt; <span class="number">0</span>:</span><br><span class="line">                profit += prices[i] - prices[i-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> profit</span><br></pre></td></tr></table></figure>
<h2 id="买卖股票的最佳时机含冷冻期-309">买卖股票的最佳时机含冷冻期[309]</h2>
<p>题目：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模板做法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices</span>):</span><br><span class="line">        <span class="comment"># dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])</span></span><br><span class="line">        <span class="comment"># dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) </span></span><br><span class="line">        <span class="comment"># k=1简化为</span></span><br><span class="line">        <span class="comment"># dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</span></span><br><span class="line">        <span class="comment"># dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices[i])</span></span><br><span class="line">        dp = [[<span class="number">0</span>]*<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices))]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices)):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">                dp[i][<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>], dp[i-<span class="number">2</span>][<span class="number">0</span>]-prices[i]) <span class="comment"># 改动点</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="built_in">len</span>(prices)-<span class="number">1</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h2 id="买卖股票的最佳时机含手续费-714">买卖股票的最佳时机含手续费[714]</h2>
<p>题目：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices, fee</span>):</span><br><span class="line">        <span class="comment"># dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])</span></span><br><span class="line">        <span class="comment"># dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) </span></span><br><span class="line">        <span class="comment"># k=1简化为</span></span><br><span class="line">        <span class="comment"># dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</span></span><br><span class="line">        <span class="comment"># dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices[i])</span></span><br><span class="line">        dp = [[<span class="number">0</span>]*<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices))]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices)):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">                dp[i][<span class="number">1</span>] = -prices[<span class="number">0</span>] - fee <span class="comment"># 改动点</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>], dp[i-<span class="number">1</span>][<span class="number">0</span>]-prices[i]-fee) <span class="comment"># 改动点</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="built_in">len</span>(prices)-<span class="number">1</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h2 id="买卖股票的最佳时机-III-123">买卖股票的最佳时机 III[123]</h2>
<p>题目：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])</span></span><br><span class="line">        <span class="comment"># dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) </span></span><br><span class="line">        <span class="comment"># k=1简化为</span></span><br><span class="line">        <span class="comment"># dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</span></span><br><span class="line">        <span class="comment"># dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices[i])</span></span><br><span class="line">        max_k = <span class="number">2</span></span><br><span class="line">        dp = [[[<span class="number">0</span>] * <span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(max_k + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices))]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices)):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, max_k+<span class="number">1</span>): <span class="comment"># 改动点</span></span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                    dp[i][k][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">                    dp[i][k][<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                dp[i][k][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][k][<span class="number">0</span>], dp[i-<span class="number">1</span>][k][<span class="number">1</span>] + prices[i])</span><br><span class="line">                dp[i][k][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][k][<span class="number">1</span>], dp[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>]-prices[i])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="built_in">len</span>(prices)-<span class="number">1</span>][max_k][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h1>博弈问题</h1>
<p><a href="https://labuladong.online/algo/dynamic-programming/game-theory/">https://labuladong.online/algo/dynamic-programming/game-theory/</a></p>
<h2 id="预测赢家-486">预测赢家[486]</h2>
<p>题目：<a href="https://leetcode.cn/problems/predict-the-winner/description/">https://leetcode.cn/problems/predict-the-winner/description/</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predictTheWinner</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        length = <span class="built_in">len</span>(nums)</span><br><span class="line">        dp = [[<span class="number">0</span>] * length <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(length)]</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            dp[i][i] = num</span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,length):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length-l):</span><br><span class="line">                j = i + l</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(nums[i] - dp[i + <span class="number">1</span>][j], nums[j] - dp[i][j - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][length - <span class="number">1</span>] &gt;= <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h2 id="石子游戏-877">石子游戏[877]</h2>
<p>题目：<a href="https://leetcode.cn/problems/stone-game/description/">https://leetcode.cn/problems/stone-game/description/</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">stoneGame</span>(<span class="params">self, piles: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        length = <span class="built_in">len</span>(piles)</span><br><span class="line">        dp = [[<span class="number">0</span>] * <span class="built_in">len</span>(piles) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(piles))]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(piles)):</span><br><span class="line">            dp[i][i] = piles[i]</span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,length):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length-l):</span><br><span class="line">                j = i + l        </span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(piles[i] - dp[i + <span class="number">1</span>][j], piles[j] - dp[i][j - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][length - <span class="number">1</span>] &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>和上面一样，严格意义上，不算双序列问题，所以这里不用dp=[[0]*(n+1) for i in range(n+1)]</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>题目汇总</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>链表</title>
    <url>/2024/03/19/leetcode/link_list/</url>
    <content><![CDATA[<h1>单链表</h1>
<h2 id="总结基础操作">总结基础操作</h2>
<h3 id="反转后保留head和尾部">反转后保留head和尾部</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reversePart</span>(<span class="params">head</span>):</span><br><span class="line">    pre = <span class="literal">None</span></span><br><span class="line">    cur = head</span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        <span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">        cur.<span class="built_in">next</span> = pre</span><br><span class="line">        pre = cur</span><br><span class="line">        cur = <span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> pre【新的头】, head【新的尾】</span><br></pre></td></tr></table></figure>
<p>输入head后，返回反转后的头pre和尾head</p>
<h3 id="涉及指定位置的反转">涉及指定位置的反转</h3>
<p>对于206和24两道题，其实本质上要处理的还是两个点，也就是node0和node1,因此都定义两个点就够了，只是在处理的过程中，需要借用到一些临时的变量，这时候，可以使用一些node2等作为辅助。</p>
<h3 id="双指针技巧">双指针技巧</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">slow = head</span><br><span class="line">fast = head</span><br><span class="line"><span class="keyword">while</span> fast <span class="keyword">and</span> fast.nex:</span><br><span class="line">    slow = slow.<span class="built_in">next</span></span><br><span class="line">    fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<h3 id="统计链表长度">统计链表长度</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cnt = <span class="number">0</span></span><br><span class="line">cur = head</span><br><span class="line"><span class="keyword">while</span> cur:</span><br><span class="line">    cnt += <span class="number">1</span></span><br><span class="line">    cur = cur.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<h3 id="虚拟头">虚拟头</h3>
<p>方便后续对指针的操作，在删除链表元素以及去除重复项中都有用。可以看到基本上对单链表中翻转或者元素操作的地方，都用到了dummy这个虚拟的链表节点，方便对一些异常节点的处理。就是第一个节点一旦不太好定义或者后面会随着代码中的处理逻辑会发生变化，比如删除指定元素万一删除到了自己，或者旋转链表的时候头也变了，这些情况下用一个虚拟的头接着后面的head然后处理完之后再用next进行获取就好。</p>
<p>先<code>dummy=ListNode(-1)</code>后一定不能直接对dummy操作，也就是不能直接<code>dummy=dummy.next</code>，那样随着后面写代码的话，dummy的head就不知道哪里去了，应该先定义一个<code>cur=dummy</code>，然后访问的时候使用<code>cur=cur.next</code>来按照顺序访问指针，最后我们获取整个更新后的链表的时候，直接使用<code>dummy.next</code>就好了。</p>
<p>使用到dummy基本上都要left=dummy=ListNode(None,next=…),然后用left操作，最后返回dummy.next就可以</p>
<h3 id="操作的先后顺序">操作的先后顺序</h3>
<p>在链表中，主要是对指针进行操作，那么操作的顺序，以及如何使用next，使用的时机要把握好，不然容易出现<code>cur=cur.next</code>后，再把指针指向<code>cur</code>，因为这时<code>cur</code>都变了，你再指的话是有问题的，所有对于具体的问题要画出图来分析，我们结合两个案例来说明，第一是链表的翻转</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> cur:</span><br><span class="line">    <span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">    cur.<span class="built_in">next</span> = pre</span><br><span class="line">    pre = cur</span><br><span class="line">    cur = <span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<p>这里相当于前面的None和节点1，变成了后面迭代中节点1和节点2，但是呢，我们得先把节点2的指针存下来，不然后面cur.next变了之后，你就再也访问不到了。</p>
<p>还有一些案例，比如合并有序链表，其实这个相当于重新构建一个链表，我们写的时候不太需要保存后面的指针了，因为不需要像翻转链表那样，不保存的话会导致里面的值被修改掉。这个案例的代码就很简单如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> cur:</span><br><span class="line">    cur.<span class="built_in">next</span> = head1</span><br><span class="line">    cur = head1</span><br></pre></td></tr></table></figure>
<p>就是先指完后再重置<code>cur</code>到移动指针的位置。</p>
<h3 id="重新定义个链表">重新定义个链表</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">cur = dummy <span class="comment"># 面说到了，我们定义了dummy后，还需要定义一个cur指向他，对他的值进行修改，然后cur动dummy不动</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> res[::-<span class="number">1</span>]:</span><br><span class="line">    cur.<span class="built_in">next</span> = ListNode(i)</span><br><span class="line">    cur = cur.<span class="built_in">next</span></span><br><span class="line"><span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<p>注意，千万不能写成如下的形式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> res[::-<span class="number">1</span>]:</span><br><span class="line">    dummy.<span class="built_in">next</span> = ListNode(i)</span><br><span class="line">    dummy = dummy.<span class="built_in">next</span></span><br><span class="line"><span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<p>这里用到dummy指针就有用了</p>
<h3 id="将链表从中间断开">将链表从中间断开</h3>
<p>目的是为了二分，便于后面进行归并排序，下面这段代码集中了错误和正确的，可以对比下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 错误的</span></span><br><span class="line">slow = cur</span><br><span class="line">fast = cur</span><br><span class="line"><span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">    slow = slow.<span class="built_in">next</span></span><br><span class="line">    fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">right = slow.<span class="built_in">next</span></span><br><span class="line">slow.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">left_sort_results = merge_sort(cur)</span><br></pre></td></tr></table></figure>
<p>这样在递归的时候，程序会无限，无法跳出，下面看下没问题的结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">slow = cur</span><br><span class="line">fast = cur</span><br><span class="line">pre = <span class="literal">None</span></span><br><span class="line"><span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">    pre = slow</span><br><span class="line">    slow = slow.<span class="built_in">next</span></span><br><span class="line">    fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">pre.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">left_sort_results = merge_sort(cur)</span><br></pre></td></tr></table></figure>
<h3 id="关于步进访问">关于步进访问</h3>
<p>这里需要指出的是，使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> fast:</span><br><span class="line">	fast = fast.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<p>这里这么做是没问题的，但是如果一旦涉及到fast.next=xxx的时候就要注意了，可能会改变这个链表原来的数据流的走向，建议画图看奇偶链表。</p>
<h3 id="关于链表重新整理顺序">关于链表重新整理顺序</h3>
<p>我们看到很多对链表进行操作，排序也好，还是交换顺序也好，对于翻转，这种是有规律的，而且是反向操作，因此有固定的模版可以写的，对于一些其它稀奇古怪的题，可以尝试如下的做法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">small_dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">big_dummy = ListNode(-<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">small = small_dummy</span><br><span class="line">big = big_dummy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后遍历cur，把数值放到，small和big的next中</span></span><br></pre></td></tr></table></figure>
<p>就是用两个虚拟的指针来操作，然后进行组合，如 分隔链表[86]，奇偶链表[328]，合并链表等操作，简单连接就是借助外部的指针来对现有的指针进行串起来。</p>
<h3 id="多指针同时操作链表存在的问题">多指针同时操作链表存在的问题</h3>
<p>对于单个指针，使用cur=cur.next可以步进访问链表的元素，使用cur.next=cur.next.next也可是进行断点连接某节点。但是对于多个指针，如两个指针，同时操作链表，则会存在一个指针修改了链表的结构，另一个再修改的话会出问题的情况，如奇偶链表那道题，和其它的很多题都不一样，它有两个指针指着链表，然后都需要进行链表值的替换等，这样一个链表修改了值，另外一个链表再访问就会出问题。</p>
<h3 id="快慢指针操作">快慢指针操作</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 建议写法</span></span><br><span class="line">slow = head</span><br><span class="line">fast = head</span><br><span class="line"><span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">    slow = slow.<span class="built_in">next</span></span><br><span class="line">    fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line"><span class="comment"># 2. 不建议写法</span></span><br><span class="line">slow = head</span><br><span class="line">fast = head.<span class="built_in">next</span></span><br><span class="line"><span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">    slow = slow.<span class="built_in">next</span></span><br><span class="line">    fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<h2 id="翻转系列">翻转系列</h2>
<h3 id="反转链表-206">反转链表[206]</h3>
<p>题号为 206， 位于 <a href="https://leetcode.cn/problems/reverse-linked-list/">https://leetcode.cn/problems/reverse-linked-list/</a><br>
题解如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        node0 = <span class="literal">None</span></span><br><span class="line">        node1 = head</span><br><span class="line">        <span class="keyword">while</span> node1:</span><br><span class="line">            node2 = node1.<span class="built_in">next</span></span><br><span class="line">            node1.<span class="built_in">next</span> = node0</span><br><span class="line">            node0 = node1</span><br><span class="line">            node1 = node2</span><br><span class="line">        <span class="keyword">return</span> node0</span><br></pre></td></tr></table></figure>
<p>总结下来，就是先保存好数据，代码是</p>
<pre><code>node2 = node1.next
</code></pre>
<p>然后操作</p>
<pre><code>node1.next = node0
</code></pre>
<p>然后平移</p>
<pre><code>node0 = node1
node1 = node2
</code></pre>
<p>相当于从[1,2,3,4,5]中的1,2为node0,node1,变成了2为node1,3为node2</p>
<p>递归方法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">recur</span>(<span class="params">cur, pre</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur: <span class="keyword">return</span> pre     <span class="comment"># 终止条件</span></span><br><span class="line">            res = recur(cur.<span class="built_in">next</span>, cur) <span class="comment"># 递归后继节点</span></span><br><span class="line">            cur.<span class="built_in">next</span> = pre             <span class="comment"># 修改节点引用指向</span></span><br><span class="line">            <span class="keyword">return</span> res                 <span class="comment"># 返回反转链表的头节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> recur(head, <span class="literal">None</span>)       <span class="comment"># 调用递归并返回</span></span><br></pre></td></tr></table></figure>
<p>来自 <a href="https://leetcode.cn/problems/reverse-linked-list/solutions/2361282/206-fan-zhuan-lian-biao-shuang-zhi-zhen-r1jel/">https://leetcode.cn/problems/reverse-linked-list/solutions/2361282/206-fan-zhuan-lian-biao-shuang-zhi-zhen-r1jel/</a></p>
<p>建议用下面的递归，更加的简答，但是不太好懂，我在代码中添加了注释</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> head==<span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span>==<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        ret = self.reverseList(head.<span class="built_in">next</span>)</span><br><span class="line">        <span class="comment"># 假设的是head.next后面已经反转好了，假设head=1,head.next.next就是5 4 3 2 的2， 然后2 的next=1,然后1再指定下</span></span><br><span class="line">        head.<span class="built_in">next</span>.<span class="built_in">next</span> = head</span><br><span class="line">        head.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<h3 id="反转链表-II-92">反转链表 II[92]</h3>
<p>位于 <a href="https://leetcode.cn/problems/reverse-linked-list-ii/">https://leetcode.cn/problems/reverse-linked-list-ii/</a><br>
题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseBetween</span>(<span class="params">self, head, left, right</span>):</span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>, <span class="built_in">next</span>=head)</span><br><span class="line">        first = dummy</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left-<span class="number">1</span>):</span><br><span class="line">            first = first.<span class="built_in">next</span></span><br><span class="line">        first_above = first</span><br><span class="line">        first = first.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        second = dummy</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(right):</span><br><span class="line">            second = second.<span class="built_in">next</span></span><br><span class="line">        second_after = second.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        cur = first</span><br><span class="line">        second.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">reversePart</span>(<span class="params">head</span>):</span><br><span class="line">            pre = <span class="literal">None</span></span><br><span class="line">            cur = head</span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                <span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">                cur.<span class="built_in">next</span> = pre</span><br><span class="line">                pre = cur</span><br><span class="line">                cur = <span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> pre, head</span><br><span class="line">        </span><br><span class="line">        reverse_head, reverse_tail = reversePart(cur)</span><br><span class="line">        first_above.<span class="built_in">next</span> = reverse_head</span><br><span class="line">        reverse_tail.<span class="built_in">next</span> = second_after</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<h3 id="两两交换链表中的节点-24">两两交换链表中的节点[24]</h3>
<p>题号 24， 位于 <a href="https://leetcode.cn/problems/swap-nodes-in-pairs/description/">https://leetcode.cn/problems/swap-nodes-in-pairs/description/</a><br>
题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">swapPairs</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        node0 = dummy = ListNode(<span class="built_in">next</span>=head)</span><br><span class="line">        node1 = head</span><br><span class="line">        <span class="keyword">while</span> node1 <span class="keyword">and</span> node1.<span class="built_in">next</span>:</span><br><span class="line">            node2 = node1.<span class="built_in">next</span></span><br><span class="line">            node3 = node2.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            node0.<span class="built_in">next</span> = node2</span><br><span class="line">            node2.<span class="built_in">next</span> = node1</span><br><span class="line">            node1.<span class="built_in">next</span> = node3</span><br><span class="line"></span><br><span class="line">            node0 = node1</span><br><span class="line">            node1 = node3</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<p>和上面一样的分析思路，先保存好数据，然后操作，然后平移，这个过程可以看 <a href="https://leetcode.cn/problems/swap-nodes-in-pairs/solutions/2374872/tu-jie-die-dai-di-gui-yi-zhang-tu-miao-d-51ap/">https://leetcode.cn/problems/swap-nodes-in-pairs/solutions/2374872/tu-jie-die-dai-di-gui-yi-zhang-tu-miao-d-51ap/</a></p>
<p>递归解法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">swapPairs</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> head==<span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span>==<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="built_in">next</span> = head.<span class="built_in">next</span></span><br><span class="line">        head.<span class="built_in">next</span> = self.swapPairs(<span class="built_in">next</span>.<span class="built_in">next</span>)</span><br><span class="line">        <span class="built_in">next</span>.<span class="built_in">next</span> = head</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<p>和前面的那道题不太一样，这里不需要pre那个东西的</p>
<h3 id="K-个一组翻转链表-25">K 个一组翻转链表[25]</h3>
<p>位于 <a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/description/">https://leetcode.cn/problems/reverse-nodes-in-k-group/description/</a><br>
题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseKGroup</span>(<span class="params">self, head, k</span>):</span><br><span class="line">        <span class="comment"># 旋转链表</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">reversePart</span>(<span class="params">head</span>):</span><br><span class="line">            pre = <span class="literal">None</span></span><br><span class="line">            cur = head</span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                <span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">                cur.<span class="built_in">next</span> = pre</span><br><span class="line">                pre = cur</span><br><span class="line">                cur = <span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> pre, head</span><br><span class="line">        <span class="comment"># 统计节点数量</span></span><br><span class="line">        node1 = head</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> node1:</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">            node1 = node1.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 保存每段的链表反转后的开始点和结束点</span></span><br><span class="line">        res = []</span><br><span class="line">        cur = head</span><br><span class="line">        old_cur = head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(cnt // k): <span class="comment"># 这里不要考虑最后一段哈，最后一段在res.append([cur, cur])这里</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k - <span class="number">1</span>):</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            tail_old = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">            new_head, new_tail = reversePart(old_cur)</span><br><span class="line">            res.append([new_head, new_tail])</span><br><span class="line">            cur = tail_old</span><br><span class="line">            old_cur = tail_old</span><br><span class="line">        res.append([cur, cur])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(res) - <span class="number">1</span>):</span><br><span class="line">            res[i][<span class="number">1</span>].<span class="built_in">next</span> = res[i + <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h3 id="旋转链表-61">旋转链表[61]</h3>
<p>位于 <a href="https://leetcode.cn/problems/rotate-list/description/">https://leetcode.cn/problems/rotate-list/description/</a><br>
思路是先闭合为环，然后再打断<br>
题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotateRight</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], k: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="comment"># 统计长度</span></span><br><span class="line">        cur = head</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            cnt = cnt + <span class="number">1</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 表示成环</span></span><br><span class="line">        cur2 = head</span><br><span class="line">        <span class="keyword">while</span> cur2.<span class="built_in">next</span>:</span><br><span class="line">            cur2 = cur2.<span class="built_in">next</span></span><br><span class="line">        cur2.<span class="built_in">next</span> = head</span><br><span class="line">        <span class="comment"># 断点</span></span><br><span class="line">        diff = cnt - k%cnt</span><br><span class="line">        cur3 = head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(diff-<span class="number">1</span>):</span><br><span class="line">            cur3 = cur3.<span class="built_in">next</span></span><br><span class="line">        new_head = cur3.<span class="built_in">next</span></span><br><span class="line">        cur3.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> new_head</span><br></pre></td></tr></table></figure>
<h3 id="排序链表-148">排序链表 [148]</h3>
<p>位于 <a href="https://leetcode.cn/problems/sort-list">https://leetcode.cn/problems/sort-list</a><br>
使用冒泡排序来做的话，比较耗时，做法如下，建议将图画出来，便于理解中间的指针的操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>, <span class="built_in">next</span>=head)</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(cnt):</span><br><span class="line">            node0 = dummy <span class="comment"># 注意这里</span></span><br><span class="line">            node1 = dummy.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">while</span> node1 <span class="keyword">and</span> node1.<span class="built_in">next</span>:</span><br><span class="line">                <span class="keyword">if</span> node1.val &lt;= node1.<span class="built_in">next</span>.val:</span><br><span class="line">                    node0 = node0.<span class="built_in">next</span></span><br><span class="line">                    node1 = node1.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    node2 = node1.<span class="built_in">next</span></span><br><span class="line">                    node3 = node2.<span class="built_in">next</span></span><br><span class="line">                    node0.<span class="built_in">next</span> = node2</span><br><span class="line">                    node2.<span class="built_in">next</span> = node1</span><br><span class="line">                    node1.<span class="built_in">next</span> = node3</span><br><span class="line"></span><br><span class="line">                    node0 = node2</span><br><span class="line">                    node1 = node1</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<p>上述代码中我们使用了node0和node1两个指针来做维护的，当然在程序的执行过程中，我们还使用了其他的临时指针，这些在程序运行过程中定义就好了，不需要在进入while的之前定义，这道题和上面的24有点像，它也是定义了node0和node1，然后其他的需要的时候自己定义，具体操作看具体情况。</p>
<p>可以使用归并排序算法来做，具体的思路如下，这是我自己写的，也遇到了很多的问题，主要的问题在代码中已经说明了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">p1, p2</span>):</span><br><span class="line">            dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">            cur = dummy</span><br><span class="line">            <span class="keyword">while</span> p1 <span class="keyword">and</span> p2:</span><br><span class="line">                <span class="keyword">if</span> p1.val &lt; p2.val:</span><br><span class="line">                    cur.<span class="built_in">next</span> = p1</span><br><span class="line">                    p1 = p1.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cur.<span class="built_in">next</span> = p2</span><br><span class="line">                    p2 = p2.<span class="built_in">next</span></span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = p1 <span class="keyword">if</span> p1 <span class="keyword">else</span> p2</span><br><span class="line">            <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">cur</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur <span class="keyword">or</span> <span class="keyword">not</span> cur.<span class="built_in">next</span>:</span><br><span class="line">                <span class="keyword">return</span> cur</span><br><span class="line">            slow = cur</span><br><span class="line">            fast = cur</span><br><span class="line">            pre = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>: <span class="comment"># 这里要注意为啥要用pre这个东西，如果不要，直接将slow.next作为后半段，然后将cur作为前半段的话，会出问题</span></span><br><span class="line">                pre = slow</span><br><span class="line">                slow = slow.<span class="built_in">next</span></span><br><span class="line">                fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            pre.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">            left_sort_results = merge_sort(cur)</span><br><span class="line">            right_sort_results = merge_sort(slow)</span><br><span class="line">            <span class="keyword">return</span> merge(left_sort_results, right_sort_results)</span><br><span class="line">        <span class="keyword">return</span> merge_sort(head)</span><br></pre></td></tr></table></figure>
<h3 id="重排链表-143">重排链表[143]</h3>
<p>位于 <a href="https://leetcode.cn/problems/reorder-list/description/">https://leetcode.cn/problems/reorder-list/description/</a><br>
思路：将链表全部断开，变成一个一个的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reorderList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify head in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        cur = head</span><br><span class="line">        node_list = []</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            node_list.append(cur)</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        queue = deque([])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> node_list[::-<span class="number">1</span>]:</span><br><span class="line">            i.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">            queue.insert(<span class="number">0</span>, i)</span><br><span class="line"></span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        cur = dummy</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="keyword">if</span> queue:</span><br><span class="line">                cur.<span class="built_in">next</span> = queue.popleft()</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> queue:</span><br><span class="line">                cur.<span class="built_in">next</span> = queue.pop()</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<h2 id="删除系列">删除系列</h2>
<h3 id="删除链表的倒数第-N-个结点-19">删除链表的倒数第 N 个结点[19]</h3>
<p>题号 19，位于 <a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/</a><br>
题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeNthFromEnd</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], n: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        vals = []</span><br><span class="line">        dummy = head</span><br><span class="line">        <span class="keyword">while</span> dummy:</span><br><span class="line">            vals.append(dummy.val)</span><br><span class="line">            dummy = dummy.<span class="built_in">next</span></span><br><span class="line">        t = <span class="built_in">len</span>(vals) - n + <span class="number">1</span></span><br><span class="line">        dummy2 = ListNode(-<span class="number">1</span>, <span class="built_in">next</span>=head)</span><br><span class="line">        dummy3 = dummy2</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> dummy2:</span><br><span class="line">            cnt = cnt + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cnt == t:</span><br><span class="line">                dummy2.<span class="built_in">next</span> = dummy2.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">return</span> dummy3.<span class="built_in">next</span></span><br><span class="line">            dummy2 = dummy2.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy2.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<p>这种做法也可以，不过比较耗时，接下来的方法比较简答，思路也很容易理解，就是先让fast移动k位，然后快慢指针同时移动，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeNthFromEnd</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], n: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        slow = fast = dummy = ListNode(-<span class="number">1</span>,<span class="built_in">next</span>=head) <span class="comment"># 一步到位劝赋值</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">        slow.<span class="built_in">next</span> = slow.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<h3 id="删除排序链表中的重复元素-83">删除排序链表中的重复元素[83]</h3>
<p>位于 <a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/description/">https://leetcode.cn/problems/remove-duplicates-from-sorted-list/description/</a><br>
题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteDuplicates</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        left = dummy = ListNode(-<span class="number">9999</span>,<span class="built_in">next</span>=head)</span><br><span class="line">        right = head <span class="comment"># 最好别right=dummy，和后面那道题保持一致</span></span><br><span class="line">        <span class="keyword">while</span> right:</span><br><span class="line">            <span class="keyword">if</span> right.val == left.val:</span><br><span class="line">                right = right.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            left.<span class="built_in">next</span> = right</span><br><span class="line">            left = left.<span class="built_in">next</span></span><br><span class="line">            right = right.<span class="built_in">next</span></span><br><span class="line">        left.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<p>和之前的删除数组元素中的重复值很像，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">pass</span> <span class="comment">#这里不需要操作啥</span></span><br><span class="line">            <span class="keyword">if</span> nums[right] == nums[left]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            left = left + <span class="number">1</span>    </span><br><span class="line">            nums[left] = nums[right]</span><br><span class="line">        <span class="keyword">return</span> left + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>只是一个用while的，一个用for，链表这里没法用for,用while的话要手动给right移动一位才可以。</p>
<h3 id="删除排序链表中的重复元素-II-82">删除排序链表中的重复元素 II[82]</h3>
<p>位于 <a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/description/">https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/description/</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteDuplicates</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        cur = head</span><br><span class="line">        values = <span class="built_in">set</span>()</span><br><span class="line">        duplicated_values = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            val = cur.val</span><br><span class="line">            <span class="keyword">if</span> val <span class="keyword">in</span> values:</span><br><span class="line">                duplicated_values.add(val)</span><br><span class="line">            values.add(val)</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        left = dummy = ListNode(-<span class="number">9999</span>,<span class="built_in">next</span>=head)</span><br><span class="line">        right = head <span class="comment"># 最好别right=dummy，和后面那道题保持一致</span></span><br><span class="line">        <span class="keyword">while</span> right:</span><br><span class="line">            <span class="keyword">if</span> right.val <span class="keyword">in</span> duplicated_values:</span><br><span class="line">                right = right.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            left.<span class="built_in">next</span> = right</span><br><span class="line">            left = left.<span class="built_in">next</span></span><br><span class="line">            right = right.<span class="built_in">next</span></span><br><span class="line">        left.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<h3 id="移除链表元素-203">移除链表元素[203]</h3>
<p>位于 <a href="https://leetcode.cn/problems/remove-linked-list-elements/description/">https://leetcode.cn/problems/remove-linked-list-elements/description/</a><br>
题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElements</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        left = dummy = ListNode(-<span class="number">1</span>, <span class="built_in">next</span>=head)</span><br><span class="line">        right = head <span class="comment"># 不能right=dummy，不然会一直while</span></span><br><span class="line">        <span class="keyword">while</span> right:</span><br><span class="line">            <span class="keyword">if</span> right.val == val:</span><br><span class="line">                right = right.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            left.<span class="built_in">next</span> = right</span><br><span class="line">            left = left.<span class="built_in">next</span>  <span class="comment"># 这两段代码不要顺序弄错了</span></span><br><span class="line">            right = right.<span class="built_in">next</span></span><br><span class="line">        left.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<p>最好用一个dummy来做，这样方便操作。和数组中的删除一个元素很像，那道题的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">pass</span> <span class="comment">#这里不需要操作啥</span></span><br><span class="line">            <span class="keyword">if</span> nums[right] == val:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            nums[left] = nums[right]</span><br><span class="line">            left = left + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>
<p>只是一个用while的，一个用for，链表这里没法用for,用while的话要手动给right移动一位才可以。</p>
<h2 id="相交-环等问题">相交-环等问题</h2>
<h3 id="相交链表-160">相交链表[160]</h3>
<p>题号 160， 位于 <a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">https://leetcode.cn/problems/intersection-of-two-linked-lists/</a><br>
解法如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="comment">#遍历到A的尾部</span></span><br><span class="line">        head1 = headA</span><br><span class="line">        <span class="keyword">while</span> head1.<span class="built_in">next</span>:</span><br><span class="line">            head1 = head1.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#遍历到B的尾部</span></span><br><span class="line">        head2 = headB</span><br><span class="line">        <span class="keyword">while</span> head2.<span class="built_in">next</span>:</span><br><span class="line">            head2 = head2.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 首位相连构成环</span></span><br><span class="line">        head1.<span class="built_in">next</span> = headB</span><br><span class="line">        <span class="comment"># 快慢指针</span></span><br><span class="line">        slow = headA</span><br><span class="line">        fast = headA</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            slow = slow.<span class="built_in">next</span> <span class="comment"># 这里容易弄错，把判断写在前面了</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> slow == fast:</span><br><span class="line">                p = headA</span><br><span class="line">                q = slow</span><br><span class="line">                <span class="keyword">while</span> p != q:</span><br><span class="line">                    p = p.<span class="built_in">next</span></span><br><span class="line">                    q = q.<span class="built_in">next</span></span><br><span class="line">                head1.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">                head2.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">                <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line">        head1.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        head2.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>更简单的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        A, B = headA, headB </span><br><span class="line">        <span class="keyword">while</span> A != B: <span class="comment">#这里写错成A and B</span></span><br><span class="line">            A = A.<span class="built_in">next</span> <span class="keyword">if</span> A <span class="keyword">else</span> headB</span><br><span class="line">            B = B.<span class="built_in">next</span> <span class="keyword">if</span> B <span class="keyword">else</span> headA</span><br><span class="line">        <span class="keyword">return</span> A</span><br></pre></td></tr></table></figure>
<h3 id="环形链表-141">环形链表[141]</h3>
<p>位于 <a href="https://leetcode.cn/problems/linked-list-cycle/">https://leetcode.cn/problems/linked-list-cycle/</a></p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasCycle</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        slow = head</span><br><span class="line">        fast = head <span class="comment"># 这里也可以head.next</span></span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span> <span class="comment"># 别写错了</span></span><br><span class="line">            <span class="keyword">if</span> slow == fast:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span>           </span><br></pre></td></tr></table></figure>
<h3 id="环形链表II-142">环形链表II[142]</h3>
<p>位于 <a href="https://leetcode.cn/problems/linked-list-cycle-ii/description/">https://leetcode.cn/problems/linked-list-cycle-ii/description/</a><br>
题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">detectCycle</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        slow = head</span><br><span class="line">        fast = head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> slow == fast: <span class="comment"># 注意：下面的操作不熟悉</span></span><br><span class="line">                p = slow </span><br><span class="line">                q = head</span><br><span class="line">                <span class="keyword">while</span> p!=q:</span><br><span class="line">                    p= p.<span class="built_in">next</span></span><br><span class="line">                    q=q.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">return</span> p</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>         </span><br></pre></td></tr></table></figure>
<h2 id="分割系列">分割系列</h2>
<h3 id="分隔链表-725">分隔链表[725]</h3>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">splitListToParts</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">Optional</span>[ListNode]]:</span><br><span class="line">        cur = head</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            cnt = cnt + <span class="number">1</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        a, b = <span class="built_in">divmod</span>(cnt, k)</span><br><span class="line">        res = [a <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(b):</span><br><span class="line">            res[i] = res[i] + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        new_res = []</span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">for</span> lens <span class="keyword">in</span> res:</span><br><span class="line">            <span class="keyword">if</span> lens==<span class="number">0</span>:</span><br><span class="line">                new_res.append(<span class="literal">None</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                new_res.append(cur)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(lens-<span class="number">1</span>): <span class="comment">#注意点1</span></span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            new_head = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = <span class="literal">None</span> <span class="comment"># 注意点2</span></span><br><span class="line">            cur = new_head</span><br><span class="line">        <span class="keyword">return</span> new_res</span><br></pre></td></tr></table></figure>
<h3 id="分隔链表-86">分隔链表[86]</h3>
<p>位于：<a href="https://leetcode.cn/problems/partition-list/description/">https://leetcode.cn/problems/partition-list/description/</a><br>
解法如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], x: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        small_dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        big_dummy = ListNode(-<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        small = small_dummy</span><br><span class="line">        big = big_dummy</span><br><span class="line"></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur.val &lt; x:</span><br><span class="line">                small.<span class="built_in">next</span> = cur</span><br><span class="line">                small = small.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                big.<span class="built_in">next</span> = cur</span><br><span class="line">                big = big.<span class="built_in">next</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        big.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        small.<span class="built_in">next</span> = big_dummy.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> small_dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<p>上述我在写的时候没有注意，直接用如下代码，导致了错误</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], x: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        small = ListNode(-<span class="number">1</span>)</span><br><span class="line">        big = ListNode(-<span class="number">2</span>)</span><br><span class="line">        </span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur.val &lt; x:</span><br><span class="line">                small.<span class="built_in">next</span> = cur</span><br><span class="line">                small = small.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                big.<span class="built_in">next</span> = cur</span><br><span class="line">                big = big.<span class="built_in">next</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        big.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        small.<span class="built_in">next</span> = big.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> small.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<p>可以看到，到最后的话，small都不知道是啥了，因此还是需要使用一个指针，来指向dummy 也就是这里的small和big 小细节要注意</p>
<h2 id="定位系列">定位系列</h2>
<h3 id="训练计划-II-LCR-140">训练计划 II[LCR 140]</h3>
<p>位于：<a href="https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof">https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof</a></p>
<p>题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trainingPlan</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], cnt: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        lens = <span class="number">0</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            lens += <span class="number">1</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        p = head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(lens-cnt):</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure>
<h3 id="链表的中间结点-876">链表的中间结点[876]</h3>
<p>位于 <a href="https://leetcode.cn/problems/middle-of-the-linked-list">https://leetcode.cn/problems/middle-of-the-linked-list</a><br>
这么做也挺方便的，不用便利两次，就是多了些存储</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">middleNode</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        <span class="keyword">if</span> head.<span class="built_in">next</span> == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        cur = head</span><br><span class="line">        allNodes = []</span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span>:</span><br><span class="line">            allNodes.append(cur)</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        allNodes.append(cur)</span><br><span class="line">        <span class="keyword">return</span> allNodes[<span class="built_in">int</span>(<span class="built_in">len</span>(allNodes)//<span class="number">2</span>)]</span><br></pre></td></tr></table></figure>
<h3 id="LRU-缓存-146">LRU 缓存[146]</h3>
<p>位于 <a href="https://leetcode.cn/problems/lru-cache/description/">https://leetcode.cn/problems/lru-cache/description/</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span>(collections.OrderedDict):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.capacity = capacity</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        self.move_to_end(key)</span><br><span class="line">        <span class="keyword">return</span> self[key]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self:</span><br><span class="line">            self.move_to_end(key)</span><br><span class="line">        self[key] = value</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self) &gt; self.capacity:</span><br><span class="line">            self.popitem(last=<span class="literal">False</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在get</p>
<h1>双链表</h1>
<h2 id="链表合并">链表合并</h2>
<h3 id="合并两个有序链表-21">合并两个有序链表[21]</h3>
<p>位于 <a href="https://leetcode.cn/problems/merge-two-sorted-lists/description/">https://leetcode.cn/problems/merge-two-sorted-lists/description/</a><br>
题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTwoLists</span>(<span class="params">self, list1: <span class="type">Optional</span>[ListNode], list2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> list1 <span class="keyword">and</span> <span class="keyword">not</span> list2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> list1:</span><br><span class="line">            <span class="keyword">return</span> list2</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> list2:</span><br><span class="line">            <span class="keyword">return</span> list1</span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>, <span class="built_in">next</span>=list1)</span><br><span class="line">        cur = dummy <span class="comment">#上面说到了，我们定义了dummy后，还需要定义一个cur指向他，对他的值进行修改，然后cur动dummy不动</span></span><br><span class="line">        head1 = list1</span><br><span class="line">        head2 = list2</span><br><span class="line">        <span class="keyword">while</span> head1 <span class="keyword">and</span> head2:</span><br><span class="line">            <span class="keyword">if</span> head1.val &lt;= head2.val:</span><br><span class="line">                cur.<span class="built_in">next</span> = head1</span><br><span class="line">                head1 = head1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur.<span class="built_in">next</span> = head2</span><br><span class="line">                head2 = head2.<span class="built_in">next</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        cur.<span class="built_in">next</span> = head1 <span class="keyword">if</span> head1 <span class="keyword">else</span> head2</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<h3 id="合并-K-个升序链表-23">合并 K 个升序链表[23]</h3>
<p>位于：<a href="https://leetcode.cn/problems/merge-k-sorted-lists">https://leetcode.cn/problems/merge-k-sorted-lists</a><br>
题目虽然为困难，但是思路很简答，就是把上面那个题改为递归就好</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeKLists</span>(<span class="params">self, lists: <span class="type">List</span>[<span class="type">Optional</span>[ListNode]]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">mergeSingle</span>(<span class="params">list1, list2</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> list1 <span class="keyword">and</span> <span class="keyword">not</span> list2:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> list1:</span><br><span class="line">                <span class="keyword">return</span> list2</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> list2:</span><br><span class="line">                <span class="keyword">return</span> list1</span><br><span class="line">            dummy = ListNode(-<span class="number">1</span>, <span class="built_in">next</span>=list1)</span><br><span class="line"></span><br><span class="line">            cur = dummy</span><br><span class="line">            head1 = list1</span><br><span class="line">            head2 = list2</span><br><span class="line">            <span class="keyword">while</span> head1 <span class="keyword">and</span> head2:</span><br><span class="line">                <span class="keyword">if</span> head1.val &lt;= head2.val:</span><br><span class="line">                    cur.<span class="built_in">next</span> = head1</span><br><span class="line">                    cur = head1</span><br><span class="line">                    head1 = head1.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cur.<span class="built_in">next</span> = head2</span><br><span class="line">                    cur = head2</span><br><span class="line">                    head2 = head2.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = head1 <span class="keyword">if</span> head1 <span class="keyword">else</span> head2</span><br><span class="line">            <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(lists)==<span class="number">0</span>: <span class="comment"># 注意边界</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(lists)==<span class="number">1</span>: <span class="comment"># 注意边界</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> lists[<span class="number">0</span>]: <span class="comment"># 注意边界</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">return</span> lists[<span class="number">0</span>] <span class="comment"># 注意边界</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(lists)==<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> mergeSingle(lists[<span class="number">0</span>], lists[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> mergeSingle(lists[<span class="number">0</span>], self.mergeKLists(lists[<span class="number">1</span>:]))</span><br></pre></td></tr></table></figure>
<h3 id="奇偶链表-328">奇偶链表[328]</h3>
<p>位于 <a href="https://leetcode.cn/problems/odd-even-linked-list/description/">https://leetcode.cn/problems/odd-even-linked-list/description/</a><br>
题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">oddEvenList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        A = head</span><br><span class="line">        B = head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        first = A</span><br><span class="line">        second = B</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> second <span class="keyword">and</span> second.<span class="built_in">next</span>:</span><br><span class="line">            temp1 = first.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            first.<span class="built_in">next</span> = first.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            first = temp1</span><br><span class="line"></span><br><span class="line">            temp2 = second.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            second.<span class="built_in">next</span> = second.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            second = temp2</span><br><span class="line"></span><br><span class="line">        first.<span class="built_in">next</span> = B</span><br><span class="line">        <span class="keyword">return</span> A</span><br></pre></td></tr></table></figure>
<p>容易写错为如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">oddEvenList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        A = head</span><br><span class="line">        B = head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        first = A</span><br><span class="line">        second = B</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 下面这么写的话自己画画图就知道一旦使用fast.next后，链表原来的顺序结构就被打断了，再去寻的话就会出错。</span></span><br><span class="line">        <span class="keyword">while</span> first <span class="keyword">and</span> first.<span class="built_in">next</span>:</span><br><span class="line">            temp1 = first.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            first.<span class="built_in">next</span> = first.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            first = temp1</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> second <span class="keyword">and</span> second.<span class="built_in">next</span>:</span><br><span class="line">            temp2 = second.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            second.<span class="built_in">next</span> = second.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            second = temp2</span><br><span class="line"></span><br><span class="line">        first.<span class="built_in">next</span> = B</span><br><span class="line">        <span class="keyword">return</span> A</span><br></pre></td></tr></table></figure>
<h2 id="两数相加">两数相加</h2>
<h3 id="两数相加-2">两数相加[2]</h3>
<p>位于 <a href="https://leetcode.cn/problems/add-two-numbers">https://leetcode.cn/problems/add-two-numbers</a><br>
代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addTwoNumbers</span>(<span class="params">self, l1: <span class="type">Optional</span>[ListNode], l2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">get_list</span>(<span class="params">head</span>):</span><br><span class="line">            cur = head</span><br><span class="line">            res = []</span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        l1_res = get_list(l1)</span><br><span class="line">        l2_res = get_list(l2)</span><br><span class="line"></span><br><span class="line">        max_lens = <span class="built_in">max</span>(<span class="built_in">len</span>(l1_res), <span class="built_in">len</span>(l2_res))</span><br><span class="line">        res = []</span><br><span class="line">        a = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(max_lens):</span><br><span class="line">            n1 = l1_res[i] <span class="keyword">if</span> i&lt;<span class="built_in">len</span>(l1_res) <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            n2 = l2_res[i] <span class="keyword">if</span> i&lt;<span class="built_in">len</span>(l2_res) <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            a, b = <span class="built_in">divmod</span>(n1+n2+a, <span class="number">10</span>)</span><br><span class="line">            res.append(b)</span><br><span class="line">        <span class="keyword">if</span> a&gt;<span class="number">0</span>:</span><br><span class="line">            res.append(a)</span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>) <span class="comment">#说到了，我们定义了dummy后，还需要定义一个cur指向他，对他的值进行修改，然后cur动dummy不动</span></span><br><span class="line">        cur = dummy</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line">            cur.<span class="built_in">next</span> = ListNode(i)</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<p>和下面的这道题一样，没啥好说的</p>
<h3 id="两数相加-II-445">两数相加 II[445]</h3>
<p>位于 <a href="https://leetcode.cn/problems/add-two-numbers-ii">https://leetcode.cn/problems/add-two-numbers-ii</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addTwoNumbers</span>(<span class="params">self, l1: <span class="type">Optional</span>[ListNode], l2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="comment"># 获取链表的值</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">get_list</span>(<span class="params">head</span>):</span><br><span class="line">            cur = head</span><br><span class="line">            res = []</span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        l1_res = get_list(l1)[::-<span class="number">1</span>]</span><br><span class="line">        l2_res = get_list(l2)[::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获取最大的长度</span></span><br><span class="line">        max_lens = <span class="built_in">max</span>(<span class="built_in">len</span>(l1_res), <span class="built_in">len</span>(l2_res))</span><br><span class="line">        res = []</span><br><span class="line">        a = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(max_lens):</span><br><span class="line">            n1 = l1_res[i] <span class="keyword">if</span> i&lt;<span class="built_in">len</span>(l1_res) <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            n2 = l2_res[i] <span class="keyword">if</span> i&lt;<span class="built_in">len</span>(l2_res) <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            a, b = <span class="built_in">divmod</span>(n1+n2+a, <span class="number">10</span>)</span><br><span class="line">            res.append(b)</span><br><span class="line">        <span class="keyword">if</span> a&gt;<span class="number">0</span>:</span><br><span class="line">            res.append(a)</span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>) <span class="comment"># 说到了，我们定义了dummy后，还需要定义一个cur指向他，对他的值进行修改，然后cur动dummy不动</span></span><br><span class="line">        cur = dummy</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> res[::-<span class="number">1</span>]:</span><br><span class="line">            cur.<span class="built_in">next</span> = ListNode(i)</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>题目汇总</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>递归</title>
    <url>/2024/03/19/leetcode/recur/</url>
    <content><![CDATA[<h1>递归题目</h1>
<h2 id="递归">递归</h2>
<h3 id="括号生成-22">括号生成[22]</h3>
<p>题目见 <a href="https://leetcode-cn.com/problems/generate-parentheses/">https://leetcode-cn.com/problems/generate-parentheses/</a>, 就是用到递归的方法。<br>
解法代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateParenthesis</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        cur = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">left, right, cur</span>):</span><br><span class="line">            <span class="keyword">if</span> left==<span class="number">0</span> <span class="keyword">and</span> right==<span class="number">0</span>:</span><br><span class="line">                res.append(cur)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> left&gt;right:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> left&gt;<span class="number">0</span>: <span class="comment"># 注意</span></span><br><span class="line">                dfs(left-<span class="number">1</span>,right,cur+<span class="string">&quot;(&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> right&gt;<span class="number">0</span>:</span><br><span class="line">                dfs(left, right-<span class="number">1</span>,cur+<span class="string">&quot;)&quot;</span>)</span><br><span class="line">        dfs(n,n,cur)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>其他不太好的方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateParenthesis</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">generate</span>(<span class="params">A</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(A) == <span class="number">2</span>*n:</span><br><span class="line">                <span class="keyword">if</span> valid(A):</span><br><span class="line">                    ans.append(<span class="string">&quot;&quot;</span>.join(A))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                A.append(<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                generate(A)</span><br><span class="line">                A.pop()</span><br><span class="line">                A.append(<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">                generate(A)</span><br><span class="line">                A.pop()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">valid</span>(<span class="params">A</span>):</span><br><span class="line">            bal = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> A:</span><br><span class="line">                <span class="keyword">if</span> c == <span class="string">&#x27;(&#x27;</span>: bal += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: bal -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> bal &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> bal == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        ans = []</span><br><span class="line">        generate([])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>可以看到代码比较狂野，就是啥都没判断，就直接append，然后pop，最后再去判断。<br>
那么久可以优化一下了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateParenthesis</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">back</span>(<span class="params">state, left, right</span>):</span><br><span class="line">            <span class="keyword">if</span> left == <span class="number">0</span> <span class="keyword">and</span> right == <span class="number">0</span>:</span><br><span class="line">                res.append(<span class="string">&quot;&quot;</span>.join(state[:]))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> left &gt; right:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> left &gt; <span class="number">0</span>:</span><br><span class="line">                state.append(<span class="string">&quot;(&quot;</span>)</span><br><span class="line">                back(state, left - <span class="number">1</span>, right)</span><br><span class="line">                state.pop()</span><br><span class="line">            <span class="keyword">if</span> right &gt; <span class="number">0</span>:</span><br><span class="line">                state.append(<span class="string">&quot;)&quot;</span>)</span><br><span class="line">                back(state, left, right - <span class="number">1</span>)</span><br><span class="line">                state.pop()</span><br><span class="line"></span><br><span class="line">        back([], n, n)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="整数替换-397">整数替换[397]</h3>
<p>题目见 <a href="https://leetcode-cn.com/problems/integer-replacement/">https://leetcode-cn.com/problems/integer-replacement/</a> 这里考虑用动态规划，但是无法写出整体的转移方程，递归的做法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">integerReplacement</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">n</span>):</span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">1</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span> + helper(n/<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">min</span>(helper(n+<span class="number">1</span>),helper(n-<span class="number">1</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> helper(n)</span><br></pre></td></tr></table></figure>
<h3 id="分割数组为连续子序列-659">分割数组为连续子序列[659]</h3>
<p>自己写的超时了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPossible</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">if_increase</span>(<span class="params">nums2</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(nums2)&lt;<span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums2)-<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> nums2[i+<span class="number">1</span>] - nums2[i]==<span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> if_increase(nums):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> lens <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            left = []</span><br><span class="line">            right = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">or</span> i - left[-<span class="number">1</span>] == <span class="number">1</span> <span class="keyword">and</span> <span class="built_in">len</span>(left) &lt; lens:</span><br><span class="line">                    left.append(i)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right.append(i)</span><br><span class="line">            <span class="keyword">if</span> self.isPossible(left) <span class="keyword">and</span> self.isPossible(right):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>别人写的非递归</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPossible</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        counter = Counter(nums)</span><br><span class="line">        tail = Counter()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> counter[i] <span class="keyword">and</span> tail[i - <span class="number">1</span>]:  <span class="comment"># 可以衔接</span></span><br><span class="line">                counter[i] -= <span class="number">1</span></span><br><span class="line">                tail[i - <span class="number">1</span>] -= <span class="number">1</span></span><br><span class="line">                tail[i] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> counter[i] <span class="keyword">and</span> counter[i + <span class="number">1</span>] <span class="keyword">and</span> counter[i + <span class="number">2</span>]:  <span class="comment"># 可以生成新序列</span></span><br><span class="line">                tail[i + <span class="number">2</span>] += <span class="number">1</span></span><br><span class="line">                counter[i] -= <span class="number">1</span></span><br><span class="line">                counter[i + <span class="number">1</span>] -= <span class="number">1</span></span><br><span class="line">                counter[i + <span class="number">2</span>] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> counter.items():</span><br><span class="line">            <span class="keyword">if</span> v &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>来自 <a href="https://leetcode.cn/problems/split-array-into-consecutive-subsequences/description/">https://leetcode.cn/problems/split-array-into-consecutive-subsequences/description/</a></p>
<h3 id="目标和-494">目标和[494]</h3>
<p>代码如下，会超时</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findTargetSumWays</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        sets = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">back</span>(<span class="params">state, s, index</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(state) == <span class="built_in">len</span>(nums):</span><br><span class="line">                <span class="keyword">if</span> s == target:</span><br><span class="line">                    <span class="keyword">if</span> <span class="string">&quot;&quot;</span>.join(state) <span class="keyword">not</span> <span class="keyword">in</span> sets:</span><br><span class="line">                        sets.add(<span class="string">&quot;&quot;</span>.join(state[:]))</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index, <span class="built_in">len</span>(nums)):</span><br><span class="line">                state.append(<span class="string">&quot;+1&quot;</span>)</span><br><span class="line">                s = s + nums[i]</span><br><span class="line">                back(state, s, i + <span class="number">1</span>)</span><br><span class="line">                s = s - nums[i]</span><br><span class="line">                state.pop()</span><br><span class="line"></span><br><span class="line">                s = s - nums[i]</span><br><span class="line">                state.append(<span class="string">&quot;-1&quot;</span>)</span><br><span class="line">                back(state, s, i + <span class="number">1</span>)</span><br><span class="line">                s = s + nums[i]</span><br><span class="line">                state.pop()</span><br><span class="line"></span><br><span class="line">        back([], <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        sums = <span class="built_in">len</span>(sets)</span><br><span class="line">        <span class="keyword">return</span> sums</span><br></pre></td></tr></table></figure>
<p>其实是需要动态规划的。</p>
<h2 id="回溯">回溯</h2>
<h3 id="模板">模板</h3>
<p>关于模板可以参考知乎这里<br>
<a href="https://zhuanlan.zhihu.com/p/112926891">https://zhuanlan.zhihu.com/p/112926891</a></p>
<p>下面对其中说的好的部分进行说明（哈哈，就是直接复制过来方便自己看）。后面会总结自己的模板。</p>
<p>按照文章中所说的，大概的思路如下<br>
直接给出设计思路<br>
全局变量： 保存结果<br>
参数设计： 递归函数的参数，是将上一次操作的合法状态当作下一次操作的初始位置。这里的参数，我理解为两种参数：状态变量和条件变量。（1）状态变量（state）就是最后结果（result）要保存的值；（2）条件变量就是决定搜索是否完毕或者合法的值。<br>
完成条件： 完成条件是决定 状态变量和条件变量 在取什么值时可以判定整个搜索流程结束。搜索流程结束有两种含义： 搜索成功并保存结果 和 搜索失败并返回上一次状态。<br>
递归过程： 传递当前状态给下一次递归进行搜索。</p>
<p>大概的代码上的逻辑是如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res = []    <span class="comment"># 定义全局变量保存最终结果</span></span><br><span class="line">state = []  <span class="comment"># 定义状态变量保存当前状态</span></span><br><span class="line">p,q,r       <span class="comment"># 定义条件变量（一般条件变量就是题目直接给的参数）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">back</span>(<span class="params">状态，条件<span class="number">1</span>，条件<span class="number">2</span>，……</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="comment"># 不满足合法条件（可以说是剪枝）</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">elif</span> <span class="comment"># 状态满足最终要求</span></span><br><span class="line">        res.append(state)   <span class="comment"># 加入结果</span></span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    <span class="comment"># 主要递归过程，一般是带有 循环体 或者 条件体</span></span><br><span class="line">    <span class="keyword">for</span> <span class="comment"># 满足执行条件</span></span><br><span class="line">    <span class="keyword">if</span>  <span class="comment"># 满足执行条件</span></span><br><span class="line">        back(状态，条件<span class="number">1</span>，条件<span class="number">2</span>，……)</span><br><span class="line">back(状态，条件<span class="number">1</span>，条件<span class="number">2</span>，……)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>个人感觉这个写的以很好了，不过可以稍微改进下，让它更容易被看懂</p>
<pre><code>res = []    # 定义全局变量保存最终结果
state = []  # 定义状态变量保存当前状态
p,q,r       # 定义条件变量（一般条件变量就是题目直接给的参数）
def back(状态，条件1，条件2，……):
    if # 不满足合法条件（可以说是剪枝）
        return
    elif # 状态满足最终要求
        res.append(state)   # 加入结果
        return 
    # 主要递归过程，一般是带有 循环体 或者 条件体
    for # 满足执行条件
    if  # 满足执行条件
        状态+值 # 比如stata.append(xx)
        back(状态，条件1，条件2，……)
        状态-值 # 比如 state.pop()
back(状态，条件1，条件2，……)
return res
</code></pre>
<p>当然这里主要还是对于不同的题要注意不同的条件了，状态是很简单的，你就可以定义为state, 然后在for条件的时候，state加上这个值就可以了。条件的话，就是千奇百怪的了，相比较而言看你对题目的理解了，不同的题目写法是不同的，这点只能靠练了。</p>
<h3 id="组合类问题">组合类问题</h3>
<h4 id="总结">总结</h4>
<ol>
<li>遍历方向，for i in range(index,len(xx))</li>
<li>重复取，back(state, i), 不能重复取，back(state,i+1)</li>
<li>去重的，if index&gt;i and used[i]==used[i-1] continue</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">back</span>(<span class="params">state, index</span>):</span><br><span class="line">    <span class="keyword">if</span> xxx:</span><br><span class="line">        res.append(xxx)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index, <span class="built_in">len</span>(xxx)):</span><br><span class="line">        <span class="comment"># 需要的话这里加上剪枝</span></span><br><span class="line">        <span class="keyword">if</span> index&gt;i <span class="keyword">and</span> used[i]==used[i-<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        state.append(nums[i] 或者 nums[i, index])</span><br><span class="line">        back(state, i+<span class="number">1</span>) <span class="comment">#这里注意是i+1还是index+1的呢</span></span><br><span class="line">        state.pop()</span><br></pre></td></tr></table></figure>
<p>三个重点</p>
<ol>
<li>range(index,len(xxx))</li>
<li>剪枝</li>
<li>i或者i+1，或者index+1</li>
</ol>
<h4 id="电话号码的字母组合-17">电话号码的字母组合[17]</h4>
<p>题目见 <a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">https://leetcode.cn/problems/letter-combinations-of-a-phone-number/</a> , 因为在back的时候，换了一个集合了，所以back的时候，不是i或者i+1,而是index+1. 题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">letterCombinations</span>(<span class="params">self, digits: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> digits:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        digit_alpha_maps = &#123;</span><br><span class="line">            <span class="string">&quot;2&quot;</span>: <span class="string">&quot;abc&quot;</span>,</span><br><span class="line">            <span class="string">&quot;3&quot;</span>: <span class="string">&quot;def&quot;</span>,</span><br><span class="line">            <span class="string">&quot;4&quot;</span>: <span class="string">&quot;ghi&quot;</span>,</span><br><span class="line">            <span class="string">&quot;5&quot;</span>: <span class="string">&quot;jkl&quot;</span>,</span><br><span class="line">            <span class="string">&quot;6&quot;</span>: <span class="string">&quot;mno&quot;</span>,</span><br><span class="line">            <span class="string">&quot;7&quot;</span>: <span class="string">&quot;pqrs&quot;</span>,</span><br><span class="line">            <span class="string">&quot;8&quot;</span>: <span class="string">&quot;tuv&quot;</span>,</span><br><span class="line">            <span class="string">&quot;9&quot;</span>: <span class="string">&quot;wxyz&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">back</span>(<span class="params">state, index</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(state) == <span class="built_in">len</span>(digits):</span><br><span class="line">                res.append(<span class="string">&quot;&quot;</span>.join(state[:]))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            alp = digit_alpha_maps[digits[index]]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(alp)):</span><br><span class="line">                state.append(alp[i])</span><br><span class="line">                back(state, index+<span class="number">1</span>) <span class="comment">#改动 密切注意</span></span><br><span class="line">                state.pop()</span><br><span class="line"></span><br><span class="line">        back([], <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>如何看做一棵树的话，横向的是abc这种字母，纵向的就是递归，也就是index+1. 下一轮的话，是取新的字母集合了，不是刚刚的了。</p>
<h4 id="组合-77">组合[77]</h4>
<p>题目见 <a href="https://leetcode.cn/problems/combinations/">https://leetcode.cn/problems/combinations/</a> ，因为不能重复取，所以back的时候，需要i+1, 题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 好解</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combine</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">back</span>(<span class="params">state, index</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(state) == k:</span><br><span class="line">                res.append(state[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index,n+<span class="number">1</span>):  <span class="comment"># 1. 不同点</span></span><br><span class="line">                state.append(i)</span><br><span class="line">                back(state, i+<span class="number">1</span>)</span><br><span class="line">                state.pop()</span><br><span class="line">        back([], <span class="number">1</span>) <span class="comment"># 注意，这里为1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>可以看下 <a href="https://leetcode.cn/problems/combinations/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-ma-/">https://leetcode.cn/problems/combinations/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-ma-/</a> 他总结的还是很清晰的。</p>
<h4 id="组合总和-39">组合总和[39]</h4>
<p>题目见 <a href="https://leetcode.cn/problems/combination-sum/">https://leetcode.cn/problems/combination-sum/</a> ,题目说了可以无限制取，因此back的时候，用i不用i+1.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum</span>(<span class="params">self, candidates: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = []</span><br><span class="line">        n = <span class="built_in">len</span>(candidates)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">back</span>(<span class="params">state,index</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span>(state[:]) == target:</span><br><span class="line">                res.append(state[:])</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span>(state[:]) &gt; target: <span class="comment"># 注意</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index,n):</span><br><span class="line">                state.append(candidates[i])</span><br><span class="line">                back(state,i) <span class="comment"># 注意</span></span><br><span class="line">                state.pop()</span><br><span class="line">        </span><br><span class="line">        back([], <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>详解看 <a href="https://programmercarl.com/0039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">https://programmercarl.com/0039.组合总和.html#算法公开课</a></p>
<h4 id="组合总和-II-40">组合总和 II[40]</h4>
<p>题目在 <a href="https://leetcode.cn/problems/combination-sum-ii/">https://leetcode.cn/problems/combination-sum-ii/</a> 又是求和的这道题，这道题要去重，因此在back的时候，需要i+1。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不使用used数组</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum2</span>(<span class="params">self, candidates: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        candidates.sort() <span class="comment">#注意</span></span><br><span class="line">        res = []</span><br><span class="line">        n = <span class="built_in">len</span>(candidates)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">back</span>(<span class="params">state,index</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span>(state[:]) == target:</span><br><span class="line">                res.append(state[:])</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span>(state[:]) &gt; target:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index,n)     :</span><br><span class="line">                <span class="keyword">if</span> i&gt;index <span class="keyword">and</span> candidates[i]==candidates[i-<span class="number">1</span>]: <span class="comment">#注意</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                state.append(candidates[i])</span><br><span class="line">                back(state,i+<span class="number">1</span>) <span class="comment"># 注意</span></span><br><span class="line">                state.pop()</span><br><span class="line">        </span><br><span class="line">        back([], <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>再看下这个用used数组的版本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum2</span>(<span class="params">self, candidates: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        candidates.sort()</span><br><span class="line">        res = []</span><br><span class="line">        n = <span class="built_in">len</span>(candidates)        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">back</span>(<span class="params">state,index</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span>(state[:]) == target:</span><br><span class="line">                res.append(state[:])</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span>(state[:]) &gt; target:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            used  = <span class="built_in">set</span>()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index,n):</span><br><span class="line">                <span class="keyword">if</span> candidates[i] <span class="keyword">in</span> used:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                used.add(candidates[i])</span><br><span class="line">                state.append(candidates[i])</span><br><span class="line">                back(state,i+<span class="number">1</span>)</span><br><span class="line">                state.pop()</span><br><span class="line">        </span><br><span class="line">        back([], <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>注意，这里很容易把used写在外面。</p>
<p>为何使用i&gt;index有效果，建议看 <a href="https://leetcode.cn/problems/combination-sum-ii/solutions/14753/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-3/">https://leetcode.cn/problems/combination-sum-ii/solutions/14753/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-3/</a> 这里评论中的回复。</p>
<h4 id="组合总数III-216">组合总数III[216]</h4>
<p>题目见 <a href="https://leetcode.cn/problems/combination-sum-iii/">https://leetcode.cn/problems/combination-sum-iii/</a> 题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum3</span>(<span class="params">self, k: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">back</span>(<span class="params">state, index</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span>(state[:])==n <span class="keyword">and</span> <span class="built_in">len</span>(state[:])==k:</span><br><span class="line">                res.append(state[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span>(state[:])&gt;n: <span class="comment"># 注意</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index, <span class="number">9</span>+<span class="number">1</span>): <span class="comment"># 注意</span></span><br><span class="line">                state.append(i)</span><br><span class="line">                back(state, i+<span class="number">1</span>)<span class="comment"># 注意</span></span><br><span class="line">                state.pop()</span><br><span class="line">        back([], <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>套路还是一样的，依然说后面不会使用到之前的话那就可以，使用i+1来做了，其他的就很方便了。</p>
<h4 id="组合总和-Ⅳ-377">组合总和 Ⅳ[377]</h4>
<p>题目见 <a href="https://leetcode.cn/problems/combination-sum-iv/">https://leetcode.cn/problems/combination-sum-iv/</a>  题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum4</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="number">1</span>] + [<span class="number">0</span>] * (target) <span class="comment"># 注意</span></span><br><span class="line">        <span class="keyword">for</span> amount <span class="keyword">in</span> <span class="built_in">range</span>(target+<span class="number">1</span>): <span class="comment"># 注意</span></span><br><span class="line">            <span class="keyword">for</span> coins <span class="keyword">in</span> nums:     <span class="comment"># 注意 完全背包 排列</span></span><br><span class="line">                <span class="keyword">if</span> amount&gt;=coins:       </span><br><span class="line">                    dp[amount] = dp[amount] + dp[amount-coins]</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="子集问题">子集问题</h3>
<h4 id="总结-2">总结</h4>
<p>注意的是这里收集的结果是所有节点的值，不像组合是叶子节点了，其中说到底也差不多额，就是判断一下而已。</p>
<p>要点如下：<br>
子集问题先排序，然后用i+1，然后不需要判断条件直接res.append(state[:]).</p>
<h4 id="子集-78">子集[78]</h4>
<p>题目见 <a href="https://leetcode-cn.com/problems/subsets/">https://leetcode-cn.com/problems/subsets/</a> 题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsets</span>(<span class="params">self, nums</span>):</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">back</span>(<span class="params">state, index</span>):</span><br><span class="line">            res.append(state[:])</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index, <span class="built_in">len</span>(nums)):</span><br><span class="line">                state.append(nums[i])</span><br><span class="line">                back(state, i + <span class="number">1</span>)  <span class="comment"># 注意点</span></span><br><span class="line">                state.pop()</span><br><span class="line">        nums.sort() <span class="comment"># 注意点# 注意点</span></span><br><span class="line">        back([], <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">print</span>(res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">su = Solution()</span><br><span class="line">su.subsets([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure>
<h4 id="子集-II-90">子集 II[90]</h4>
<p>题目见 <a href="https://leetcode-cn.com/problems/subsets-ii/">https://leetcode-cn.com/problems/subsets-ii/</a> 题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums.sort() <span class="comment"># 注意点</span></span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">back</span>(<span class="params">state, index</span>):</span><br><span class="line">    res.append(state[:])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index, <span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">if</span> i&gt;index <span class="keyword">and</span> nums[i]==nums[i-<span class="number">1</span>]:<span class="comment"># 注意点</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        state.append(nums[i])</span><br><span class="line">        back(state, i+<span class="number">1</span>) <span class="comment"># 注意点</span></span><br><span class="line">        state.pop()</span><br><span class="line">back([], <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="分割问题">分割问题</h3>
<h4 id="总结-3">总结</h4>
<p>就是进行for循环中，state添加数据的时候，不是back(state, s[i])了，而是back(state, s[i:i+1])了。然后是back中的i+1.</p>
<h4 id="分割回文串-131">分割回文串[131]</h4>
<p>题目见 <a href="https://leetcode.cn/problems/palindrome-partitioning/">https://leetcode.cn/problems/palindrome-partitioning/</a> 题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">if_pa</span>(<span class="params">x</span>):</span><br><span class="line">            <span class="keyword">return</span> x==x[::-<span class="number">1</span>]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">back</span>(<span class="params">state, index</span>):</span><br><span class="line">            <span class="keyword">if</span> index==<span class="built_in">len</span>(s): <span class="comment"># 注意点</span></span><br><span class="line">                res.append(state[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index, <span class="built_in">len</span>(s)):</span><br><span class="line">                <span class="keyword">if</span> if_pa(s[index:i+<span class="number">1</span>]): <span class="comment"># 注意点</span></span><br><span class="line">                    state.append(s[index:i+<span class="number">1</span>]) <span class="comment"># 注意点</span></span><br><span class="line">                    back(state, i+<span class="number">1</span>) <span class="comment"># 注意点</span></span><br><span class="line">                    state.pop()</span><br><span class="line">        back([], <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h4 id="复原IP地址-93">复原IP地址[93]</h4>
<p>题目在  <a href="https://leetcode.cn/problems/restore-ip-addresses/description/">https://leetcode.cn/problems/restore-ip-addresses/description/</a>  ,这道题和上面峰分割类似，就是分割好了之后再判断，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">restoreIpAddresses</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">is_legal_str</span>(<span class="params">x</span>):</span><br><span class="line">            int_x = <span class="built_in">int</span>(x)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">str</span>(int_x)==x:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> int_x&gt;<span class="number">255</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">back</span>(<span class="params">state, index</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(state)==<span class="number">4</span> <span class="keyword">and</span> <span class="built_in">len</span>(<span class="string">&quot;&quot;</span>.join(state))==<span class="built_in">len</span>(s):</span><br><span class="line">                res.append(<span class="string">&quot;.&quot;</span>.join(state))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index, <span class="built_in">len</span>(s)):</span><br><span class="line">                <span class="keyword">if</span> is_legal_str(s[index:i+<span class="number">1</span>]):</span><br><span class="line">                    state.append(s[index:i+<span class="number">1</span>])</span><br><span class="line">                    back(state, i+<span class="number">1</span>)</span><br><span class="line">                    state.pop()</span><br><span class="line">        back([], <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="排列问题">排列问题</h3>
<h4 id="总结-4">总结</h4>
<p>遵循同样的模版，排列问题，没有start_index, back中不需要使用back(state, i+1)，需要used保存是否使用过。</p>
<h4 id="打印从1到最大的n位数-LCR-135">打印从1到最大的n位数[LCR.135]</h4>
<p>题目见 <a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/">https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/</a> 题解如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用库的解法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">printNumbers</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        max_val = <span class="number">10</span>**n</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,max_val))</span><br><span class="line"><span class="comment"># 使用回溯来做</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">printNumbers</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">back</span>(<span class="params">state, digit</span>):</span><br><span class="line">            <span class="keyword">if</span> digit == <span class="built_in">len</span>(state):</span><br><span class="line">                res.append(<span class="built_in">int</span>(<span class="string">&quot;&quot;</span>.join(state[:])))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">                    state.append(<span class="built_in">str</span>(i))</span><br><span class="line">                    back(state, digit)</span><br><span class="line">                    state.pop()</span><br><span class="line"></span><br><span class="line">        back([], n)</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">1</span>:]</span><br><span class="line"><span class="comment"># 注意这里的做法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">printNumbers</span>(<span class="params">self, n: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">num, digit</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(num) == digit:</span><br><span class="line">                res.append(<span class="built_in">int</span>(<span class="string">&#x27;&#x27;</span>.join(num)))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">                num.append(<span class="built_in">str</span>(i))</span><br><span class="line">                dfs(num, digit)</span><br><span class="line">                num.pop()</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> digit <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> first <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">                num = [<span class="built_in">str</span>(first)]</span><br><span class="line">                dfs(num, digit)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>注意对于大数的处理，这里需要考虑到，不然会越界的，虽然方案2也可以通过，但是对于大数的话是不行的。</p>
<h4 id="全排列-46">全排列[46]</h4>
<p>遵循同样的模版，排列问题，没有start_index, back中不需要使用back(state, i+1)，需要used保存是否使用过。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permute</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        nums.sort()</span><br><span class="line">        res = []</span><br><span class="line">        used = [<span class="literal">False</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">back</span>(<span class="params">state</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(state) == <span class="built_in">len</span>(nums):</span><br><span class="line">                res.append(state[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> used[i]: <span class="comment"># 1. 很重要</span></span><br><span class="line">                    state.append(nums[i])</span><br><span class="line">                    used[i] = <span class="literal">True</span></span><br><span class="line">                    back(state) <span class="comment"># 没要i+1</span></span><br><span class="line">                    used[i] = <span class="literal">False</span></span><br><span class="line">                    state.pop()</span><br><span class="line"></span><br><span class="line">        back([])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h4 id="全排列II-47">全排列II[47]</h4>
<p>遵循同样的模版，排列问题，没有start_index, back中不需要使用back(state, i+1)，需要used保存是否使用过。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permuteUnique</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        nums.sort()</span><br><span class="line">        res = []</span><br><span class="line">        used = [<span class="literal">False</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">back</span>(<span class="params">state</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(state) == <span class="built_in">len</span>(nums):</span><br><span class="line">                res.append(state[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> used[i]: <span class="comment"># 1. 很重要</span></span><br><span class="line">                    <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>] <span class="keyword">and</span> <span class="keyword">not</span> used[i - <span class="number">1</span>]: <span class="comment">#2.剪枝</span></span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    state.append(nums[i])</span><br><span class="line">                    used[i] = <span class="literal">True</span></span><br><span class="line">                    back(state) <span class="comment"># 没要i+1</span></span><br><span class="line">                    used[i] = <span class="literal">False</span></span><br><span class="line">                    state.pop()</span><br><span class="line"></span><br><span class="line">        back([])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="矩阵类类问题">矩阵类类问题</h3>
<h4 id="单词搜索-79">单词搜索[79]</h4>
<p>题目见 <a href="https://leetcode.cn/problems/word-search/">https://leetcode.cn/problems/word-search/</a>  ，这道题是可以使用回溯来做的，但是回溯可能会比较麻烦，而且在二维数组中的回溯相比于一维比较难写。<br>
回溯可以使用不一样的递归来做，也是好理解的。<br>
使用回溯法结果如下的代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">exist</span>(<span class="params">self, board: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]], word: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        m = <span class="built_in">len</span>(board)</span><br><span class="line">        n = <span class="built_in">len</span>(board[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        visited = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">row, col, index</span>):</span><br><span class="line">            <span class="keyword">if</span> index == <span class="built_in">len</span>(word):   <span class="comment">#</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">for</span> delta_x, delta_y <span class="keyword">in</span> [(<span class="number">0</span>,<span class="number">1</span>),(<span class="number">0</span>,-<span class="number">1</span>),(<span class="number">1</span>,<span class="number">0</span>),(-<span class="number">1</span>,<span class="number">0</span>)]:</span><br><span class="line">                new_row = row + delta_x</span><br><span class="line">                new_col = col + delta_y</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span>&lt;=new_row&lt;m <span class="keyword">and</span> <span class="number">0</span>&lt;=new_col&lt;n <span class="keyword">and</span> <span class="keyword">not</span> visited[new_row][new_col] <span class="keyword">and</span> board[new_row][new_col]==word[index]:</span><br><span class="line">                    visited[new_row][new_col]=<span class="number">1</span>   <span class="comment">#</span></span><br><span class="line">                    <span class="keyword">if</span> helper(new_row,new_col,index+<span class="number">1</span>):  <span class="comment">#</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                    visited[new_row][new_col]=<span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> board[i][j]==word[<span class="number">0</span>]:</span><br><span class="line">                    visited[i][j]=<span class="number">1</span>  <span class="comment">#</span></span><br><span class="line">                    <span class="keyword">if</span> helper(i,j,<span class="number">1</span>):</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">else</span>:  <span class="comment">#</span></span><br><span class="line">                        visited[i][j] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>感觉上面的写法不统一，改用下面的写法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.res = <span class="literal">False</span></span><br><span class="line">        self.used = <span class="literal">None</span></span><br><span class="line">        self.len_word = <span class="number">0</span></span><br><span class="line">        self.board = <span class="literal">None</span></span><br><span class="line">        self.word = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">exist</span>(<span class="params">self, board: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]], word: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        self.used = [[<span class="literal">False</span>] * <span class="built_in">len</span>(board[<span class="number">0</span>]) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board))]</span><br><span class="line">        self.word = word</span><br><span class="line">        self.board = board</span><br><span class="line">        self.len_word = <span class="built_in">len</span>(word)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == word[<span class="number">0</span>]:</span><br><span class="line">                    self.used[i][j] = <span class="literal">True</span></span><br><span class="line">                    self.searchWord(i, j, <span class="number">1</span>, <span class="built_in">len</span>(board), <span class="built_in">len</span>(board[<span class="number">0</span>]))</span><br><span class="line">                    self.used[i][j] = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchWord</span>(<span class="params">self, i, j, pos, m, n</span>):</span><br><span class="line">        <span class="keyword">if</span> pos == self.len_word:</span><br><span class="line">            self.res = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> delta_x, delta_y <span class="keyword">in</span> [(<span class="number">0</span>, -<span class="number">1</span>), (<span class="number">0</span>, <span class="number">1</span>), (-<span class="number">1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">0</span>)]:</span><br><span class="line">            new_x = i + delta_x</span><br><span class="line">            new_y = j + delta_y</span><br><span class="line">            <span class="keyword">if</span> new_x &lt; <span class="number">0</span> <span class="keyword">or</span> new_y &lt; <span class="number">0</span> <span class="keyword">or</span> new_x &gt;= m <span class="keyword">or</span> new_y &gt;= n <span class="keyword">or</span> self.board[new_x][new_y] != self.word[pos] <span class="keyword">or</span> self.used[new_x][new_y]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            self.used[new_x][new_y] = <span class="literal">True</span></span><br><span class="line">            self.searchWord(new_x, new_y, pos + <span class="number">1</span>, m, n)</span><br><span class="line">            self.used[new_x][new_y] = <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h4 id="N皇后问题-51">N皇后问题[51]</h4>
<p>位于 <a href="https://leetcode.cn/problems/n-queens/description/">https://leetcode.cn/problems/n-queens/description/</a> ,一般来说这种问题需要for循环进行回溯的，但是我们理清楚后可以发现，back中的index+1就可以切换到另一个循环了，和电话号码有点像。这种二维的回溯，一般一个for就可以了，然后再外围的index加上一个1.</p>
<p>题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_check</span>(<span class="params">self, state, row, col, n</span>):</span><br><span class="line">        <span class="comment"># 检查行</span></span><br><span class="line">        <span class="keyword">for</span> row1 <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> state[row1][col] == <span class="string">&#x27;Q&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 检查列</span></span><br><span class="line">        <span class="keyword">for</span> col1 <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> state[row][col1] == <span class="string">&quot;Q&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 检查135度方向</span></span><br><span class="line">        row1, col1 = row, col</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            row1 -= <span class="number">1</span></span><br><span class="line">            col1 -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> row1 &gt;= <span class="number">0</span> <span class="keyword">and</span> col1 &gt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> state[row1][col1] == <span class="string">&quot;Q&quot;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 检查45度方向</span></span><br><span class="line">        row1, col1 = row, col</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            row1 -= <span class="number">1</span></span><br><span class="line">            col1 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> row1 &gt;= <span class="number">0</span> <span class="keyword">and</span> col1 &lt;= n-<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> state[row1][col1] == <span class="string">&quot;Q&quot;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">solveNQueens</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span><br><span class="line">        res = []</span><br><span class="line">        init_state = [[<span class="string">&#x27;.&#x27;</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">back</span>(<span class="params">state, row</span>):</span><br><span class="line">            <span class="keyword">if</span> row == n:</span><br><span class="line">                res.append([<span class="string">&#x27;&#x27;</span>.join(i) <span class="keyword">for</span> i <span class="keyword">in</span> state])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> self.is_check(state, row, col, n):</span><br><span class="line">                    state[row][col] = <span class="string">&#x27;Q&#x27;</span></span><br><span class="line">                    back(state, row + <span class="number">1</span>)</span><br><span class="line">                    state[row][col] = <span class="string">&quot;.&quot;</span></span><br><span class="line">        back(init_state, <span class="number">0</span>)     </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h4 id="解数独-37">解数独[37]</h4>
<p>这里直接说一下思路，back返回结果是bool类型，判断有没有解，而不是状态集合了。因此这里用两个for来循环一下的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_valid</span>(<span class="params">self, row: <span class="built_in">int</span>, col: <span class="built_in">int</span>, val: <span class="built_in">int</span>, board</span>):</span><br><span class="line">        <span class="comment"># 判断同一行是否冲突</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">if</span> board[row][i] == <span class="built_in">str</span>(val):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 判断同一列是否冲突</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">if</span> board[j][col] == <span class="built_in">str</span>(val):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 判断同一九宫格是否有冲突</span></span><br><span class="line">        start_row = (row // <span class="number">3</span>) * <span class="number">3</span></span><br><span class="line">        start_col = (col // <span class="number">3</span>) * <span class="number">3</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start_row, start_row + <span class="number">3</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(start_col, start_col + <span class="number">3</span>):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="built_in">str</span>(val):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">solveSudoku</span>(<span class="params">self, board</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">back</span>(<span class="params">state</span>):</span><br><span class="line">            <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board)):</span><br><span class="line">                <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board[<span class="number">0</span>])):</span><br><span class="line">                    <span class="keyword">if</span> board[row][col] != <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">                        <span class="keyword">if</span> self.is_valid(row, col, k, state):</span><br><span class="line">                            state[row][col] = <span class="built_in">str</span>(k)</span><br><span class="line">                            <span class="keyword">if</span> back(state):</span><br><span class="line">                                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                            state[row][col] = <span class="string">&quot;.&quot;</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        back(board)</span><br></pre></td></tr></table></figure>
<p>和单词搜索很像，虽然那道题我也用了以往回溯的思路</p>
<h4 id="所有可能得路径-797">所有可能得路径[797]</h4>
<p>严格意义上不算这类问题，但是仔细看，也是发现有回溯的性质在里面，题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">allPathsSourceTarget</span>(<span class="params">self, graph: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">back</span>(<span class="params">state, index</span>):</span><br><span class="line">            <span class="keyword">if</span> index == <span class="built_in">len</span>(graph) - <span class="number">1</span>:</span><br><span class="line">                res.append(state[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(graph[index])):</span><br><span class="line">                state.append(graph[index][i])</span><br><span class="line">                back(state, graph[index][i])</span><br><span class="line">                state.pop()</span><br><span class="line">        </span><br><span class="line">        state = [<span class="number">0</span>]</span><br><span class="line">        back(state, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>和电话号码有点类似，电话号码里面的是index+1,因为要取下一个数字，这里我们下一个要取得是图节点中的索引，所以直接传入节点的对应的索引就好了，这个index就是传入后，graph得到的值也是index，因此归根到底还是index，因此也符合回溯的模板。</p>
<h4 id="岛屿数量-200">岛屿数量[200]</h4>
<p>代码如下：首先定义递归的出来条件，然后赋值访问过的，然后递归。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numIslands</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">grid, i, j</span>):</span><br><span class="line">            <span class="keyword">if</span> grid[i][j]==<span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            grid[i][j] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">            <span class="keyword">for</span> delta_x, delta_y <span class="keyword">in</span> [(<span class="number">0</span>,<span class="number">1</span>),(<span class="number">0</span>,-<span class="number">1</span>),(-<span class="number">1</span>,<span class="number">0</span>),(<span class="number">1</span>,<span class="number">0</span>)]:</span><br><span class="line">                new_i = i + delta_x</span><br><span class="line">                new_j = j + delta_y</span><br><span class="line">                <span class="keyword">if</span> new_i&gt;=<span class="number">0</span> <span class="keyword">and</span> new_i&lt;<span class="built_in">len</span>(grid) <span class="keyword">and</span> new_j&gt;=<span class="number">0</span> <span class="keyword">and</span> new_j&lt;<span class="built_in">len</span>(grid[<span class="number">0</span>]):                </span><br><span class="line">                    dfs(grid, new_i, new_j)</span><br><span class="line"></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j]==<span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                    res = res + <span class="number">1</span></span><br><span class="line">                    dfs(grid,i,j)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h4 id="岛屿最大面积-695">岛屿最大面积[695]</h4>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxAreaOfIsland</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">grid, i, j,current_res</span>):</span><br><span class="line">            <span class="keyword">if</span> grid[i][j]==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            current_res[<span class="number">0</span>]= current_res[<span class="number">0</span>]+<span class="number">1</span></span><br><span class="line">            grid[i][j] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> delta_x, delta_y <span class="keyword">in</span> [(<span class="number">0</span>,<span class="number">1</span>),(<span class="number">0</span>,-<span class="number">1</span>),(-<span class="number">1</span>,<span class="number">0</span>),(<span class="number">1</span>,<span class="number">0</span>)]:</span><br><span class="line">                new_i = i + delta_x</span><br><span class="line">                new_j = j + delta_y</span><br><span class="line">                <span class="keyword">if</span> new_i&gt;=<span class="number">0</span> <span class="keyword">and</span> new_i&lt;<span class="built_in">len</span>(grid) <span class="keyword">and</span> new_j&gt;=<span class="number">0</span> <span class="keyword">and</span> new_j&lt;<span class="built_in">len</span>(grid[<span class="number">0</span>]):                </span><br><span class="line">                    dfs(grid, new_i, new_j, current_res)</span><br><span class="line"></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j]==<span class="number">1</span>:</span><br><span class="line">                    current_res = [<span class="number">0</span>] <span class="comment"># 注意</span></span><br><span class="line">                    dfs(grid,i,j,current_res)</span><br><span class="line">                    res = <span class="built_in">max</span>(res, current_res[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h4 id="岛屿的周长-463">岛屿的周长[463]</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">islandPerimeter</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">get_nb_nums</span>(<span class="params">i,j</span>):</span><br><span class="line">            cnt = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> delta_x, delta_y <span class="keyword">in</span> [(-<span class="number">1</span>,<span class="number">0</span>),(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">1</span>),(<span class="number">0</span>,-<span class="number">1</span>)]:</span><br><span class="line">                new_i = i + delta_x</span><br><span class="line">                new_j = j + delta_y</span><br><span class="line">                <span class="keyword">if</span> new_i&gt;=<span class="number">0</span> <span class="keyword">and</span> new_i&lt; <span class="built_in">len</span>(grid) <span class="keyword">and</span> new_j&gt;=<span class="number">0</span> <span class="keyword">and</span> new_j&lt;<span class="built_in">len</span>(grid[<span class="number">0</span>]) <span class="keyword">and</span> grid[new_i][new_j]==<span class="number">1</span>:</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> cnt</span><br><span class="line"></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="number">1</span>:</span><br><span class="line">                    cur_bord = <span class="number">4</span> - get_nb_nums(i,j)</span><br><span class="line">                    res = res + cur_bord</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h4 id="最大人工岛-827">最大人工岛[827]</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DIRS = [(-<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, -<span class="number">1</span>)]</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">largestIsland</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n, mp, idx, size_map, res = <span class="built_in">len</span>(grid), <span class="built_in">dict</span>(), <span class="number">0</span>, <span class="built_in">dict</span>(), <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">x, y</span>):</span><br><span class="line">            ans = <span class="number">1</span></span><br><span class="line">            mp[(x, y)] = idx</span><br><span class="line">            <span class="keyword">for</span> dx, dy <span class="keyword">in</span> DIRS:</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt;= (nx := x + dx) &lt; n <span class="keyword">and</span> <span class="number">0</span> &lt;= (ny := y + dy) &lt; n <span class="keyword">and</span> grid[nx][ny] <span class="keyword">and</span> (nx, ny) <span class="keyword">not</span> <span class="keyword">in</span> mp:</span><br><span class="line">                    ans += dfs(nx, ny)</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] <span class="keyword">and</span> (i, j) <span class="keyword">not</span> <span class="keyword">in</span> mp:</span><br><span class="line">                    size_map[idx] = dfs(i, j)</span><br><span class="line">                    res = <span class="built_in">max</span>(res, size_map[idx])</span><br><span class="line">                    idx += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> grid[i][j]:</span><br><span class="line">                    tmp, cur = <span class="built_in">set</span>(), <span class="number">1</span></span><br><span class="line">                    <span class="keyword">for</span> dx, dy <span class="keyword">in</span> DIRS:</span><br><span class="line">                        <span class="keyword">if</span> <span class="number">0</span> &lt;= (nx := i + dx) &lt; n <span class="keyword">and</span> <span class="number">0</span> &lt;= (ny := j + dy) &lt; n <span class="keyword">and</span> grid[nx][ny] <span class="keyword">and</span> mp[(nx, ny)] <span class="keyword">not</span> <span class="keyword">in</span> tmp:</span><br><span class="line">                            tmp.add(mp[(nx, ny)])</span><br><span class="line">                            cur += size_map[mp[(nx, ny)]]</span><br><span class="line">                    res = <span class="built_in">max</span>(res, cur)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>查看：<a href="https://leetcode.cn/problems/making-a-large-island/solutions/1831000/-by-himymb">https://leetcode.cn/problems/making-a-large-island/solutions/1831000/-by-himymb</a></p>
<h3 id="总结-5">总结</h3>
<h4 id="组合总结">组合总结</h4>
<p>对于组合问题有三道题<br>
第一道是没有重复值的，无重复值，在计算的时候back(state, i+1)<br>
第二道题是有重复值的，可无限取，在计算的时候，back(state,i)<br>
第三道题是有重复的，有重复值，在计算的时候，back(state,i+1)，外加剪枝，这里使用到的used[i]只是单单为了剪枝而已</p>
<h4 id="排列问题-2">排列问题</h4>
<p>对于排列问题的两道题<br>
第一道是没有重复值的，无重复值，在计算的时候back(state,i)，为啥要i不是i+1，因此它不是组合问题，取到一个值之后还可以往前取，如 [1,2,3]   取了2之后，还可以去2这样，因此需要使用used来判断是否之前用过，也是为了剪枝<br>
第二道题是有重复值的，有重复值，在计算的时候back(state,i), 外加剪枝，在此使用used[i]表示一个值是否被使用过</p>
<h4 id="如何剪枝">如何剪枝</h4>
<p>剪枝大部分的情况是为了去重，你也可以res中每进入一个新的后去重，也可以在循环里面进行判断后去重。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant A as Alice</span><br><span class="line">    participant J as John</span><br><span class="line">    A-&gt;&gt;J: Hello John, how are you?</span><br><span class="line">    J-&gt;&gt;A: Great!</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>题目汇总</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动窗口与双指针</title>
    <url>/2024/03/19/leetcode/sliding_wind_and_point/</url>
    <content><![CDATA[<h1>滑动窗口</h1>
<h2 id="模板">模板</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">findSubArray</span>(<span class="params">nums</span>):</span><br><span class="line">    N = <span class="built_in">len</span>(nums) <span class="comment"># 数组/字符串长度</span></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="number">0</span> <span class="comment"># 双指针，表示当前遍历的区间[left, right]，闭区间</span></span><br><span class="line">    sums = <span class="number">0</span> <span class="comment"># 用于统计 子数组/子区间 是否有效，根据题目可能会改成求和/计数</span></span><br><span class="line">    res = <span class="number">0</span> <span class="comment"># 保存最大的满足题目要求的 子数组/子串 长度</span></span><br><span class="line">    <span class="keyword">while</span> right &lt; N: <span class="comment"># 当右边的指针没有搜索到 数组/字符串 的结尾</span></span><br><span class="line">        sums += nums[right] <span class="comment"># 增加当前右边指针的数字/字符的求和/计数</span></span><br><span class="line">        <span class="keyword">while</span> sums 符合题意：<span class="comment"># </span></span><br><span class="line">            res = <span class="built_in">max</span>(res, right - left + <span class="number">1</span>) <span class="comment"># 需要更新结果 </span></span><br><span class="line">            sums -= nums[left] <span class="comment">#移除值 </span></span><br><span class="line">            left += <span class="number">1</span>   <span class="comment">#移动左指针</span></span><br><span class="line">        right += <span class="number">1</span> <span class="comment"># 移动右指针，去探索新的区间</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>具体讲解可以看 <a href="https://leetcode-cn.com/problems/max-consecutive-ones-iii/solution/fen-xiang-hua-dong-chuang-kou-mo-ban-mia-f76z/">https://leetcode-cn.com/problems/max-consecutive-ones-iii/solution/fen-xiang-hua-dong-chuang-kou-mo-ban-mia-f76z/</a></p>
<p><strong>注意点</strong>：滑动窗口对数据的单调性有一定的约束的，比如 和至少为k的最短子数组[862] 这道题，数组中值的累加不满足单调性，因此用滑动窗口是不行的。</p>
<h2 id="总结">总结</h2>
<ul>
<li>一般都是先sum数组先减去一个值，然后index再进行操作，如对于长度最小的子数组这个题目，我们发现加多了之后，不能先对left加1，而应该是先减去left的值，然后再加1。</li>
<li>左右都要移动的代码规律如下</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> left &lt; right:</span><br><span class="line">    操作s[加减] 比如s是累计窗口内的和或者用来保存出现次数的字典</span><br><span class="line">    条件s[判断s是否符合条件]</span><br><span class="line">    条件<span class="number">1</span>：</span><br><span class="line">        left + <span class="number">1</span></span><br><span class="line">    条件<span class="number">2</span>：</span><br><span class="line">        right -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>右边按照1步慢慢来移动，左边自适应移动代码规律如下</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="comment"># 1. 先操作</span></span><br><span class="line">    s = s + nums[right]【题目<span class="number">3</span> <span class="number">209</span> <span class="number">904</span>】或者不操作【题目<span class="number">26</span> <span class="number">27</span> <span class="number">80</span>】</span><br><span class="line">    <span class="comment"># 2. 循环左</span></span><br><span class="line">    <span class="keyword">while</span> condition(s)【题目<span class="number">3</span> <span class="number">209</span> <span class="number">904</span>】 或者 <span class="keyword">if</span> 【题目<span class="number">26</span> <span class="number">27</span> <span class="number">80</span>】</span><br><span class="line">        操作s</span><br><span class="line">        保存结果ans</span><br><span class="line">        left = left + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="长度最小的子数组-209">长度最小的子数组[209]</h2>
<p>这是很简单的滑动窗口，没有复杂的逻辑，就是简答的滑窗，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minSubArrayLen</span>(<span class="params">self, target: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        start, end = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        s  = <span class="number">0</span></span><br><span class="line">        min_lens = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">        <span class="keyword">while</span> end &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            s += nums[end]</span><br><span class="line">            <span class="keyword">while</span> s &gt;= target: <span class="comment"># 刚好满足条件了</span></span><br><span class="line">                <span class="keyword">if</span> end - start + <span class="number">1</span> &lt; min_lens:</span><br><span class="line">                    min_lens = end - start + <span class="number">1</span></span><br><span class="line">                s -= nums[start]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">            end += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> min_lens==<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> min_lens</span><br></pre></td></tr></table></figure>
<p>刚好满足条件了 end - start + 1</p>
<h2 id="滑动窗口最大值-239">滑动窗口最大值[239]</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        q = [(-nums[i], i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k)]</span><br><span class="line">        heapq.heapify(q)</span><br><span class="line">        ans = [-q[<span class="number">0</span>][<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, <span class="built_in">len</span>(nums)):</span><br><span class="line">            heapq.heappush(q, (-nums[i],i))</span><br><span class="line">            <span class="keyword">while</span> q[<span class="number">0</span>][<span class="number">1</span>] &lt; i -k + <span class="number">1</span>: <span class="comment"># 不能超过界限</span></span><br><span class="line">                heapq.heappop(q)</span><br><span class="line">            ans.append(-q[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"><span class="comment"># 2. </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        q = []</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(q) &lt;= k - <span class="number">1</span>:</span><br><span class="line">                heapq.heappush(q, (-nums[i], i))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(-q[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">                <span class="keyword">while</span> q <span class="keyword">and</span> i - q[<span class="number">0</span>][<span class="number">1</span>] &gt;= k:</span><br><span class="line">                    heapq.heappop(q)</span><br><span class="line">                heapq.heappush(q, (-nums[i], i))</span><br><span class="line">        res.append(-q[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>最好是上面的那种，push完之后立马算最小值，不然2解法中，最后还要加一个，很麻烦的</p>
<h2 id="滑动窗口中位数">滑动窗口中位数</h2>
<p>题目见 <a href="https://leetcode-cn.com/problems/sliding-window-median/%EF%BC%8C">https://leetcode-cn.com/problems/sliding-window-median/，</a> 题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">medianSlidingWindow</span>(<span class="params">self, nums, k</span>):</span><br><span class="line">        <span class="keyword">import</span> bisect</span><br><span class="line">        res = []</span><br><span class="line">        res2 = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(res) &gt;= k:</span><br><span class="line">                <span class="keyword">if</span> k &amp; <span class="number">1</span>:</span><br><span class="line">                    res2.append(res[k // <span class="number">2</span>])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res2.append((res[k // <span class="number">2</span>] + res[k // <span class="number">2</span>] - <span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">                idx = bisect.bisect_left(res, nums[i - k]) <span class="comment"># 找到位置</span></span><br><span class="line">                res[idx:idx + <span class="number">1</span>] = [] <span class="comment"># 清除</span></span><br><span class="line">            idx = bisect.bisect_left(res, nums[i])</span><br><span class="line">            res[idx:idx] = [nums[i]]</span><br><span class="line">        <span class="keyword">return</span> res2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">su = Solution()</span><br><span class="line">su.medianSlidingWindow([<span class="number">1</span>, <span class="number">3</span>, -<span class="number">1</span>, -<span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>], <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<h2 id="最小覆盖子串-76">最小覆盖子串[76]</h2>
<p>题目见 <a href="https://leetcode-cn.com/problems/minimum-window-substring/%EF%BC%8C">https://leetcode-cn.com/problems/minimum-window-substring/，</a> 解法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minWindow</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># 定义函数</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">all_map</span>(<span class="params">t, s</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> t:</span><br><span class="line">                <span class="keyword">if</span> t[i] &gt; s[i]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 定义开始和结束</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        end = <span class="number">0</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">        t_dict = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> t:  <span class="comment"># 统计</span></span><br><span class="line">            t_dict[i] += <span class="number">1</span></span><br><span class="line">        s_dict = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        min_len = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">        min_res = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 循环</span></span><br><span class="line">        <span class="keyword">while</span> end &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            s_dict[s[end]] += <span class="number">1</span> <span class="comment"># 注意点1，后面那道题就放在end+=1之前了</span></span><br><span class="line">            <span class="keyword">while</span> all_map(t_dict, s_dict): <span class="comment"># 刚刚满足条件了</span></span><br><span class="line">                <span class="keyword">if</span> end - start + <span class="number">1</span> &lt; min_len:</span><br><span class="line">                    min_len = end + <span class="number">1</span> - start</span><br><span class="line">                    min_res = s[start:end + <span class="number">1</span>]</span><br><span class="line">                s_dict[s[start]] -= <span class="number">1</span></span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">            end += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> min_res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">su = Solution()</span><br><span class="line">f = su.minWindow(s=<span class="string">&quot;ADOBECODEBANC&quot;</span>, t=<span class="string">&quot;ABC&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(f)</span><br></pre></td></tr></table></figure>
<p>刚好满足条件了 end - start + 1</p>
<h2 id="无重复字符的最长子串-3">无重复字符的最长子串[3]</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 删除字典元素</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">remove_d_v</span>(<span class="params">d,v</span>):</span><br><span class="line">            <span class="keyword">if</span> v <span class="keyword">in</span> d:</span><br><span class="line">                d[v] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> d[v]==<span class="number">0</span>:</span><br><span class="line">                d.pop(v)</span><br><span class="line">        <span class="comment"># 开始逻辑</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s)==<span class="number">1</span>:<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">        start, end = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        d = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        max_lens = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> end &lt; <span class="built_in">len</span>(s):            </span><br><span class="line">            <span class="keyword">while</span> s[end] <span class="keyword">in</span> d: <span class="comment"># 刚好不满足条件了</span></span><br><span class="line">                max_lens = <span class="built_in">max</span>(max_lens, end - start)</span><br><span class="line">                remove_d_v(d,s[start])</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">            d[s[end]] += <span class="number">1</span> <span class="comment"># 注意点，位置放这里</span></span><br><span class="line">            end += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(max_lens, end - start)</span><br></pre></td></tr></table></figure>
<p>刚好不满足条件了 end - start</p>
<h2 id="最长重复子串-1044">最长重复子串[1044]</h2>
<p>题目见 <a href="https://leetcode-cn.com/problems/longest-duplicate-substring/">https://leetcode-cn.com/problems/longest-duplicate-substring/</a> 这道题还可以用字符串哈希来做，不过比较麻烦，这里就使用常规的方法来做了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestDupSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        ans = <span class="string">&quot;&quot;</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        end = <span class="number">1</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">while</span> start &lt; n:</span><br><span class="line">            <span class="keyword">while</span> s[start:end] <span class="keyword">in</span> s[start+<span class="number">1</span>:]:</span><br><span class="line">                <span class="keyword">if</span> end - start&gt; <span class="built_in">len</span>(ans):</span><br><span class="line">                    ans = s[start:end]</span><br><span class="line">                end += <span class="number">1</span></span><br><span class="line">            start += <span class="number">1</span></span><br><span class="line">            end += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>大部分题解是while end &lt; n</p>
<h2 id="和大于等于-target-的最短子数组-LCR-008">和大于等于 target 的最短子数组[LCR 008]</h2>
<p>题解如下，注意一下边界的条件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minSubArrayLen</span>(<span class="params">self, target: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">import</span> bisect</span><br><span class="line">        prefix = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            prefix.append(prefix[-<span class="number">1</span>] + i)</span><br><span class="line">        <span class="keyword">if</span> prefix[-<span class="number">1</span>]&lt;target:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        res = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prefix)):</span><br><span class="line">            index = bisect.bisect_left(prefix, prefix[i] + target)</span><br><span class="line">            <span class="keyword">if</span> index != <span class="built_in">len</span>(prefix):           </span><br><span class="line">                res = <span class="built_in">min</span>(index - i, res)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> res==<span class="built_in">len</span>(prefix) <span class="keyword">else</span> res</span><br></pre></td></tr></table></figure>
<p>也可以使用滑窗解法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def minSubArrayLen(self, s: int, nums: List[int]) -&gt; int:</span><br><span class="line">        if not nums:</span><br><span class="line">            return 0</span><br><span class="line">        </span><br><span class="line">        n = len(nums)</span><br><span class="line">        ans = n + 1</span><br><span class="line">        start, end = 0, 0</span><br><span class="line">        total = 0</span><br><span class="line">        while end &lt; n:</span><br><span class="line">            total += nums[end]</span><br><span class="line">            while total &gt;= s:</span><br><span class="line">                ans = min(ans, end - start + 1)</span><br><span class="line">                total -= nums[start]</span><br><span class="line">                start += 1</span><br><span class="line">            end += 1</span><br><span class="line">        </span><br><span class="line">        return 0 if ans == n + 1 else ans</span><br></pre></td></tr></table></figure>
<h2 id="将-x-减到-0-的最小操作数-1658">将 x 减到 0 的最小操作数[1658]</h2>
<p>题目见 <a href="https://leetcode-cn.com/problems/minimum-operations-to-reduce-x-to-zero/">https://leetcode-cn.com/problems/minimum-operations-to-reduce-x-to-zero/</a> ，解法如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># bisect 因此nums都是正数，所以可以使用二分查找来做</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minOperations</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">get_prefix_sum</span>(<span class="params">nums</span>):</span><br><span class="line">            prefix = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">                val = prefix[-<span class="number">1</span>] <span class="keyword">if</span> prefix <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">                prefix.append(i+val)</span><br><span class="line">            <span class="keyword">return</span> prefix</span><br><span class="line"></span><br><span class="line">        res = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            nums2 = nums[<span class="number">0</span>:i][::-<span class="number">1</span>] + nums[i:][::-<span class="number">1</span>]</span><br><span class="line">            prefix = get_prefix_sum(nums2)</span><br><span class="line">            <span class="built_in">print</span>(prefix)</span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">in</span> prefix:</span><br><span class="line">                res = <span class="built_in">min</span>(res, prefix.index(x)+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span> <span class="keyword">if</span> res==<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>) <span class="keyword">else</span> res</span><br><span class="line"><span class="comment"># 滑窗</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minOperations</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        diff = <span class="built_in">sum</span>(nums) - x</span><br><span class="line">        <span class="keyword">if</span> diff &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="number">0</span></span><br><span class="line">        sm = <span class="number">0</span></span><br><span class="line">        res = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            sm += nums[right]</span><br><span class="line">            <span class="keyword">while</span> sm &gt; diff:</span><br><span class="line">                sm -= nums[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> sm == diff:</span><br><span class="line">                res = <span class="built_in">max</span>(res,right - left + <span class="number">1</span>)</span><br><span class="line">            right += <span class="number">1</span> <span class="comment"># 一定放这里</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span> <span class="keyword">if</span> res==-<span class="number">1</span> <span class="keyword">else</span> <span class="built_in">len</span>(nums)-res</span><br></pre></td></tr></table></figure>
<h2 id="下标对中的最大距离-1855">下标对中的最大距离[1855]</h2>
<p>题目见 <a href="https://leetcode-cn.com/problems/maximum-distance-between-a-pair-of-values/">https://leetcode-cn.com/problems/maximum-distance-between-a-pair-of-values/</a> 按照滑动窗口模板来写的话，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 错误</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDistance</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(nums2):</span><br><span class="line">            <span class="keyword">while</span> left &lt; <span class="built_in">len</span>(nums1) <span class="keyword">and</span> nums1[left] &gt; nums2[right] <span class="keyword">and</span> left&lt;=right:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            res = <span class="built_in">max</span>(res, right-left)</span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"><span class="comment"># 正确</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDistance</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(nums2):</span><br><span class="line">            <span class="keyword">while</span> left &lt; <span class="built_in">len</span>(nums1) <span class="keyword">and</span> nums1[left] &gt; nums2[right] <span class="keyword">and</span> left&lt;=right:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left &lt; <span class="built_in">len</span>(nums1):  <span class="comment"># 这里要加一个</span></span><br><span class="line">                res = <span class="built_in">max</span>(res, right-left)</span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h2 id="水果成篮-904">水果成篮[904]</h2>
<p>题号 904， 位于 <a href="https://leetcode.cn/problems/fruit-into-baskets/description/">https://leetcode.cn/problems/fruit-into-baskets/description/</a><br>
题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">totalFruit</span>(<span class="params">self, fruits: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        cnt = Counter()</span><br><span class="line"></span><br><span class="line">        left = ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> right, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(fruits):</span><br><span class="line">            cnt[x] += <span class="number">1</span> <span class="comment">#这里字典操作</span></span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(cnt) &gt; <span class="number">2</span>:</span><br><span class="line">                cnt[fruits[left]] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> cnt[fruits[left]] == <span class="number">0</span>:</span><br><span class="line">                    cnt.pop(fruits[left])</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, right - left + <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h2 id="找到字符串中所有字母异位词-438">找到字符串中所有字母异位词[438]</h2>
<p>位于 <a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/">https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/</a> 题解看我这就好</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findAnagrams</span>(<span class="params">self, s: <span class="built_in">str</span>, p: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        s_list = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">        p_list = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> p:</span><br><span class="line">            p_list[<span class="built_in">ord</span>(n)-<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">        left=<span class="number">0</span></span><br><span class="line">        right=<span class="number">0</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            s_list[<span class="built_in">ord</span>(s[right])-<span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>)] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> right - left &gt;= <span class="built_in">len</span>(p): <span class="comment"># 发现右比左多的话，左边也动</span></span><br><span class="line">                s_list[<span class="built_in">ord</span>(s[left])-<span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>)] -= <span class="number">1</span></span><br><span class="line">                left = left + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> s_list == p_list:</span><br><span class="line">                ans.append(left)</span><br><span class="line">            right = right + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h2 id="串联所有单词的子串-30">串联所有单词的子串 [30]</h2>
<p>位于 <a href="https://leetcode.cn/problems/substring-with-concatenation-of-all-words/description/?envType=study-plan-v2&amp;envId=top-interview-150">https://leetcode.cn/problems/substring-with-concatenation-of-all-words/description/?envType=study-plan-v2&amp;envId=top-interview-150</a> 题解和上面类似</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findSubstring</span>(<span class="params">self, s: <span class="built_in">str</span>, words: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        p = <span class="string">&quot;&quot;</span>.join(words)</span><br><span class="line">        s_list = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">        p_list = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> p:</span><br><span class="line">            p_list[<span class="built_in">ord</span>(n) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="number">0</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            s_list[<span class="built_in">ord</span>(s[right]) - <span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>)] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> right - left &gt;= <span class="built_in">len</span>(p):</span><br><span class="line">                s_list[<span class="built_in">ord</span>(s[left]) - <span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>)] -= <span class="number">1</span></span><br><span class="line">                left = left + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> s_list == p_list:</span><br><span class="line">                d = Counter(words) <span class="comment"># 开始一步一步查验是否存在</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(left, left + <span class="built_in">len</span>(words) * <span class="built_in">len</span>(words[<span class="number">0</span>]), <span class="built_in">len</span>(words[<span class="number">0</span>])):</span><br><span class="line">                    <span class="keyword">if</span> s[j:j + <span class="built_in">len</span>(words[<span class="number">0</span>])] <span class="keyword">in</span> words:</span><br><span class="line">                        d[s[j:j + <span class="built_in">len</span>(words[<span class="number">0</span>])]] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">all</span>([i==<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>(d.values())]):</span><br><span class="line">                    ans.append(left)</span><br><span class="line">            right = right + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h1>双指针</h1>
<h2 id="验证回文串-125">验证回文串[125]</h2>
<p>位于<a href="https://leetcode.cn/problems/valid-palindrome/solutions/?envType=study-plan-v2&amp;envId=top-interview-150">https://leetcode.cn/problems/valid-palindrome/solutions/?envType=study-plan-v2&amp;envId=top-interview-150</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> left &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> <span class="keyword">not</span> s[left].isalpha() <span class="keyword">and</span> <span class="keyword">not</span> s[left].isdigit():</span><br><span class="line">                left = left + <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> right &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> <span class="keyword">not</span> s[right].isalpha() <span class="keyword">and</span> <span class="keyword">not</span> s[right].isdigit():</span><br><span class="line">                right = right-<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> s[left].lower() == s[right].lower():</span><br><span class="line">                left = left + <span class="number">1</span></span><br><span class="line">                right = right - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(left, right)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h2 id="判断子序列-392">判断子序列[392]</h2>
<p>位于 <a href="https://leetcode.cn/problems/is-subsequence/description/?envType=study-plan-v2&amp;envId=top-interview-150">https://leetcode.cn/problems/is-subsequence/description/?envType=study-plan-v2&amp;envId=top-interview-150</a>  感觉使用while会好一些，这样就不用判断是否index超了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用while</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSubsequence</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        n, m = <span class="built_in">len</span>(s), <span class="built_in">len</span>(t)</span><br><span class="line">        i = j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> j &lt; m:</span><br><span class="line">            <span class="keyword">if</span> s[i] == t[j]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i == n</span><br><span class="line"><span class="comment"># 使用for</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSubsequence</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> s==<span class="string">&quot;&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        p1 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> p2 <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(t)):</span><br><span class="line">            <span class="keyword">if</span> t[p2] == s[p1]:</span><br><span class="line">                p1 = p1 + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> p1 == <span class="built_in">len</span>(s):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h2 id="移除元素-27">移除元素[27]</h2>
<p>位于 <a href="https://leetcode.cn/problems/remove-element/">https://leetcode.cn/problems/remove-element/</a><br>
题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">pass</span> <span class="comment">#这里不需要操作啥</span></span><br><span class="line">            <span class="keyword">if</span> nums[right] == val:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            nums[left] = nums[right]</span><br><span class="line">            left = left + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>
<h2 id="删除有序数组中的重复项-26">删除有序数组中的重复项[26]</h2>
<p>位于 <a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">https://leetcode.cn/problems/remove-duplicates-from-sorted-array/</a></p>
<p>题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[right] == nums[left]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            left = left + <span class="number">1</span></span><br><span class="line">            nums[left] = nums[right]</span><br><span class="line">        <span class="keyword">return</span> left + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="删除有序数组中的重复项-II-80">删除有序数组中的重复项 II[80]</h2>
<p>位于 <a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/">https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/</a><br>
题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        d = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            d[nums[right]] = d[nums[right]] + <span class="number">1</span> <span class="comment"># 注意点，先加1，然后再判断</span></span><br><span class="line">            <span class="keyword">if</span> d[nums[right]] &gt; <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            nums[left] = nums[right]</span><br><span class="line">            left = left + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>
<h2 id="轮转数组-189">轮转数组[189]</h2>
<p>位于 <a href="https://leetcode.cn/problems/rotate-array/solutions/?envType=study-plan-v2&amp;envId=top-interview-150">https://leetcode.cn/problems/rotate-array/solutions/?envType=study-plan-v2&amp;envId=top-interview-150</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> k==<span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(nums)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        k = k % <span class="built_in">len</span>(nums)</span><br><span class="line">        num2 = nums[-k:] + nums[<span class="number">0</span>:-k] <span class="comment"># 注意</span></span><br><span class="line">        <span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(num2):</span><br><span class="line">            nums[index] = value</span><br></pre></td></tr></table></figure>
<h2 id="合并两个有序数组-88">合并两个有序数组[88]</h2>
<p>位于 <a href="https://leetcode.cn/problems/merge-sorted-array/description/?envType=study-plan-v2&amp;envId=top-interview-150">https://leetcode.cn/problems/merge-sorted-array/description/?envType=study-plan-v2&amp;envId=top-interview-150</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], m: <span class="built_in">int</span>, nums2: <span class="type">List</span>[<span class="built_in">int</span>], n: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        p1, p2 = m - <span class="number">1</span>, n - <span class="number">1</span></span><br><span class="line">        tail = m + n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p1 &gt;= <span class="number">0</span> <span class="keyword">or</span> p2 &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> p1 == -<span class="number">1</span>:</span><br><span class="line">                nums1[tail] = nums2[p2]</span><br><span class="line">                p2 = p2 - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> p2 == -<span class="number">1</span>:</span><br><span class="line">                nums1[tail] = nums1[p1]</span><br><span class="line">                p1 = p1 - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums1[p1] &gt; nums2[p2]:</span><br><span class="line">                nums1[tail] = nums1[p1]</span><br><span class="line">                p1 = p1 - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[tail] = nums2[p2]</span><br><span class="line">                p2 = p2 - <span class="number">1</span></span><br><span class="line">            tail = tail - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="两数之和-1">两数之和[1]</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            d[nums[i]] = i </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            current_value = nums[i]</span><br><span class="line">            <span class="keyword">if</span> target - current_value <span class="keyword">in</span> d:</span><br><span class="line">                <span class="keyword">if</span> d[target - current_value]!= i:</span><br><span class="line">                    <span class="keyword">return</span> [i, d[target - current_value]]</span><br></pre></td></tr></table></figure>
<h2 id="两数之和II-167">两数之和II[167]</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, numbers: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        d=<span class="built_in">dict</span>(<span class="built_in">zip</span>(numbers,<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="built_in">len</span>(numbers)))))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(numbers)):</span><br><span class="line">            <span class="keyword">if</span> (target-numbers[i]) <span class="keyword">in</span> d:</span><br><span class="line">                <span class="keyword">return</span> [i+<span class="number">1</span>,d[target-numbers[i]]+<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h2 id="三数之和-15">三数之和[15]</h2>
<p>思路:采用总结里面第2点，涉及到while i &lt; j，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">if</span> nums[<span class="number">0</span>] == <span class="number">0</span> <span class="keyword">and</span> nums[-<span class="number">1</span>] == <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(nums) &gt;= <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> [[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= <span class="number">1</span> <span class="keyword">and</span> nums[i - <span class="number">1</span>] == nums[i]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            m, n = i + <span class="number">1</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> m &lt; n:</span><br><span class="line">                s = nums[i] + nums[m] + nums[n]</span><br><span class="line">                <span class="keyword">if</span> s &lt; <span class="number">0</span>:</span><br><span class="line">                    m = m + <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> s &gt; <span class="number">0</span>:</span><br><span class="line">                    n = n - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res.append([nums[i], nums[m], nums[n]])</span><br><span class="line">                    m = m + <span class="number">1</span></span><br><span class="line">                    n = n - <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> m &lt; n <span class="keyword">and</span> nums[m] == nums[m - <span class="number">1</span>]: <span class="comment"># 注意，不是m+1，是从后往前去你有没有重复的</span></span><br><span class="line">                        m = m + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> m &lt; n <span class="keyword">and</span> nums[n] == nums[n + <span class="number">1</span>]:</span><br><span class="line">                        n = n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h2 id="文本左右对齐-68">文本左右对齐[68]</h2>
<p>位于 <a href="https://leetcode.cn/problems/text-justification/?envType=study-plan-v2&amp;envId=top-interview-150">https://leetcode.cn/problems/text-justification/?envType=study-plan-v2&amp;envId=top-interview-150</a> 解法如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fullJustify</span>(<span class="params">self, words: <span class="type">List</span>[<span class="built_in">str</span>], maxWidth: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="number">0</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> left &lt; <span class="built_in">len</span>(words) <span class="keyword">and</span> right &lt; <span class="built_in">len</span>(words):</span><br><span class="line">            str_sums = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(words) <span class="keyword">and</span> str_sums + <span class="built_in">len</span>(words[right]) + right - left &lt;= maxWidth: <span class="comment"># 注意这里直接加上去</span></span><br><span class="line">                str_sums = str_sums + <span class="built_in">len</span>(words[right])</span><br><span class="line">                right = right + <span class="number">1</span></span><br><span class="line">            res.append(words[left:right])</span><br><span class="line">            left = right</span><br><span class="line">        new_list = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> res[:-<span class="number">1</span>]:</span><br><span class="line">            diff = maxWidth - <span class="built_in">len</span>(<span class="string">&quot;&quot;</span>.join(i))</span><br><span class="line">            <span class="keyword">for</span> lens <span class="keyword">in</span> <span class="built_in">range</span>(diff):</span><br><span class="line">                index = lens % <span class="built_in">max</span>(<span class="number">1</span>, (<span class="built_in">len</span>(i) - <span class="number">1</span>))</span><br><span class="line">                i[index] = i[index] + <span class="string">&quot; &quot;</span></span><br><span class="line">            new_list.append(<span class="string">&quot;&quot;</span>.join(i))</span><br><span class="line">        new_list.append(<span class="string">&quot; &quot;</span>.join(res[-<span class="number">1</span>]) + <span class="string">&quot; &quot;</span>*(maxWidth-<span class="built_in">len</span>(<span class="string">&quot; &quot;</span>.join(res[-<span class="number">1</span>]))))</span><br><span class="line">        <span class="keyword">return</span> new_list</span><br></pre></td></tr></table></figure>
<h2 id="四数之和-18">四数之和 [18]</h2>
<h2 id="有序数组平方和-977">有序数组平方和[977]</h2>
<p>思路:采用总结里面的第2点，涉及到while i &lt; j</p>
<h2 id="训练计划I-LCR-139">训练计划I [LCR 139]</h2>
<p>位于 <a href="https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/description/">https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/description/</a><br>
题解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trainingPlan</span>(<span class="params">self, actions: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        i, j = <span class="number">0</span>, <span class="built_in">len</span>(actions) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> actions[i] &amp; <span class="number">1</span> == <span class="number">1</span>: i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> actions[j] &amp; <span class="number">1</span> == <span class="number">0</span>: j -= <span class="number">1</span></span><br><span class="line">            actions[i], actions[j] = actions[j], actions[i]</span><br><span class="line">        <span class="keyword">return</span> actions</span><br></pre></td></tr></table></figure>
<p>就是上面说的第一个模版，在三数之和中也遇到了，外面一个大的<code>while i&lt;j</code>里面还有两个小的<code>while i&lt;j</code>然后加上一些判断条件。</p>
<h2 id="盛水最多的容器-11">盛水最多的容器 [11]</h2>
<p>位于 <a href="https://leetcode.cn/problems/container-with-most-water/description/?envType=study-plan-v2&amp;envId=top-interview-150">https://leetcode.cn/problems/container-with-most-water/description/?envType=study-plan-v2&amp;envId=top-interview-150</a><br>
思路:采用总结里面的第2点，涉及到while i &lt; j</p>
<p>题号:11</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxArea</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(height) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        area = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            temp = <span class="built_in">min</span>(height[left], height[right]) * (right - left)</span><br><span class="line">            <span class="keyword">if</span> height[left] &lt; height[right]:</span><br><span class="line">                left = left + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = right - <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> temp &gt; area:</span><br><span class="line">                area = temp</span><br><span class="line">        <span class="keyword">return</span> area</span><br></pre></td></tr></table></figure>
<h2 id="反转字符串中的单词-151">反转字符串中的单词[151]</h2>
<p>位于 <a href="https://leetcode.cn/problems/reverse-words-in-a-string/description/?envType=study-plan-v2&amp;envId=top-interview-150">https://leetcode.cn/problems/reverse-words-in-a-string/description/?envType=study-plan-v2&amp;envId=top-interview-150</a> 代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseWords</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="number">0</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> left &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> right &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">while</span> left &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[left] == <span class="string">&quot; &quot;</span>:</span><br><span class="line">                left = left + <span class="number">1</span></span><br><span class="line">            right = left</span><br><span class="line">            <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[right] != <span class="string">&quot; &quot;</span>:</span><br><span class="line">                right = right + <span class="number">1</span></span><br><span class="line">            res.append(s[left:right])</span><br><span class="line">            left = right</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; &quot;</span>.join(res[::-<span class="number">1</span>]).strip()</span><br></pre></td></tr></table></figure>
<h2 id="验证回文串-125-2">验证回文串[125]</h2>
<p>位于  <a href="https://leetcode.cn/problems/valid-palindrome/description/?envType=study-plan-v2&amp;envId=top-interview-150">https://leetcode.cn/problems/valid-palindrome/description/?envType=study-plan-v2&amp;envId=top-interview-150</a>  代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> left &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> <span class="keyword">not</span> s[left].isalpha() <span class="keyword">and</span> <span class="keyword">not</span> s[left].isdigit(): <span class="comment">#注意点1</span></span><br><span class="line">                left = left + <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> right &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> <span class="keyword">not</span> s[right].isalpha() <span class="keyword">and</span> <span class="keyword">not</span> s[right].isdigit():</span><br><span class="line">                right = right-<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> s[left].lower() == s[right].lower():</span><br><span class="line">                left = left + <span class="number">1</span></span><br><span class="line">                right = right - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(left, right)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h2 id="判断子序列-392-2">判断子序列 [392]</h2>
<p>位于 <a href="https://leetcode.cn/problems/is-subsequence/description/?envType=study-plan-v2&amp;envId=top-interview-150">https://leetcode.cn/problems/is-subsequence/description/?envType=study-plan-v2&amp;envId=top-interview-150</a> 题解如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSubsequence</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> s==<span class="string">&quot;&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        p1 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> p2 <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(t)):</span><br><span class="line">            <span class="keyword">if</span> t[p2] == s[p1]:</span><br><span class="line">                p1 = p1 + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> p1 == <span class="built_in">len</span>(s):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>题目汇总</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>小抄</title>
    <url>/2024/03/19/leetcode/small/</url>
    <content><![CDATA[<h1>快速初始化方法</h1>
<h2 id="zip用于旋转">zip用于旋转</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>(<span class="built_in">zip</span>(*a))[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>二维数组这么旋转最快</p>
<h2 id="高级乘法">高级乘法</h2>
<p>a&gt;&gt;1 表示a//2<br>
a&lt;&lt;1 表示a*2</p>
<h2 id="判断是否为数字等">判断是否为数字等</h2>
<p>i.isalnnum()是否是数字或字符串<br>
i.isalpha()判断是否字母<br>
isdigit函数判断是否数字<br>
isdecimal() 方法检查字符串是否只包含十进制字符这种方法只存在于unicode对象。</p>
<p><a href="https://www.runoob.com/python/att-string-isdecimal.html">https://www.runoob.com/python/att-string-isdecimal.html</a></p>
<h2 id="负数求补码">负数求补码</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x &amp; <span class="number">0xffffffff</span></span><br></pre></td></tr></table></figure>
<p>补码如何变成一个数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~(a ^ x)</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/solution/pythonjie-fa-xiang-xi-jie-du-wei-yun-sua-jrk8/">https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/solution/pythonjie-fa-xiang-xi-jie-du-wei-yun-sua-jrk8/</a></p>
<h2 id="不能返回数字用于后续对的判断">不能返回数字用于后续对的判断</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">if</span> contiions1:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>不能用该函数的结果给后面的代码做判断，万一输出的是0，但是这个0是有意义的，那你这么判断是有问题的。</p>
<h2 id="获取数字的二进制">获取数字的二进制</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bin</span>(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<h2 id="获取ascill码的转换">获取ascill码的转换</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="number">104</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>))</span><br></pre></td></tr></table></figure>
<h2 id="list和str赋值">list和str赋值</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="string">&quot;123&quot;</span>,<span class="string">&quot;456&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)):</span><br><span class="line">    a[i] = a[i] + <span class="string">&#x27;_&#x27;</span></span><br><span class="line">可以得到[<span class="string">&quot;123_&quot;</span>,<span class="string">&quot;456_&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    i = i + <span class="string">&quot;_&quot;</span></span><br><span class="line">得到[<span class="string">&quot;123&quot;</span>,<span class="string">&quot;456&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>只能对list中的值修改，不能对str进行修改</p>
<h2 id="快速间隔取数">快速间隔取数</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">43</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">nums[<span class="number">1</span>::<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<h2 id="快速求余">快速求余</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def remainder(x, a, p):</span><br><span class="line">    rem = 1</span><br><span class="line">    for _ in range(a):</span><br><span class="line">        rem = (rem * x) % p</span><br><span class="line">    return rem</span><br><span class="line"></span><br><span class="line"># 求 (x^a) % p —— 快速幂求余</span><br><span class="line">def remainder(x, a, p):</span><br><span class="line">    rem = 1</span><br><span class="line">    while a &gt; 0:</span><br><span class="line">        if a % 2: rem = (rem * x) % p</span><br><span class="line">        x = x ** 2 % p</span><br><span class="line">        a //= 2</span><br><span class="line">    return rem</span><br></pre></td></tr></table></figure>
<p>参考 <a href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/solution/mian-shi-ti-14-ii-jian-sheng-zi-iitan-xin-er-fen-f/">https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/solution/mian-shi-ti-14-ii-jian-sheng-zi-iitan-xin-er-fen-f/</a></p>
<h2 id="快速求进位数">快速求进位数</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(x&gt;&gt;10)&amp;1</span><br><span class="line">看x的第10位是啥</span><br></pre></td></tr></table></figure>
<h2 id="快速轮询">快速轮询</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i%4表示以4作为循环</span><br><span class="line">for i in range(100):</span><br><span class="line">    res[i%4] += i</span><br><span class="line"></span><br><span class="line"># 循环访问数组</span><br><span class="line">res = 0</span><br><span class="line">week = [1,2,3,4,5,6,7]</span><br><span class="line">for i in range(n):</span><br><span class="line">    res = res + week[i%7] + i//7</span><br><span class="line">return res</span><br></pre></td></tr></table></figure>
<h2 id="快速判断奇偶">快速判断奇偶</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x&amp;1</span><br><span class="line">为1表示奇数</span><br></pre></td></tr></table></figure>
<h2 id="快速获取间隔的数组">快速获取间隔的数组</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">a[<span class="number">1</span>:<span class="number">10</span>:<span class="number">3</span>] 每间隔<span class="number">3</span></span><br></pre></td></tr></table></figure>
<h2 id="快速计算斐波那契数列">快速计算斐波那契数列</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line">math.factorial(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<h2 id="快速求中位数">快速求中位数</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 奇数</span></span><br><span class="line">n = <span class="built_in">len</span>(nums1)</span><br><span class="line"><span class="keyword">if</span> n &amp; <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">return</span> nums1[(n-<span class="number">1</span>)//<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 偶数</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> (nums1[(n-<span class="number">1</span>)//<span class="number">2</span>] + nums1[(n-<span class="number">1</span>)//<span class="number">2</span> + <span class="number">1</span>])/<span class="number">2</span></span><br></pre></td></tr></table></figure>
<h2 id="快速循环一个序列">快速循环一个序列</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">    <span class="built_in">print</span>(nums[i])</span><br><span class="line">    index = (i + <span class="number">1</span>) % <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">while</span> index != i:</span><br><span class="line">        <span class="built_in">print</span>(nums[index])</span><br><span class="line">        index = (index + <span class="number">1</span>) % <span class="built_in">len</span>(nums)</span><br></pre></td></tr></table></figure>
<p>加油站[134]那道题</p>
<h2 id="快速判断是否为素数">快速判断是否为素数</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_prime</span>(<span class="params">n</span>):</span><br><span class="line">		<span class="keyword">return</span> n &gt;= <span class="number">2</span> <span class="keyword">and</span> <span class="built_in">all</span>(n%i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">int</span>(n**<span class="number">0.5</span>) + <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<h2 id="for也可以这么搞">for也可以这么搞</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    <span class="keyword">if</span> i%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">        xxx</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        xxx</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    xxxx</span><br></pre></td></tr></table></figure>
<h2 id="排序和字典排序">排序和字典排序</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nums.sort()</span><br><span class="line">t = list(zip(numn1,nu8m2))</span><br><span class="line">t.sort(key=lambda x:x[0])</span><br></pre></td></tr></table></figure>
<p>字典排序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">cnt = <span class="built_in">list</span>(Counter(nums).items())</span><br><span class="line">cnt.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>或者使用defaultdict来排序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">d = defaultdict(<span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">    d[i] = d[i] + <span class="number">1</span></span><br><span class="line">d_list = <span class="built_in">list</span>(d.items())</span><br><span class="line">d_list.sort(key=<span class="keyword">lambda</span> x: -x[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(d_list)</span><br></pre></td></tr></table></figure>
<h2 id="快速计算除数和余数">快速计算除数和余数</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a,b=<span class="built_in">divmod</span>(<span class="number">10</span>,<span class="number">3</span>)</span><br><span class="line">a=<span class="number">3</span></span><br><span class="line">b=<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="快速复制">快速复制</h2>
<p>a = [1,2,3]<br>
b=a 这样的话a变了的话，b也会变<br>
b=a[:] 这样就不会了</p>
<p>b=a=0<br>
这样不会有问题的</p>
<h2 id="连续求和快速初始化">连续求和快速初始化</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">continueSum</span>(<span class="params">nums</span>):</span><br><span class="line">    target = <span class="number">9</span></span><br><span class="line">    c = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, target))</span><br><span class="line">    sums = [c[<span class="number">0</span>]]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(c)):</span><br><span class="line">        sums.append(c[i] + sums[-<span class="number">1</span>])</span><br><span class="line">    <span class="built_in">print</span>(sums)</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(sums)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, <span class="built_in">len</span>(sums)):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                val = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                val = sums[i - <span class="number">1</span>]</span><br><span class="line">            <span class="built_in">print</span>(i, j, sums[j] - val)</span><br><span class="line">continueSum([<span class="number">9</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">6</span>])</span><br></pre></td></tr></table></figure>
<p>如果要求i-j的和，则必须sums[j] - sum[i-1]</p>
<h2 id="数组双循环">数组双循环</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure>
<h2 id="快速前缀和初始化">快速前缀和初始化</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">13</span>]</span><br><span class="line">prefix = [<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">    prefix.append(prefix[-<span class="number">1</span>] + i)</span><br><span class="line"><span class="comment"># 求解 i-j的值</span></span><br><span class="line"><span class="built_in">print</span>(prefix[j+<span class="number">1</span>]-prefix[i])</span><br></pre></td></tr></table></figure>
<p>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">if</span> (prefix[j + <span class="number">1</span>] - prefix[i]) &gt;= lower <span class="keyword">and</span> (prefix[j + <span class="number">1</span>] - prefix[i]) &lt;= upper:</span><br><span class="line">            <span class="built_in">print</span>(i, j)</span><br><span class="line">            cnt += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>计算两个索引之间的差值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">predix = [<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">    predix.append(predix[-<span class="number">1</span>] + i)</span><br><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="built_in">len</span>(arr)):</span><br><span class="line">        <span class="built_in">print</span>(i, j)</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/count-of-range-sum/submissions/">https://leetcode-cn.com/problems/count-of-range-sum/submissions/</a></p>
<h2 id="快速累积和">快速累积和</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> accumulate</span><br><span class="line"></span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">res = <span class="built_in">list</span>(accumulate(nums))</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="动态规划初始化">动态规划初始化</h2>
<h3 id="初始化动态规划数组">初始化动态规划数组</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dp = [[<span class="number">0</span>]* <span class="number">5</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br></pre></td></tr></table></figure>
<p>注意，有的时候，行数和列数是不一样的，需要这样初始化</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">m = <span class="number">2</span></span><br><span class="line">n = <span class="number">3</span></span><br><span class="line">dp = [[<span class="number">0</span>] * m <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"><span class="built_in">print</span>(dp)</span><br></pre></td></tr></table></figure>
<p>输出为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>]]</span><br></pre></td></tr></table></figure>
<p>其中m为列数，n为行的数目</p>
<p>初始化3维的如下，这点在股票交易中常用到的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成一个3个2 x 2的矩阵</span></span><br><span class="line">dp = [[[<span class="number">0</span>] * <span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br></pre></td></tr></table></figure>
<h3 id="多种遍历方法">多种遍历方法</h3>
<p>右上矩阵遍历</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="number">5</span></span><br><span class="line"><span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - l):</span><br><span class="line">        j = l + i</span><br><span class="line">        <span class="built_in">print</span>(i, j)</span><br></pre></td></tr></table></figure>
<p>其它的遍历方方法的话，可以看连接<br>
<a href="https://blog.csdn.net/miyagiSimple/article/details/110561865">https://blog.csdn.net/miyagiSimple/article/details/110561865</a><br>
大部分的情况下，使用横向的遍历就可以了</p>
<h2 id="二分查找Bisect">二分查找Bisect</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用bisect模块，使用如下</span></span><br><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line">arr = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">15</span>]</span><br><span class="line">value = <span class="number">3</span></span><br><span class="line">idx_left=bisect.bisect_left(arr,value) <span class="comment"># 结果1</span></span><br><span class="line">idx_right=bisect.bisect_right(arr,value) <span class="comment"># 结果3</span></span><br><span class="line">bisect.insort(arr,<span class="number">13</span>)</span><br></pre></td></tr></table></figure>
<p>注意哈，可能会有搜索到的值的索引在最后一个，这就需要判断index是不是&gt;=len(Nums)如果是大于的话，那就要报错了</p>
<p>二分查找的边界条件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(bisect.bisect_left(nums,<span class="number">12</span>))</span><br><span class="line"><span class="comment"># 得到的值为5，但是没有5的索引的，因此会报错</span></span><br><span class="line">index = bisect.bisect_left(array2, i + diff // <span class="number">2</span>)</span><br><span class="line">index = <span class="built_in">min</span>(<span class="built_in">len</span>(array2)-<span class="number">1</span>, index)</span><br><span class="line"><span class="keyword">if</span> array2[index] == i + diff // <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">return</span> [i, i + diff // <span class="number">2</span>]</span><br><span class="line"><span class="comment"># 通过将值插入后，判断位置，如果是=len()的话，那直接为len()-1。</span></span><br></pre></td></tr></table></figure>
<p>二分查找中边界的设置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    index = bisect.bisect_left(b, i)</span><br><span class="line">    <span class="keyword">if</span> index==<span class="built_in">len</span>(b):</span><br><span class="line">        diff = <span class="built_in">abs</span>(i-b[index-<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">elif</span> index == <span class="number">0</span>:</span><br><span class="line">        diff = <span class="built_in">abs</span>(i - b[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">elif</span> index&gt;<span class="number">0</span>:</span><br><span class="line">        diff = <span class="built_in">min</span>(<span class="built_in">abs</span>(i-b[index-<span class="number">1</span>]), <span class="built_in">abs</span>(i-b[index]))</span><br><span class="line">    res = <span class="built_in">min</span>(diff, res)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h2 id="堆模块heapq">堆模块heapq</h2>
<p>堆的队列，称为优先队列，通常是一个小顶锥，每次维护的头部是最小值。因此可以用来解决topK最大值问题。注意想一下，为啥是一个小顶锥，可以用来解决最大值问题。</p>
<p>注意：heapq.pop是弹出第一个元素，也就是最小的那个</p>
<h3 id="最大topk">最大topk</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 最大topk问题</span></span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bigestK</span>(<span class="params">arr, k</span>):</span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        l = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(l) &lt; k:</span><br><span class="line">                heapq.heappush(l, i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> i &gt; l[<span class="number">0</span>]:<span class="comment"># 注意点</span></span><br><span class="line">                    heapq.heappop(l)</span><br><span class="line">                    heapq.heappush(l, i)</span><br><span class="line">    <span class="keyword">return</span> l</span><br><span class="line">a = bigestK([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>], <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<p>可以看到，heapq就是对一个list做操作而已，因此。最后动的还是列表。<br>
可以简化写成如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i in nums:</span><br><span class="line">    if len(res) &gt;= k:</span><br><span class="line">        if i &gt; res[0]:</span><br><span class="line">            heapq.heappop(res)</span><br><span class="line">    else:</span><br><span class="line">        heapq.heappush(res, i)</span><br></pre></td></tr></table></figure>
<h3 id="最小topk">最小topk</h3>
<p>题目见<a href="https://leetcode-cn.com/problems/smallest-k-lcci/">https://leetcode-cn.com/problems/smallest-k-lcci/</a><br>
对于最小的topk问题解法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 最小tooK问题</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">smallestK</span>(<span class="params">arr, k</span>):</span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        l = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(l) &lt; k:</span><br><span class="line">                heapq.heappush(l, -i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> -i &gt; l[<span class="number">0</span>]: <span class="comment"># 注意点</span></span><br><span class="line">                    heapq.heappop(l)</span><br><span class="line">                    heapq.heappush(l, -i)</span><br><span class="line">    <span class="keyword">return</span> [-i <span class="keyword">for</span> i <span class="keyword">in</span> l]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = smallestK([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>], <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<h3 id="滑动窗口最大值">滑动窗口最大值</h3>
<p>解决滑动窗口最大值，题目见 <a href="https://leetcode-cn.com/problems/sliding-window-maximum/">https://leetcode-cn.com/problems/sliding-window-maximum/</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">maxSlidingWindow2</span>(<span class="params">nums, k</span>):</span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ans = []</span><br><span class="line">        l = []</span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> i &lt; k: <span class="comment"># 别写错</span></span><br><span class="line">                heapq.heappush(l, (-j, i))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">while</span> l <span class="keyword">and</span> l[<span class="number">0</span>][<span class="number">1</span>] &lt;= i - k:<span class="comment"># 别写错</span></span><br><span class="line">                    heapq.heappop(l)</span><br><span class="line">                heapq.heappush(l, (-j, i))</span><br><span class="line">            <span class="keyword">if</span> i &gt;= k - <span class="number">1</span>:<span class="comment"># 别写错</span></span><br><span class="line">                ans.append(-l[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>这里注意为啥要取-的呢，因为我们只取一个数值，不会取前K个。<br>
简单写法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">maxSlidingWindow3</span>(<span class="params">nums, k</span>):</span><br><span class="line">    hp, ret = [], []</span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">        <span class="keyword">while</span> hp <span class="keyword">and</span> hp[<span class="number">0</span>][<span class="number">1</span>] &lt;= i - k:</span><br><span class="line">            heapq.heappop(hp)</span><br><span class="line">        heapq.heappush(hp, [-j, i])</span><br><span class="line">        <span class="keyword">if</span> i &gt;= k - <span class="number">1</span>:</span><br><span class="line">            ret.append(-hp[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<h2 id="单调栈">单调栈</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">heights = [2, 1, 5, 6, 2, 3]</span><br><span class="line">stack = []</span><br><span class="line">n = len(heights)</span><br><span class="line">right_min = [n] * n</span><br><span class="line">for i in range(n):</span><br><span class="line">    while stack and stack[-1][0] &gt; heights[i]:</span><br><span class="line">        val = stack.pop()</span><br><span class="line">        right_min[val[1]] = i</span><br><span class="line">    stack.append((heights[i], i))</span><br><span class="line"># 求出右边最大的也是可以的</span><br></pre></td></tr></table></figure>
<h2 id="队列queue">队列queue</h2>
<p>解决滑动窗口最大值，题目见 <a href="https://leetcode-cn.com/problems/sliding-window-maximum/">https://leetcode-cn.com/problems/sliding-window-maximum/</a><br>
解法如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">nums, k</span>):</span><br><span class="line">    q, ret = deque(), []</span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">        <span class="keyword">while</span> q <span class="keyword">and</span> nums[q[-<span class="number">1</span>]] &lt; j:</span><br><span class="line">            q.pop()</span><br><span class="line">        <span class="keyword">if</span> q <span class="keyword">and</span> q[<span class="number">0</span>] &lt;= i - k:</span><br><span class="line">            q.popleft()</span><br><span class="line">        q.append(i)</span><br><span class="line">        <span class="keyword">if</span> i &gt;= k - <span class="number">1</span>:</span><br><span class="line">            ret.append(nums[q[<span class="number">0</span>]])</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<p>队列在使用中需要注意，需要判断队列是否为空，如在56 合并区间这道题中，如果你需要用队列的话，需要变成这样。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> q <span class="keyword">or</span> value[<span class="number">0</span>]&gt;a[-<span class="number">1</span>][<span class="number">0</span>] <span class="keyword">and</span> value[<span class="number">0</span>]&lt;q[-<span class="number">1</span>][<span class="number">1</span>]:</span><br><span class="line">        q.append(value)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        results.append(<span class="built_in">list</span>(q)</span><br></pre></td></tr></table></figure>
<h2 id="collection常用函数">collection常用函数</h2>
<h3 id="defaultdict">defaultdict</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from collections import defaultdict</span><br><span class="line">d = defaultdict(int)</span><br><span class="line">for i in a:</span><br><span class="line">    d[i] = d[i] + 1</span><br></pre></td></tr></table></figure>
<h3 id="Counter">Counter</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">from</span>  collections <span class="keyword">import</span> Counter</span><br><span class="line">ct = Counter(a)</span><br><span class="line"><span class="built_in">print</span>(ct)</span><br></pre></td></tr></table></figure>
<p>如果一个数字不在其中，则输出结果为0，如ct[6]</p>
<h2 id="deque">deque</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">d = deque()</span><br><span class="line">d.append(<span class="number">1</span>)</span><br><span class="line">d.append(<span class="number">2</span>)</span><br><span class="line">d.popleft()</span><br><span class="line">d.pop()</span><br></pre></td></tr></table></figure>
<h2 id="回溯结构">回溯结构</h2>
<h3 id="分割字符串">分割字符串</h3>
<p>将&quot;abc&quot;分割为[a,b,c],[ab,c],[abc],[a,bc]…<br>
代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">seg_str</span>(<span class="params">s</span>):</span><br><span class="line">    res = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">back</span>(<span class="params">state, s</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span>:</span><br><span class="line">            res.append(state[:])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">                state.append(s[:i + <span class="number">1</span>])</span><br><span class="line">                back(state, s[i + <span class="number">1</span>:])</span><br><span class="line">                state.pop()</span><br><span class="line"></span><br><span class="line">    back([], s)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>
<h3 id="随机组合元素">随机组合元素</h3>
<p>将[1,2,3,4]变为[1],[1,2,3],[1,2,4],[3,4],[3],[3,4,5],[3,5],…<br>
代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">com_seq</span>(<span class="params">nums</span>):</span><br><span class="line">    res = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">back</span>(<span class="params">state, s</span>):</span><br><span class="line">        res.append(state[:])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            state.append(s[i])</span><br><span class="line">            back(state, s[i + <span class="number">1</span>:])</span><br><span class="line">            state.pop()</span><br><span class="line"></span><br><span class="line">    back([], nums)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>
<p>这里注意在back中没使用到if条件，因为不需要使用到if条件，如果来了一句</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>这点在单词拆分 II中用到了，可以看下。</p>
<h2 id="快速访问二维的list">快速访问二维的list</h2>
<p>下面介绍下访问二维的list的方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">matrix = [[<span class="string">&quot;1&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>], [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>], [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>], [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;0&quot;</span>]]</span><br><span class="line">m = <span class="built_in">len</span>(matrix)</span><br><span class="line">n = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">max_k = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">max</span>(m - i, n - i)):</span><br><span class="line">            c = [i[j:j + k] <span class="keyword">for</span> i <span class="keyword">in</span> matrix[i:i + k]]</span><br><span class="line">            <span class="built_in">print</span>(c)</span><br></pre></td></tr></table></figure>
<h2 id="初始化结果表">初始化结果表</h2>
<p>我们在很多情况下，都会要保持结果，如果我们定义了res=[]和res=[0]*n<br>
这两张方式，哪种会更好呢，答案是res=[0]*n。具体可以看特殊数据结构这里的每日温度这道题。如果我们用[]的话，每次都要往里面添加数据，可能有的时候回漏掉数据，但是第二种方式就不会。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res1 = []</span><br><span class="line">res1 = [<span class="number">0</span>] * <span class="number">5</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="keyword">if</span> i%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">        res1.append(i)</span><br><span class="line">        res1[i] = <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>上述得到的res1和res2结果是不一样的。</p>
<h1>常见必备基础算法</h1>
<h2 id="快速幂">快速幂</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">myPow</span>(<span class="params">self, x: <span class="built_in">float</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0.0</span>: <span class="keyword">return</span> <span class="number">0.0</span></span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>: x, n = <span class="number">1</span> / x, -n</span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            <span class="keyword">if</span> n &amp; <span class="number">1</span>: res *= x</span><br><span class="line">            x *= x</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h2 id="字典序">字典序</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lexicalOrder</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        ans = []</span><br><span class="line">        num = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(ans) &lt; n:</span><br><span class="line">            <span class="keyword">while</span> num &lt;= n:  <span class="comment"># 不断进入下一层</span></span><br><span class="line">                ans.append(num)</span><br><span class="line">                num *= <span class="number">10</span></span><br><span class="line">            <span class="keyword">while</span> num % <span class="number">10</span> == <span class="number">9</span> <span class="keyword">or</span> num &gt; n:  <span class="comment"># 不断返回上一层</span></span><br><span class="line">                num //= <span class="number">10</span></span><br><span class="line">            num += <span class="number">1</span>  <span class="comment"># 遍历该层下一个数</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h2 id="bisect快速赋值">bisect快速赋值</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a[<span class="number">0</span>:<span class="number">0</span>] = [<span class="number">0</span>] 得到结果[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a[<span class="number">0</span>:<span class="number">1</span>] = [] 得到[<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>这样的效率会高很多</p>
<h2 id="快速定位数据的位数">快速定位数据的位数</h2>
<p>我们自做1011121314这种题目是，问道你n个数字对应的数值是多少时，可以通过如下简单的方式进行访问。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">digit = <span class="number">2</span></span><br><span class="line">n = <span class="number">5</span></span><br><span class="line">nums = <span class="number">10</span> + (n-<span class="number">1</span>)//digit</span><br><span class="line">v = <span class="built_in">str</span>(nums)[(n-<span class="number">1</span>)%digit]</span><br></pre></td></tr></table></figure>
<p>这里你也可以通过如下的方式来访问，不过很慢的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = <span class="number">10</span> + n//digit - <span class="number">1</span></span><br><span class="line">index = last_nums % digit</span><br><span class="line"><span class="keyword">if</span> index==<span class="number">0</span>:</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">int</span>(<span class="built_in">str</span>(nums)[-<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">int</span>(<span class="built_in">str</span>(nums+<span class="number">1</span>)[index-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>这样也可以不过很蛮烦的。</p>
<h2 id="获取最长递增子序列">获取最长递增子序列</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stk = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> posAr:</span><br><span class="line">    <span class="keyword">if</span> stk <span class="keyword">and</span> x &lt;= stk[-<span class="number">1</span>]:</span><br><span class="line">        idx = bisect_left(stk, x)</span><br><span class="line">        stk[idx] = x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        stk.append(x)</span><br></pre></td></tr></table></figure>
<p>更简答的方法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stk = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> posAr:</span><br><span class="line">    pos = bisect.bisect_left(stk, x)</span><br><span class="line">    stk[pos: pos + <span class="number">1</span>] = [x]</span><br></pre></td></tr></table></figure>
<p>注意这里不是stk[pos:pos]</p>
<h2 id="列表快速插入和替换">列表快速插入和替换</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">a[<span class="number">1</span>:<span class="number">1</span>] = [<span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">a[<span class="number">3</span>:<span class="number">4</span>] = []</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">a[<span class="number">1</span>:<span class="number">2</span>] = [<span class="number">8</span>]</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>
<h2 id="埃及筛">埃及筛</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sign = [<span class="number">1</span>] * <span class="number">100</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="number">100</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>*i, <span class="number">101</span>, i):</span><br><span class="line">        sign[j] = <span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>题目汇总</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>特殊数据结构</title>
    <url>/2024/03/19/leetcode/small_data_stru/</url>
    <content><![CDATA[<h1>特殊数据结构</h1>
<h2 id="单调栈">单调栈</h2>
<h3 id="模板">模板</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stack = []</span><br><span class="line">right = [<span class="built_in">len</span>(nums)] * <span class="built_in">len</span>(nums)</span><br><span class="line">left = [-<span class="number">1</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">    <span class="keyword">while</span> stack <span class="keyword">and</span> nums[i] &gt; nums[stack[-<span class="number">1</span>]]:</span><br><span class="line">        right[stack.pop()] = i</span><br><span class="line">    left[i] = stack[-<span class="number">1</span>] <span class="keyword">if</span> stack <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">    stack.append(i)  <span class="comment"># 保存的是下一个最大的数对应的索引</span></span><br><span class="line"><span class="built_in">print</span>(right) <span class="comment"># 右边比当前值大的第一个值的index</span></span><br><span class="line"><span class="built_in">print</span>(left) <span class="comment"># 左边比当前值大的第一个值的index</span></span><br></pre></td></tr></table></figure>
<h3 id="每日温度-739">每日温度[739]</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dailyTemperatures</span>(<span class="params">self, temperatures: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        stack = []</span><br><span class="line">        res = [<span class="number">0</span>]*<span class="built_in">len</span>(temperatures)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(temperatures)):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> temperatures[i]&gt;temperatures[stack[-<span class="number">1</span>]]:</span><br><span class="line">                c = stack.pop()</span><br><span class="line">                res[c] = i - c</span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="下一个更大元素-I-496">下一个更大元素 I[496]</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextGreaterElement</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        stack = []</span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums2)):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> nums2[i]&gt;nums2[stack[-<span class="number">1</span>]]:</span><br><span class="line">                d[nums2[stack.pop()]] = nums2[i]</span><br><span class="line">            stack.append(i) <span class="comment">#保存的是下一个最大的数对应的索引</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums1:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> d:</span><br><span class="line">                res.append(d[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="接雨水-42">接雨水[42]</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trap</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">get_max_weight</span>(<span class="params">height</span>):</span><br><span class="line">            left = [<span class="number">0</span>] * <span class="built_in">len</span>(height) <span class="comment"># 注意：这里初始化为0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(height)):</span><br><span class="line">                left[i] = <span class="built_in">max</span>(left[i-<span class="number">1</span>], height[i-<span class="number">1</span>]) <span class="comment"># 注意：这里从height[i-1]对比</span></span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        left_max = get_max_weight(height)</span><br><span class="line">        right_max = get_max_weight(height[::-<span class="number">1</span>])[::-<span class="number">1</span>]</span><br><span class="line">        <span class="built_in">print</span>(height)</span><br><span class="line">        <span class="built_in">print</span>(left_max)</span><br><span class="line">        <span class="built_in">print</span>(right_max)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(height)):</span><br><span class="line">            res = res + <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">min</span>(left_max[i], right_max[i])-height[i])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>感觉不用单调栈来做，直接正反把arr遍历后，得到左右最大值，然后最大值的最小，减去当前的高度，就是可以接雨水的量。</p>
<h3 id="柱状图中最大的矩形-84">柱状图中最大的矩形[84]</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">largestRectangleArea</span>(<span class="params">self, heights: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        stack = []</span><br><span class="line">        right = [<span class="built_in">len</span>(heights)] * <span class="built_in">len</span>(heights)</span><br><span class="line">        left = [-<span class="number">1</span>] * <span class="built_in">len</span>(heights)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(heights)):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> heights[i] &lt; heights[stack[-<span class="number">1</span>]]:</span><br><span class="line">                right[stack.pop()] = i</span><br><span class="line">            left[i] = stack[-<span class="number">1</span>] <span class="keyword">if</span> stack <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">            stack.append(i)  <span class="comment"># 保存的是下一个最大的数对应的索引</span></span><br><span class="line">        max_area = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(heights)):</span><br><span class="line">            max_area = <span class="built_in">max</span>(max_area, heights[i] * (right[i] - left[i] - <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> max_area</span><br></pre></td></tr></table></figure>
<h2 id="盛水最多的容器-11">盛水最多的容器 [11]</h2>
<p>位于 <a href="https://leetcode.cn/problems/container-with-most-water/description/?envType=study-plan-v2&amp;envId=top-interview-150">https://leetcode.cn/problems/container-with-most-water/description/?envType=study-plan-v2&amp;envId=top-interview-150</a><br>
思路:采用总结里面的第2点，涉及到while i&lt;j</p>
<p>题号:11</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxArea</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(height) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        area = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            temp = <span class="built_in">min</span>(height[left], height[right]) * (right - left)</span><br><span class="line">            <span class="keyword">if</span> height[left] &lt; height[right]:</span><br><span class="line">                left = left + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = right - <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> temp &gt; area:</span><br><span class="line">                area = temp</span><br><span class="line">        <span class="keyword">return</span> area</span><br></pre></td></tr></table></figure>
<h2 id="单调队列">单调队列</h2>
<h3 id="滑动数组最大值-239">滑动数组最大值[239]</h3>
<p>题目见 <a href="https://leetcode-cn.com/problems/sliding-window-maximum/">https://leetcode-cn.com/problems/sliding-window-maximum/</a> 题解有很多，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 单调队列</span></span><br><span class="line">q, ret = deque(), []</span><br><span class="line"><span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">    <span class="keyword">while</span> q <span class="keyword">and</span> nums[q[-<span class="number">1</span>]] &lt; j:</span><br><span class="line">        q.pop()</span><br><span class="line">    <span class="keyword">if</span> q <span class="keyword">and</span> q[<span class="number">0</span>] &lt;= i - k:</span><br><span class="line">        q.popleft()</span><br><span class="line">    q.append(i)</span><br><span class="line">    <span class="keyword">if</span> i &gt;= k - <span class="number">1</span>:</span><br><span class="line">        ret.append(nums[q[<span class="number">0</span>]])</span><br><span class="line"><span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<p>最小堆解法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        q = []</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(q) &lt;= k - <span class="number">1</span>:</span><br><span class="line">                heapq.heappush(q, (-nums[i], i))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(-q[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">                <span class="keyword">while</span> q <span class="keyword">and</span> i - q[<span class="number">0</span>][<span class="number">1</span>] &gt;= k:</span><br><span class="line">                    heapq.heappop(q)</span><br><span class="line">                heapq.heappush(q, (-nums[i], i))</span><br><span class="line">        res.append(-q[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>题解 <a href="https://leetcode-cn.com/problems/sliding-window-maximum/solution/239hua-dong-chuang-kou-zui-da-zhi-bao-li-z4q2/">https://leetcode-cn.com/problems/sliding-window-maximum/solution/239hua-dong-chuang-kou-zui-da-zhi-bao-li-z4q2/</a></p>
<h2 id="最小堆">最小堆</h2>
<h3 id="模板-2">模板</h3>
<p>建议查看这里 <a href="https://blog.csdn.net/aabbccas/article/details/127742912">https://blog.csdn.net/aabbccas/article/details/127742912</a> 了解基础的使用，主要包括的函数和功能点</p>
<h3 id="前-K-个高频元素-347">前 K 个高频元素[347]</h3>
<p>解法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">topKFrequent</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        d = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            d[i] = d[i] + <span class="number">1</span></span><br><span class="line">        cnt_key_value = []</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> d.items():</span><br><span class="line">            cnt_key_value.append([value, key])</span><br><span class="line">        temp = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> cnt_key_value:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(temp) &lt; k:</span><br><span class="line">                heapq.heappush(temp, i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> i[<span class="number">0</span>] &gt; temp[<span class="number">0</span>][<span class="number">0</span>]:</span><br><span class="line">                    heapq.heappop(temp)</span><br><span class="line">                    heapq.heappush(temp, i)</span><br><span class="line">        <span class="keyword">return</span> [i[<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> temp]</span><br></pre></td></tr></table></figure>
<p>最大的K个就用最小堆，如果是最小的k个就要取负了</p>
<h3 id="数组中的第K个最大元素-215">数组中的第K个最大元素[215]</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findKthLargest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        temp = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(temp)&lt;k:</span><br><span class="line">                heapq.heappush(temp, nums[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[i]&gt;temp[<span class="number">0</span>]:</span><br><span class="line">                    heapq.heappop(temp)</span><br><span class="line">                    heapq.heappush(temp, nums[i])</span><br><span class="line">        <span class="keyword">return</span> temp[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>最大的K个就用最小堆，如果是最小的k个就要取负了</p>
<h3 id="分割数组为连续子序列-659">分割数组为连续子序列[659]</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPossible</span>(<span class="params">self, nums</span>):</span><br><span class="line">        chains = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> chains[i-<span class="number">1</span>]:</span><br><span class="line">                heapq.heappush(chains[i],<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                min_len = heapq.heappop(chains[i-<span class="number">1</span>])</span><br><span class="line">                heapq.heappush(chains[i],min_len+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> _,chain <span class="keyword">in</span> chains.items():</span><br><span class="line">            <span class="keyword">if</span> chain <span class="keyword">and</span> chain[<span class="number">0</span>] &lt; <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>字典的键为序列结尾数值，值为结尾为该数值的所有序列长度（以堆存储）。<br>
更新方式：每遍历一个数，将该数加入能加入的长度最短的序列中，不能加入序列则新建一个序列；然后更新字典。比如<img src="https://note.youdao.com/yws/res/10173/WEBRESOURCE5e269d3fc26f5a05749ce10e505c7b48" alt="image.png"><br>
当i=7时候，前面只有6能保持一个连续的序列，因此为2，这个2也是从6中来的，6这个键对应的值是[1,3]，然后pop之后给7加上去的。</p>
<h3 id="最接近原点的-K-个点-973">最接近原点的 K 个点[973]</h3>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 最小堆</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">kClosest</span>(<span class="params">self, points: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        points_distance = []</span><br><span class="line">        <span class="keyword">for</span> idc, i <span class="keyword">in</span> <span class="built_in">enumerate</span>(points):</span><br><span class="line">            dis = i[<span class="number">0</span>]*i[<span class="number">0</span>] + i[<span class="number">1</span>] * i[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(points_distance)&lt;k:</span><br><span class="line">                heapq.heappush(points_distance, (-dis, idc))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> dis &gt; points_distance[<span class="number">0</span>][<span class="number">0</span>]:</span><br><span class="line">                    heapq.heappop(points_distance)</span><br><span class="line">                    heapq.heappush(points_distance, (-dis, idc))</span><br><span class="line">        <span class="keyword">return</span> [points[i[<span class="number">1</span>]] <span class="keyword">for</span> i <span class="keyword">in</span> points_distance]</span><br><span class="line"><span class="comment"># NB一句话</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">kClosest</span>(<span class="params">self, points: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        points.sort(key=<span class="keyword">lambda</span> x: (x[<span class="number">0</span>] ** <span class="number">2</span> + x[<span class="number">1</span>] ** <span class="number">2</span>))</span><br><span class="line">        <span class="keyword">return</span> points[:k]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>题目汇总</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心算法</title>
    <url>/2024/03/19/leetcode/tanxing_alg/</url>
    <content><![CDATA[<h1>贪心算法</h1>
<h2 id="跳跃游戏-55">跳跃游戏[55]</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canJump</span>(<span class="params">self, nums</span>):</span><br><span class="line">        max_can_reach = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)): <span class="comment">#注意</span></span><br><span class="line">            <span class="keyword">if</span> i &lt;= max_can_reach:</span><br><span class="line">                max_can_reach = <span class="built_in">max</span>(nums[i] + i, max_can_reach)</span><br><span class="line">                <span class="keyword">if</span> max_can_reach &gt;= <span class="built_in">len</span>(nums) - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h2 id="跳跃游戏II-45">跳跃游戏II[45]</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">jump</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        step = <span class="number">0</span></span><br><span class="line">        end = <span class="number">0</span></span><br><span class="line">        max_can_reach = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>):</span><br><span class="line">            max_can_reach = <span class="built_in">max</span>(nums[i]+i, max_can_reach)</span><br><span class="line">            <span class="keyword">if</span> i == end:</span><br><span class="line">                end = max_can_reach</span><br><span class="line">                step+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> step</span><br><span class="line"><span class="comment"># 和上面一致</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">jump</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        step = <span class="number">0</span></span><br><span class="line">        end = <span class="number">0</span></span><br><span class="line">        max_can_reach = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>):<span class="comment">#注意</span></span><br><span class="line">            <span class="keyword">if</span> i&lt;= max_can_reach:</span><br><span class="line">                max_can_reach = <span class="built_in">max</span>(nums[i]+i, max_can_reach)</span><br><span class="line">                <span class="keyword">if</span> i == end:</span><br><span class="line">                    end = max_can_reach</span><br><span class="line">                    step+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> step</span><br></pre></td></tr></table></figure>
<h2 id="摆动序列-376">摆动序列[376]</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wiggleMaxLength</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(nums)==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            direction = <span class="literal">None</span></span><br><span class="line">            res = <span class="number">0</span> </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">elif</span> nums[i] &gt; nums[i-<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">if</span> direction == <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    direction = <span class="number">0</span></span><br><span class="line">                    res += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> nums[i] &lt; nums[i-<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">if</span> direction == <span class="number">1</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    direction = <span class="number">1</span></span><br><span class="line">                    res += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> res + <span class="number">1</span>    </span><br></pre></td></tr></table></figure>
<h2 id="分发饼干-455">分发饼干[455]</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findContentChildren</span>(<span class="params">self, g: <span class="type">List</span>[<span class="built_in">int</span>], s: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 将胃口和饼干排序</span></span><br><span class="line">        g.sort()</span><br><span class="line">        s.sort()</span><br><span class="line">        <span class="comment"># 孩子的数量</span></span><br><span class="line">        n = <span class="built_in">len</span>(g)</span><br><span class="line">        <span class="comment"># 饼干的数量</span></span><br><span class="line">        m = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="comment"># 记录结果</span></span><br><span class="line">        res = <span class="number">0</span> </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="comment"># 从胃口小的开始喂</span></span><br><span class="line">            <span class="keyword">if</span> res &lt; n <span class="keyword">and</span> g[res] &lt;= s[i]:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h2 id="最大子序和-53">最大子序和[53]</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSubArray</span>(<span class="params">self, nums</span>):</span><br><span class="line">        result = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)  <span class="comment"># 初始化结果为负无穷大</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            count += nums[i]</span><br><span class="line">            <span class="keyword">if</span> count &gt; result:  <span class="comment"># 取区间累计的最大值（相当于不断确定最大子序终止位置）</span></span><br><span class="line">                result = count</span><br><span class="line">            <span class="keyword">if</span> count &lt;= <span class="number">0</span>:  <span class="comment"># 相当于重置最大子序起始位置，因为遇到负数一定是拉低总和</span></span><br><span class="line">                count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h2 id="K-次取反后最大化的数组和-1005">K 次取反后最大化的数组和[1005]</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 题解1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">largestSumAfterKNegations</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        nums.sort(key=<span class="keyword">lambda</span> x: <span class="built_in">abs</span>(x))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> k &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] &lt; <span class="number">0</span>:</span><br><span class="line">                nums[i] = -nums[i]</span><br><span class="line">                k = k - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> k % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">sum</span>(nums) - <span class="number">2</span>*nums[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 错误解法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">largestSumAfterKNegations</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i]==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">sum</span>(nums)</span><br><span class="line">            <span class="keyword">elif</span> k&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i]&lt;<span class="number">0</span>:</span><br><span class="line">                nums[i] = -nums[i]</span><br><span class="line">                k = k-<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> k&gt;=<span class="number">0</span> <span class="keyword">and</span> nums[i]&gt;<span class="number">0</span>:</span><br><span class="line">                nums[i] = nums[i] <span class="keyword">if</span> k%<span class="number">2</span>==<span class="number">0</span> <span class="keyword">else</span> -nums[i]</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">sum</span>(nums)</span><br></pre></td></tr></table></figure>
<p>必须对nums按照abs来排序，不然出错<br>
还要一种基于heapq的方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">largestSumAfterKNegations</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        heapq.heapify(nums)</span><br><span class="line">        <span class="keyword">while</span> k&gt;<span class="number">0</span>:</span><br><span class="line">            heapq.heappush(nums, -heapq.heappop(nums))</span><br><span class="line">            k-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(nums)</span><br></pre></td></tr></table></figure>
<h2 id="加油站-134">加油站[134]</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 暴力</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canCompleteCircuit</span>(<span class="params">self, gas: <span class="type">List</span>[<span class="built_in">int</span>], cost: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cost)):</span><br><span class="line">            index = (i + <span class="number">1</span>)%<span class="built_in">len</span>(cost)</span><br><span class="line">            rest = gas[i] - cost[i]</span><br><span class="line">            <span class="keyword">while</span> rest&gt;=<span class="number">0</span> <span class="keyword">and</span> index!=i:</span><br><span class="line">                rest += gas[index] - cost[index]</span><br><span class="line">                index = (index+<span class="number">1</span>)%<span class="built_in">len</span>(cost)</span><br><span class="line">            <span class="keyword">if</span> rest&gt;=<span class="number">0</span> <span class="keyword">and</span> index==i:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"><span class="comment"># 贪心</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canCompleteCircuit</span>(<span class="params">self, gas: <span class="type">List</span>[<span class="built_in">int</span>], cost: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        curSum = <span class="number">0</span></span><br><span class="line">        totalSum = <span class="number">0</span></span><br><span class="line">        idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cost)):</span><br><span class="line">            curSum += gas[i] - cost[i]</span><br><span class="line">            totalSum += gas[i] - cost[i]</span><br><span class="line">            <span class="keyword">if</span> curSum&lt;<span class="number">0</span>:</span><br><span class="line">                idx = i + <span class="number">1</span></span><br><span class="line">                curSum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> totalSum &lt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> idx</span><br></pre></td></tr></table></figure>
<p>i从0开始累加rest[i]，和记为curSum，一旦curSum小于零，说明[0, i]区间都不能作为起始位置，因为这个区间选择任何一个位置作为起点，到i这里都会断油，那么起始位置从i+1算起，再从0计算curSum。</p>
<h2 id="分发糖果-135">分发糖果[135]</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 正常解法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">candy</span>(<span class="params">self, ratings: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left = [<span class="number">1</span>] * <span class="built_in">len</span>(ratings)</span><br><span class="line">        right = [<span class="number">1</span>] * <span class="built_in">len</span>(ratings)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(ratings)):</span><br><span class="line">            <span class="keyword">if</span> ratings[i] &gt; ratings[i - <span class="number">1</span>]:</span><br><span class="line">                left[i] = left[i - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ratings) - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> ratings[i] &gt; ratings[i + <span class="number">1</span>]: <span class="comment">#注意</span></span><br><span class="line">                right[i] = right[i+<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">        s = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(left)):</span><br><span class="line">            s = s + <span class="built_in">max</span>(left[i], right[i])</span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>
<h2 id="柠檬水找零-860">柠檬水找零[860]</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lemonadeChange</span>(<span class="params">self, bills: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        five = <span class="number">0</span></span><br><span class="line">        ten = <span class="number">0</span></span><br><span class="line">        twenty = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> bills:</span><br><span class="line">            <span class="keyword">if</span> i==<span class="number">5</span>:</span><br><span class="line">                five += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> i==<span class="number">10</span>:</span><br><span class="line">                <span class="keyword">if</span> five&gt;<span class="number">0</span>:</span><br><span class="line">                    five -=<span class="number">1</span></span><br><span class="line">                    ten += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> i==<span class="number">20</span>:</span><br><span class="line">                <span class="keyword">if</span> ten&gt;<span class="number">0</span> <span class="keyword">and</span> five&gt;<span class="number">0</span>:</span><br><span class="line">                    ten -= <span class="number">1</span></span><br><span class="line">                    five -=<span class="number">1</span></span><br><span class="line">                    twenty += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> five&gt;=<span class="number">3</span>:</span><br><span class="line">                    five -= <span class="number">3</span></span><br><span class="line">                    twenty += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h2 id="根据身高重建队列-406">根据身高重建队列[406]</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reconstructQueue</span>(<span class="params">self, people: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        people.sort(key=<span class="keyword">lambda</span> x:(-x[<span class="number">0</span>],x[<span class="number">1</span>]))</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> people:</span><br><span class="line">            res.insert(i[<span class="number">1</span>], i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>这里解释的详细 <a href="https://leetcode.cn/problems/queue-reconstruction-by-height/discussion/comments/1809851">https://leetcode.cn/problems/queue-reconstruction-by-height/discussion/comments/1809851</a></p>
<h2 id="用最少数量的箭引爆气球">用最少数量的箭引爆气球</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMinArrowShots</span>(<span class="params">self, points: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        result = <span class="number">1</span></span><br><span class="line">        points.sort(key =  <span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(points)):</span><br><span class="line">            <span class="keyword">if</span> points[i][<span class="number">0</span>] &gt; points[i-<span class="number">1</span>][<span class="number">1</span>]:</span><br><span class="line">                result = result + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                points[i][<span class="number">1</span>] = <span class="built_in">min</span>(points[i][<span class="number">1</span>], points[i-<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h2 id="无重叠区间-435">无重叠区间[435]</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eraseOverlapIntervals</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> intervals:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        intervals.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])  <span class="comment"># 按照左边界升序排序</span></span><br><span class="line">        </span><br><span class="line">        result = <span class="number">1</span>  <span class="comment"># 不重叠区间数量，初始化为1，因为至少有一个不重叠的区间</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(intervals)):</span><br><span class="line">            <span class="keyword">if</span> intervals[i][<span class="number">0</span>] &gt;= intervals[i - <span class="number">1</span>][<span class="number">1</span>]:  <span class="comment"># 没有重叠</span></span><br><span class="line">                result += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># 重叠情况</span></span><br><span class="line">                intervals[i][<span class="number">1</span>] = <span class="built_in">min</span>(intervals[i - <span class="number">1</span>][<span class="number">1</span>], intervals[i][<span class="number">1</span>])  <span class="comment"># 更新重叠区间的右边界</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(intervals) - result</span><br></pre></td></tr></table></figure>
<h2 id="划分字母区间-763">划分字母区间[763]</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">partitionLabels</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">        d = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        <span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            d[value] = index</span><br><span class="line">        end = <span class="number">0</span></span><br><span class="line">        results = []</span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            end = <span class="built_in">max</span>(end, d[value])</span><br><span class="line">            <span class="keyword">if</span> index == end:</span><br><span class="line">                results.append(index-start+<span class="number">1</span>)</span><br><span class="line">                start = index+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure>
<h2 id="合并区间-56">合并区间[56]</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        intervals.sort()</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> intervals:</span><br><span class="line">            <span class="keyword">if</span> stack <span class="keyword">and</span> i[<span class="number">0</span>] &lt;= stack[-<span class="number">1</span>][<span class="number">1</span>]:</span><br><span class="line">                v = stack.pop()</span><br><span class="line">                stack.append([<span class="built_in">min</span>(v[<span class="number">0</span>],i[<span class="number">0</span>]), <span class="built_in">max</span>(v[<span class="number">1</span>],i[<span class="number">1</span>])])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> stack</span><br></pre></td></tr></table></figure>
<h2 id="单调递增的数字-738">单调递增的数字[738]</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">monotoneIncreasingDigits</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        s = [<span class="built_in">int</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">str</span>(n)]</span><br><span class="line">        max_idx = <span class="number">0</span> </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] &gt; s[i-<span class="number">1</span>]:</span><br><span class="line">                max_idx = i</span><br><span class="line">            <span class="keyword">elif</span> s[i] == s[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> s[i] &lt; s[i-<span class="number">1</span>]:</span><br><span class="line">                s[max_idx] = s[max_idx] - <span class="number">1</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(max_idx+<span class="number">1</span>, <span class="built_in">len</span>(s)):</span><br><span class="line">                    s[j] = <span class="number">9</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(<span class="string">&quot;&quot;</span>.join([<span class="built_in">str</span>(k) <span class="keyword">for</span> k <span class="keyword">in</span> s]))</span><br></pre></td></tr></table></figure>
<p>来自 <a href="https://leetcode.cn/problems/monotone-increasing-digits/solutions/521966/jian-dan-tan-xin-shou-ba-shou-jiao-xue-k-a0mp/">https://leetcode.cn/problems/monotone-increasing-digits/solutions/521966/jian-dan-tan-xin-shou-ba-shou-jiao-xue-k-a0mp/</a><br>
按照自己的写法来的</p>
<h2 id="分割数组为连续子序列-659">分割数组为连续子序列[659]</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPossible</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        counter = Counter(nums)</span><br><span class="line">        tail = Counter()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> counter[i] <span class="keyword">and</span> tail[i - <span class="number">1</span>]:  <span class="comment"># 可以衔接</span></span><br><span class="line">                counter[i] -= <span class="number">1</span></span><br><span class="line">                tail[i - <span class="number">1</span>] -= <span class="number">1</span></span><br><span class="line">                tail[i] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span> <span class="comment">#注意这里</span></span><br><span class="line">            <span class="keyword">if</span> counter[i] <span class="keyword">and</span> counter[i + <span class="number">1</span>] <span class="keyword">and</span> counter[i + <span class="number">2</span>]:  <span class="comment"># 可以生成新序列</span></span><br><span class="line">                tail[i + <span class="number">2</span>] += <span class="number">1</span></span><br><span class="line">                counter[i] -= <span class="number">1</span></span><br><span class="line">                counter[i + <span class="number">1</span>] -= <span class="number">1</span></span><br><span class="line">                counter[i + <span class="number">2</span>] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span> <span class="comment">#注意这里</span></span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> counter.items():</span><br><span class="line">            <span class="keyword">if</span> v &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>来自 <a href="https://leetcode.cn/problems/split-array-into-consecutive-subsequences/description/">https://leetcode.cn/problems/split-array-into-consecutive-subsequences/description/</a> 还有一个方法说的很好 <a href="https://leetcode.cn/problems/split-array-into-consecutive-subsequences/solutions/376129/zui-jian-dan-de-pythonban-ben-by-semirondo/">https://leetcode.cn/problems/split-array-into-consecutive-subsequences/solutions/376129/zui-jian-dan-de-pythonban-ben-by-semirondo/</a> 这个方法的思路很清晰，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPossible</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> res:</span><br><span class="line">                <span class="keyword">if</span> n == v[-<span class="number">1</span>] + <span class="number">1</span>:</span><br><span class="line">                    v.append(n)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.insert(<span class="number">0</span>,[n])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">all</span>([<span class="built_in">len</span>(v)&gt;=<span class="number">3</span> <span class="keyword">for</span> v <span class="keyword">in</span> res])</span><br></pre></td></tr></table></figure>
<p>例如 2， 3， 4， 4， 5， 5， 6<br>
顺序如下<br>
[[2]]<br>
[[2, 3]]<br>
[[2, 3, 4]]<br>
4不能后接，前插一行<br>
[[4], [2, 3, 4]]<br>
[[4, 5], [2, 3, 4]]<br>
[[4, 5], [2, 3, 4, 5]]<br>
[[4, 5, 6], [2, 3, 4, 5]]<br>
最后比较是否所有序列长度大于等于3就可以了。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>题目汇总</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>集成学习</title>
    <url>/2024/03/19/machine_learning/ens_learning/</url>
    <content><![CDATA[<h1>集成学习方法</h1>
<h2 id="bagging">bagging</h2>
<h3 id="bagging和boosting区别">bagging和boosting区别</h3>
<p>Bagging：即自助法，无放回的采样，学习到多个基模型，然后进行融合。<br>
Boosting是一族可以将弱分类器提升为强分类器的算法，首先基于初始数据集训练基模型，然后再根据基学习期的表现对样本分布进行调整，使得错误的样本得到较大的关注，基于调整后的数据训练模型，训练得到多个模型，然后将模型的结果加权即可。</p>
<p>区别如下：<br>
Bagging和Boosting的区别：<br>
1）样本选择上<br>
Bagging：训练集是在原始集中有放回选取的，从原始集中选出的各轮训练集之间是独立的。<br>
Boosting：每一轮的训练集不变，只是训练集中每个样例在分类器中的权重发生变化。而权值是根据上一轮的分类结果进行调整。<br>
2）样例权重<br>
Bagging：使用均匀取样，每个样例的权重相等Boosting：根据错误率不断调整样例的权值，错误率越大则权重越大。<br>
3）预测函数<br>
Bagging：所有预测函数的权重相等。Boosting：每个弱分类器都有相应的权重，对于分类误差小的分类器会有更大的权重。<br>
4）并行计算<br>
Bagging：各个预测函数可以并行生成Boosting：各个预测函数只能顺序生成，因为后一个模型参数需要前一轮模型的结果。</p>
<p>详细见：<br>
<a href="https://zhuanlan.zhihu.com/p/81340270">https://zhuanlan.zhihu.com/p/81340270</a></p>
<h3 id="为啥adboost不容易过拟合？">为啥adboost不容易过拟合？</h3>
<p>在解决这个问题之前，我们需要先了解一下隐马科夫模型Adboost的定义是什么？Adaboost算法是一种提升方法，将多个弱分类器，组合成强分类器。AdaBoost，是英文”Adaptive Boosting“（自适应增强）的缩写，由Yoav Freund和Robert Schapire在1995年提出。它的自适应在于：前一个弱分类器分错的样本的权值（样本对应的权值）会得到加强，权值更新后的样本再次被用来训练下一个新的弱分类器。在每轮训练中，用总体（样本总体）训练新的弱分类器，产生新的样本权值、该弱分类器的话语权，一直迭代直到达到预定的错误率或达到指定的最大迭代次数。</p>
<p>对于过拟合问题，如今找到的能解释只有Margin理论能解释的还不错，这个理论是从泛化错误 &lt; 训练Margin项 + 学习算法容量相关项到泛化错误 &lt; 训练Margin项最小值 + 学习算法容量相关项进行发展，国内的一些学者 周志华 王立威 等也做了相关的研究。Margin理论讨论的主要是学习算法在训练样本上的信心.通过其他一些在variance-bias 分解实验中也观察到，AdaBoost不仅是减少了bias，同时也减少了variance，variance的减少往往与算法容量减少有关。有兴趣的小伙伴可以看一下参考文献。</p>
<p><a href="https://jeremykun.com/2015/09/21/the-boosting-margin-or-why-boosting-doesnt-overfit/">https://jeremykun.com/2015/09/21/the-boosting-margin-or-why-boosting-doesnt-overfit/</a></p>
<h3 id="为什么随机森林的泛化能力较强？">为什么随机森林的泛化能力较强？</h3>
<p>随机森林的泛化误差界与单个决策树的分类强度 $s$ 成负相关，与决策树之间的相关性 $\rho$ 成正相关，分类强度 $\rho$ 越大且相关性 $s$ 越小，泛化误差界越小，可以看到随机森林中的随机性可以保证 $\rho$ 越小，如果每棵树的越大的话，泛化误差会收敛到一个small界，这个界当然越小越好，就是泛化误差越小。</p>
<h3 id="解释下stacking技术？">解释下stacking技术？</h3>
<p>Stacking是通过一个元分类器或者元回归器来整合多个分类模型或回归模型的集成学习技术。基础模型利用整个训练集做训练，元模型将基础模型的特征作为特征进行训练。</p>
<h3 id="为什么bagging减少方差">为什么bagging减少方差</h3>
<p>当融合多棵树的结果的时候，最后的方差是</p>
$$
\rho \sigma^2 +(1-\rho)\frac{\sigma^2}{B}
$$
<p>可以看到 $\rho$ 越小，$B$ 越大，方差越小<br>
详细可以看<br>
<a href="https://stats.stackexchange.com/questions/380023/how-can-we-explain-the-fact-that-bagging-reduces-the-variance-while-retaining-t">https://stats.stackexchange.com/questions/380023/how-can-we-explain-the-fact-that-bagging-reduces-the-variance-while-retaining-t</a><br>
推导在<br>
<a href="https://zhuanlan.zhihu.com/p/373404605">https://zhuanlan.zhihu.com/p/373404605</a></p>
<h3 id="什么场景下采用bagging集成方法">什么场景下采用bagging集成方法</h3>
<p>学习算法不稳定：if small changes to the training set cause large changes in the learned classifier.（也就是说如果训练集稍微有所改变就会导致分类器性能比较大大变化那么我们可以采用bagging这种集成方法）If the learning algorithm is unstable, then Bagging almost always improves performance.(当学习算法不稳定的时候，Bagging这种方法通常可以改善模型的性能)</p>
<p>详细见<br>
<a href="https://zhuanlan.zhihu.com/p/81340270">https://zhuanlan.zhihu.com/p/81340270</a></p>
<h3 id="bagging和dropout区别">bagging和dropout区别</h3>
<p>dropout训练与bagging训练不太一样，bagging的各个子模型之间是完全独立的，而在dropout里，这些参数是共享的。每个模型集成父神经网络参数的不同子集，参数共享使得在有限可用内存下表示指数级数量的模型变得可能，在bagging的情况下，每一个模型在其训练集上训练到收敛，而在dropout情况下，通常大部分的模型都没有显式的训练，因为父神经网络很大，大到宇宙毁灭都不可能采样完所有的网络，在每一个步骤中，我们训练一小部分网络，参数共享会使得剩余的网络也有好的参数设定。<br>
详细见<br>
<a href="https://zhuanlan.zhihu.com/p/149575988">https://zhuanlan.zhihu.com/p/149575988</a></p>
<h3 id="bagging和boosting的区别">bagging和boosting的区别</h3>
<p>1）样本选择上：<br>
Bagging：训练集是在原始集中有放回选取的，从原始集中选出的各轮训练集之间是独立的.<br>
Boosting：每一轮的训练集不变，只是训练集中每个样例在分类器中的权重发生变化.而权值是根据上一轮的分类结果进行调整.<br>
2）样例权重：<br>
Bagging：使用均匀取样，每个样例的权重相等.<br>
Boosting：根据错误率不断调整样例的权值，错误率越大则权重越大.<br>
<strong>3）预测函数：</strong><br>
Bagging：所有预测函数的权重相等.<br>
Boosting：每个弱分类器都有相应的权重，对于分类误差小的分类器会有更大的权重.<br>
4）并行计算：<br>
Bagging：各个预测函数可以并行生.<br>
Boosting：各个预测函数只能顺序生成，因为后一个模型参数需要前一轮模型的结果.</p>
<h3 id="为什么说bagging是减少variance，而boosting是减少bias">为什么说bagging是减少variance，而boosting是减少bias?</h3>
<p>boosting是把许多弱的分类器组合成一个强的分类器。弱的分类器bias高，而强的分类器bias低，所以说boosting起到了降低bias的作用。variance不是boosting的主要考虑因素。bagging是对许多强（甚至过强）的分类器求平均。在这里，每个单独的分类器的bias都是低的，平均之后bias依然低；而每个单独的分类器都强到可能产生overfitting的程度，也就是variance高，求平均的操作起到的作用就是降低这个variance。</p>
<h3 id="请从偏差和方差的角度解释bagging和boosting的原理">请从偏差和方差的角度解释bagging和boosting的原理</h3>
<p>偏差指的是算法的期望预测与真实值之间的偏差程度，反映了模型本身的拟合能力；方差度量了同等大小的训练集的变动导致学习性能的变化，刻画了数据扰动所导致的影响。</p>
<p>Bagging对样本重采样，对每一重采样得到的子样本集训练一个模型，最后取平均。由于子样本集的相似性以及使用的是同种模型，因此各模型有近似相等的bias和variance。由于$E[\frac{{\sum {{X_i}} }}{n}] = E[{X_i}]$ ，所以bagging后的bias和单个子模型的接近，一般来说不能显著降低bias。另一方面，若各子模型独立，则有$Var[\frac{{\sum {{X_i}} }}{n}] = \frac{{Var[{X_i}]}}{n}$ ，此时可以显著降低variance。若各子模型完全相同，则$Var[\frac{{\sum {{X_i}} }}{n}] = Var[{X_i}]$ ，此时不会降低variance。</p>
<p>bagging方法得到的各子模型是有一定相关性的，属于上面两个极端状况的中间态，因此可以一定程度降低variance。</p>
<p>boosting从优化角度来看，是用forward-stagewise这种贪心法去最小化损失函数,由于采取的是串行优化的策略，各子模型之间是强相关的，于是子模型之和并不能显著降低variance。所以说boosting主要还是靠降低bias来提升预测精度。</p>
<h3 id="详细说明下决策数如何计算特征重要性的？">详细说明下决策数如何计算特征重要性的？</h3>
<p>对于简单的的决策数，sklearn中是使用基尼指数来计算的，也就是基尼不纯度，决策数首先要构造好后才可以计算特征重要性，当然，我们在构建数的过程中已近计算好了特征重要性的一些值，如基尼指数，最后我们得到特征重要性的话，就直接将基尼指数做些操作就可以了。在sklearn中，feature_importances_应当就是这个Gini importance，也是就</p>
$$
N_t / N * (impurity - N_tR / N_t * right_impurity - N_tL / N_t * left_impurity)
$$
<h3 id="softmax的这个小细节问题吗">softmax的这个小细节问题吗?</h3>
<p>在我们的softmax计算过程中会遇到上溢下溢的问题，这点我们可以从softmax的函数中看到。</p>
$$
f(x) = \frac{{\exp (x)}}{{\sum\limits_{i = 1}^k {\exp (x)} }}
$$
<p>可以看到我们的分子和分母都是指数函数，当 $x$ 取值过大时会导致数据溢出，当<code>$x$</code>都很小的时候，分母为0，举个例子，当x=[10000,5000,2000]的时候，超过了计算机所能存储的最大范围，就会发生溢出。当x=[-10000,-1000,-34343]的时候，分母很小很小，基本为0，导致计算结果为nan.</p>
<p>那如何解决呢，只要将x进行变换就可以,将原数组变成x-max(x)。对于x=[10000,5000,2000]，则变成x=[0,-5000,-8000]，这样分母最少为1，分子不用说没问题也不会溢出。为啥减去一个max(x)就可以呢，我们看如下的公式：</p>
$$
\frac{{\exp (x - a)}}{{\sum\limits_{i = 1}^k {\exp (x - a)} }} = \frac{{\exp (x)\exp ( - a)}}{{\exp ( - a)\sum\limits_{i = 1}^k {\exp (x)} }}
$$
<p>这样就可以啦。</p>
<h3 id="adaboost为什么不容易过拟合？">adaboost为什么不容易过拟合？</h3>
<p>这里需要用到一个理论来说一下。<br>
Margin理论讨论的主要是学习算法在训练样本上的信心，学习算法的容量是不是随着训练轮数的增加而增加呢，其实并不一定，近来有工作表明，有差异的学习器的组合，能够起到正则化的作用，也就是减少学习算法容量（Diversity regularized ensemble pruning. ECML’12; On the Generalization Error Bounds of Neural Networks under Diversity-Inducing Mutual Angular Regularization）。在许多variance-bias 分解实验中也观察到，AdaBoost不仅是减少了bias，同时也减少了variance，variance的减少往往与算法容量减少有关。</p>
<p>详细见<br>
<a href="https://www.zhihu.com/question/41047671/answer/127832345">https://www.zhihu.com/question/41047671/answer/127832345</a></p>
<h3 id="Random-Forest可以用来做聚类？">Random Forest可以用来做聚类？</h3>
<p>其实随机森林是可以用来做聚类的，对于没有标签的特征，随机森林通过生成数据来实现聚类。其主要的步骤如下：</p>
<p>第一步：生成假冒数据和临时标签。</p>
<p>我们先给原数据集增加一列，名叫“标签”，原生数据每一行的标签都是“1”。下面生成一些假数据，假数据的每一列都是从原生数据中根据其经验分布随机产生的，人工合成的数据的标签是“0”。举个例子，</p>
<p>标签 身高 体重 年龄</p>
<p>1 184 158 25</p>
<p>1 170 162 37</p>
<p>1 165 132 45</p>
<p>1 110 78 9</p>
<p>1 145 100 14</p>
<p>1 … … …</p>
<p>上面是原生数据，下面我们开始制造虚假数据</p>
<p>标签 身高 体重 年龄</p>
<p>1 184 158 25</p>
<p>1 170 162 37</p>
<p>1 165 132 45</p>
<p>1 110 78 9</p>
<p>1 145 100 14</p>
<p>1 … … …</p>
<p>0 170 100 9</p>
<p>0 110 162 37</p>
<p>0 165 158 14</p>
<p>每行假数据的每一个元素都是从它所在的那一列中随机抽取的，列和列之间的抽取是独立的。这样一来，人工合成的假数据就破坏了原有数据的结构性。现在我们的数据集和标签就生成完了。</p>
<p>第二步：用该数据集训练Random Forest并获得样本间的临近性(proximity)。</p>
<p>假设原生样本有N行，我们再生成M个假数据。现在我们就有了带标签的样本之后就可以用它训练出一个Random Forest。Random Forest在训练的同时，可以返回样本之间的临近性(proximity，两个样本出现在树杈同一节点的频率越高，它们就越临近)。我们就有了一个(N+M)x(N+M)的临近矩阵（这是个对称矩阵）。把与假数据相关的M行、M列去掉，我们就得到了NxN的矩阵，矩阵的第i行第j列的数值就是原生数据中第i个样本和第j个样本之间的临近性。</p>
<p>第三步：根据每个样本点两两之间的临近性来聚类。</p>
<p>这个是最后一步，在其中可以用两两之间的临近性当做两两之间的距离，然后再利用常规的聚类算法，比如层次聚类法(Hierarchical clustering)，就可以完成对原样本的聚类。</p>
<h3 id="组合弱学习器的算法？">组合弱学习器的算法？</h3>
<p>为了建立一个集成学习方法，我们首先要选择待聚合的基础模型。在大多数情况下（包括在众所周知的 bagging 和 boosting 方法中），我们会使用单一的基础学习算法，这样一来我们就有了以不同方式训练的同质弱学习器。这样得到的集成模型被称为「同质的」。然而，也有一些方法使用不同种类的基础学习算法：将一些异质的弱学习器组合成「异质集成模型」。很重要的一点是：我们对弱学习器的选择应该和我们聚合这些模型的方式相一致。如果我们选择具有低偏置高方差的基础模型，我们应该使用一种倾向于减小方差的聚合方法；而如果我们选择具有低方差高偏置的基础模型，我们应该使用一种倾向于减小偏置的聚合方法。</p>
<p>bagging，该方法通常考虑的是同质弱学习器，相互独立地并行学习这些弱学习器，并按照某种确定性的平均过程将它们组合起来。boosting，该方法通常考虑的也是同质弱学习器。它以一种高度自适应的方法顺序地学习这些弱学习器（每个基础模型都依赖于前面的模型），并按照某种确定性的策略将它们组合起来。stacking，该方法通常考虑的是异质弱学习器，并行地学习它们，并通过训练一个「元模型」将它们组合起来，根据不同弱模型的预测结果输出一个最终的预测结果。</p>
<p>详细见<br>
<a href="https://zhuanlan.zhihu.com/p/6588817">https://zhuanlan.zhihu.com/p/6588817</a></p>
]]></content>
      <categories>
        <category>算法面试</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>刷八股</tag>
      </tags>
  </entry>
  <entry>
    <title>线性模型与经典算法</title>
    <url>/2024/03/19/machine_learning/linear_model_and_class_algorithm/</url>
    <content><![CDATA[<h1>线性模型与经典算法</h1>
<h2 id="PLA-感知机">PLA(感知机)</h2>
<h3 id="简单介绍下感知机算法？">简单介绍下感知机算法？</h3>
<p>感知机算法的全称是Perceptron Linear Algorithm，是由美国学者Fran Rosenblatt 在1957 年提出的一种线性的算法模型，它也是神经网络的算法的起源思想。感知机是一个接受输入并具有输出，感知机的信号流只有1或者0。公式如下所示：</p>
 $$
f(x)=sign(wx+b)
$$ 
<p>其中sign是符号函数, 如果 $wx+b>0$ 则输出1，如果 $wx+b<0$ ，则输出0。< p>
<p><img src="fe982a7cac2145f3a4288e1385c0553b.png" alt="加载不了请走VPN"></p>
<p>其中  $w$  也即优化的参数。</p>
<h3 id="单层感知机可以实现异或运算吗？">单层感知机可以实现异或运算吗？</h3>
<p>单层的感知机可以实现与门，与非门和或门，但是无法实现异或门。可以借助下图来形象的描述相关原因。<br>
异或门的运算相当于找出一条直线将图中的圈和三角形分开，很显然是不能的。<br>
<img src="1b5bf1571bb04444958a732b46a7219f.png" alt="加载不了请走VPN"></p>
<h3 id="多层感知机可以解决异或问题吗？">多层感知机可以解决异或问题吗？</h3>
<p>实现异或主要的划分曲面如下所示，使用一条曲线即可将圈和三角形分开，这在单层感知机是无法实现的，需要通过多层感知机叠加非线性实现异或。<br>
<img src="f22e5942df894829b16b520a8e72a56c.png" alt="加载不了请走VPN"><br>
通过组合感知机（叠加层就可以实现异或门。异或门可以使用通过组合与门、与非门、或门来实现。<br>
<img src="3ecb0304269e4689b855c4110c6f96a8.png" alt="加载不了请走VPN"></p>
<h3 id="感知机损失函数是什么？">感知机损失函数是什么？</h3>
<p>感知机线性方程表示为：</p>
 $$
wx+b=0
$$ 
<p>损失函数只对于误分类的点计算值，也即当误分后有 $-y_{i}({wx_{i}+b})>0$ ，将误分点到直线的距离加起来即为损失函数</p>
 $$
{\rm{ - }}\frac{1}{{{\rm{||w||}}}}{y_i}(w{x_i} + b)
$$ 
<p>则可以得到总的距离为</p>
 $$
-{\rm{ - }}\frac{1}{{{\rm{||w||}}}}\sum\limits_{{x_i} \in M} {{y_i}(w{x_i} + b)}
$$ 
<p>不考虑 $||w||$ 的话，则损失函数可以写为</p>
 $$
-\sum\limits_{{x_i} \in M} {{y_i}(w{x_i} + b)}
$$ 
<h3 id="感知机损失函数为什么不考虑W的二范数？">感知机损失函数为什么不考虑W的二范数？</h3>
<p>其实考虑了也没用，整体上来说感知机的任务是进行二分类工作，它最终并不关心得到的超平面离各点的距离有多少，只是可能考虑后得到的新的分界线和之前不考虑得到的有些不同，但是依然可以将所有的点分开的，</p>
<h3 id="感知机优化算法是怎么做的？">感知机优化算法是怎么做的？</h3>
<p>使用SGD方法进行优化，优化更新的思路也是很简单的，如下所示，对损失函数进行求导，如下</p>
 $$
\begin{array}{l}
{\Delta _w}L(w,b) =  - \sum\limits_{{x_i} \in M} {{y_i}{x_i}} \\
{\Delta _b}L(w,b) =  - \sum\limits_{{x_i} \in M} {{y_i}} 
\end{array}
$$ 
<p>其中参数的更新如下：</p>
 $$
\begin{array}{l}
w \leftarrow w - \eta *( - {y_i}*{x_i}) = w + \eta *({y_i}*{x_i})\\
b \leftarrow b - \eta *( - {y_i}) = b + \eta *{y_i}
\end{array}
$$ 
<p>通过迭代期望损失函数 $L(w,b)$ 不断减小，直到为0。这种学习算法直观解释：当一个实例点被误分类，即位于分离超平面的错误一侧时，则调整 $w，b$ 的值，使分离超平面向该误分类点的一侧移动，以减少该误分类点与超平面的距离，直至超平面越过该误分类点使其被正确分类。</p>
<h3 id="感知机算法的解释唯一的吗？">感知机算法的解释唯一的吗？</h3>
<p>感知机算法在采用了不同的初始值后，得到的解不同，因此无法得到唯一解，可能每次得到的解都不一样，但是每次的分割线可以将正负样本很好的分开，因为能将正负样本分开的线有无限多个，因此解是无穷的。</p>
<h3 id="感知机算法和SVM的区别？">感知机算法和SVM的区别？</h3>
<p>感知机和SVM的区别：</p>
<ul>
<li>
<p>相同点<br>
都是属于监督学习的一种分类器。</p>
</li>
<li>
<p>不同点</p>
</li>
</ul>
<ol>
<li>感知机追求最大程度正确划分，最小化错误，很容易造成过拟合。</li>
<li>支持向量机追求大致正确分类的同时，一定程度上避免过拟合。</li>
<li>感知机使用的学习策略是梯度下降法，而SVM采用的SMO算法。</li>
</ol>
<h3 id="参考">参考</h3>
<blockquote>
<p><a href="https://blog.csdn.net/weixin_37762592/article/details/101760105">https://blog.csdn.net/weixin_37762592/article/details/101760105</a><br>
<a href="https://zhuanlan.zhihu.com/p/163811629">https://zhuanlan.zhihu.com/p/163811629</a><br>
<a href="https://blog.csdn.net/touch_dream/article/details/63748923">https://blog.csdn.net/touch_dream/article/details/63748923</a><br>
<a href="https://www.zhihu.com/collection/709757854">https://www.zhihu.com/collection/709757854</a><br>
<a href="https://blog.csdn.net/qq_34767784/article/details/115271164">https://blog.csdn.net/qq_34767784/article/details/115271164</a></p>
</blockquote>
<h2 id="LR（线性回归）">LR（线性回归）</h2>
<h3 id="简单介绍下线性回归？">简单介绍下线性回归？</h3>
<p>线性回归是⼀种预测模型，利⽤各个特征的数值去预测⽬标值。线性回归的主要思想是给每⼀个特征分配⼀个权值，最终的预测结果是每个特征值与权值的乘机之和再加上偏置。所以训练的⽬标是找到各个特征的最佳权值和偏置，使得误差最⼩。线性回归的假设前提是噪声符合正态分布。</p>
<h3 id="线性回归的5大假设是什么？">线性回归的5大假设是什么？</h3>
<ol>
<li>特征和标签呈线性关系。</li>
<li>误差之间相互独⽴</li>
<li>⾃变量相互独⽴</li>
<li>误差项的⽅差应为常数</li>
<li>误差呈正态分布</li>
</ol>
<h3 id="线性回归要求因变量符合正态分布？">线性回归要求因变量符合正态分布？</h3>
<p>是的。线性回归的假设前提是特征与预测值呈线性关系，误差项符合⾼斯-马尔科夫条件（零均值，零⽅差，不相关），这时候线性回归是⽆偏估计。噪声符合正态分布，那么因变量也符合分布。在进⾏线性回归之前，要求因变量近似符合正态分布，否则线性回归效果不佳（有偏估计）。</p>
<h3 id="线性回归为啥做分类不好？">线性回归为啥做分类不好？</h3>
<p>线性回归的函数形式是 $y=wx+b$ ，其中特征的值 $y$ 是无法控制的，可能会导致算出来的预测值是大于1或者小于0的，因此做分类是不太适合的。</p>
<h3 id="线性回归的损失函数是什么？">线性回归的损失函数是什么？</h3>
<p>⼀般使⽤最⼩⼆乘法，损失函数是各个样本真实值与预测值之差的平⽅和，需要找到合适的参数，也就是权重和偏置，使得这个误差平⽅和最⼩。</p>
 $$
Loss(\hat y, y) = \sum_i(wx_i+b-y)^2
$$ 
<h3 id="线性回归的求解方法有哪些？">线性回归的求解方法有哪些？</h3>
<ul>
<li>公式法<br>
损失函数对 $w$ 和 $b$ 进行求导，并令导数为0，得到最优的 $w$ 和 $b$</li>
<li>优化法<br>
可以通过梯度下降法进行求解</li>
</ul>
<h3 id="线性回归在业界用的不多的原因有哪些？">线性回归在业界用的不多的原因有哪些？</h3>
<ol>
<li>容易过拟合</li>
<li>数据假设不符合线性</li>
<li>不能做复杂的特征工程，如特征交叉等</li>
</ol>
<h3 id="为什么进行线性回归前需要对特征进行离散化处理？">为什么进行线性回归前需要对特征进行离散化处理？</h3>
<ol>
<li>离散化操作很easy，特征离散化之后易于模型的快速迭代。</li>
<li>稀疏矩阵计算快，省内存。</li>
<li>鲁棒性强。单个特征数值过⼤或者过⼩对结果的影响会被降低。</li>
<li>可以产⽣交叉特征（相当于⾮线性了）</li>
<li>模型的稳定性加强了。</li>
<li>简化了模型，相当于降低了过拟合的风险。</li>
</ol>
<h3 id="线性回归时如果数据量太大导致无法一次读进内存如何解决？">线性回归时如果数据量太大导致无法一次读进内存如何解决？</h3>
<p>可以将输入特征向量 $X$ 进行拆分，分开进行计算，将一部分数据加载到内存中计算，然后得到结果后，再计算后面的数据，这样依次得到计算的结果。</p>
<h3 id="线性回归中的R方是什么意思？">线性回归中的R方是什么意思？</h3>
<p>R平方值意义是趋势线拟合程度的指标，它的数值大小可以反映趋势线的估计值与对应的实际数据之间的拟合程度，拟合程度越高，趋势线的可靠性就越高。R平方值是取值范围在0～1之间的数值，当趋势线的 R 平方值等于 1 或接近 1 时，其可靠性最高，反之则可靠性较低。</p>
 $$
{R^2}{\rm{ = }}\frac{{SSR}}{{SST}} = \frac{{||\hat Y - \bar Y|{|^2}}}{{||Y - \bar Y|{|^2}}} = \frac{{Var(\hat y)}}{{Var(y)}} = 1 - \frac{{\sum\limits_i {{{({{\hat y}_i} - {y_i})}^2}} }}{{\sum\limits_i {{{({y_i} - \bar y)}^2}} }}
$$ 
<h3 id="解释下R方为0是什么意思？">解释下R方为0是什么意思？</h3>
<p>R方=0：一种可能情况是&quot;简单预测所有y值等于y平均值&quot;，即所有 $\hat y_i$ 都等于 $\bar y$ （即真实y值的平均数），但也有其他可能。</p>
<h3 id="相关系数和R方的关系？">相关系数和R方的关系？</h3>
<p>相关系数r，是指两个变量之间的相关关系，取值在-1~1之间。r为负数，则是指两个变量之间存在负相关关系，且越接近-1，负相关性越强，反之，为负数，则是指两个变量之间存在正相关关系，且越接近-1，正相关性越强。</p>
<p>R方指的拟合优度，即某个方程对一组数据拟合程度的大小，取值在0~1之间，越接近1，拟合程度就越大。</p>
<h3 id="线性回归中的多重共线性是什么意思？">线性回归中的多重共线性是什么意思？</h3>
<p>多重共线性（Multicollinearity）是指线性回归模型中的特征存在较高的线性关系。</p>
<h3 id="多重共线性的危害有哪些？">多重共线性的危害有哪些？</h3>
<ul>
<li>增大模型的不确定性，影响泛化能力</li>
<li>导致模型系数的值不稳定，甚至出现0和负数的情况，这样就没有通过系数值来判断特征的重要性了，无法解释单个变量对模型的影响</li>
<li>会对对非共线性变量的系数产生影响（做实验可以看出来）</li>
</ul>
<h3 id="多重共线性是如何影响算法结果的？">多重共线性是如何影响算法结果的？</h3>
<p>为了找到最优化的系数，可以对损失函数求导，也就是如下：</p>
 $$
\frac{{\partial L}}{{\partial w}} = \frac{{\partial {{(y - Xw)}^2}}}{{\partial w}} =  \cdots  = {({X^T}X)^{ - 1}}{X^T}y
$$ 
<p>我们假设 ${X^T}X$ 是可逆的，以便能够估计 $w$  。 但是，如果 $X$ 的列彼此线性相关（存在多重共线性），则 ${X^T}X$ 是不可逆的，由于回归模型中存在共线性，所以很难解释模型的系数 。</p>
<h3 id="共线性变量的处理有哪些方法？">共线性变量的处理有哪些方法？</h3>
<ul>
<li>删除共线变量<br>
可以通过启发式的方法将变量加入到模型中，看模型的效果，然后确定删除哪个</li>
<li>加正则项<br>
正则本身就可以限制模型的复杂度，如使用L2算法</li>
</ul>
<h3 id="线性回归优缺点？">线性回归优缺点？</h3>
<p>优点：实现简单，建模快，是许多非线性模型的基础<br>
缺点：模型简单所以难以拟合复杂数据，对非线性的数据难以运用</p>
<h3 id="请简单说下Lasso和Ridge的区别？">请简单说下Lasso和Ridge的区别？</h3>
<p>Lasso和Ridge都是用来在线性回归中防止过拟合的手段。</p>
<ul>
<li>Lasso<br>
在损失函数中加⼊ $w$ 的L1范数， $w$ 容易落到坐标轴上，即Lasso回归容易得到稀疏矩阵</li>
<li>Ridge<br>
在原来的损失函数基础上加⼊ $w$ 参数的平⽅和乘以 $\lambda$ （加⼊ $w$ 的L2范数） 。相当于增加了⼀个约束项，在这个约束之下求损失函数的最小值。</li>
</ul>
<h3 id="Ridge回归和Lasso回归的使用场景">Ridge回归和Lasso回归的使用场景</h3>
<ol>
<li>解决普通线性回归过拟合的问题；</li>
<li>解决⽅程求解法中⾮满秩矩阵⽆法求解的问题；</li>
<li>约束参数</li>
</ol>
<h3 id="参考-2">参考</h3>
<blockquote>
<p><a href="https://www.cnblogs.com/Ooman/p/11350095.html">https://www.cnblogs.com/Ooman/p/11350095.html</a><br>
<a href="https://blog.csdn.net/weixin_52589734/article/details/116060443">https://blog.csdn.net/weixin_52589734/article/details/116060443</a><br>
<a href="https://blog.csdn.net/Noob_daniel/article/details/76087829">https://blog.csdn.net/Noob_daniel/article/details/76087829</a><br>
<a href="https://blog.csdn.net/weixin_41761357/article/details/111589392">https://blog.csdn.net/weixin_41761357/article/details/111589392</a><br>
<a href="https://zhuanlan.zhihu.com/p/151636748?utm_source=wechat_session&amp;ivk_sa=1024320u">https://zhuanlan.zhihu.com/p/151636748?utm_source=wechat_session&amp;ivk_sa=1024320u</a><br>
<a href="https://zhuanlan.zhihu.com/p/143132259?from=singlemessage">https://zhuanlan.zhihu.com/p/143132259?from=singlemessage</a><br>
<a href="https://zhuanlan.zhihu.com/p/443658898">https://zhuanlan.zhihu.com/p/443658898</a><br>
<a href="https://www.zhihu.com/question/32021302/answer/1012441825">https://www.zhihu.com/question/32021302/answer/1012441825</a><br>
<a href="https://zhuanlan.zhihu.com/p/146478349">https://zhuanlan.zhihu.com/p/146478349</a></p>
</blockquote>
<h2 id="LR（逻辑回归）">LR（逻辑回归）</h2>
<h3 id="简单介绍下LR算法？">简单介绍下LR算法？</h3>
<p>逻辑回归（Logistic Regression）属于机器学习 — 监督学习 — 分类的一个算法，它在数据服从伯努利分布的假设下，通过极大似然的方法，运用梯度下降法来求解参数，从而达到将数据二分类的目的。</p>
<h3 id="LR是如何做分类的？">LR是如何做分类的？</h3>
<p>逻辑回归中，对于每个 x，其条件概率 y 的确是一个连续的变量。而逻辑回归中可以设定一个阈值，y 值大于这个阈值的是一类，y 值小于这个阈值的是另外一类。至于阈值的选择，通常是根据实际情况来确定，一般情况下选取 0.5 作为阈值来划分。</p>
<h3 id="LR的损失函数怎么来的？">LR的损失函数怎么来的？</h3>
<p>LR的损失函数可以通过极大似然函数推导得到，极大化似然函数就是最小化损失函数，其中损失函数就是LogLoss，就是极大似然函数取负后的结果。<br>
似然函数的形式是：</p>
  $$
L(w) = \prod\limits_{i = 1}^n {{{[p({x_i})]}^{{y_i}}}{{[1 - p({x_i})]}^{1 - {y_{i}}}}}
 $$ 
<p>损失函数如下：</p>
   $$
L(w) = -\prod\limits_{i = 1}^n {{{[p({x_i})]}^{{y_i}}}{{[1 - p({x_i})]}^{1 - {y_{i}}}}}
 $$ 
<h3 id="LR如何解决地维不可分？">LR如何解决地维不可分？</h3>
<p>这个问题类似于SVM如何解决低维不可分，如果低维不可分的话，可以使用一些核函数，进行特征空间的映射，到高维后再进行划分即可。</p>
<h3 id="LR的优缺点是什么？">LR的优缺点是什么？</h3>
<p>优点：</p>
<ol>
<li>形式简单，模型的可解释性非常好。从特征的权重可以看到不同的特征对最后结果的影响，某个特征的权重值比较高，那么这个特征最后对结果的影响会比较大。</li>
<li>模型效果不错。在工程上是可以接受的（作为 baseline），如果特征工程做的好，效果不会太差，并且特征工程可以并行开发，大大加快开发的速度。</li>
<li>训练速度较快。分类的时候，计算量仅仅只和特征的数目相关。并且逻辑回归的分布式优化 SGD 发展比较成熟。方便调整输出结果，通过调整阈值的方式。<br>
缺点：</li>
<li>准确率欠佳。因为形式非常的简单，而现实中的数据非常复杂，因此，很难达到很高的准确性。</li>
<li>很难处理数据不平衡的问题。举个例子：如果我们对于一个正负样本非常不平衡的问题比如正负样本比 10000:1。我们把所有样本都预测为正也能使损失函数的值比较小。但是作为一个分类器，它对正负样本的区分能力不会很好。</li>
<li>无法自动的进行特征筛选。</li>
<li>只能处理二分类问题。</li>
</ol>
<h3 id="LR在训练模型中出现了强相关特征怎么办？">LR在训练模型中出现了强相关特征怎么办？</h3>
<p>如果在损失函数最终收敛的情况下，其实就算有很多特征高度相关也不会影响分类器的效果。但是对特征本身来说的话，假设只有一个特征，在不考虑采样的情况下，你现在将它重复 N 遍。训练以后完以后，数据还是这么多，但是这个特征本身重复了 N 遍，实质上将原来的特征分成了 N 份，每一个特征都是原来特征权重值的百分之一。</p>
<h3 id="为什么在进入LR模型前要将强相关特征去除？">为什么在进入LR模型前要将强相关特征去除？</h3>
<ol>
<li>加快训练速度<br>
特征少了的话，无疑训练速度是会加快的</li>
<li>增加模型的可解释性<br>
如果出现了强相关特征A和B，最后得到的A的特征重要性和B的特征重要性可能是不准的，在分析的时候很难解释清楚。</li>
</ol>
<h3 id="逻辑回归与朴素贝叶斯有什么区别">逻辑回归与朴素贝叶斯有什么区别?</h3>
<ol>
<li>逻辑回归是判别模型， 朴素贝叶斯是生成模型，所以生成和判别的所有区别它们都有。</li>
<li>朴素贝叶斯属于贝叶斯派，逻辑回归是最大似然频率派，两种概率哲学间的区别。</li>
<li>朴素贝叶斯需要条件独立假设。逻辑回归需要求特征参数间是线性的。</li>
</ol>
<h3 id="LR与NB有什么区别？">LR与NB有什么区别？</h3>
<p>逻辑回归与朴素贝叶斯区别有以下几个方面：</p>
<ol>
<li>逻辑回归是判别模型， 朴素贝叶斯是生成模型，所以生成和判别的所有区别它们都有。</li>
<li>朴素贝叶斯属于贝叶斯，逻辑回归是最大似然，两种概率哲学间的区别。</li>
<li>朴素贝叶斯需要条件独立假设。</li>
<li>逻辑回归需要求特征参数间是线性的。</li>
</ol>
<h3 id="线性回归和LR的区别">线性回归和LR的区别?</h3>
<ol>
<li>线性回归主要来做预测，逻辑回归分类</li>
<li>线性回归y范围实数集，逻辑回归为0,1</li>
<li>线性回归函数为拟合函数，逻辑回归为预测函数</li>
<li>线性回归的参数计算方式为最小二乘法，逻辑回归为极大似然估计</li>
</ol>
<h3 id="为什么LR的输出值可以作为概率？">为什么LR的输出值可以作为概率？</h3>
<p>因为 sigmoid 函数是伯努利分布的联系函数的反函数，它将线性函数映射到了伯努利分布的期望上，而伯努利分布的期望本身就是概率，因此，我们最终从LR得到的输出，可以代表概率，也正是因为它代表概率，才落在(0,1)之间。</p>
<h3 id="LR和最大熵模型之间的关系到底是什么？">LR和最大熵模型之间的关系到底是什么？</h3>
<p>逻辑斯谛回归是最大熵模型的一个特例，只需将逻辑斯谛回归模型所隐含的模型约束条件引入到最大熵模型中即可导出逻辑斯谛回归模型。最大熵原理是概率模型学习的一种通用准则，可有效避免模型的过拟合。逻辑斯谛回归和最大熵模型都是对数线性模型。</p>
<h3 id="LR的并行化计算方法？">LR的并行化计算方法？</h3>
<ol>
<li>仅按照样本划分<br>
可以在样本的层次上进行拆分，对每一个分类错误的样本的计算进行并行化，然后将最终的结果相加再平均即可。</li>
<li>仅按照特征划分<br>
按列并行的意思就是将同一样本的特征也分布到不同的机器中去。</li>
<li>按照特征和样本同时划分<br>
就是将特征拆分为多个独立的块，每个块算好后进行合并，然后得到最后的梯度值。</li>
</ol>
<h3 id="为什么LR适合稀疏矩阵？">为什么LR适合稀疏矩阵？</h3>
<p>稀疏矩阵用在LR上，可以大大减少时间复杂度，比如对元素为0的部分，可以直接忽略其乘法运算，并且通过一些方式，也可以仅仅存储不等于0的元素，大大减少空间复杂度。</p>
<p>因此并非是说LR适合稀疏矩阵，而是考虑到现实情境，为了增加非线性，导致了矩阵为稀疏的，反过来，因为LR的特性，特征矩阵即使是很大且稀疏的，也可以快速运算。</p>
<h3 id="LR为什么选择0-5作为分类的阈值？">LR为什么选择0.5作为分类的阈值？</h3>
<p>我们用来训练的样本数据，通常是从总体中进行抽样得到，因此其正反例的分布也大致符合总体的分布，如果样本数据平衡，那么我们可以假设总体数据平衡，那么设置0.5为阈值便是合理的。</p>
<h3 id="LR都有哪些正则化？">LR都有哪些正则化？</h3>
<ul>
<li>L0<br>
L0正则化的想法十分直接，既然我们希望模型不要使用所有特征，那么只要让正则化项代表权重为非0的个数就好了</li>
<li>L1<br>
L1正则加入的先验知识是，模型的权重符合拉普拉斯分布，且平均值为0</li>
<li>L2<br>
这里的正则加入的先验知识是，模型的权重符合正态分布，且平均值为0</li>
</ul>
<h3 id="LR能否用于非线性分类？">LR能否用于非线性分类？</h3>
<p>关于Logistic Regression能否用于非线性分类，这是毫无悬念的，是肯定可以的，只要用一个kernel trick来帮忙就行了，对，就是我们在SVM中常常用到的核函数。在这种情况下，logistic regression模型就不能再表示成 ${w^T}x + b$ 的形式（primal form），而只能表示成 {% raw%}$\sum\limits_i {{a_i} < {x_i},{x_j} >  + b}${% endraw %} 的形式（dual form）。逻辑回归本质上是线性回归模型，关于系数是线性函数，分离平面无论是线性还是非线性的，逻辑回归其实都可以进行分类。对于非线性的，需要自己去定义一个非线性映射。</p>
<h3 id="LR如何并行化？">LR如何并行化？</h3>
<p>并行的方法可以对矩阵进行行分块并行化计算最后合并，注意的是这里随机梯度下降原则不并行话，因为只计算一个样本点的梯度，没必要并行。如果对于类似点击率这种问题，矩阵的特征数目达到上亿维，还可以对列进行分块，就是行列都分块来算，最后结果再合并。算完梯度后直接就可以更新参数值了。</p>
<p>整体上划分的话，有三种并行方法，分别是：</p>
<ol>
<li>按样本并行</li>
<li>按特征并行</li>
<li>按样本和特征并行</li>
</ol>
<h3 id="SVM和LR区别？">SVM和LR区别？</h3>
<p>相同点：</p>
<ol>
<li>LR和SVM都是判别模型。</li>
<li>LR和SVM都线性模型。(加核的话就是非线性了)</li>
<li>LR和SVM都是分类算法。(SVM也可以用来做回归)</li>
<li>LR和SVM都是监督学习算法。</li>
</ol>
<p>不同点:</p>
<ol>
<li>损失函数不同<br>
LR采用log损失，SVM采用合页(hinge)损失</li>
<li>异常值敏感不同<br>
LR对异常值敏感，SVM对异常值不敏感</li>
<li>效率不同<br>
大数据和多维特征的情况下，LR优势更明显</li>
<li>模型构建出发点<br>
LR是经验风险最小化，SVM是结构风险最小化</li>
</ol>
<h3 id="为什么LR模型损失数使用交叉熵不用MSE？">为什么LR模型损失数使用交叉熵不用MSE？</h3>
<p>LR的基本表达形式如下：</p>
 $$
{h_\theta }(x) = g({\theta ^T}x) = \frac{1}{{1 + {e^{ - {\theta ^T}x}}}}
$$ 
<p>使用交叉熵作为损失函数的梯度下降更新求导的结果如下：首先得到损失函数如下：</p>
 $$
C = \frac{1}{n}\sum {[yIn\hat y + (1 - y)In(1 - \hat y)]}
$$ 
<p>计算梯度如下：</p>
 $$
\frac{{\partial C}}{{\partial w}} = \frac{1}{n}\sum {x(\sigma (z) - y)}
$$ 
<p>如果我们使用MSE作为损失函数的话，那损失函数以及求导的结果如下所示：</p>
 $$
\begin{array}{l}
C = \frac{{{{(y - \hat y)}^2}}}{2}\\
\frac{{\partial C}}{{\partial w}} = (y - \hat y)\sigma '(z)(x)
\end{array}
$$ 
<p>可以看到使用MSE作为损失函数的话，它的梯度是和sigmod函数的导数有关的，如果当前模型的输出接近0或者1时，导数 $\sigma '(z)$ 就会非常小，接近0，使得求得的梯度很小，损失函数收敛的很慢。但是我们使用交叉熵的话就不会出现这样的情况，它的导数就是一个差值，误差大的话更新的就快，误差小的话就更新的慢点，这正是我们想要的。因此，我们需要用交叉熵而不是MSE作为损失函数。</p>
<h3 id="为什么做LR之前要做归一化？">为什么做LR之前要做归一化？</h3>
<p>特征两个不一样，则W权重中的每一个wi的梯度更新量差异很大，量纲大的特征对应的权重w的梯度更新的量纲也大。导致梯度中的偏导差异极大，使得模型收敛很慢甚至无法收敛。</p>
<h3 id="LR损失函数中为啥要加1-N">LR损失函数中为啥要加1/N</h3>
<p>1/N（N表示样本数量）可以融合到learning rate里去理解，torch的损失函数里面也设计了 对loss进行平均和对loss进行求和，平均不求和的差异就在于每一个step对参数w的梯度更新量的差异为N（样本数量）倍，数据量很大时，会导致梯度更新量非常大，权重的变化会非常的剧烈，收敛困难，所以用1/N，不过其实learning rate缩小n倍达到的效果是一样的。梯度表达式前面的以乘数的形式存在的常数项对梯度下降法的收敛没有任何的影响，本质上可以理解为learning rate的变化。</p>
<h3 id="LR使用梯度下降法的时候的停止条件是什么？">LR使用梯度下降法的时候的停止条件是什么？</h3>
<p>1、达到最大迭代次数<br>
2、权重的更新值小于设定的阈值<br>
3、设置了早停机制</p>
<h3 id="LR是线性模型还是非线性模型？">LR是线性模型还是非线性模型？</h3>
<p>经过sigmoid之后称为非线性的值，所以从决策平面的来说逻辑回归是线性模型，从输出来看逻辑回归是非线性模型，不过一般是从决策平面来定义线性和非线性的，所以我们还是将逻辑回归视为线性模型。</p>
<h3 id="请从多个角度解释下LR？">请从多个角度解释下LR？</h3>
<ul>
<li>
<p>从广义线性模型（GLM）角度出发<br>
以二分类逻辑回归为例：二分类问题的逻辑回归，是在假设先验分布p（y）为伯努利分布情况下（由于伯努利分布属于指数分布族），根据GLM规则对后验分布p（y|x）进行建模的结果。</p>
</li>
<li>
<p>从对数几率的角度出发<br>
逻辑回归的建模基础为：假设新样本分为正类别的概率的对数几率（或logit函数）是输入数据x的线性函数。（这一角度和GLM感觉有点类似）</p>
</li>
<li>
<p>从最大熵模型的角度<br>
最大熵模型是逻辑回归的一般形式，逻辑回归是最大熵模型的一个代表。</p>
</li>
</ul>
<p>三种不同角度都不约而同指向了逻辑回归。最开始接触逻辑回归时觉得其很是别扭，现在深感存在即合理。</p>
<h3 id="为什么LR要用极大似然法来进行参数估计？">为什么LR要用极大似然法来进行参数估计？</h3>
<p>极大似然估计是一种参数估计的方法，它是频率学派最经典的方法之一，认为真实发生的结果的概率应该是最大的，那么相应的参数，也应该是能让这个状态发生的概率最大的参数。简单说就是如果事件发生了被我们观测到了，那么这个事件对应发生的概率一定是最大的才能被我们观测到否则就不会被我们观测到，所以当前的状态是这个事件发生概率最大的结果。</p>
<h3 id="参考-3">参考</h3>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/441128484">https://zhuanlan.zhihu.com/p/441128484</a><br>
<a href="https://blog.csdn.net/qq_37430422/article/details/105289993">https://blog.csdn.net/qq_37430422/article/details/105289993</a><br>
<a href="https://zhuanlan.zhihu.com/p/391954665">https://zhuanlan.zhihu.com/p/391954665</a><br>
<a href="https://www.zhihu.com/collection/168981231">https://www.zhihu.com/collection/168981231</a><br>
<a href="https://blog.csdn.net/OliverLee456/article/details/86300850">https://blog.csdn.net/OliverLee456/article/details/86300850</a></p>
</blockquote>
<h2 id="KNN">KNN</h2>
<h3 id="简单介绍下KNN？">简单介绍下KNN？</h3>
<p>邻近算法，或者说K最邻近（KNN，K-NearestNeighbor）分类算法是数据挖掘分类技术中最简单的方法之一。所谓K最近邻，就是K个最近的邻居的意思，说的是每个样本都可以用它最接近的K个邻近值来代表。近邻算法就是将数据集合中每一个记录进行分类的方法。<br>
<img src="296cd0203a9a4749a8fe338deac0366c.png" alt="加载不了请走VPN"></p>
<h3 id="KNN的实现方式有哪些？">KNN的实现方式有哪些？</h3>
<ol>
<li>Kd tree<br>
大家了解最多的可能就是Kd tree了，基本思想是对样本在笛卡尔空间进行矩形划分，虽然Kd tree 的方法对于低维度 (D&lt;20) 近邻搜索非常快, 当D增长到很大时, 效率变低: 这就是所谓的“维度灾难” 的一种体现。</li>
<li>ball tree<br>
因为使用kd tree最近邻预测时，矩形与目标点和树上点构成的圆于相交，时常会因为菱角相交导致一些，无关多余的搜索，球树就是在kd树这个缺点上进行改进而生，通过将特征点转化为球状分割，从而减少无效相交。通过这种方法构建的树要比 Kd tree消耗更多的时间, 但是这种数据结构对于高结构化的数据是非常有效的, 即使在高维度上也是一样。</li>
</ol>
<h3 id="KNN的决策边界是怎样的？">KNN的决策边界是怎样的？</h3>
<p>KNN的决策边界一般不是线性的，而且随着K的变小，模型容易过拟合，此时的模型复杂度很高且决策边界崎岖，但是如果K取的过大，这时与目标点较远的样本点也会对预测起作用，就会导致欠拟合，此时模型变得简单，决策边界变平滑。如下图所示：<br>
<img src="86f18b5de0814cbbb3a53049b815cc8c.png" alt="加载不了请走VPN"></p>
<h3 id="KD树与一维二叉查找树之间的区别">KD树与一维二叉查找树之间的区别?</h3>
<p>二叉查找树：数据存放在树中的每个结点（根结点、中间结点、叶子结点）中；<br>
Kd-Tree：数据只存放在叶子结点，而根结点和中间结点存放一些空间划分信息（例如划分维度、划分值）</p>
<h3 id="KD树的构建过程是怎样的？">KD树的构建过程是怎样的？</h3>
<ol>
<li>
<p>在K维数据集合中选择具有最大方差的维度k，然后在该维度上选择中值m为pivot对该数据集合进行划分，得到两个子集合；同时创建一个树结点node，用于存储；</p>
</li>
<li>
<p>对两个子集合重复上一步骤的过程，直至所有子集合都不能再划分为止；如果某个子集合不能再划分时，则将该子集合中的数据保存到叶子结点（leaf node）。</p>
</li>
</ol>
<h3 id="高维情况下KD树查找性能如何优化？">高维情况下KD树查找性能如何优化？</h3>
<p>Kd-tree在维度较小时（例如：K≤30），算法的查找效率很高，然而当Kd-tree用于对高维数据（例如：K≥100）进行索引和查找时，就面临着维数灾难（curse of dimension）问题，查找效率会随着维度的增加而迅速下降。</p>
<p>在此情况下，我们可以使用优化后的算法BBF来处理，其主要的思路如下所示：<br>
bbf算法的思想比较简单，通过对回溯可能需要的路过的结点加入队列，并按照查找点到该结点确定的超平面的距离进行排序，然后每次首先遍历的是优先级最高（即距离最短的结点），直到队列为空算法结束。同时bbf算法也设立了一个时间限制，如果算法运行时间超过该限制，不管是不是为空，一律停止运行，返回当前的最近邻点作为结果。</p>
<p>bbf的算法流程如下：<br>
输入：kd树，查找点x<br>
输出：kd树种距离查找点最近的点以及最近的距离<br>
流程：<br>
（1）若kd树为空，则设定两者距离为无穷大，返回；如果kd树非空，则将kd树的根节点加入到优先级队列中；<br>
（2）从优先级队列中出队当前优先级最大的结点，计算当前的该点到查找点的距离是否比最近邻距离小，如果是则更新最近邻点和最近邻距离。如果查找点在切分维坐标小于当前点的切分维坐标，则把他的右孩子加入到队列中，同时检索它的左孩子，否则就把他的左孩子加入到队列中，同时检索它的右孩子。这样一直重复检索，并加入队列，直到检索到叶子节点。然后在从优先级队列中出队优先级最大的结点；<br>
（3）重复（1）和（2）中的操作，直到优先级队列为空，或者超出规定的时间，返回当前的最近邻结点和距离。</p>
<h3 id="KNN数据需要归一化吗？">KNN数据需要归一化吗？</h3>
<p>KNN对数据纲量敏感，所以数据要先归一化。因为KNN使用的方差来反映“距离”，纲量对方差计算影响较大。</p>
<h3 id="KNN的K设置的过大会有什么问题">KNN的K设置的过大会有什么问题?</h3>
<p>如果选择的K很大，相当于使用所有数据中标签多的样本进行预测，其可以减少学习的估计误差，会使学习的近似误差增大，如果考虑到极端情况，当k和整个样本的数量是一样的话，那么KNN的分类结果就是属于类别最多的那一类。<br>
如果选择较大的K值，就相当于用较大领域中的训练实例进行预测，<br>
其优点是可以减少学习的估计误差，<br>
但缺点是学习的近似误差会增大。</p>
<p>我们考虑一种极端的情况，当k和整个样本数量一样的，KNN的分类结果总是取决于样本类别数量最多的那一类。这时模型的误差最大化。</p>
<h3 id="KD树建立过程中切分维度的顺序是否可以优化？">KD树建立过程中切分维度的顺序是否可以优化？</h3>
<p>先对各个维度计算方差，选取最大方差的维度作为候选划分维度(方差越大，表示此维度上数据越分散)；对split维度上的值进行排序，选取中间的点为node-data；按照split维度的node-data对空间进行一次划分；对上述子空间递归以上操作，直到空间只包含一个数据点。分而治之，且循环选取坐标轴。从方差大的维度来逐步切分，可以取得更好的切分效果及树的平衡性。</p>
<h3 id="KNN为什么使用欧氏距离？">KNN为什么使用欧氏距离？</h3>
<p>⼀般⽤欧式距离⽽⾮曼哈顿距离的原因：欧式距离可适⽤于不同空间，表⽰不同空间点之间的距离；曼哈顿距离则只计算⽔平或垂直距离，有维度的限制</p>
<h3 id="KNN中K是怎么选的？">KNN中K是怎么选的？</h3>
<p>在实际应用中，K值一般取一个比较小的数值，例如采用交叉验证法（简单来说，就是一部分样本做训练集，一部分做测试集）来选择最优的K值。</p>
<p>1.如果选择较小的K值，就相当于用较小的领域中的训练实例进行预测，“学习”近似误差会减小，只有与输入实例较近或相似的训练实例才会对预测结果起作用，与此同时带来的问题是“学习”的估计误差会增大，换句话说，K值的减小就意味着整体模型变得复杂，容易发生过拟合；<br>
2.如果选择较大的K值，就相当于用较大领域中的训练实例进行预测，其优点是可以减少学习的估计误差，但缺点是学习的近似误差会增大。这时候，与输入实例较远（不相似的）训练实例也会对预测器作用，使预测发生错误，且K值的增大就意味着整体的模型变得简单。<br>
3.K=N，则完全不足取，因为此时无论输入实例是什么，都只是简单的预测它属于在训练实例中最多的类，模型过于简单，忽略了训练实例中大量有用信息。还有一些类似的用贝叶斯方法以及bootstrap方法也可以用来做。</p>
<h3 id="KNN的优缺点有哪些？">KNN的优缺点有哪些？</h3>
<p>优点</p>
<ol>
<li>简单，易于理解，易于实现。</li>
<li>只需保存训练样本和标记，无需估计参数，无需训练。</li>
<li>不易受小错误概率的影响。经理论证明，最近邻的渐进错误率最坏时不超过两倍的贝叶斯错误率，最好时接近或达到贝叶斯错误率。</li>
</ol>
<p>缺点</p>
<ol>
<li>K的选择不固定。</li>
<li>预测结果容易受含噪声数据的影响。</li>
<li>当样本不平衡时，新样本的类别偏向训练样本中数量占优的类别，容易导致预测错误。</li>
<li>具有较高的计算复杂度和内存消耗，因为对每一个待分类的文本，都要计算它到全体已知样本的距离，才能求得它的K个最近邻。</li>
</ol>
<h3 id="如何进行分组计算来解决KNN计算量过大的问题？">如何进行分组计算来解决KNN计算量过大的问题？</h3>
<p>先将样本按照距离分组，再计算每组内的质心，然后计算未知样本到每个质心的距离，最后选择一组或几组，在里面使用KNN。本质上就是先预处理一下，将对计算结果没有用大样本不参与后面的计算，然后在有用的样本内计算。</p>
<h3 id="KNN对不平衡样本的预测有哪些问题？">KNN对不平衡样本的预测有哪些问题？</h3>
<p>会把少数类别往多类别上预测，造成预测结果的不准，假设在训练中有100:1的负正样本比例，对于某个待预测的点来说，其周围一定范围内有50个负样本，2个正样本，这时候可能会预测出为负，但这样是不合理的，因为样本的比例差别太大。解决该方法的可以使用加权的方法，对少类别的样本进行加权，并通过实验来确定最优的权重。</p>
<h3 id="KNN分类和Kmeans的区别？">KNN分类和Kmeans的区别？</h3>
<p>KNN属于监督学习，类别是已知的，通过对已知分类的数据进行训练和学习，找到这些不同类的特征，再对未分类的数据进行分类。Kmeans属于非监督学习，事先不知道数据会分为几类，通过聚类分析将数据聚合成几个群体。聚类不需要对数据进行训练和学习。</p>
<h3 id="参考-4">参考</h3>
<blockquote>
<p><a href="https://www.csdn.net/tags/MtTaUg5sMzA1NzktYmxvZwO0O0OO0O0O.html">https://www.csdn.net/tags/MtTaUg5sMzA1NzktYmxvZwO0O0OO0O0O.html</a><br>
<a href="https://blog.csdn.net/cc13186851239/article/details/114377737">https://blog.csdn.net/cc13186851239/article/details/114377737</a><br>
<a href="https://blog.csdn.net/qq_42546127/article/details/103290498">https://blog.csdn.net/qq_42546127/article/details/103290498</a><br>
<a href="https://www.jianshu.com/p/abcaaf754f92">https://www.jianshu.com/p/abcaaf754f92</a><br>
<a href="https://zhuanlan.zhihu.com/p/377747470">https://zhuanlan.zhihu.com/p/377747470</a><br>
<a href="https://blog.csdn.net/lhanchao/article/details/52535694">https://blog.csdn.net/lhanchao/article/details/52535694</a><br>
<a href="https://zhuanlan.zhihu.com/p/521545516">https://zhuanlan.zhihu.com/p/521545516</a><br>
<a href="https://blog.csdn.net/weixin_46838716/article/details/124520422">https://blog.csdn.net/weixin_46838716/article/details/124520422</a><br>
<a href="https://blog.csdn.net/zsmjqtmd/article/details/124187905">https://blog.csdn.net/zsmjqtmd/article/details/124187905</a></p>
</blockquote>
<h2 id="SVM">SVM</h2>
<h3 id="请简单介绍下SVM？">请简单介绍下SVM？</h3>
<p>SVM是一类有监督的分类算法，它的大致思想是：假设样本空间上有两类点，我们希望找到一个划分超平面，将这两类样本分开，而划分超平面应该选择泛化能力最好的，也就是能使得两类样本中距离它最近的样本点距离最大。<br>
<img src="b0ab29eee88348a2819e85794815cb7d.png" alt="加载不了请走VPN"></p>
<h3 id="为什么SVM要引入核函数？">为什么SVM要引入核函数？</h3>
<p>当样本在原始空间线性不可分时，可将样本从原始空间映射到一个更高维的特征空间，使得样本在这个特征空间内线性可分。核函数就是这么一个映射的函数，而引入这样的映射后，所要求解的对偶问题的求解中，无需求解真正的映射函数，而只需要知道其核函数。核函数的定义：K(x,y)=&lt;ϕ(x),ϕ(y)&gt;，即在特征空间的内积等于它们在原始样本空间中通过核函数 K 计算的结果。一方面数据变成了高维空间中线性可分的数据，另一方面不需要求解具体的映射函数，只需要给定具体的核函数即可，这样使得求解的难度大大降低。</p>
<h3 id="SVM-为什么采用间隔最大化">SVM 为什么采用间隔最大化?</h3>
<p>当训练的数据线性可分的时候，可能会存在无限个超平面能够将正负样本分开，采用间隔最大化的做法，可以保证这个超平面是唯一的，就是距离正负样本都是最大的。</p>
<h3 id="SVM中的核函数有哪些？">SVM中的核函数有哪些？</h3>
<ul>
<li>Linear Kernel线性核</li>
<li>Polynomial Kernel多项式核</li>
<li>Exponential Kernel指数核</li>
<li>Gaussian Kernel高斯核</li>
<li>Laplacian Kernel拉普拉斯核</li>
<li>ANOVA Kernel</li>
<li>Sigmoid Kernel</li>
</ul>
<h3 id="SVM核函数之间的区别">SVM核函数之间的区别?</h3>
<p>主要在项目中用到的是：</p>
<ol>
<li>线性核<br>
表示简单且计算速度快，可以用于线性可分的情况下</li>
<li>多项式核<br>
可解决非线性问题，可通过主观设置幂数来实现总结的预判，对于大数量级的幂数，不太适用比较多的参数要选择</li>
<li>高斯核<br>
主要用于线性不可分的情形，参数多，分类结果非常依赖于参数。有很多人是通过训练数据的交叉验证来寻找合适的参数，不过这个过程比较耗时。</li>
</ol>
<h3 id="不同数据量和特征的情况下怎么选择核函数？">不同数据量和特征的情况下怎么选择核函数？</h3>
<ol>
<li>当特征维数 d 超过样本数 m 时 (文本分类问题通常是这种情况), 使用线性核;</li>
<li>当特征维数 d 比较小，样本数 m 中等时, 使用RBF核;</li>
<li>当特征维数 d 比较小，样本数 m 特别大时, 支持向量机性能通常不如深度神经网络。</li>
</ol>
<h3 id="SVM中的函数间隔和几何间隔是什么？">SVM中的函数间隔和几何间隔是什么？</h3>
<p>函数间隔 ： 对于在超平面上的点，  $wx+b=0$ 恒成立。而超平面之外的点，可以认为距离越远，  $wx+b$ 的绝对值越大，同时分类成功的概率也越高，表达式为：</p>
 $$
{\gamma _i} = {y_i}(w{x_i} + b)
$$ 
<p>几何间隔 ： 顾名思义，几何间隔就是两条平行线之间的距离，表达式为：</p>
 $$
{\gamma _i} = {y_i}(\frac{w}{{||w||}}{x_i} + \frac{b}{{||w||}})
$$ 
<h3 id="SVM为什么引入对偶问题？">SVM为什么引入对偶问题？</h3>
<ol>
<li>对偶问题将原始问题中的约束转为了对偶问题中的等式约束，对偶问题往往更加容易求解。</li>
<li>可以很自然的引用核函数（拉格朗日表达式里面有内积，而核函数也是通过内积进行映射的）。</li>
<li>在优化理论中，目标函数 f(x) 会有多种形式：如果目标函数和约束条件都为变量 x 的线性函数，称该问题为线性规划；如果目标函数为二次函数，约束条件为线性函数，称该最优化问题为二次规划；如果目标函数或者约束条件均为非线性函数，称该最优化问题为非线性规划。每个线性规划问题都有一个与之对应的对偶问题，对偶问题有非常良好的性质，以下列举几个：<br>
a, 对偶问题的对偶是原问题；<br>
b, 无论原始问题是否是凸的，对偶问题都是凸优化问题；<br>
c, 对偶问题可以给出原始问题一个下界；<br>
d, 当满足一定条件时，原始问题与对偶问题的解是完全等价的。</li>
</ol>
<h3 id="SVM中系数求解是怎么做的？">SVM中系数求解是怎么做的？</h3>
<p>SMO（Sequential Minimal Optimization）算法。有多个拉拉格朗日乘子，每次只选择其中两个乘子做优化，其他因子被认为是常数。将N个变量的求解问题，转换成两个变量的求解问题，并且目标函数是凸的。</p>
<h3 id="讲一下SVM中松弛变量和惩罚系数？">讲一下SVM中松弛变量和惩罚系数？</h3>
<p>松弛变量和惩罚因子是为了把线性可分SVM拓展为线性不可分SVM的。只有被决策面分类错误的点（线性不可分点）才会有松弛变量，然后惩罚因子是对线性不可分点的惩罚。 增大惩罚因子，模型泛化性能变弱，惩罚因子无穷大时，退化为线性可分SVM（硬间隔）； 减少惩罚因子，模型泛化性能变好。</p>
<h3 id="SVM在大数据情况下怎么办？">SVM在大数据情况下怎么办？</h3>
<p>原理上，SVM使用非线性特征映射将低维特征映射到高维，并通过kernel trick直接计算高维特征之间的内积，避免显式计算非线性特征映射，然后在高维特征空间中做线性分类。用 $\phi$ 表示非线性映射，它对应的核函数是，使得 $\left\langle {\phi (x),\phi (y)} \right\rangle  = k(x,y)$ 。</p>
<p>由于使用数据集的核矩阵（Kernel Matrix）描述样本之间的相似性，矩阵元素的个数随着数据规模增大成平方增长。这样要随着数据规模增大，SVM的计算变得无法处理。但是问题总是有解决方法的，2007年，Ali 等人在 NIPS发表Random Features for Large-Scale Kernel Machines，提出使用随机特征映射的方法处理大规模核函数的方法。其基本思想是，构造一个“随机”映射  直接将数据映射到高维空间，使得在这空间上的内积可以近似等于核函数。</p>
<h3 id="SVM为啥不加正则？">SVM为啥不加正则？</h3>
<p>对于SVM的original问题的表达形式如下：</p>
 $$
\begin{array}{l}
{\min _{w,b,\xi }} = \frac{1}{2}{\left\| w \right\|^2} + C\sum\limits_{i = 1}^N {{\xi _i}} \;\;\;\;\;\;\\
s.t.\;\;{y_i}(w{x_i} + b) \ge 1 - {\xi _i},i = 1,2, \cdots N\\
\;\;\;\;\;\;{\xi _i} > 0,\;\;\;i = 1,2, \cdots N
\end{array}
$$ 
<p>上面的这三个小等式可以由下面的一个式子来表示</p>
 $$
\begin{array}{l}
{\min _{w,b,\xi }} = \frac{1}{2}{\left\| w \right\|^2} + C\sum\limits_{i = 1}^N {{{[1 - {y_i}(w{x_i} + b)]}_ + }} \\
\;\;\;\;\;\;\;\;\;\;\; = \;\frac{1}{2}{\left\| w \right\|^2} + C\sum\limits_{i = 1}^N {{{[\xi ]}_ + }} \;\;\;\;\;
\end{array}
$$ 
<p>尾部的+号表示的意思是这个是一个合页损失函数，如下所示:</p>
 $$
{[z]_ + } = \left\{ \begin{array}{l}
z,z > 0\\
0,z \le 0
\end{array} \right.
$$ 
<p>可以从中看到，这就是一个加了正则化的合页损失函数的形式，因此是不需要加正则的。</p>
<h3 id="SVM和FM的区别？">SVM和FM的区别？</h3>
<p>1.SVM的二元特征交叉参数是独立的，而FM的二元特征交叉参数是两个k维的向量vi、vj，交叉参数就不是独立的，而是相互影响的。<br>
2.FM可以在原始形式下进行优化学习，而基于kernel的非线性SVM通常需要在对偶形式下进行。<br>
3.FM的模型预测与训练样本独立，而SVM则与部分训练样本有关，即支持向量。</p>
<h3 id="说说为什么svm中的某核能映射到无穷维">说说为什么svm中的某核能映射到无穷维</h3>
<p>SVM使用的核函数大致是那么几种，线性，多项式，高斯核。<br>
高斯核函数可以映射到无穷维，表达式如下：</p>
 $$
K({x_1},{x_2}) = \exp ( - \frac{{||{x_1} - {x_2}|{|^2}}}{{2{\sigma ^2}}})
$$ 
<p>展开后变成</p>
 $$
K({x_1},{x_2}) = \exp ( - \frac{{||{x_1} - {x_2}|{|^2}}}{{2{\sigma ^2}}}) = 1 + ( - \frac{{||{x_1} - {x_2}|{|^2}}}{{2{\sigma ^2}}}) + \frac{{ - {{(\frac{{||{x_1} - {x_2}|{|^2}}}{{2{\sigma ^2}}})}^2}}}{{2}} + \frac{{ - {{(\frac{{||{x_1} - {x_2}|{|^2}}}{{2{\sigma ^2}}})}^3}}}{{3}} + .... + \frac{{ - {{(\frac{{||{x_1} - {x_2}|{|^2}}}{{2{\sigma ^2}}})}^n}}}{{n}}
$$ 
<p>这就可以映射到无穷维了。</p>
<h3 id="SVM如何多分类？">SVM如何多分类？</h3>
<p>经典的支持向量机算法只给出了二类分类的算法，而在数据挖掘的实际应用中，一般要解决多类的分类问题。可以通过多个二类支持向量机的组合来解决。主要有一对多组合模式、一对一组合模式和SVM决策树；再就是通过构造多个分类器的组合来解决。主要原理是克服SVM固有的缺点，结合其他算法的优势，解决多类问题的分类精度。如：与粗集理论结合，形成一种优势互补的多类问题的组合分类器。</p>
<h3 id="为什么SVM对缺失数据敏感？">为什么SVM对缺失数据敏感？</h3>
<p>这里说的缺失数据是指缺失某些特征数据，向量数据不完整。SVM 没有处理缺失值的策略。而 SVM 希望样本在特征空间中线性可分，所以特征空间的好坏对SVM的性能很重要。缺失特征数据将影响训练结果的好坏。</p>
<h3 id="SVM的优缺点是什么？">SVM的优缺点是什么？</h3>
<ul>
<li>优点：</li>
</ul>
<ol>
<li>由于SVM是一个凸优化问题，所以求得的解一定是全局最优而不是局部最优。</li>
<li>不仅适用于线性线性问题还适用于非线性问题(用核技巧)。</li>
<li>拥有高维样本空间的数据也能用SVM，这是因为数据集的复杂度只取决于支持向量而不是数据集的维度，这在某种意义上避免了“维数灾难”。</li>
<li>理论基础比较完善。</li>
</ol>
<ul>
<li>缺点：</li>
</ul>
<ol>
<li>二次规划问题求解将涉及m阶矩阵的计算(m为样本的个数), 因此SVM不适用于超大数据集。(SMO算法可以缓解这个问题)。当样本数量比较大时，效果通常不如神经网络。</li>
<li>用SVM解决多分类问题存在困难</li>
<li>对缺失数据敏感，对参数和核函数的选择敏感</li>
</ol>
<h3 id="说一下一下SVR的原理？">说一下一下SVR的原理？</h3>
<p>传统回归模型的损失是计算模型输出f(x)和真实值y之间的差别，当且仅当f(x)=y时，损失才为零；但是SVR假设我们能容忍f(x)和y之间有一定的偏差，仅当f(x)和y之间的偏差大于该值时才计算损失。</p>
<h3 id="参考-5">参考</h3>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/43827793">https://zhuanlan.zhihu.com/p/43827793</a><br>
<a href="https://zhuanlan.zhihu.com/p/81890745">https://zhuanlan.zhihu.com/p/81890745</a><br>
<a href="https://blog.csdn.net/cc13186851239/article/details/114336039">https://blog.csdn.net/cc13186851239/article/details/114336039</a><br>
<a href="https://blog.csdn.net/Elford/article/details/121493152">https://blog.csdn.net/Elford/article/details/121493152</a><br>
<a href="https://www.csdn.net/tags/NtjaQg0sMDI3MDEtYmxvZwO0O0OO0O0O.html">https://www.csdn.net/tags/NtjaQg0sMDI3MDEtYmxvZwO0O0OO0O0O.html</a></p>
</blockquote>
<h2 id="NB">NB</h2>
<h3 id="朴素贝叶斯算法优缺点？">朴素贝叶斯算法优缺点？</h3>
<p>朴素贝叶斯的主要优点有：</p>
<ol>
<li>朴素贝叶斯模型有稳定的分类效率。</li>
<li>对小规模的数据表现很好，能处理多分类任务，适合增量式训练，尤其是数据量超出内存时，可以一批批的去增量训练。</li>
<li>对缺失数据不太敏感，算法也比较简单，常用于文本分类。</li>
</ol>
<p>朴素贝叶斯的主要缺点有：</p>
<ol>
<li>理论上，朴素贝叶斯模型与其他分类方法相比具有最小的误差率。但是实际上并非总是如此，这是因为朴素贝叶斯模型给定输出类别的情况下,假设属性之间相互独立，这个假设在实际应用中往往是不成立的，在属性个数比较多或者属性之间相关性较大时，分类效果不好。而在属性相关性较小时，朴素贝叶斯性能最为良好。对于这一点，有半朴素贝叶斯之类的算法通过考虑部分关联性适度改进。</li>
<li>需要知道先验概率，且先验概率很多时候取决于假设，假设的模型可以有很多种，因此在某些时候会由于假设的先验模型的原因导致预测效果不佳。</li>
<li>由于我们是通过先验和数据来决定后验的概率从而决定分类，所以分类决策存在一定的错误率。</li>
<li>对输入数据的表达形式很敏感。</li>
</ol>
<h3 id="什么是贝叶斯决策论？">什么是贝叶斯决策论？</h3>
<p>贝叶斯决策论是基于先验概率求解后验概率的方法，其核心是寻找一个判别准则使得条件风险达到最小。而在最小化分类错误率的目标下，贝叶斯最优分类器又可以转化为求后验概率达到最大的类别标记，即 h*（x) = argmaxP(i|x)。</p>
<h3 id="贝叶斯公式是啥？">贝叶斯公式是啥？</h3>
<p>贝叶斯定理由英国数学家贝叶斯 ( Thomas Bayes 1702-1761 ) 发展，用来描述两个条件概率之间的关系，比如 P(A|B) 和 P(B|A)。按照乘法法则，可以立刻导出：P(A∩B) = P(A)*P(B|A)=P(B)*P(A|B)。如上公式也可变形为：P(A|B)=P(B|A)*P(A)/P(B)。</p>
<h3 id="朴素怎么理解？">朴素怎么理解？</h3>
<p>朴素贝叶斯分类是一种十分简单的分类算法，其思想是朴素的，即：对于给出的待分类项，求解在此项出现的条件下各个类别出现的概率，哪个最大，就认为此待分类项属于哪个类别。</p>
<p>之所以被称为“朴素”， 是因为它假定所有的特征在数据集中的作用是同样重要和独立的，正如我们所知，这个假设在现实世界中是很不真实的，因此，说是很“朴素的”。</p>
<h3 id="贝叶斯学派和频率学派的区别？">贝叶斯学派和频率学派的区别？</h3>
<p>直至今日，关于统计推断的主张和想法，大体可以纳入到两个体系之内，其一叫频率学派，其特征是把需要推断的参数θ视作固定且未知的常数，而样本X是随机的，其着眼点在样本空间，有关的概率计算都是针对X的分布。另一派叫做贝叶斯学派，他们把参数θ视作随机变量，而样本X是固定的，其着眼点在参数空间，重视参数θ的分布，固定的操作模式是通过参数的先验分布结合样本信息得到参数的后验分布。</p>
<h3 id="什么是拉普拉斯平滑？">什么是拉普拉斯平滑？</h3>
<p>零概率问题：在计算事件的概率时，如果某个事件在观察样本库（训练集）中没有出现过，会导致该事件的概率结果是0。这是不合理的，不能因为一个事件没有观察到，就被认为该事件一定不可能发生（即该事件的概率为0）。</p>
<p>拉普拉斯平滑(Laplacian smoothing) 是为了解决零概率的问题。</p>
 $$
{\varphi _j} = \frac{{\sum\nolimits_{i = 1}^m {I({z^{(i)}} = j)}  + 1}}{m}
$$ 
<p>法国数学家 拉普拉斯 最早提出用 加1 的方法，估计没有出现过的现象的概率。<br>
理论假设：假定训练样本很大时，每个分量x的计数加1造成的估计概率变化可以忽略不计，但可以方便有效的避免零概率问题。</p>
<h3 id="朴素的缺点为什么有较好的表现效果？">朴素的缺点为什么有较好的表现效果？</h3>
<ol>
<li>对于分类任务来说，只要各个条件概率之间的排序正确，那么就可以通过比较概率大小来进行分类，不需要知道精确的概率值(朴素贝叶斯分类的核心思想是找出后验概率最大的那个类，而不是求出其精确的概率)</li>
<li>如果属性之间的相互依赖对所有类别的影响相同，或者相互依赖关系可以互相抵消，那么属性条件独立性的假设在降低计算开销的同时不会对分类结果产生不良影响。</li>
</ol>
<h3 id="朴素贝叶斯中有没有超参数可以调？">朴素贝叶斯中有没有超参数可以调？</h3>
<p>朴素贝叶斯是没有超参数可以调的，所以它不需要调参，朴素贝叶斯是根据训练集进行分类，分类出来的结果基本上就是确定了的，拉普拉斯估计器不是朴素贝叶斯中的参数，不能通过拉普拉斯估计器来对朴素贝叶斯调参。</p>
<h3 id="朴素贝叶斯中有多少种模型？">朴素贝叶斯中有多少种模型？</h3>
<p>朴素贝叶斯含有3种模型，分别是</p>
<ul>
<li>高斯模型<br>
对连续型数据进行处理</li>
<li>多项式模型<br>
对离散型数据进行处理，计算数据的条件概率(使用拉普拉斯估计器进行平滑的一个模型)</li>
<li>伯努利模型<br>
伯努利模型的取值特征是布尔型，即出现为ture,不出现为false,在进行文档分类时，就是一个单词有没有在一个文档中出现过。</li>
</ul>
<h3 id="朴素贝叶斯有哪些应用吗？">朴素贝叶斯有哪些应用吗？</h3>
<p>现实生活中朴素贝叶斯算法应用广泛，如文本分类，垃圾邮件的分类，信用评估，钓鱼网站检测等等。</p>
<h3 id="朴素贝叶斯对异常值敏不敏感？">朴素贝叶斯对异常值敏不敏感？</h3>
<p>朴素贝叶斯对异常值不敏感。所以在进行数据处理时，我们可以不去除异常值，因为保留异常值可以保持朴素贝叶斯算法的整体精度，而去除异常值则可能在进行预测的过程中由于失去部分异常值导致模型的泛化能力下降。</p>
<h3 id="朴素贝叶斯对缺失值敏不敏感？">朴素贝叶斯对缺失值敏不敏感？</h3>
<p>朴素贝叶斯是一种对缺失值不敏感的分类器，朴素贝叶斯算法能够处理缺失的数据，在算法的建模时和预测时数据的属性都是单独处理的。因此如果一个数据实例缺失了一个属性的数值，在建模时将被忽略，不影响类条件概率的计算，在预测时，计算数据实例是否属于某类的概率时也将忽略缺失属性，不影响最终结果。</p>
<h3 id="朴素贝叶斯是高方差还是低方差模型？">朴素贝叶斯是高方差还是低方差模型？</h3>
<p>朴素贝叶斯是低方差模型，可以看它的假设是独立同分布的，是一个简单的算法模型，而对于简单的模型来说，则恰恰相反，简单模型的偏差会更大，相对的，方差就会较小。(偏差是模型输出值与真实值的误差，也就是模型的精准度，方差是预测值与模型输出期望的的误差，即模型的稳定性，也就是数据的集中性的一个指标)</p>
<h3 id="朴素贝叶斯为什么适合增量计算？">朴素贝叶斯为什么适合增量计算？</h3>
<p>因为朴素贝叶斯在训练过程中实际只需要计算出各个类别的概率和各个特征的类条件概率，这些概率值可以快速的根据增量数据进行更新，无需重新全量训练，所以其十分适合增量计算，该特性可以使用在超出内存的大量数据计算和按小时级等获取的数据计算中。</p>
<h3 id="朴素贝叶斯与-LR-区别？">朴素贝叶斯与 LR 区别？</h3>
<ol>
<li>朴素贝叶斯是生成模型,LR是判别模型</li>
<li>朴素贝叶斯是基于很强的条件独立假设(在已知分类Y的条件下，各个特征变量取值是相互独立的)，而 LR 则对此没有要求</li>
<li>朴素贝叶斯适用于数据集少的情景，而LR适用于大规模数据集。</li>
</ol>
<h3 id="高度相关的特征对朴素贝叶斯有什么影响？">高度相关的特征对朴素贝叶斯有什么影响？</h3>
<p>假设有两个特征高度相关，相当于该特征在模型中发挥了两次作用(计算两次条件概率)，使得朴素贝叶斯获得的结果向该特征所希望的方向进行了偏移，影响了最终结果的准确性，所以朴素贝叶斯算法应先处理特征，把相关特征去掉。</p>
<h3 id="参考-6">参考</h3>
<blockquote>
<p><a href="https://blog.csdn.net/weixin_43868020/article/details/106602799">https://blog.csdn.net/weixin_43868020/article/details/106602799</a><br>
<a href="https://blog.csdn.net/jaffe507/article/details/105197631">https://blog.csdn.net/jaffe507/article/details/105197631</a></p>
</blockquote>
<h2 id="LDA-线性判别分析">LDA(线性判别分析)</h2>
<h3 id="请简单介绍下LDA？">请简单介绍下LDA？</h3>
<p>线性判别分析(LDA)是机器学习中常见的降维方法之一，它是一种有监督的线性的降维方法，主要思想是在给定训练集的情况下，将样本投影到一条直线上，使得同类的样本的投影尽可能的接近、异类样本的投影尽可能的远。<br>
<img src="addb57d34c264961adf843623d552ecd.png" alt="加载不了请走VPN"></p>
<h3 id="LDA和PCA的联系和区别？">LDA和PCA的联系和区别？</h3>
<p>相同点：</p>
<ol>
<li>两者均可以对数据进行降维。</li>
<li>两者在降维时均使用了矩阵特征分解的思想。</li>
<li>两者都假设数据符合高斯分布。</li>
</ol>
<p>不同点：</p>
<ol>
<li>LDA是有监督的降维方法，而PCA是无监督的降维方法</li>
<li>LDA降维最多降到类别数k-1的维数，而PCA没有这个限制。</li>
<li>LDA除了可以用于降维，还可以用于分类。</li>
<li>LDA选择分类性能最好的投影方向，而PCA选择样本点投影具有最大方差的方向。这点可以从下图形象的看出，在某些数据分布下LDA比PCA降维较优。</li>
</ol>
<h3 id="LDA的优缺点？">LDA的优缺点？</h3>
<p>LDA算法的主要优点有：</p>
<ol>
<li>在降维过程中可以使用类别的先验知识经验，而像PCA这样的无监督学习则无法使用类别先验知识。</li>
<li>LDA在样本分类信息依赖均值而不是方差的时候，比PCA之类的算法较优。</li>
</ol>
<p>LDA算法的主要缺点有：</p>
<ol>
<li>LDA不适合对非高斯分布样本进行降维，PCA也有这个问题。</li>
<li>LDA降维最多降到类别数k-1的维数，如果我们降维的维度大于k-1，则不能使用LDA。当然目前有一些LDA的进化版算法可以绕过这个问题。</li>
<li>LDA在样本分类信息依赖方差而不是均值的时候，降维效果不好。</li>
<li>LDA可能过度拟合数据。</li>
</ol>
<h3 id="LDA算法步骤简单说一下？">LDA算法步骤简单说一下？</h3>
<p>输入：数据集 {% raw%}$D{\rm{ = \{ (}}{x_1}{\rm{,}}{{\rm{y}}_1}{\rm{),(}}{x_2}{\rm{,}}{{\rm{y}}_2}{\rm{)}},{\rm{(}}{x_3}{\rm{,}}{{\rm{y}}_3}{\rm{)}} \cdots {\rm{(}}{x_m}{\rm{,}}{{\rm{y}}_m}{\rm{)\} }}${% endraw %}  ，其中任意样本 {% raw%}$x_i${% endraw %} 为 {% raw%}$n${% endraw %} 维向量， {% raw%}${y_i} \in \{ {C_1},{C_2}, \cdots ,{C_k}\}${% endraw %} ，降维到的维度 $d$ 。</p>
<p>输出：降维后的样本集 $\hat D$</p>
<ol>
<li>计算类内散度矩阵 $S_w$</li>
<li>计算类间散度矩阵 $S_b$</li>
<li>计算矩阵  $S^{-1} wS_b$</li>
<li>计算的最大的 $d$ 个特征值和对应的 $d$ 个特征向量 $w_1,w_2 \cdots w_n$ 得到投影矩阵 $w$</li>
<li>对样本集中的每一个样本特征 $x_i$ ,转化为新的样本，得到输出样本集</li>
</ol>
<h3 id="协方差为什么可以反映类内方差？">协方差为什么可以反映类内方差？</h3>
<p>协方差的表达式如下所示：</p>
 $$
\begin{array}{l}
{\mathop{\rm cov}}  = \frac{1}{n}\sum {(Y - \bar Y)} (Y - \bar Y)\\
{\mathop{\rm cov}}  = \frac{1}{n}\sum {(X - \bar X)} (X - \bar X)
\end{array}
$$ 
<p>可以看到协方差的公式和方差十分相近，甚至可以说方差是协方差的一种特例。我们知道方差可以用来度量数据的离散程度， $（X - \bar X）$ 越大，表示数据距离样本中心越远，数据越离散，数据的方差越大。同样我们观察，协方差的公式， $（X - \bar X）$ 和  $（Y - \bar Y）$  越大，表示数据距离样本中心越远，数据分布越分散，协方差越大。相反他们越小表示数据距离样本中心越近，数据分布越集中，协方差越小。</p>
<p>所以协方差不仅是反映了变量之间的相关性，同样反映了多维样本分布的离散程度（一维样本使用方差），协方差越大（对于负相关来说是绝对值越大），表示数据的分布越分散。所以上面的“欲使同类样例的投影点尽可能接近，可以让同类样本点的协方差矩阵尽可能小”就可以理解了。</p>
<h3 id="特征的辨识信息不是均值，LDA还可以用吗？">特征的辨识信息不是均值，LDA还可以用吗？</h3>
<p>LDA在样本分类信息依赖方差而不是均值的时候，降维效果不好；LDA是有监督学习，它既可以用作数据降维，又可以用于分类，但要保证不同类别数据的投影中心尽可能远；有辨识的信息即分类依据，如果有辨识的信息不是平均值，那么就无法保证投影后的异类数据点中心尽可能远，LDA就会失败。</p>
<h3 id="解释一下LDA的目标函数？">解释一下LDA的目标函数？</h3>
<p>LDA的目标函数包括两个部分，分别是类内方差和类间的距离，目标函数如下所示：</p>
 $$
J(w) = \frac{{|{{\tilde u}_1} - {{\tilde u}_2}{|^2}}}{{{{\tilde s}^2}_1 + {{\tilde s}^2}_2}}
$$ 
<p>分子表示不同类别均值之差，分母表示不同类别方差之和，因此我们的目标就是最大化 $J(w)$ 即可</p>
<h3 id="LDA需要对数据归一化吗？">LDA需要对数据归一化吗？</h3>
<p>LDA 假设输入变量是数值型且正态分布，并且它们具有相同的方差（分布）。如果不是这种情况，则可能需要将数据转换为具有高斯分布并在建模之前对数据进行标准化或归一化。</p>
<h3 id="参考-7">参考</h3>
<blockquote>
<p><a href="https://blog.csdn.net/qq_25990967/article/details/123465182">https://blog.csdn.net/qq_25990967/article/details/123465182</a><br>
<a href="https://www.jianshu.com/p/a6232ca325ed">https://www.jianshu.com/p/a6232ca325ed</a><br>
<a href="https://www.cnblogs.com/wj-1314/p/10234256.html">https://www.cnblogs.com/wj-1314/p/10234256.html</a><br>
<a href="https://zhuanlan.zhihu.com/p/468965293">https://zhuanlan.zhihu.com/p/468965293</a><br>
<a href="https://www.jianshu.com/p/13ec606fdd5f?ivk_sa=1024320u">https://www.jianshu.com/p/13ec606fdd5f?ivk_sa=1024320u</a></p>
</blockquote>
<h2 id="FM">FM</h2>
<h3 id="简单介绍下FM？">简单介绍下FM？</h3>
<p>FM即Factor Machine，因⼦分解机，算法可进行回归和二分类预测，它的特点是考虑了特征之间的相互作用，是一种非线性模型，目前FM算法是推荐领域被验证的效果较好的推荐方案之一，在诸多电商、广告、直播厂商的推荐领域有广泛应用。</p>
<h3 id="为什么使用FM？">为什么使用FM？</h3>
<p>在实际的工业界场景中，经常遇到类似点击率预测这种工程问题，其特征高维稀疏且需要考虑特征交叉，FM则提出了二阶特征交叉的思路用于完成LR不能进行特征交叉的缺陷，且对每个稀疏的特征学习相应的隐向量来缓解高维特征情况下的参数学习问题。</p>
<h3 id="FM的公式是什么样的？">FM的公式是什么样的？</h3>
<p>表达式如下：</p>
 $$
y = {w_0} + \sum\limits_{i = 1}^n {{w_i}{x_i} + \sum\limits_{i = 1}^{n - 1} {\sum\limits_{j = i + 1}^n {{w_{ij}}{x_i}{x_j}} } }
$$ 
<p>其中 $w_0$  为初始权值，或者理解为偏置项， $w_i$  为每个特征 $x_i$ 对应的权值。可以看到<br>
，FM的表达式只是在线性表达式后面加入了新的交叉项特征及对应的权值。</p>
<h3 id="FM公式是如何化简的？">FM公式是如何化简的？</h3>
<p>FM的简化主要体现在交叉特征系数的矩阵上，也就 $w_{ij}$ 这个参数上，FM为了简化计算，使用了隐向量的乘积来近似 $w_{ij}$ ，其中计算过程如下所示，最终的结果可以通过“两两相乘求和就等于先求和再平方减去先平方再求和””这个思路，将N方的复杂度降低到KN的复杂度，其中K为隐含向量的维度，其中简化的过程如下所示：</p>
 $$
[\begin{array}{l}
\sum\limits_{i = 1}^{n - 1} {\sum\limits_{j = i + 1}^n {{w_{ij}}{x_i}{x_j}} }  \approx \sum\limits_{i = 1}^{n - 1} {\sum\limits_{j = i + 1}^n { < {v_i}.{v_j} > {x_i}{x_j}} } \\
\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\; = \frac{1}{2}\sum\limits_{i = 1}^n {\sum\limits_{j = 1}^n { < {v_i}.{v_j} > {x_i}{x_j}} }  - \frac{1}{2}\sum\limits_{i = 1}^n { < {v_i},{v_j} > } {x_i}{x_i}\\
\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\; = \frac{1}{2}(\sum\limits_{i = 1}^n {\sum\limits_{j = 1}^n {\sum\limits_{f = 1}^k {{v_{i,f}}{v_{j,f}}} {x_i}{x_j}} }  - \sum\limits_{i = 1}^n {\sum\limits_{f = 1}^k {{v_{i,f}}{v_{i,f}}} } {x_i}{x_i})\\
\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\; = \frac{1}{2}\sum\limits_{f = 1}^k {((\sum\limits_{i = 1}^n {{v_{i,f}}{x_i}} )(\sum\limits_{j = 1}^n {{v_{j,f}}{x_j}} ) - \sum\limits_{i = 1}^n {{v^2}_{i,f}{x_i}^2} )} \\
\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\; = \frac{1}{2}\sum\limits_{f = 1}^k {({{(\sum\limits_{i = 1}^n {{v_{i,f}}{x_i}} )}^2} - \sum\limits_{i = 1}^n {{v^2}_{i,f}{x_i}^2} )} 
\end{array}
$$ 
<p>在实际的实现中，我们也不会对向量的每一位进行for循环计算，在tensorflow或pytorch里，我们直接可以计算出整个向量的结果。</p>
<h3 id="FM为什么要引入隐向量？">FM为什么要引入隐向量？</h3>
<p>为了用两个隐向量的內积模拟二次项的参数，从而极大降低参数个数，并且缓解二次项稀疏的问题。</p>
<p>假设有1万个特征，特征的两两组合，那么二次项就有  $C_{10000}^2$ 这么权重。</p>
<p>而加入隐向量后，可以看公式的等号右边：中括号内只有 $N$ 的复杂度，中括外边是 $k$ 的复杂度，因此总的复杂度就降到了  $kN$  。考虑到 $k$ 是隐向量的维度，可以根据效果和复杂度来人为指定，是远远小于特征数的，比如取 $k$ 为16，则 $kN=160000$ ，参数量是小来很多。</p>
<h3 id="FM如何做优化的？">FM如何做优化的？</h3>
<p>FM使用随机梯度下降法进行参数的更新，其中导数的计算如下所示：</p>
 $$
\frac{{\partial y}}{{\partial \theta }} = \left\{ \begin{array}{l}
1,\;\;\;if\;\theta \;is\;{w_0}\\
{x_i},\;\;if\;\theta \;is\;{w_i}\\
{x_i}\sum\nolimits_{j = 1}^n {{v_{j,f}}{x_j} - {v_{i,f}}{x_i}^2} ,\;if\;\theta \;is\;{v_{i,f}}
\end{array} \right.
$$ 
<h3 id="FM和SVM的区别？">FM和SVM的区别？</h3>
<p>FM和SVM最大的不同，在于特征组合时权重的计算方法</p>
<ol>
<li>SVM的二元特征交叉参数是独立的，而FM的二元特征交叉参数是两个k维的向量 $v_i, v_j$  ，交叉参数不是独立的，而是互相影响的</li>
<li>FM可以在原始形式下进行优化学习，而基于kernel的非线性SVM通常需要在对偶形式下进行</li>
<li>FM的模型预测与训练样本独立，而SVM则与部分训练样本有关，即支持向量</li>
</ol>
<h3 id="FM和FFM的区别？">FM和FFM的区别？</h3>
<ol>
<li>FFM将特征按照事先的规则分为多个filed，特征 $x_i$ 属于某个特定的场 $f$</li>
<li>当两个特征 $x_i, x_j$ 组合时，用对方对应的filed对应的隐向量做内积</li>
</ol>
<h3 id="FM和LR的区别？">FM和LR的区别？</h3>
<ol>
<li>FM学习的是特征的隐向量，没有出现的特征组合也可以通过隐向量内积得到，打破了特征之间的独立性。</li>
<li>LR学习的是组合特征的权重，没有出现过的特征组合，权重无法学习。对于稀疏样本 $ x_i*x_j $ 的组合不一定存在，LR就无法学习 $w_{ij}$</li>
</ol>
<h3 id="FFM中的F是什么意思？">FFM中的F是什么意思？</h3>
<p>FFM(Field Factorization Machine)是在FM的基础上引入了“场（Field）”的概念而形成的新模型。在FM中的特征 与其他特征的交叉时，特征 使用的都是同一个隐向量 。而FFM将特征按照事先的规则分为多个场(Field)，特征属于某个特定的场F。每个特征将被映射为多个隐向量 ，每个隐向量对应一个场。当两个特征 ,组合时，用对方对应的场对应的隐向量做内积。说白了就是一个特征的embedding不是[1,n]维的了，是[k,n]维了，其中k是场的数量。</p>
<h3 id="FFM现实使用中存在哪些问题？">FFM现实使用中存在哪些问题？</h3>
<ol>
<li>参数交大导致模型很大，如果我们的任务有100个特征域，FFM模型的参数量就是FM模型的大约100倍。在现实任务中，特征数量n是个很大的数值，特征域几十上百也很常见，这样的话，参数量会爆炸的。</li>
<li>正因为FFM模型参数量太大，所以在训练FFM模型的时候，很容易过拟合，需要采取早停等防止过拟合的手段。而根据经验，FFM模型的k值可以取得小一些，一般在几千万训练数据规模下，取8到10能取得较好的效果，当然，k具体取哪个数值，这其实跟具体训练数据规模大小有关系，理论上，训练数据集合越大，越不容易过拟合，这个k值可以设置得越大些。</li>
</ol>
<h3 id="FM算法的优缺点是什么？">FM算法的优缺点是什么？</h3>
<p>优点：</p>
<ol>
<li>支持非常稀疏的特征，适用在高维稀疏的情况下</li>
<li>FM的计算时间复杂度为线性的，并且可以直接优化原问题的参数</li>
</ol>
<p>缺点：</p>
<ol>
<li>在稠密特征的情况下，效果可能和LR差不多</li>
<li>特征组合也只能到二阶，三阶往上效率就变低了</li>
</ol>
<h3 id="FM如何用于多路召回？">FM如何用于多路召回？</h3>
<ol>
<li>基于离线数据训练号FM模型，得到各个特征维度的embedding</li>
<li>对于某个用户 $u$ ，我们可以把属于这个用户子集合的特征，查询离线训练好的FM模型对应的特征embedding向量，然后将 $n$ 个用户子集合的特征embedding向量累加，形成用户兴趣向量 $U$ ，这个向量维度和每个特征的维度是相同的</li>
<li>当用户登陆或者刷新页面时，可以根据用户ID取出其对应的兴趣向量embedding，然后和Faiss中存储的物料embedding做内积计算，按照得分由高到低返回得分Top K的物料作为召回结果。</li>
</ol>
<h3 id="参考-8">参考</h3>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/298277108">https://zhuanlan.zhihu.com/p/298277108</a><br>
<a href="https://blog.csdn.net/GFDGFHSDS/article/details/104782245/">https://blog.csdn.net/GFDGFHSDS/article/details/104782245/</a><br>
<a href="https://blog.csdn.net/Super_Json/article/details/105324546">https://blog.csdn.net/Super_Json/article/details/105324546</a><br>
<a href="https://zhuanlan.zhihu.com/p/58160982">https://zhuanlan.zhihu.com/p/58160982</a><br>
<a href="https://blog.csdn.net/zwqjoy/article/details/118145249">https://blog.csdn.net/zwqjoy/article/details/118145249</a><br>
<a href="https://blog.csdn.net/Su_Mo/article/details/11699324">https://blog.csdn.net/Su_Mo/article/details/11699324</a></p>
</blockquote>
</0$></p>]]></content>
      <categories>
        <category>算法面试</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>刷八股</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习理论</title>
    <url>/2024/03/19/machine_learning/ml_theory/</url>
    <content><![CDATA[<h1>机器学习理论</h1>
<h2 id="数学知识">数学知识</h2>
<h3 id="机器学习中的距离和相似度度量方式有哪些？">机器学习中的距离和相似度度量方式有哪些？</h3>
<ul>
<li>欧氏距离</li>
<li>曼哈顿距离</li>
<li>切比雪夫距离</li>
<li>闵可夫斯基距离</li>
<li>标准化欧氏距离</li>
<li>马氏距离</li>
<li>夹角余弦</li>
<li>汉明距离<br>
这里无法给出具体的公式，定义是两个等长字符串s1与s2之间的汉明距离定义为将其中一个变为另外一个所需要作的最小替换次数。例如字符串“1111”与“1001”之间的汉明距离为2</li>
<li>杰卡德距离 &amp; 杰卡德相似系数</li>
<li>相关系数 &amp; 相关距离</li>
</ul>
<h3 id="马氏距离比欧式距离的异同点？">马氏距离比欧式距离的异同点？</h3>
<p>马氏距离（Mahalanobis Distance）是由印度统计学家马哈拉诺比斯（P. C. Mahalanobis）提出的，表示数据的协方差距离。它是一种有效的计算两个未知样本集的相似度的方法。与欧氏距离不同的是它考虑到各种特性之间的联系（例如：一条关于身高的信息会带来一条关于体重的信息，因为两者是有关联的）并且是尺度无关的（scale-invariant），即独立于测量尺度。</p>
<p>马氏距离有很多优点，马氏距离不受量纲的影响，两点之间的马氏距离与原始数据的测量单位无关；由标准化数据和中心化数据(即原始数据与均值之差）计算出的二点之间的马氏距离相同。马氏距离还可以排除变量之间的相关性的干扰。它的缺点是夸大了变化微小的变量的作用。</p>
<h3 id="张量与矩阵的区别？">张量与矩阵的区别？</h3>
<ul>
<li>从代数角度讲， 矩阵它是向量的推广。向量可以看成一维的“表格”（即分量按照顺序排成一排）， 矩阵是二维的“表格”（分量按照纵横位置排列）， 那么阶张量就是所谓的维的“表格”。张量的严格定义是利用线性映射来描述。</li>
<li>从几何角度讲， 矩阵是一个真正的几何量，也就是说，它是一个不随参照系的坐标变换而变化的东西。向量也具有这种特性。</li>
</ul>
<h3 id="如何判断矩阵为正定？">如何判断矩阵为正定？</h3>
<p>判定一个矩阵是否为正定，通常有以下几个方面：</p>
<ul>
<li>顺序主子式全大于0；</li>
<li>存在可逆矩阵$C$使得$C^TC$等于该矩阵；</li>
<li>正惯性指数等于n；</li>
<li>合同于单位矩阵$E$（即：规范形为$E$）</li>
<li>标准形中主对角元素全为正；</li>
<li>特征值全为正；</li>
<li>是某基的度量矩阵。</li>
</ul>
<h3 id="距离的严格定义？">距离的严格定义？</h3>
<p>距离的定义：在一个集合中，如果每一对元素均可唯一确定一个实数，使得三条距离公理（正定性，对称性，三角不等式）成立，则该实数可称为这对元素之间的距离。</p>
<p>在机器学习领域，被俗称为距离，却不满足三条距离公理的不仅仅有余弦距离，还有 KL 距离，也叫作相对熵，它常用于计算两个分布之间的差异，但不满足对称性和三角不等式。<br>
来自</p>
<h3 id="参考">参考</h3>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/85408804">https://zhuanlan.zhihu.com/p/85408804</a><br>
<a href="https://www.zhihu.com/question/27057384/answer/2182368961">https://www.zhihu.com/question/27057384/answer/2182368961</a></p>
</blockquote>
<h2 id="概率论">概率论</h2>
<h3 id="什么是概率？">什么是概率？</h3>
<p>“概率，亦称“或然率”，它是反映随机事件出现的可能性大小。</p>
<h3 id="概率和频率的区别？">概率和频率的区别？</h3>
<p>概率是一个稳定的数值，也就是某件事发生或不发生的概率是多少。频率是在一定数量的某件事情上面，发生的数与总数的比值。频率是有限次数的试验所得的结果，概率是频数无限大时对应的频率。</p>
<h3 id="泊松分布与二项分布的关系？">泊松分布与二项分布的关系？</h3>
<p>泊松分布可看成是二项分布的极限而得到，当$\lambda = np$时，两者是相同的。</p>
<h3 id="常见分布的期望和方差是什么？">常见分布的期望和方差是什么？</h3>
<p><img src="https://s21.ax1x.com/2024/03/23/pFh7pxe.png" alt="image"></p>
<h3 id="什么是大数定理？">什么是大数定理？</h3>
<p>大数定理简单来说，指得是某个随机事件在单次试验中可能发生也可能不发生，但在大量重复实验中往往呈现出明显的规律性，即该随机事件发生的频率会向某个常数值收敛，该常数值即为该事件发生的概率。</p>
<p>另一种表达方式为当样本数据无限大时，样本均值趋于总体均值。</p>
<p>因为现实生活中，我们无法进行无穷多次试验，也很难估计出总体的参数。</p>
<p>大数定律告诉我们能用频率近似代替概率；能用样本均值近似代替总体均值。</p>
<h3 id="什么是中心极限定理？">什么是中心极限定理？</h3>
<p>中心极限定理是概率论中的一组重要定理，它的中心思想是无论是什么分布的数据，当我们从中抽取相互独立的随机样本，且采集的样本足够多时，样本均值的分布将收敛于正态分布。</p>
<h3 id="求最大似然估计量的一般步骤？">求最大似然估计量的一般步骤？</h3>
<ol>
<li>写出似然函数</li>
<li>对似然函数取对数，并整理</li>
<li>求导数</li>
<li>解似然方程</li>
</ol>
<h3 id="什么是无偏性？">什么是无偏性？</h3>
<p>无偏性（Unbiasedness）是指单凭某一次抽样的样本是不具有说服力的，必须要通过很多次抽样的样本来衡量。因此，我们容易能想到的就是，经过多次抽样后，将所有的点估计值平均起来，也就是取期望值，这个期望值应该和总体参数一样。这就是所谓的无偏性（Unbiasedness）。</p>
<h3 id="说一下条件概率、全概率和贝叶斯公式？">说一下条件概率、全概率和贝叶斯公式？</h3>
<ul>
<li>条件概率/分布律（乘法公式）</li>
</ul>
<p>P(A|B)=P(AB)/P(B)，演化式P(A|B)*P(B)=P(B|A)*P(A)</p>
<ul>
<li>全概率公式</li>
</ul>
<p>P(A)= P(A|B1)+P(A|B2)+P(A|B3)+…+P(A|Bn)，其中A为样本空间的事件，B1、B2、B3…Bn为样本空间的一个划分。</p>
<ul>
<li>贝叶斯公式</li>
</ul>
<p>P(Bi|A)= P(A|Bi)*P(Bi)/[P(A|B1)+P(A|B2)+P(A|B3)+…+P(A|Bn)]，其中A为样本空间的事件，B1、B2、B3…Bn为样本空间的一个划分。</p>
<h3 id="一句话解释极大似然估计法和概率的区别">一句话解释极大似然估计法和概率的区别?</h3>
<p>概率是已知分布和参数，求事件结果出现的次数；极大似然估计是已知分布和事件结果出现的次数，估计事件结果以最大概率的出现情况下的参数。</p>
<h3 id="极大似然估计，最大后验估计的区别？">极大似然估计，最大后验估计的区别？</h3>
<p>当先验概率是分布均匀的情况下，则相当于没有给参数提供任何有用的信息，例如每种情况都是等概率的事件，那此时的极大似然估计就等于最大后验估计。</p>
<p>因此，可以把极大似然估计看成一种特殊的先验概率为均匀分布的最大后验估计，</p>
<p>也可以把最大后验估计估计看成是必须考虑先验概率的极大似然估计（即最大后验估计是规则化的)极大似然估计）</p>
<h3 id="协方差为0，一定独立吗？">协方差为0，一定独立吗？</h3>
<p>因为协方差等于零只能推出不相关的，所以不能推出互相独立的。但互相独立的可以推出互不相干的。比如X=cosa, Y=sina, 则X和Y的协方差为0, 但是X,Y两者不独立.</p>
<p>协方差的算法：COV(X,Y)=E{(X-E(X))(Y=E(Y))}E为数学期望；它反映随机变量平均取值的大小。又称期望或均值。它是简单算术平均的一种推广。</p>
<h3 id="参考-2">参考</h3>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/87299555">https://zhuanlan.zhihu.com/p/87299555</a><br>
<a href="https://zhuanlan.zhihu.com/p/427883809">https://zhuanlan.zhihu.com/p/427883809</a><br>
<a href="https://blog.csdn.net/qq_41897154/article/details/109125820">https://blog.csdn.net/qq_41897154/article/details/109125820</a><br>
<a href="https://blog.csdn.net/m0_37382341/article/details/80049976">https://blog.csdn.net/m0_37382341/article/details/80049976</a><br>
<a href="https://zhuanlan.zhihu.com/p/159115973">https://zhuanlan.zhihu.com/p/159115973</a></p>
</blockquote>
<h2 id="学习理论">学习理论</h2>
<h3 id="什么是表示学习？">什么是表示学习？</h3>
<p>在深度学习领域内，表示是指通过模型的参数，采用何种形式、何种方式来表示模型的输入观测样本X。表示学习指学习对观测样本X有效的表示。</p>
<h3 id="什么是端到端学习？">什么是端到端学习？</h3>
<p>端到端学习（End-to-End Learning），也称端到端训练，是指在学习过程中不进行分模块或分阶段训练，直接优化任务的总体目标．在端到端学习中，一般不需要明确地给出不同模块或阶段的功能，中间过程不需要人为干预</p>
<h3 id="机器学习的学习方式主要有哪些">机器学习的学习方式主要有哪些?</h3>
<p>监督学习</p>
<p>非监督式学习</p>
<p>半监督式学习</p>
<p>弱监督学习</p>
<h3 id="如何开展监督学习">如何开展监督学习?</h3>
<p>步骤1：数据集的创建和分类 。</p>
<p>步骤2：数据增强（Data Augmentation）</p>
<p>步骤3：特征工程（Feature Engineering）</p>
<p>步骤4：构建预测模型和损失</p>
<p>步骤5：训练</p>
<p>步骤6：验证和模型选择</p>
<p>步骤7：测试及应用</p>
<h3 id="类别不均衡问题怎么做">类别不均衡问题怎么做?</h3>
<p>防止类别不平衡对学习造成的影响，在构建分类模型之前，需要对分类不平衡性问题进行处理。主要解决方法有：</p>
<p>1、扩大数据集</p>
<p>增加包含小类样本数据的数据，更多的数据能得到更多的分布信息。</p>
<p>2、对大类数据欠采样</p>
<p>减少大类数据样本个数，使与小样本个数接近。 缺点：欠采样操作时若随机丢弃大类样本，可能会丢失重要信息。 代表算法：EasyEnsemble。其思想是利用集成学习机制，将大类划分为若干个集合供不同的学习器使用。相当于对每个学习器都进行欠采样，但对于全局则不会丢失重要信息。</p>
<p>3、对小类数据过采样</p>
<p>过采样：对小类的数据样本进行采样来增加小类的数据样本个数。</p>
<p>代表算法：SMOTE和ADASYN。</p>
<p>SMOTE：通过对训练集中的小类数据进行插值来产生额外的小类样本数据。</p>
<p>新的少数类样本产生的策略：对每个少数类样本a，在a的最近邻中随机选一个样本b，然后在a、b之间的连线上随机选一点作为新合成的少数类样本。 ADASYN：根据学习难度的不同，对不同的少数类别的样本使用加权分布，对于难以学习的少数类的样本，产生更多的综合数据。通过减少类不平衡引入的偏差和将分类决策边界自适应地转移到困难的样本两种手段，改善了数据分布。</p>
<p>4、使用新评价指标</p>
<p>如果当前评价指标不适用，则应寻找其他具有说服力的评价指标。比如准确度这个评价指标在类别不均衡的分类任务中并不适用，甚至进行误导。因此在类别不均衡分类任务中，需要使用更有说服力的评价指标来对分类器进行评价。</p>
<p>5、选择新算法</p>
<p>不同的算法适用于不同的任务与数据，应该使用不同的算法进行比较。</p>
<p>6、数据代价加权</p>
<p>例如当分类任务是识别小类，那么可以对分类器的小类样本数据增加权值，降低大类样本的权值，从而使得分类器将重点集中在小类样本身上。</p>
<p>7、转化问题思考角度</p>
<p>例如在分类问题时，把小类的样本作为异常点，将问题转化为异常点检测或变化趋势检测问题。异常点检测即是对那些罕见事件进行识别。变化趋势检测区别于异常点检测在于其通过检测不寻常的变化趋势来识别。</p>
<p>8、将问题细化分析</p>
<p>对问题进行分析与挖掘，将问题划分成多个更小的问题，看这些小问题是否更容易解决。</p>
<h3 id="维度灾难是啥？怎么避免？">维度灾难是啥？怎么避免？</h3>
<p>维数灾难(Curse of Dimensionality)：通常是指在涉及到向量的计算的问题中，随着维数的增加，计算量呈指数倍增长的一种现象。维数灾难涉及数字分析、抽样、组合、机器学习、数据挖掘和数据库等诸多领域。在机器学习的建模过程中，通常指的是随着特征数量的增多，计算量会变得很大，如特征得到上亿维的话，在进行计算的时候是算不出来的。如我们熟悉的KNN的问题，如果不是 构建Kd数等可以加快计算，按照暴力的话，计算量是很大的。而且有的时候，维度太大也会导致机器学习性能的下降，并不是特征维度越大越好，模型的性能会随着特征的增加先上升后下降。</p>
<p>解决维度灾难问题：</p>
<ol>
<li>主成分分析法PCA，线性判别法LDA</li>
<li>奇异值分解简化数据、拉普拉斯特征映射</li>
<li>Lassio缩减系数法、小波分析法</li>
</ol>
<h3 id="生成模型和判别模型的区别">生成模型和判别模型的区别?</h3>
<p>判别模型：由数据直接学习决策函数Y=f(X)或者条件概率分布P(Y|X)作为预测的模型，即判别模型。基本思想是有限样本条件下建立判别函数，不考虑样本的产生模型，直接研究预测模型。典型的判别模型包括k近邻，感知级，决策树，支持向量机等。</p>
<p>生成模型：由数据学习联合概率密度分布P(X,Y)，然后求出条件概率分布P(Y|X)作为预测的模型，即生成模型：P(Y|X)= P(X,Y)/ P(X)。基本思想是首先建立样本的联合概率概率密度模型P(X,Y)，然后再得到后验概率P(Y|X)，再利用它进行分类。常见的有NB HMM模型。</p>
<h2 id="优化理论">优化理论</h2>
<h3 id="什么是凸优化？">什么是凸优化？</h3>
<p>凸优化问题（OPT，convex optimization problem）指定义在凸集中的凸函数最优化的问题。尽管凸优化的条件比较苛刻，但仍然在机器学习领域有十分广泛的应用。</p>
<h3 id="凸优化的优势是什么？">凸优化的优势是什么？</h3>
<ol>
<li>凸优化问题的局部最优解就是全局最优解</li>
<li>很多非凸问题都可以被等价转化为凸优化问题或者被近似为凸优化问题（例如拉格朗日对偶问题）</li>
<li>凸优化问题的研究较为成熟，当一个具体被归为一个凸优化问题，基本可以确定该问题是可被求解的</li>
</ol>
<h3 id="如何判断函数是否为凸的">如何判断函数是否为凸的?</h3>
<p>熟悉凸函数的定义，即在凸的定义域上取两个点$x,y$ ，其凸组合的值应该小于等于其值的凸组合，对任意$\lambda  \in [0,1]$,有的话$f(\lambda x + (1 - \lambda )y) \le \lambda f(x) + (1 - \lambda )f(y)$,那么它就是凸函数。</p>
<h3 id="什么是鞍点？">什么是鞍点？</h3>
<p>鞍点（Saddle point）在微分方程中，沿着某一方向是稳定的，另一条方向是不稳定的奇点，叫做鞍点。在泛函中，既不是极大值点也不是极小值点的临界点，叫做鞍点。在矩阵中，一个数在所在行中是最大值，在所在列中是最小值，则被称为鞍点。在物理上要广泛一些，指在一个方向是极大值，另一个方向是极小值的点。从海塞矩阵的角度来说，Hessian矩阵不定的点称为鞍点，它不是函数的极值点。</p>
<p><img src="https://s21.ax1x.com/2024/03/23/pFh7iqA.png" alt="image"></p>
<h3 id="解释什么是局部极小值，什么是全局极小值？">解释什么是局部极小值，什么是全局极小值？</h3>
<p>局部极值点：假设是一个$X^<em>$可行解，如果对可行域内所有点$X$都有$f({x^</em>}) \le f(x)$，则称为全局极小值。</p>
<p>全局极值点。对于可行解$X^<em>$，如果存在其邻域$\delta$，使得该邻域内的所有点即所有满足$||x - x</em>|| \le \delta$的点$x$，都有$f({x^*}) \le f(x)$，则称为局部极小值。</p>
<h3 id="既然有全局最优，为什么还需要有局部最优呢？">既然有全局最优，为什么还需要有局部最优呢？</h3>
<p>对于优化问题，尤其是最优化问题，总是希望能找到全局最优的解决策略，但是当问题的复杂度过于⾼，要考虑的因素和处理的信息量过多的时候，我们往往会倾向于接受局部最优解，因为局部最优解的质量不⼀定最差的。尤其是当我们有确定的评判标准标明得出的解释可以接受的话，通常会接受局部最优的结果。这样，从成本、效率等多⽅⾯考虑，才是实际⼯程中会才去的策略。</p>
<h3 id="机器学习有哪些优化方法？">机器学习有哪些优化方法？</h3>
<p>机器学习和深度学习中常用的算法包含不局限如下：梯度下降、牛顿法和拟牛顿、动量法momentum、Adagrad、RMSProp、Adadelta、Adam等，无梯度优化算法也有很多，像粒子群优化算法、蚁群算法、遗传算法、模拟退火等群体智能优化算法。<br>
几个常见的优化方法的比较如下：<br>
<img src="https://i.hd-r.cn/2744457cc4f3f695a6042570f5b367d7.png" alt="image"></p>
<h3 id="梯度下降法和牛顿法能保证找到函数的极小值点吗，为什么？">梯度下降法和牛顿法能保证找到函数的极小值点吗，为什么？</h3>
<p>不能，可能收敛到鞍点，不是极值点。</p>
<h3 id="解释一元函数极值判别法则是什么？">解释一元函数极值判别法则是什么？</h3>
<p>假设为函数的驻点，可分为以下三种情况。</p>
<p>情况一：在该点处的二阶导数大于0，则为函数的极小值点；<br>
情况二：在该点处的二阶导数小于0，则为极大值点；<br>
情况三：在该点处的二阶导数等于0，则情况不定，可能是极值点，也可能不是极值点。</p>
<h3 id="解释多元函数极值判别法则是什么？">解释多元函数极值判别法则是什么？</h3>
<p>假设多元函数在点M的梯度为0，即M是函数的驻点。其Hessian矩阵有如下几种情况。</p>
<p>情况一：Hessian矩阵正定，函数在该点有极小值。<br>
情况二：Hessian矩阵负定，函数在该点有极大值。<br>
情况三：Hessian矩阵不定，则不是极值点，称为鞍点。</p>
<p>Hessian矩阵正定类似于一元函数的二阶导数大于0，负定则类似于一元函数的二阶导数小于0。</p>
<h3 id="什么是对偶问题？">什么是对偶问题？</h3>
<p>可以将对偶问题看成是关于原问题松弛问题的优化问题，对偶问题的目标，是以一定方式，找到最贴近原问题的松弛问题。如果将原问题以对偶变量为参数进行松弛，将得到一系列以对偶变量为参数的松弛问题（例如拉格朗日松弛问题，是以拉格朗日乘子为参数，将原问题约束松弛到目标函数后得到的松弛问题）对偶问题则是通过优化对偶变量，找到最逼近原问题的松弛问题（例如拉格朗日对偶问题，是优化拉格朗日乘子，得到最接近原问题的松弛问题，即原问题的下界）</p>
<h3 id="随机梯度下降法、批量梯度下降法有哪些区别？">随机梯度下降法、批量梯度下降法有哪些区别？</h3>
<p>批量梯度下降：<br>
(1) 采用所有数据来梯度下降。<br>
(2) 批量梯度下降法在样本量很大的时候，训练速度慢。</p>
<p>随机梯度下降<br>
(1) 随机梯度下降用一个样本来梯度下降。<br>
(2) 训练速度很快。<br>
(3) 随机梯度下降法仅仅用一个样本决定梯度方向，导致解有可能不是全局最优。<br>
(4) 收敛速度来说，随机梯度下降法一次迭代一个样本，导致迭代方向变化很大，不能很快的收敛到局部最优解。</p>
<h3 id="各种梯度下降法性能对比？">各种梯度下降法性能对比？</h3>
<p><img src="news.png" alt="图片"></p>
<h3 id="说一下梯度下降法缺点">说一下梯度下降法缺点?</h3>
<ol>
<li>靠近极小值时收敛速度减慢<br>
在极小值点附近的话，梯度比较小了，毕竟那个点的梯度都快为零了，收敛的就慢了</li>
<li>直线搜索时可能会产生一些问题<br>
步子大或者小会导致来回的震荡，导致不太好收敛</li>
<li>可能会“之字形”地下降<br>
如下所示，梯度下降会来回走之字，导致优化速度慢</li>
</ol>
<h3 id="如何对梯度下降法进行调优">如何对梯度下降法进行调优?</h3>
<ol>
<li>
<p>算法迭代步长选择<br>
在算法参数初始化时，有时根据经验将步长初始化为1。实际取值取决于数据样本。可以从大到小，多取一些值，分别运行算法看迭代效果，如果损失函数在变小，则取值有效。如果取值无效，说明要增大步长。但步长太大，有时会导致迭代速度过快，错过最优解。步长太小，迭代速度慢，算法运行时间长。</p>
</li>
<li>
<p>参数的初始值选择<br>
初始值不同，获得的最小值也有可能不同，梯度下降有可能得到的是局部最小值。如果损失函数是凸函数，则一定是最优解。由于有局部最优解的风险，需要多次用不同初始值运行算法，关键损失函数的最小值，选择损失函数最小化的初值。</p>
</li>
<li>
<p>标准化处理<br>
由于样本不同，特征取值范围也不同，导致迭代速度慢。为了减少特征取值的影响，可对特征数据标准化，使新期望为0，新方差为1，可节省算法运行时间。</p>
</li>
</ol>
<h3 id="随机梯度下降法、批量梯度下降法有哪些区别？-2">随机梯度下降法、批量梯度下降法有哪些区别？</h3>
<p>批量梯度下降：<br>
(1) 采用所有数据来梯度下降。<br>
(2) 批量梯度下降法在样本量很大的时候，训练速度慢。<br>
随机梯度下降<br>
(1) 随机梯度下降用一个样本来梯度下降。<br>
(2) 训练速度很快。<br>
(3) 随机梯度下降法仅仅用一个样本决定梯度方向，导致解有可能不是全局最优。<br>
(4) 收敛速度来说，随机梯度下降法一次迭代一个样本，导致迭代方向变化很大，不能很快的收敛到局部最优解。</p>
<h3 id="梯度下降法缺点">梯度下降法缺点</h3>
<p>梯度下降法是最早最简单，也是最为常用的最优化方法。梯度下降法实现简单，当目标函数是凸函数时，梯度下降法的解是全局解。<br>
一般情况下，其解不保证是全局最优解，梯度下降法的速度也未必是最快的。梯度下降法的优化思想是用当前位置负梯度方向作为搜索方向，因为该方向为当前位置的最快下降方向，所以也被称为是”最速下降法“。最速下降法越接近目标值，步长越小，前进越慢。</p>
<p>梯度下降法缺点有以下几点：<br>
（1）靠近极小值时收敛速度减慢。<br>
在极小值点附近的话，梯度比较小了，毕竟那个点的梯度都快为零了，收敛的就慢了<br>
（2）直线搜索时可能会产生一些问题。<br>
步子大或者小会导致来回的震荡，导致不太好收敛<br>
（3）可能会“之字形”地下降。<br>
如下所示，梯度下降会来回走之字，导致优化速度慢</p>
<p><a href="https://blog.csdn.net/qq_40722827/article/details/107297535%E3%80%81">https://blog.csdn.net/qq_40722827/article/details/107297535、</a></p>
<h3 id="批量梯度下降和随机梯度下降法的缺点？">批量梯度下降和随机梯度下降法的缺点？</h3>
<p>批量梯度下降<br>
a）采用所有数据来梯度下降。<br>
b）批量梯度下降法在样本量很大的时候，训练速度慢。<br>
随机梯度下降	<br>
a）随机梯度下降用一个样本来梯度下降。<br>
b）训练速度很快。<br>
c）随机梯度下降法仅仅用一个样本决定梯度方向，导致解有可能不是全局最优。<br>
d）收敛速度来说，随机梯度下降法一次迭代一个样本，导致迭代方向变化很大，不能很快的收敛到局部最优解。</p>
<h3 id="如何对梯度下降法进行调优-2">如何对梯度下降法进行调优?</h3>
<p>实际使用梯度下降法时，各项参数指标不能一步就达到理想状态，对梯度下降法调优主要体现在以下几个方面：</p>
<p>（1）算法迭代步长$\alpha$选择。 在算法参数初始化时，有时根据经验将步长初始化为1。实际取值取决于数据样本。可以从大到小，多取一些值，分别运行算法看迭代效果，如果损失函数在变小，则取值有效。如果取值无效，说明要增大步长。但步长太大，有时会导致迭代速度过快，错过最优解。步长太小，迭代速度慢，算法运行时间长。</p>
<p>（2）参数的初始值选择。 初始值不同，获得的最小值也有可能不同，梯度下降有可能得到的是局部最小值。如果损失函数是凸函数，则一定是最优解。由于有局部最优解的风险，需要多次用不同初始值运行算法，关键损失函数的最小值，选择损失函数最小化的初值。</p>
<p>（3）标准化处理。 由于样本不同，特征取值范围也不同，导致迭代速度慢。为了减少特征取值的影响，可对特征数据标准化，使新期望为0，新方差为1，可节省算法运行时间。</p>
<h3 id="各种梯度下降法性能比较">各种梯度下降法性能比较</h3>
<p>对比维度-BGD-SGD-Mini-batch GD-Online GD<br>
训练集-固定-固定-固定-实时更新<br>
单次迭代样本数-整个训练集-单个样本-训练集的子集-根据具体算法定<br>
算法复杂度-高-低-一般-低<br>
时效性-低-一般-一般-高<br>
收敛性-稳定-不稳定-较稳定-不稳定</p>
<h3 id="为什么归一化能加快梯度下降法求优化速度？">为什么归一化能加快梯度下降法求优化速度？</h3>
<p>归一化后的数据有助于在求解是缓解求解过程中的参数寻优的动荡，以加快收敛。对于不归一化的收敛，可以发现其参数更新、收敛如左图，归一化后的收敛如右图。可以看到在左边是呈现出之字形的寻优路线，在右边则是呈现较快的梯度下降。</p>
<p><img src="guiyi.png" alt="图片"></p>
<h3 id="标准化和归一化有什么区别？">标准化和归一化有什么区别？</h3>
<p>归一化是将样本的特征值转换到同一量纲下把数据映射到[0,1]或者[-1, 1]区间内，仅由变量的极值决定，因区间放缩法是归一化的一种。</p>
$$
x' = \frac{{x - \min (x)}}{{\max (x) - \min (x)}}
$$
<p>标准化是依照特征矩阵的列处理数据，其通过求z-score的方法，转换为标准正态分布，和整体样本分布相关，每个样本点都能对标准化产生影响。它们的相同点在于都能取消由于量纲不同引起的误差；都是一种线性变换，都是对向量X按照比例压缩再进行平移。</p>
$$
x' = \frac{{x - \bar x}}{\sigma }
$$
<h3 id="批量梯度下降和随机梯度下降法的缺点">批量梯度下降和随机梯度下降法的缺点</h3>
<p>批量梯度下降</p>
<p>a）采用所有数据来梯度下降。</p>
<p>b）批量梯度下降法在样本量很大的时候，训练速度慢。</p>
<p>随机梯度下降</p>
<p>a）随机梯度下降用一个样本来梯度下降。</p>
<p>b）训练速度很快。</p>
<p>c）随机梯度下降法仅仅用一个样本决定梯度方向，导致解有可能不是全局最优。</p>
<p>d）收敛速度来说，随机梯度下降法一次迭代一个样本，导致迭代方向变化很大，不能很快的收敛到局部最优解。</p>
<h3 id="极大似然估计和最小二乘法区别？">极大似然估计和最小二乘法区别？</h3>
<p>对于最小二乘法，当从模型总体随机抽取n组样本观测值后，最合理的参数估计量应该使得模型能最好地拟合样本数据，也就是估计值和观测值之差的平方和最小。</p>
<p>而对于最大似然法，当从模型总体随机抽取n组样本观测值后，最合理的参数估计量应该使得从模型中抽取该n组样本观测值的概率最大。</p>
<p>在最大似然法中，通过选择参数，使已知数据在某种意义下最有可能出现，而某种意义通常指似然函数最大，而似然函数又往往指数据的概率分布函数。与最小二乘法不同的是，最大似然法需要已知这个概率分布函数，这在实践中是很困难的。一般假设其满足正态分布函数的特性，在这种情况下，最大似然估计和最小二乘估计相同。</p>
<p>最小二乘法以估计值与观测值的差的平方和作为损失函数，极大似然法则是以最大化目标值的似然概率函数为目标函数，从概率统计的角度处理线性回归并在似然概率函数为高斯函数的假设下同最小二乘建立了的联系。</p>
<h2 id="信息论">信息论</h2>
<h3 id="什么是信息增益？">什么是信息增益？</h3>
<p>定义：以某特征划分数据集前后的熵的差值。 熵可以表示样本集合的不确定性，熵越大，样本的不确定性就越大。因此可以使用划分前后集合熵的差值来衡量使用当前特征对于样本集合D划分效果的好坏。  假设划分前样本集合D的熵为H(D)。使用某个特征A划分数据集D，计算划分后的数据子集的熵为H(D|A)。<br>
则信息增益为：g(D,A)=H(D)-H(D|A)</p>
<h3 id="熵是什么？">熵是什么？</h3>
<p>熵 Entropy 也叫信息熵（Information Entropy）或香农熵（Shannon Entropy）,是度量 信息的随机度和不确定度。实验中的不确定性使用熵来测量，因此，如果实验中存在固有的不确定性越多，那么它的熵就会越高。</p>
<h3 id="交叉熵表示的意义是什么？">交叉熵表示的意义是什么？</h3>
<p>交叉熵（Cross-Entropy）用来比较两个概率分布的。它会告诉我们两个分布的相似程度。 在同一组结果上定义的两个概率分布p和q之间的交叉熵，也就是$H(p,q) = \sum {p\log q}$.</p>
<h3 id="KL散度是什么？">KL散度是什么？</h3>
<p>KL 散度通常用来度量两个分布之间的差异。KL 散度全称叫kullback leibler 散度，也叫做相对熵（relative entropy）。在机器学习中常用到，譬如近似推断中，有变分推断和期望传播，都是通过 Minimize KL散度来实现推断实现逼近目标分布。</p>
$$
{D_{kl}}(A||B) = \sum\limits_i {{p_A}({v_i})\log \frac{{{p_A}({v_i})}}{{{p_B}({v_i})}}}
$$
<h3 id="KL散度有哪些问题，该如何解决？">KL散度有哪些问题，该如何解决？</h3>
<p>我们从上面的公式可以看到，KL上散度是非对称的，因此在算两个分布相似性的时候，分布计算的顺序会影响到计算的结果，因此有的时候会导致无法解释。为了解决这个这个问题，可以使用JS散度，计算结果如下：</p>
$$
{D_{js}}(A||B) = \frac{1}{2}({D_{kl}}(A||B) + {D_{kl}}(B||A))
$$
<h3 id="KL散度和交叉熵的区别？">KL散度和交叉熵的区别？</h3>
<p>从交叉熵的定义来看，得到KL散度的计算方法如下：</p>
$$
H(A,B) = {D_{kl}}(A||B) + S(A)
$$
<p>可以看到两者相差一个常数，优化的时候可以看到两者是一样的。</p>
<h3 id="什么是最大熵模型以及它的基本原理？">什么是最大熵模型以及它的基本原理？</h3>
<p>MaxEnt （最大熵模型）是概率模型学习中一个准则，其思想为：在学习概率模型时，所有可能的模型中熵最大的模型是最好的模型；若概率模型需要满足一些约束，则最大熵原理就是在满足已知约束的条件集合中选择熵最大模型。最大熵原理指出，对一个随机事件的概率分布进行预测时，预测应当满足全部已知的约束，而对未知的情况不要做任何主观假设。在这种情况下，概率分布最均匀，预测的风险最小，因此得到的概率分布的熵是最大</p>
<h3 id="最大熵与逻辑回归的区别？">最大熵与逻辑回归的区别？</h3>
<p>逻辑回归是最大熵对应类别为两类时的特殊情况，也就是当逻辑回归类别扩展到多类别时，就是最大熵。</p>
<p>其联系在于：最大熵与逻辑回归均属于对数线性模型。它们的学习一般采用极大似然估计，或正则化的极大似然估计，可以形式化为无约束最优化问题。求解该优化问题的算法有改进的迭代尺度法、梯度下降法、拟牛顿法。<br>
指数簇分布的最大熵等价于其指数形式的最大似然界；二项式的最大熵解等价于二项式指数形式(sigmoid)的最大似然，多项式分布的最大熵等价于多项式分布指数形式(softmax)的最大似然。</p>
<h3 id="最大熵优缺点？">最大熵优缺点？</h3>
<p>最大熵模型的优点有：</p>
<ul>
<li>最大熵统计模型获得的是所有满足约束条件的模型中信息熵极大的模型,作为经典的分类模型时准确率较高。</li>
<li>可以灵活地设置约束条件，通过约束条件的多少可以调节模型对未知数据的适应度和对已知数据的拟合程度。</li>
</ul>
<p>最大熵模型的缺点有：</p>
<ul>
<li>由于约束函数数量和样本数目有关系，导致迭代过程计算量巨大，实际应用比较难。</li>
</ul>
<h3 id="参考-3">参考</h3>
<blockquote>
<p><a href="https://blog.csdn.net/SecondLieutenant/article/details/79042717">https://blog.csdn.net/SecondLieutenant/article/details/79042717</a><br>
<a href="https://www.cnblogs.com/hellojamest/p/10862264.html">https://www.cnblogs.com/hellojamest/p/10862264.html</a><br>
<a href="https://zhuanlan.zhihu.com/p/292434104">https://zhuanlan.zhihu.com/p/292434104</a></p>
</blockquote>
<h2 id="其他">其他</h2>
<h3 id="分类问题标签长尾分布该怎么办？">分类问题标签长尾分布该怎么办？</h3>
<p>1.最常用的技巧，up-sampling 或 down-sampling, 其实在 long tail 的 data 做这两种 sampling 都不是特别好的办法. 由于 tail label 数据非常 scarce, 如果对 head label 做 down-sampling 会丢失绝大部分信息. 同理, 对 tail label 做 up-sampling, 则引入大量冗余数据. 这里有篇文章对比了这两种采样方法。 可以参考文献1</p>
<p>2.divide-and-conquer, 即将 head label 和 tail label 分别建模. 比如先利用 data-rich 的 head label 训练 deep model, 然后将学到的样本的 representation 迁移到 tail label model, 利用少量 tail label data 做 fine-tune. 具体做法可以参考文献2</p>
<p>3.对 label 加权, 每个 label 赋予不同的 cost. 如给予 head label 较低的 weight, 而 tail label 则给予较高的 weight, 但是这个权重是怎么设置还需要参考相关文献。</p>
<h3 id="当机器学习性能不是很好时，你会如何优化？">当机器学习性能不是很好时，你会如何优化？</h3>
<ol>
<li>基于数据来改善性能</li>
<li>基于算法</li>
<li>算法调参</li>
<li>模型融合</li>
</ol>
<h3 id="包含百万、上亿特征的数据在深度学习中怎么处理？">包含百万、上亿特征的数据在深度学习中怎么处理？</h3>
<p>这么多的特征，肯定不能直接拿去训练，特征多，数据少，很容易导致模型过拟合。<br>
（1）特征降维：PCA或LDA<br>
（2）使用正则化，L1或L2<br>
引入 L_1 范数除了降低过拟合风险之外，还有一个好处：它求得的 w 会有较多的分量为零。即：它更容易获得稀疏解。<br>
（3）样本扩充：数据增强<br>
（4）特征选择：去掉不重要的特征</p>
<h3 id="类别型数据你是如何处理的？比如游戏品类，地域，设备？">类别型数据你是如何处理的？比如游戏品类，地域，设备？</h3>
<p>序号编码、one-hot编码、多热编码，二进制编码，搞成嵌入向量</p>
<h3 id="参考-4">参考</h3>
<blockquote>
<p><a href="https://blog.csdn.net/weixin_46838716/article/details/124424903">https://blog.csdn.net/weixin_46838716/article/details/124424903</a><br>
learning-to-model-the-tail<br>
deepxml: scalable &amp; accurate deep extreme classification for matching user ueries to advertiser bid phrases<br>
extreme multi-label learning with label features for warm-start tagging, ranking &amp; recommendation</p>
</blockquote>
]]></content>
      <categories>
        <category>算法面试</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>刷八股</tag>
      </tags>
  </entry>
  <entry>
    <title>模型选择与评估</title>
    <url>/2024/03/19/machine_learning/mode_selection_and_ev/</url>
    <content><![CDATA[<h1>模型选择与评估</h1>
<h2 id="损失函数类">损失函数类</h2>
<h3 id="代价函数，损失函数和目标函数的区别？">代价函数，损失函数和目标函数的区别？</h3>
<p>损失函数（Loss Function ）是定义在单个样本上的，算的是一个样本的误差。<br>
代价函数（Cost Function）是定义在整个训练集上的，是所有样本误差的平均，也就是损失函数的平均。<br>
目标函数（Object Function）定义为：最终需要优化的函数。等于经验风险+结构风险（也就是代价函数 + 正则化项）。代价函数最小化，降低经验风险，正则化项最小化降低。<br>
风险函数(risk function)，风险函数是损失函数的期望，这是由于我们输入输出的(X,Y)遵循一个联合分布，但是这个联合分布是未知的，所以无法计算。但是我们是有历史数据的，就是我们的训练集，f(x) 关于训练集的平均损失称作经验风险(empirical risk)，即，所以我们的目标就是最小化 称为经验风险最小化。</p>
<h3 id="误差、偏差和方差的区别是啥？">误差、偏差和方差的区别是啥？</h3>
<p>噪声：描述了在当前任务上任何学习算法所能达到的期望泛化误差的下界，即刻画了学习问题本身的难度。说人话，就是数据中的有些标签不是真的标签，也是有限噪声的标签。</p>
<p>偏差：是指预测结果与真实值之间的差异，排除噪声的影响，偏差更多的是针对某个模型输出的样本误差，偏差是模型无法准确表达数据关系导致，比如模型过于简单，非线性的数据关系采用线性模型建模，偏差较大的模型是错的模型。</p>
<p>方差：不是针对某一个模型输出样本进行判定，而是指多个(次)模型输出的结果之间的离散差异，注意这里写的是多个模型或者多次模型，即不同模型或同一模型不同时间的输出结果方差较大，方差是由训练集的数据不够导致，一方面量 (数据量) 不够，有限的数据集过度训练导致模型复杂，另一方面质(样本质量)不行，测试集中的数据分布未在训练集中，导致每次抽样训练模型时，每次模型参数不同，输出的结果都无法准确的预测出正确结果。</p>
<h3 id="常见的损失函数有哪些？">常见的损失函数有哪些？</h3>
<ol>
<li>0-1损失函数<br>
0-1损失是指，预测值和目标值不相等为1，否则为0</li>
<li>绝对值损失函数平方损失函数（squared loss）<br>
实际结果和观测结果之间差距的平方和，一般用在线性回归中，可以理解为最小二乘法</li>
<li>对数损失函数（logarithmic loss）这个在逻辑回归中用到的</li>
<li>指数损失函数，这个在Adaboost中就有体现的</li>
<li>铰链损失函数，这个在SVM中用到过</li>
</ol>
<h3 id="均方差损失函数和高斯假设的关系？">均方差损失函数和高斯假设的关系？</h3>
<p>事先我们模型预测与真实值之间的误差是服从标准高斯分布也就是$\mu {\rm{ = }}0,\sigma {\rm{ = }}1$，我们给定一个输入$x_i$，则模型输出真实值$y_i$的概率为:</p>
$$
p({y_i}|{x_i}) = \frac{1}{{\sqrt {2\pi } }}\exp ( - \frac{{{{({y_i} - {{\hat y}_i})}^2}}}{2})
$$
<p>再假设各个样本点之间是相互独立的，那么最大似然函数可以写为：</p>
$$
L(x,y) = \prod\limits_{i = 1}^N {\frac{1}{{\sqrt {2\pi } }}} \exp ( - \frac{{{{({y_i} - {{\hat y}_i})}^2}}}{2})
$$
<p>为了计算方便，通常取对数似然函数，结果如下：</p>
$$
\log L(x,y) =  - \frac{N}{2}\log 2\pi  - \frac{1}{2}\sum\limits_{i = 1}^N {{{({y_i} - {{\hat y}_i})}^2}}
$$
<p>可以看到前面的一项是C，只与后面的结果有关，然后转化为最小化负对数似然 Negative Log-Likelihood</p>
$$
- \log L(x,y) = \frac{1}{2}\sum\limits_{i = 1}^N {{{({y_i} - {{\hat y}_i})}^2}}
$$
<p>这就是MSE的基本形式，也就是说在假设误差为高斯分布的情况下，最小化均方差损失函数与极大似然估计本质上是一致的。</p>
<h3 id="平均绝对误差损失函数和拉普拉斯假设的关系？">平均绝对误差损失函数和拉普拉斯假设的关系？</h3>
<p>事先我们模型预测与真实值之间的误差是服从拉普拉斯分布也就是$\mu {\rm{ = }}0,b {\rm{ = }}1$，我们给定一个输入$x_i$，则模型输出真实值$y_i$的概率为:</p>
$$
p({y_i}|{x_i}) = \frac{1}{2}\exp ( - |{y_i} - {{\hat y}_i}|)
$$
<p>和上面的推导类似，最后可以得到如下的公式：</p>
$$
- \log L(x,y) = \frac{1}{2}\sum\limits_{i = 1}^N {(|{y_i} - {{\hat y}_i}|)}
$$
<p>这就是MAE我的基本形式，也就是说在假设误差为拉普拉斯分布的情况下，最小化均方差损失函数与极大似然估计本质上是一致的。</p>
<h3 id="均方差损失函数与平均绝对误差损失函数区别">均方差损失函数与平均绝对误差损失函数区别?</h3>
<p>通过上述分析我们可以发现，MSE损失相对于MAE会更加快速的收敛，但是MAE相比于异常点会更健壮。</p>
<p>当使用梯度下降算法时，MSE 损失的梯度为$-{ \hat y }$，而 MAE 损失的梯度为$\pm 1$，即 MSE 的梯度的值会随误差大小而变化，而 MAE 的梯度的则一直保持为 1，即便在绝对误差$|{y_i} - {\hat y_i}|$很小的时候 MAE 的梯度也同样保持为 1，这实际上是非常不利于模型的训练的，也就是我们看到的训练的时候呈现上下左右直线跳的现象。</p>
<p>从上述的损失函数计算公式中我们也可以看到，MSE的公式中有平方项，这样当数据中存在较大的异常值的话会导致较大的异常的梯度，但MAE就不会，梯度就是1，就是这么拽。</p>
<h3 id="mse对于异常样本的鲁棒性差的问题怎么解决？">mse对于异常样本的鲁棒性差的问题怎么解决？</h3>
<ol>
<li>如果异常样本无意义，可以进行异常值的平滑或者直接删除。</li>
<li>如果异常样本有意义，需要模型把这些有意义的异常考虑进来，则从模型侧考虑使用表达能力更强的模型或复合模型或分群建模等；</li>
<li>在损失层面选择更鲁棒的损失函数例如smape</li>
</ol>
<h3 id="介绍你了解到的熵的相关知识点？">介绍你了解到的熵的相关知识点？</h3>
<ul>
<li>信息量<br>
度量一个事件的不确定性程度，不确定性越高则信息量越大，一般通过事件发生的概率来定义不确定性，信息量则是基于概率密度函数的log运算，用以下式子定义：</li>
</ul>
$$
I(x) =  - \log p(x)
$$
<ul>
<li>信息熵<br>
衡量的是一个事件集合的不确定性程度，就是事件集合中所有事件的不确定性的期望，公式定义如下：</li>
</ul>
$$
H(X) =  - \sum\limits_{x \in X} {[p(x)\log p(x)]}
$$
<ul>
<li>相对熵(KL散度)<br>
kl散度，从概统角度出发，表示用于两个概率分布的差异的非对称衡量，kl散度也可以从信息理论的角度出发，从这个角度出发的kl散度我们也可以称之为相对熵，实际上描述的是两个概率分布的信息熵的差值：</li>
</ul>
$$
KL(P||Q) = \sum {P(x)\log \frac{{P(x)}}{{Q(x)}}}
$$
<p>kl散度和余弦距离一样，不满足距离的严格定义；非负且不对称。</p>
<ul>
<li>js散度<br>
公式如下：</li>
</ul>
$$
JS(P||Q) = \frac{1}{2}KL(P(x))||\frac{{P(x) + Q(x)}}{2} + \frac{1}{2}KL(Q(x))||\frac{{P(x) + Q(x)}}{2}
$$
<p>js散度的范围是[0,1],相同则是0，相反为1。相较于KL，对相似度的判别更准确;同时，js散度满足对称性 JS(P||Q)=JS(Q||P)</p>
<ul>
<li>交叉熵<br>
公式如下：</li>
</ul>
$$
H(P,Q) =  - \sum {p\log q = H(P) + {D_{kl}}(P||Q)}
$$
<p>可见,交叉熵就是真值分布的信息熵与KL散度的和,而真值的熵是确定的,与模型的参数θ 无关,所以梯度下降求导时，优化交叉熵和优化kl散度（相对熵）是一样的；</p>
<ul>
<li>联合熵<br>
公式如下：</li>
</ul>
$$
H(X,Y) =  - \sum\limits_{x,y} {p(x,y)\log p(x,y)}
$$
<p>联合熵实际上衡量的是两个事件集合，经过组合之后形成的新的大的事件集合的信息熵；</p>
<ul>
<li>条件熵<br>
公式如下：</li>
</ul>
$$
H(Y|X) = H(X,Y) - H(X)
$$
<p>事件集合Y的条件熵=联合熵-事件集合X的信息熵，用来衡量在事件集合X已知的基础上，事件集合Y的不确定性的减少程度；</p>
<h3 id="交叉熵的设计思想是什么？">交叉熵的设计思想是什么？</h3>
<p>优化交叉熵等价于优化kl散度</p>
$$
H(P,Q) =  - \sum {p\log q = H(P) + {D_{kl}}(P||Q)}
$$
<p>这里的P是真实分布，它的信息熵 H（p）是一个定值，对于模型来说是一个不可优化的常数, 因此优化的时候可以忽略。</p>
<h3 id="怎么衡量两个分布的差异？">怎么衡量两个分布的差异？</h3>
<p>使用KL散度或者JS散度</p>
<h3 id="Huber-Loss-有什么特点？">Huber Loss 有什么特点？</h3>
<p>首先看下huber loss的形状：</p>
<p><img src="https://pic2.zhimg.com/80/v2-68de6203f87d93fe9134c7c89745a31d_720w.jpg" alt="image"></p>
<p>Huber Loss 结合了 MSE 和 MAE 损失，在误差接近 0 时使用 MSE，使损失函数可导并且梯度更加稳定；在误差较大时使用 MAE 可以降低 outlier 的影响，使训练对 outlier 更加健壮。缺点是需要额外地设置一个超参数。</p>
<h3 id="为何使用Huber损失函数？">为何使用Huber损失函数？</h3>
<p>使用MAE用于训练神经网络的一个大问题就是，它的梯度始终很大，这会导致使用梯度下降训练模型时，在结束时遗漏最小值。对于MSE，梯度会随着损失值接近其最小值逐渐减少，从而使其更准确。<br>
在这些情况下，Huber损失函数真的会非常有帮助，因为它围绕的最小值会减小梯度。而且相比MSE，它对异常值更具鲁棒性。因此，它同时具备MSE和MAE这两种损失函数的优点。不过，Huber损失函数也存在一个问题，我们可能需要训练超参数δ，而且这个过程需要不断迭代。</p>
<h3 id="如何理解Hinger-Loss？">如何理解Hinger Loss？</h3>
<p>首先看下Hinger Loss的图像，如下：</p>
<p><img src="https://pic3.zhimg.com/80/v2-3c6aa9626ee8e4609b0d7c5712baf624_720w.jpg" alt="image"></p>
<p>可以看到，当x大于某个值的时候，loss为0，当x小于某个值的时候，那就需要算loss了，说明模型对小于阈值的样本进行了惩罚，而且越大惩罚的越厉害，对于大于阈值的样本不进行惩罚，总的来说就是该损失函数寻找一个边界，对具有可信的样本不惩罚，对不可信的样本或者超出决策边界的样本进行惩罚。</p>
<h3 id="交叉熵与最大似然估计的联系？">交叉熵与最大似然估计的联系？</h3>
<p>交叉熵刻画的是实际输出（概率）与期望输出（概率）的距离，也就是交叉熵的值越小，两个概率分布就越接近，即拟合的更好。<br>
最小化交叉熵即最小化KL散度，即最小化实际与预估之间的差距，这与最大似然的目的是一致的。即最大似然与交叉熵在目标上一致，只是由于正负号，而导致一个为最小化（交叉熵，前面有负号），一个为最大化（最大似然）</p>
<h3 id="分类问题为何用交叉熵而不用MSE？">分类问题为何用交叉熵而不用MSE？</h3>
<p>首先来看两者的表达式<br>
MSE的表达式如下：</p>
$$
L = \frac{1}{N}\sum\limits_{i = 1}^N {||{y_i} - {{\hat y}_i}|{|^2}}
$$
<p>交叉熵的表达式如下：</p>
$$
L = \frac{1}{N}\sum\limits_{i = 1}^N {\sum\limits_{k = 1}^N {{y_i}^k\log {{\hat y}_i}^k} }
$$
<p>可以看到，对于分类问题，实际的标签为0和1，那么交叉熵很多项是不用算的，举个例子， 实际标签是[1,0,0],模型预测得到的概率是[0.9,0.4,0.3],那么交叉熵损失函数的结果是 1log(0.9)+0log(0.4)+0log(0.3),而MSE则都得全部算一遍。<br>
结论1：MSE无差别得关注全部类别上预测概率和真实概率的差.交叉熵关注的是正确类别的预测概率。<br>
其次，我们在之前的文章中也说到了关于求解优化模型的时候的问题，MSE会收敛的慢一些，因为它求导的结果相比于交叉熵还多乘以一个sigmod函数，但是交叉熵梯度中不再含有sigmoid的导数，有的是sigmoid的值和实际值之间的差，也就满足了我们之前所说的错误越大，下降的越快的要求。<br>
结论2：是交叉熵更有利于梯度更新。<br>
MSE是假设数据符合高斯分布时,模型概率分布的负条件对数似然;交叉熵是假设模型分布为多项式分布时,模型分布的负条件对数似然。<br>
还有一点要说明，MSE对残差大的样例惩罚更大些.，我们还举个例子看看，比如真实标签分别是(1, 0, 0).模型1的预测标签是(0.8, 0.2, 0),模型2的是(0.9, 0.1, 0). 但MSE-based算出来模型1的误差是MSE-based算出模型2的4倍,而交叉熵-based算出来模型1的误差是交叉熵-based算出来模型2的2倍左右.对于模型1和模型2输出的结果。其实也主要是由于MSE太苛刻了，想要把左右的值都预测的分毫不差，而交叉熵只关注正样本也也是就1的那些，计算那些损失函数就可以了，样本标签为0的压根不用算。</p>
<h3 id="类别不均衡情况下使用什么损失函数？">类别不均衡情况下使用什么损失函数？</h3>
<p>可以使用Focal loss函数：为了解决正负样本严重失衡的问题，由 log loss 改进而来</p>
$$
{L_{FL}} =  - \frac{1}{n}\sum\limits_{i = 1}^N {[\alpha {y_i}{{(1 - {{\hat y}_i})}^\gamma }\log {{\hat y}_i} + (1 - \alpha )(1 - {y_i}){{\hat y}_i}^\gamma \log (1 - {{\hat y}_i})]}
$$
<p>基本思想：对于类别极度不平衡的情况下，网络如果在 log loss 下会倾向于之预测负样本，并且负样本的预测概率$ {{{\hat y}_i}} $ 也会非常的高，回传的梯度也很大。但是如果添加${(1 - {\hat y_i})^\gamma }$则会使预测概率大的样本得到的 loss 变小，而预测概率小的样本，loss 变得大，从而加强对正样本的关注度。可以改善目标不均衡的现象，对此情况比交叉熵要好很多。</p>
<h3 id="参考">参考</h3>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/358103958">https://zhuanlan.zhihu.com/p/358103958</a><br>
<a href="https://zhuanlan.zhihu.com/p/149093389">https://zhuanlan.zhihu.com/p/149093389</a><br>
<a href="https://zhuanlan.zhihu.com/p/376387915">https://zhuanlan.zhihu.com/p/376387915</a><br>
<a href="https://zhuanlan.zhihu.com/p/77686118">https://zhuanlan.zhihu.com/p/77686118</a><br>
<a href="https://blog.csdn.net/Scc_hy/article/details/84190080">https://blog.csdn.net/Scc_hy/article/details/84190080</a><br>
<a href="https://zhuanlan.zhihu.com/p/391954665">https://zhuanlan.zhihu.com/p/391954665</a><br>
<a href="https://www.zhihu.com/collection/168981231">https://www.zhihu.com/collection/168981231</a></p>
</blockquote>
<h2 id="偏差与方差">偏差与方差</h2>
<h3 id="什么是偏差和方差？">什么是偏差和方差？</h3>
<p>不要看这个问题简单，但是问的时候，真的一下子你可能会答不上来。偏差度量了学习算法的期望预测与真实结果的偏离程度，即刻画了学习算法本身的拟合能力;方差 度量了同样大小的训练集的变动所导致的学习性能的变化，即刻画了数据扰动所造成的影响。</p>
<h3 id="什么是噪声？">什么是噪声？</h3>
<p>噪声则表达了在当前任务上任何学习算法所能达到的期望泛化误差的下界，即刻画了学习问题本身的难度。噪声的存在是学习算法所无法解决的问题，数据的质量决定了学习的上限。假设在数据已经给定的情况下，此时上限已定，我们要做的就是尽可能的接近这个上限。举个简单的例子，对于一个预测性别的任务来说，特征中有胡子，标签为女性，这样的数据就是噪声数据，它反应的是数据质量的问题。</p>
<h3 id="泛化误差、偏差和方差的关系？">泛化误差、偏差和方差的关系？</h3>
<p>关系如下：<br>
$E = bia{s^2}(x) + {\mathop{\rm var}} (x) + {\varepsilon ^2}$<br>
也就是说，泛化误差可以通过一系列公式分解运算证明：泛化误差为偏差、方差与噪声之和。证明过程如下：</p>
<p><img src="https://s21.ax1x.com/2024/03/23/pFhIBZt.png" alt="image"></p>
<p>“偏差-方差分解”说明，泛化性能是由学习算法的能力、数据的充分性以及学习任务本身的难度所共同决定的。给定学习任务，为了取得好的泛化性能，则需使偏差较小，即能够充分拟合数据，并且使方差较小，即使得数据扰动产生的影响小。</p>
<h3 id="偏差、方差与过拟合、欠拟合的关系？">偏差、方差与过拟合、欠拟合的关系？</h3>
<p>一般来说，简单的模型会有一个较大的偏差和较小的方差，复杂的模型偏差较小方差较大。</p>
<p>欠拟合：模型不能适配训练样本，有一个很大的偏差。</p>
<p>举个例子：我们可能有本质上是多项式的连续非线性数据，但模型只能表示线性关系。在此情况下，我们向模型提供多少数据不重要，因为模型根本无法表示数据的基本关系，模型不能适配训练样本，有一个很大的偏差，因此我们需要更复杂的模型。那么，是不是模型越复杂拟合程度越高越好呢？也不是，因为还有方差。</p>
<p>过拟合：模型很好的适配训练样本，但在测试集上表现很糟，有一个很大的方差。</p>
<p>方差就是指模型过于拟合训练数据，以至于没办法把模型的结果泛化。而泛化正是机器学习要解决的问题，如果一个模型只能对一组特定的数据有效，换了数据就无效，我们就说这个模型过拟合。这就是模型很好的适配训练样本，但在测试集上表现很糟，有一个很大的方差。</p>
<h3 id="偏差、方差与模型复杂度的关系">偏差、方差与模型复杂度的关系?</h3>
<p>复杂度高的模型通常对训练数据有很好的拟合能力，但是对测试数据就不一定了。而复杂度太低的模型又不能很好的拟合训练数据，更不能很好的拟合测试数据。因此，模型复杂度和模型偏差和方差具有如下图所示关系</p>
<p><img src="https://s21.ax1x.com/2024/03/23/pFhTWEq.png" alt="image"></p>
<h3 id="请从偏差和方差的角度解释bagging和boosting的原理？">请从偏差和方差的角度解释bagging和boosting的原理？</h3>
<p>偏差指的是算法的期望预测与真实值之间的偏差程度，反映了模型本身的拟合能力；方差度量了同等大小的训练集的变动导致学习性能的变化，刻画了数据扰动所导致的影响。</p>
<p>Bagging对样本重采样，对每一重采样得到的子样本集训练一个模型，最后取平均。由于子样本集的相似性以及使用的是同种模型，因此各模型有近似相等的bias和variance。由于$E[\frac{{\sum {{X_i}} }}{n}] = E[{X_i}]$，所以bagging后的bias和单个子模型的接近，一般来说不能显著降低bias。另一方面，若各子模型独立，则有$Var[\frac{{\sum {{X_i}} }}{n}] = \frac{{Var[{X_i}]}}{n}$，此时可以显著降低variance。若各子模型完全相同，则$Var[\frac{{\sum {{X_i}} }}{n}] = Var[{X_i}]$，此时不会降低variance。</p>
<p>bagging方法得到的各子模型是有一定相关性的，属于上面两个极端状况的中间态，因此可以一定程度降低variance。</p>
<p>boosting从优化角度来看，是用forward-stagewise这种贪心法去最小化损失函数,由于采取的是串行优化的策略，各子模型之间是强相关的，于是子模型之和并不能显著降低variance。所以说boosting主要还是靠降低bias来提升预测精度。</p>
<h3 id="为什么说bagging是减少variance，而boosting是减少bias">为什么说bagging是减少variance，而boosting是减少bias?</h3>
<p>boosting是把许多弱的分类器组合成一个强的分类器。弱的分类器bias高，而强的分类器bias低，所以说boosting起到了降低bias的作用。variance不是boosting的主要考虑因素。bagging是对许多强（甚至过强）的分类器求平均。在这里，每个单独的分类器的bias都是低的，平均之后bias依然低；而每个单独的分类器都强到可能产生overfitting的程度，也就是variance高，求平均的操作起到的作用就是降低这个variance。</p>
<h3 id="如何解决偏差、方差问题？">如何解决偏差、方差问题？</h3>
<p>偏差和方差是无法完全避免的，只能尽量减少其影响。<br>
(1) 在避免偏差时，需尽量选择正确的模型，一个非线性问题而我们一直用线性模型去解决，那无论如何，高偏差是无法避免的。<br>
(2) 有了正确的模型，我们还要慎重选择数据集的大小，通常数据集越大越好，但大到数据集已经对整体所有数据有了一定的代表性后，再多的数据已经不能提升模型了，反而会带来计算量的增加。而训练数据太小一定是不好的，这会带来过拟合，模型复杂度太高，方差很大，不同数据集训练出来的模型变化非常大。<br>
(3) 最后，要选择合适的模型复杂度，复杂度高的模型通常对训练数据有很好的拟合能力。</p>
<h3 id="训练集上预测误差大，在测试集上预测误差小的情况？">训练集上预测误差大，在测试集上预测误差小的情况？</h3>
<p>模型恰好在验证数据上的泛化性能好，例如二分类问题中，测试集数据恰好是和分界超平面距离很远的样本或者是回归问题中，验证数据在模型的拟合曲面上。</p>
<h3 id="参考-2">参考</h3>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/38853908">https://zhuanlan.zhihu.com/p/38853908</a><br>
<a href="https://www.zhihu.com/question/27068705">https://www.zhihu.com/question/27068705</a><br>
<a href="https://www.zhihu.com/question/27068705/answer/416457469">https://www.zhihu.com/question/27068705/answer/416457469</a><br>
<a href="https://www.zhihu.com/collection/168981231">https://www.zhihu.com/collection/168981231</a></p>
</blockquote>
<h2 id="过拟合和欠拟合">过拟合和欠拟合</h2>
<h3 id="什么是欠拟合？">什么是欠拟合？</h3>
<p>欠拟合是指模型不能在训练集上获得足够低的误差。换句换说，就是模型复杂度低，模型在训练集上就表现很差，没法学习到数据背后的规律。</p>
<h3 id="什么是过拟合？">什么是过拟合？</h3>
<p>过拟合是指训练误差和测试误差之间的差距太大。换句换说，就是模型复杂度高于实际问题，模型在训练集上表现很好，但在测试集上却表现很差。模型对训练集&quot;死记硬背&quot;（记住了不适用于测试集的训练集性质或特点），没有理解数据背后的规律，泛化能力差。</p>
<h3 id="如何解决欠拟合">如何解决欠拟合?</h3>
<ol>
<li>添加其他特征项。组合、泛化、相关性、上下文特征、平台特征等特征是特征添加的重要手段，有时候特征项不够会导致模型欠拟合。</li>
<li>添加多项式特征。例如将线性模型添加二次项或三次项使模型泛化能力更强。例如，FM（Factorization Machine）模型、FFM（Field-aware Factorization Machine）模型，其实就是线性模型，增加了二阶多项式，保证了模型一定的拟合程度。</li>
<li>可以增加模型的复杂程度。</li>
<li>减小正则化系数。正则化的目的是用来防止过拟合的，但是现在模型出现了欠拟合，则需要减少正则化参数。</li>
</ol>
<h3 id="过拟合原因有哪些？">过拟合原因有哪些？</h3>
<p>（1）建模样本选取有误，样本标签错误等，导致选取的样本数据不足以代表预定的分类规则<br>
（2）样本噪音干扰过大，使得机器将学习了噪音，还认为是特征，从而扰乱了预设的分类规则<br>
（3）假设的模型无法合理存在，或者说是假设成立的条件实际并不成立<br>
（4）参数太多，模型复杂度过高<br>
（5）对于tree-based模型，如果我们对于其深度与split没有合理的限制，有可能使节点只包含单纯的事件数据(event)或非事件数据(no event)，使其虽然可以完美匹配（拟合）训练数据，但是无法适应其他数据集<br>
（6）对于神经网络模型：1.权值学习迭代次数太多(Overtraining)，2。BP算法使权值可能收敛过于复杂的决策面</p>
<h3 id="如何解决过拟合">如何解决过拟合?</h3>
<ol>
<li>重新清洗数据，数据不纯会导致过拟合，此类情况需要重新清洗数据。</li>
<li>增加训练样本数量。</li>
<li>降低模型复杂程度。</li>
<li>增大正则项系数。</li>
<li>采用dropout方法。</li>
<li>early stopping。</li>
<li>减少迭代次数。</li>
<li>增大学习率。</li>
<li>添加噪声数据。</li>
<li>树结构中，可以对树进行剪枝。</li>
<li>减少特征项。</li>
</ol>
<p>欠拟合和过拟合这些方法，需要根据实际问题，实际模型，进行选择。</p>
<h3 id="为什么L1正则化会产生更稀疏？">为什么L1正则化会产生更稀疏？</h3>
<p>L1中的参数更新如下所示：</p>
$$
w \to w' = w - \frac{{\eta \lambda }}{n}{\mathop{\rm sgn}} (w) - \eta \frac{{\partial {C_0}}}{{\partial w}}
$$
<p>其中$C_0$是损失函数，$n$是样本数，$\lambda$是正则参数，我们看这个参数更新的公式，发现</p>
<p>$w=0$, 时，$w=0$是不可导的。所以我们仅仅能依照原始的未经正则化的方法去更新$w=0$。<br>
当 $w&gt;0$ 时，$sgn(w)&gt;0$, 则梯度下降时更新后的$w$变小。<br>
当 $w&lt;0$ 时，$sgn(w)&lt;0$, 则梯度下降时更新后的$w$变大，换句换说，L1正则化使得权重$w$往0靠，使网络中的权重尽可能为0，也就相当于减小了网络复杂度，防止过拟合。</p>
<h3 id="为啥L1正则先验分布是Laplace分布，L2正则先验分布是Gaussian分布">为啥L1正则先验分布是Laplace分布，L2正则先验分布是Gaussian分布</h3>
<p>L1正则先验分布是Laplace分布，L2正则先验分布是Gaussian分布。接下来从最大后验概率的角度进行推导和分析。在机器学习建模中，我们知道了$x$和$y$以后,需要对参数$w$进行建模。那么后验概率表达式如下:</p>
$$
MAP = \log P(y|X,w)P(w) = \log P(y|X,w) + \log P(w)
$$
<p>可以看出来后验概率函数为在似然函数的基础上增加了$logP(w)$，$P(w)$的意义是对权重系数$w$的概率分布的先验假设，在收集到训练样本$X$，$y$<br>
后，则可根据$w$在$X$，$y$<br>
下的后验概率对$w$进行修正，从而做出对的更好地估计。若假设$w$的先验分布为0均值的高斯分布，即 $w \sim N(0,{\sigma ^2})$,则有</p>
$$
\log P(w) = \log \prod\limits_j {P({w_j}) = } \log \prod\limits_j {[\frac{1}{{\sqrt {2\pi } \sigma }}{e^{ - \frac{{{w_j}^2}}{{2{\sigma ^2}}}}}] =  - \frac{1}{{2{\sigma ^2}}}} \sum\limits_j {{w_j}^2 + C}
$$
<p>可以看到，在高斯分布$logP(w)$下的效果等价于在代价函数中增加L2正则项。若假设服$w$从均值为0，参数为a的拉普拉斯分布，即$P({w_j}) = \frac{1}{{\sqrt {2a} }}{e^{\frac{{|{w_j}|}}{a}}}$，则有</p>
$$
\log P(w) = \log \prod\limits_j {P({w_j}) = } \log \prod\limits_j {\frac{1}{{\sqrt {2a} }}{e^{\frac{{|{w_j}|}}{a}}}}  =  - \frac{1}{{2a}}\sum\limits_j {|{w_j}| + C} 
$$
<p>可以看到，在拉普拉斯分布$logP(W)$下的效果等价在代价函数中增加L1正项。</p>
<p>L1正则化可通过假设权重w的先验分布为拉普拉斯分布，由最大后验概率估计导出。</p>
<p>L2正则化可通过假设权重w的先验分布为高斯分布，由最大后验概率估计导出。</p>
<h3 id="Lasso回归的求解方法有哪些？">Lasso回归的求解方法有哪些？</h3>
<p>Lasso回归有时也叫做线性回归的L1正则化，和Ridge回归的主要区别就是在正则化项，Ridge回归用的是L2正则化，而Lasso回归用的是L1正则化。由于L1范数用的是绝对值之和，在零点处不可求导，所以使用非梯度下降法进行求解，如 坐标轴下降法（coordinate descent）和最小角回归法（ Least Angle Regression， LARS）。</p>
<ul>
<li>
<p>坐标轴下降法<br>
坐标轴下降法坐标下降优化方法是一种非梯度优化算法，坐标下降算法每次选择一个维度进行参数更新，维度的选择可以是随机的或者是按顺序。当一轮更新结束后，更新步长的最大值少于预设阈值时，终止迭代。</p>
</li>
<li>
<p>最小角回归法<br>
最小角回归法运用到了前向选择法（选取余弦距离最小的值进行投影，计算残差，迭代这个过程，直到残差达到我们的较小值或者已经遍历了整个变量）和前向梯度算法（选取余弦距离最小的值的样本方向进行移动一定距离，计算残差，重复这个迭代过程）的综合，做法就是取投影方向和前向梯度算法的残差方向形成的角的平分线方向，进行移动。对前向梯度算法和前向选择算法做了折中，保留了前向梯度算法一定程度的精确性，同时简化了前向梯度算法一步步迭代的过程。</p>
</li>
</ul>
<h3 id="为什么L2正则化会产生更稠密解？">为什么L2正则化会产生更稠密解？</h3>
<p>L2正则化通常被称为权重衰减（weight decay），就是在原始的损失函数后面再加上一个L2正则化项，即全部权重[公式]的平方和，再乘以λ/2n。则损失函数变为：</p>
$$
C = {C_0} + \frac{\lambda }{{2n}}\sum {{w_i}^2}
$$
<p>对应的梯度（导数）：</p>
$$
\begin{array}{l}
\frac{{\partial C}}{{\partial w}} = \frac{{\partial {C_0}}}{{\partial w}} + \frac{\lambda }{n}w\\
\frac{{\partial C}}{{\partial b}} = \frac{{\partial {C_0}}}{{\partial b}}
\end{array}
$$
<p>能够发现L2正则化项对偏置 b 的更新没有影响，可是对于权重$w$的更新有影响：<br>
参数的更新步骤如下：</p>
$$
\begin{array}{l}
w \to w' = w - \frac{{\eta \lambda }}{n}w - \eta \frac{{\partial {C_0}}}{{\partial w}}\\
\;\;\;\;\;\;\;\;\;\;\;\; = (1 - \frac{{\eta \lambda }}{n})w - \eta \frac{{\partial {C_0}}}{{\partial w}}
\end{array}
$$
<p>这里的参数都是大于0的，所以 $1 - \frac{{\eta \lambda }}{n}<1$,因此在梯度下降过程中，权重$w$将逐渐减小，趋向于0但不等于0。这也就是权重衰减（weight decay）的由来。< p>
<p>L2正则化起到使得权重参数$w$变小的效果，为什么能防止过拟合呢？因为更小的权重参数$w$意味着模型的复杂度更低，对训练数据的拟合刚刚好，不会过分拟合训练数据，从而提高模型的泛化能力。</p>
<h3 id="L1和L2的区别和联系？">L1和L2的区别和联系？</h3>
<p>相同的点：<br>
都可以用来解决过拟合问题的，提高模型的泛化能力。</p>
<p>不同的点：<br>
l1-norm使用的是每个权重值的绝对值之和，l2-norm使用的是每个权重值的平方和；<br>
l1-norm会得到稀疏解，可用于特征选择，l2-norm不会；<br>
l1-norm下降速度更快。</p>
<h3 id="为什么权重变小可以防止过拟合呢？">为什么权重变小可以防止过拟合呢？</h3>
<p>还是借助上面的公式来说明下问题：</p>
<p>直观上：算法会在训练过程中梯度下降迭代时损失函数尽量的小，而这需要更多复杂的参数，就容易导致过拟合，加上L2之后，当参数变多变复杂时就会导致L2正则化项增大，从而导致损失函数增大，达到制约参数的目的。</p>
<p>模型复杂度：更小的权值w，从某种意义上说，表示网络的复杂度更低，对数据的拟合更好(这个法则也叫做奥卡姆剃刀)，而在实际应用中，也验证了这一点，L2正则化的效果往往好于未经正则化的效果。</p>
<p>数学方面：过拟合的时候，拟合函数a的系数往往非常大，为什么?如下图所示，过拟合，就是拟合函数需要顾忌每一个点，最终形成的拟合函数波动很大。在某些很小的区间里，函数值的变化很剧烈。这就意味着数据在某些小区间内的导数值(绝对值)非常大，由于自变量值可大可小，所以只有系数足够大，才能保证导数值很大。而正则化是通过约束参数的大小，使其不要太大，所以可以在一定程度上减少过拟合情况。</p>
<h3 id="为什么增加样本可以减少过拟合？">为什么增加样本可以减少过拟合？</h3>
<p>增加的数据主要会引入学习器没有看到过的样本，其中可能包括测试集的分布，这样让模型开开眼界，不会局限于当前数据的分布。<br>
但是如果引入的数据和未来的样本完全不相似，例如不均衡学习中的许多上采样的方法，纯粹基于训练数据的一些加减计算，难以扩充和未来相似的样本，自然是不能缓解过拟合问题了。</p>
<h3 id="参考-3">参考</h3>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/72038532">https://zhuanlan.zhihu.com/p/72038532</a><br>
<a href="https://zhuanlan.zhihu.com/p/64127398">https://zhuanlan.zhihu.com/p/64127398</a><br>
<a href="https://zhuanlan.zhihu.com/p/495738409">https://zhuanlan.zhihu.com/p/495738409</a></p>
</blockquote>
<h2 id="检验方法">检验方法</h2>
<h3 id="比较检验方法有哪些？">比较检验方法有哪些？</h3>
<ol>
<li>假设检验——二项检验</li>
<li>假设检验——t检验</li>
<li>交叉验证t检验</li>
<li>McNemar检验</li>
<li>Friedman检验和Nemenyi后续检验</li>
</ol>
<h3 id="什么是假设检验？">什么是假设检验？</h3>
<p>假设检验是用来判断样本与样本，样本与总体的差异是由抽样误差引起还是本质差别造成的统计推断方法。其基本原理是先对总体的特征作出某种假设，然后通过抽样研究的统计推理，对此假设应该被拒绝还是接受作出推断。</p>
<p>举两个例子：1.在产品的质量检验中经常会遇到的问题就是样本是否可以代替总体，这就涉及用样本来估计总体。2.你先后做了两批实验，得到两组数据，你想知道在这两试实验中合格率有无显著变化，那怎么做呢？这时你可以使用假设检验这种统计方法，来比较你的数据。可以先假设这两批实验合格率没有显著变化，然后用统计的方法推断假设成立的概率，如果是小概率事件，那么原假设不成立。</p>
<h3 id="简述假设检验的一般步骤？">简述假设检验的一般步骤？</h3>
<ol>
<li>建立原假设和备择假设。</li>
<li>在原假设成立的前提下，选择合适统计量的抽样分布，计算统计量的值，常用的有Z 分布、T 分布、F 分布。</li>
<li>选定显著性水平，查相应分布表确定临界值，从而确定原假设的拒绝区间和接受区间。</li>
<li>对原假设做出判断和解释，如果统计量值大于临界值，拒绝原假设。反之，则接受</li>
</ol>
<h3 id="什么是置信区间？">什么是置信区间？</h3>
<p>任何测量的数据都会存在误差，即使实验条件再精确也无法完全避免随机干扰的影响，所以科学实验往往要测量或实验多次，用取平均值之类的手段去取得结果。多次测量是个排除偶然因素的好办法，但再好的统计手段也不能把所有的偶然因素全部排除。所以，在科学实验中总是会在测量结果上加一个误差范围，这里的误差范围（区间）在统计概率中就叫做置信区间。</p>
<h3 id="为什么小样本用t检验？">为什么小样本用t检验？</h3>
<p>从抽样研究所得的样本均数特点来看，只要样本量&gt;60，（无论总体是否服从正态分布）抽样研究的样本均数服从或者近似服从正态分布；而如果样本量较小（参考样本量&lt;100）,抽样分布随着样本量的减小，与正态分布的差别越来越大。此时需要用小样本理论来解释样本均数的分布——而t分布就是小样本理论的代表。因此，小样本的检验需要用到t检验。</p>
<h3 id="各中检验方法的适用范围是什么？">各中检验方法的适用范围是什么？</h3>
<p>T检验又叫做student t检验，即Student’s t test，通常用于样本含量较小(一般n&lt;30)，总体标准差σ未知的正态分布。目的为：比较样本均数所代表的未知总体均数μ和已知总体均数μ0.</p>
<p>Z检验是通常用于大样本(也就是样本容量&gt;30)平均值差异性检验的方法。是用标准正态分布的理论来推断差异发生的概率，从而对两个平均数的差异进行比较，判断该差异是否显著。</p>
<p>卡方检验又叫做X2检验，简单来说就是，检验两个变量之间有没有关系。卡方检验属于非参数检验，通常是用来比较两个及两个以上样本率(构成比)，以及两个分类变量的关联性分析。基本思想为：比较理论频数和实际频数的吻合程度或者拟合优度问题。</p>
<p>F 检验是为检验方差是否有显著性差异。经常被叫做，联合假设检验(joint hypotheses test)，也可以叫做方差比率检验、方差齐性检验。F 检验为一种在零假设(null hypothesis, H0)情况之下，统计值服从F-分布的检验。</p>
<h3 id="相关性检验有那些标准？">相关性检验有那些标准？</h3>
<p>相关分析是一种简单易行的测量定量数据之间的关系情况的分析方法。可以分析包括变量间的关系情况以及关系强弱程度等。相关系数常见有三类，分别是：</p>
<ol>
<li>Pearson相关系数</li>
<li>Spearman等级相关系数</li>
<li>Kendall相关系数</li>
</ol>
<p>三种相关系数最常使用的是Pearson相关系数；当数据不满足正态性时，则使用Spearman相关系数，Kendall相关系数用于判断数据一致性，比如裁判打分。</p>
<h3 id="参考-4">参考</h3>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/409625718">https://zhuanlan.zhihu.com/p/409625718</a><br>
机器学习-西瓜书<br>
<a href="https://zhuanlan.zhihu.com/p/93182578">https://zhuanlan.zhihu.com/p/93182578</a><br>
<a href="https://blog.csdn.net/weixin_39875181/article/details/78612348">https://blog.csdn.net/weixin_39875181/article/details/78612348</a><br>
<a href="https://blog.csdn.net/m0_37228052/article/details/121498111">https://blog.csdn.net/m0_37228052/article/details/121498111</a><br>
<a href="https://blog.csdn.net/qq_48988106/article/details/121113200">https://blog.csdn.net/qq_48988106/article/details/121113200</a></p>
</blockquote>
<h2 id="模型评估">模型评估</h2>
<h3 id="什么是模型的泛化能力？">什么是模型的泛化能力？</h3>
<p>泛化能力：指模型对未知的、新鲜的数据的预测能力，通常是根据测试误差来衡量模型的泛化能力，测试误差越小，模型能力越强；<br>
统计理论表明：如果训练集和测试集中的样本都是独立同分布产生的，则有 模型的训练误差的期望等于模型的测试误差的期望 。</p>
<h3 id="模型评估的方法主要有哪些？">模型评估的方法主要有哪些？</h3>
<ul>
<li>留出法</li>
<li>交叉验证</li>
<li>自助法</li>
</ul>
<h3 id="Bootstrap原理以及抽样到的概率是啥？">Bootstrap原理以及抽样到的概率是啥？</h3>
<p>63.2%原始数据元组将出现在自助样本中，而其他36.8%的元组将形成检验集。假设每个元组被选中的概率是 1/d, 因此未被选中的概率是（1-1/d）, 需要挑选 d 次，因此一个元组在 d 次都未被选中的概率是（1-1/d）^d。如果 d 很大，该概率近似为 e^(-1)=0.368。因此36.8%的元组将作为验证集。</p>
<h3 id="自助法优缺点？">自助法优缺点？</h3>
<p>自助法的优点有：<br>
在数据集比较小、难以有效划分训练/测试集时很有用：<br>
能从初始数据集中产生多个不同的训练集，这对集成学习等方法而言有很大好处。</p>
<p>但也存在如下缺点：<br>
产生的数据集改变了初始数据集的分布，这会引入估计偏差。因此在初始数据量足够时，留出法和折交叉验证法更常用。</p>
<h3 id="交叉验证的方法主要分为哪些？">交叉验证的方法主要分为哪些？</h3>
<p>1.Holdout验证<br>
严格意义上来说的话，这个不算是交叉验证，因为根本没有用到交叉。首先，我们随机的将样本数据分为两部分（比如：70%的训练集，30%的测试集），然后用训练集来训练模型，在测试集上验证模型及参数。<br>
2.K折交叉验<br>
也是经常会用到的一种方法。主要思想是将数据集划分为互斥的K个集合，用K-1个集合做训练，然后剩下的一个做验证，这里不做过多的解释。<br>
3.留一交叉验证<br>
假设有N个训练样本，它的思想是每次选择N-1个样本来训练数据，留一个样本来验证模型预测的好坏。此方法主要用于样本量非常少的情况，比如对于普通适中问题，当样本小于50时，我一般采用留一交叉验证。</p>
<h3 id="k折交叉验证中k取值多少有什么关系？">k折交叉验证中k取值多少有什么关系？</h3>
<p>在理想情况下，可认为K折交叉验证可以降低模型的方差，从而提高模型的泛化能力，通俗地说，我们期望模型在训练集的多个子数据集上表现良好，要胜过单单在整个训练数据集上表现良好。（但实际上，由于我们所得到K折数据之间并非独立而存在相关性，K折交叉验证到底能降低多少方差还不确定，同时带来的偏差上升有多少也还存疑。）</p>
<p><img src="https://s21.ax1x.com/2024/03/23/pFhTfU0.png" alt="image"></p>
<p>完全不使用交叉验证是一种极端情况，即K=1的情况下。在这个情况下所有数据都被用于训练，因而过拟合导致低偏差、高方差(low bias and high variance)。留一法是K折的另一种极端情况，即K=n。随着K值的不断升高，单一模型评估时的方差逐渐加大而偏差减小。但从总体模型角度来看，反而是偏差升高了而方差降低了。所以当K值在1到n之间的游走，可以理解为一种方差和偏差妥协的结果。<br>
2017年的一项研究给出了另一种经验式的选择方法，作者建议k=log(n) 且保证n/K&gt;3d ，n代表了数据量，d代表了特征数。<br>
1、使用交叉验证的根本原因是数据集太小，而较小的K值会导致可用于建模的数据量太小，所以小数据集的交叉验证结果需要格外注意。建议选择较大的K值。<br>
2、当模型稳定性较低时，增大K的取值可以给出更好的结果<br>
3、相对而言，较大的K值的交叉验证结果倾向于更好。但同时也要考虑较大K值的计算开销。</p>
<h3 id="训练集、验证集合测试集的作用？">训练集、验证集合测试集的作用？</h3>
<p>训练集：主要就是训练模型，理论上越大越好；<br>
验证集：用于模型调试超参数。通常要求验证集比较大，避免模型会对验证集过拟合；<br>
测试集：用于评估模型的泛化能力。理论上，测试集越大，评估结果就约精准。另外，测试集必须不包含训练样本，否则会影响对模型泛化能力的评估。<br>
验证集和测试集的对比：</p>
<p>测试集通常用于对模型的预测能力进行评估，它是提供模型预测能力的无偏估计；如果不需要对模型预测能力的无偏估计，可以不需要测试集；<br>
验证集主要是用于超参数的选择。</p>
<h3 id="划分数据集的比例选择方法">划分数据集的比例选择方法?</h3>
<p>对于小批量数据，数据的拆分的常见比例为：<br>
如果未设置验证集，则将数据三七分：70% 的数据用作训练集、30% 的数据用作测试集。<br>
如果设置验证集，则将数据划分为：60% 的数据用作训练集、20%的数据用过验证集、20% 的数据用作测试集。<br>
对于大批量数据，验证集和测试集占总数据的比例会更小。<br>
对于百万级别的数据，其中 1 万条作为验证集、1 万条作为测试集即可。<br>
验证集的目的就是验证不同的超参数；测试集的目的就是比较不同的模型。<br>
一方面它们要足够大，才足够评估超参数、模型。<br>
另一方面，如果它们太大，则会浪费数据（验证集和训练集的数据无法用于训练）</p>
<h3 id="调参的方法有哪些？">调参的方法有哪些？</h3>
<ul>
<li><strong>传统的手工调参</strong><br>
在传统的调参过程中，我们通过训练算法手动检查随机超参数集，并选择符合我们目标的最佳参数集。没办法确保得到最佳的参数组合。这是一个不断试错的过程，所以，非常的耗时。</li>
<li><strong>网格搜索</strong><br>
网格搜索是一种基本的超参数调优技术。它类似于手动调优，为网格中指定的所有给定超参数值的每个排列构建模型，评估并选择最佳模型。由于它尝试了超参数的每一个组合，并根据交叉验证得分选择了最佳组合，这使得GridsearchCV非常慢。</li>
<li><strong>随机搜索</strong><br>
使用随机搜索代替网格搜索的动机是，在许多情况下，所有的超参数可能不是同等重要的。随机搜索从超参数空间中随机选择参数组合，参数由n_iter给定的固定迭代次数的情况下选择。实验证明，随机搜索的结果优于网格搜索。随机搜索的问题是它不能保证给出最好的参数组合。</li>
<li><strong>贝叶斯搜索</strong><br>
贝叶斯优化属于一类优化算法，称为基于序列模型的优化(SMBO)算法。这些算法使用先前对损失 f 的观察结果，以确定下一个(最优)点来抽样 f。要在2维或3维的搜索空间中得到一个好的代理曲面需要十几个样本，增加搜索空间的维数需要更多的样本。</li>
</ul>
<p>在确定参数的最佳组合的保证和计算时间之间总是存在权衡。如果超参数空间(超参数个数)非常大，则使用随机搜索找到超参数的潜在组合，然后在该局部使用网格搜索(超参数的潜在组合)选择最优特征。</p>
<h3 id="参考-5">参考</h3>
<blockquote>
<p><a href="https://blog.51cto.com/u_8985428/3866903">https://blog.51cto.com/u_8985428/3866903</a></p>
</blockquote>
<h2 id="性能度量">性能度量</h2>
<h3 id="TP、FP、TN、FN具体指的是什么？">TP、FP、TN、FN具体指的是什么？</h3>
<p>FN：False Negative,被判定为负样本，但事实上是正样本。<br>
FP：False Positive,被判定为正样本，但事实上是负样本。<br>
TN：True Negative,被判定为负样本，事实上也是负样本。<br>
TP：True Positive,被判定为正样本，事实上也是证样本。</p>
<h3 id="ROC曲线和PR曲线的区别？">ROC曲线和PR曲线的区别？</h3>
<p>ROC曲线的纵坐标是TPR，横坐标是FPR<br>
PR曲线的纵坐标是Precision，纵坐标是Recall</p>
<p>其中TPR、FPR以及Precision、Recall的计算方法如下：</p>
$$
\begin{array}{l}
TPR = \frac{{TP}}{{TP + FN}}\\
FPR = \frac{{FP}}{{FP + TN}}\\
\Pr ecision = \frac{{TP}}{{TP + FP}}\\
{\mathop{\rm Re}\nolimits} call = \frac{{TP}}{{TP + FN}}
\end{array}
$$  
<p>注意看到TPR就是Recall。</p>
<h3 id="如何综合precision和recall指标？">如何综合precision和recall指标？</h3>
<p>可以使用 F1评分（F1-Score）：查全率和查准率的调和平均数。</p>
$$
F1 = \frac{{2PR}}{{P + R}}
$$
<p>所谓调和平均数，考虑的是，赋予较小值更大的权重，避免较小值和较大值对结果产生较大影响。对于二分类的情况，则讲究的是不偏科。因为我们追求的就是更高的查全率和更高的查准率，即刚才思考中的情况4。因此F1评分相较于单一的查全率和查准率具备更好的评估效果。</p>
<h3 id="Precision和Recall的应用场景？">Precision和Recall的应用场景？</h3>
<p>Precision适用于那些对预测结果很有信心的场景下，比如买股票，希望只要自己选择的标签为1股票，都是涨的；或者在推荐中给用户推荐的视频或者新闻等内容，用户肯定会消费的。</p>
<p>Recall适用于对标签也就是实际上的正样本有很大注意的场景，比如抓坏人，总是希望将坏人都抓回来，因此多抓了几个好人也没事，只要能把坏人抓回来就可以，而不关系自己抓的人中有多少被误伤的。</p>
<h3 id="如何判断一个学习器的性能比另一个好？">如何判断一个学习器的性能比另一个好？</h3>
<p><img src="https://s21.ax1x.com/2024/03/23/pFhTTv4.png" alt="image"></p>
<p>如果一个学习器的P-R曲线被另一个学习器的P-R曲线完全包住，则可认为后者的性能优于前者，例如上面的A和B优于学习器C。</p>
<h3 id="ROC曲线中，高于和低于对角线表示意义">ROC曲线中，高于和低于对角线表示意义?</h3>
<p>如果模型的roc曲线在对角线下方，则该模型比随机模型还差，高于对角线则表示模型比随机模型好，模型是有意义的。</p>
<p>ROC曲线下的面积就AUC，其中AUC大于0.5表示模型的排序能力是正向的，最起码比随机要好，如果小于0.5，说明模型的排序结果很差了。</p>
<h3 id="多分类AUC怎么算？">多分类AUC怎么算？</h3>
<p>基于macro的策略：ovr的划分方式，分别计算每个类别的metrics然后再进行平均</p>
<p>基于micro的策略：所有类放在一起算metrics；</p>
<p>micro的评估方式，当类别非常不均衡时，micro的计算结果会被样本数量多的类别主导，此时需要使用macro</p>
<h3 id="ROC曲线和PR曲线的区别，适用场景，各自优缺点？">ROC曲线和PR曲线的区别，适用场景，各自优缺点？</h3>
<p>roc曲线和正负样本的比例是没有关系的，roc聚焦于二分类模型整体对正负样本的预测能力，所以适用于评估模型整体的性能，如在rank算法中，如果主要关注正样本的预测能力而不care负样本的预测能力，则pr曲线更合适。</p>
<h3 id="准确率Accuracy的局限性是什么？">准确率Accuracy的局限性是什么？</h3>
<p>说明下Accuracy的计算公式如下所示：</p>
$$
A = \frac{{TP + FP}}{{TP + FN + TN + FP}}
$$
<p>准确率是分类问题最简单也是最直接的评价标准，但存在明显的缺陷。如：当负样本数占99%时，分类器把所有样本都预测为负样本也可以获得99%的准确率。所以，当不同类别的样本比例非常不均衡时，占比大的类别往往成为影响准确率的最主要因素。</p>
<h3 id="AUC的物理意义是啥">AUC的物理意义是啥?</h3>
<p>AUC是衡量排序能力的好坏，越大越好，值在0和1之间，AUC 的原始定义是 ROC 下的面积，计算起来比较麻烦。从ROC 的曲线可以看出， AUC的值 不会超过1。同时，对于相同的 FPR ，当 TPR 越大时，面积越大，即 AUC 越大。这也就是说，被模型预测为正的样本中，实际的正样本越多越好，实际的负样本越少越好。从另外一个角度来说， AUC的物理意义就是：随机选出一对正负样本，模型对正样本的打分大于对负样本打分的概率。</p>
$$
AUC = \frac{{\sum {{r_i} - \frac{{P*(P + 1)}}{2}} }}{{P*N}}
$$
<p>其中P表示正样本数量，N表示负样本数量, 以及r表示排序值。</p>
<h3 id="AUC为啥对正负样本比例不敏感？">AUC为啥对正负样本比例不敏感？</h3>
<p>AUC的全称是 area under the curve，即曲线下的面积， 通常这里的曲线指的是受试者操作曲线(Receiver operating characteristic, ROC)。实际的模型的ROC曲线则是一条上凸的曲线，介于随机和理想的ROC曲线之间。而ROC曲线下的面积，即为AUC的表达式：</p>
$$
% MathType!MTEF!2!1!+-
AUC{\rm{ = }}\int_{t =  - \infty }^\infty  {y(t)dx(t)} 
$$
<p>可以证明得到如下的结果：AUC可以看做随机从正负样本中选取一对正负样本，其中正样本的得分大于负样本的概率，证明如下：</p>
<p><img src="https://s21.ax1x.com/2024/03/23/pFhTHKJ.png" alt="image"></p>
<h3 id="为啥很多工程上的评价指标使用ROC或AUC">为啥很多工程上的评价指标使用ROC或AUC</h3>
<p>ROC和AUC是用来衡量模型的排序能力的，可能预测的precision和recall很差，但是AUC很好，在一些推荐排序的算法中，经常使用到AUC指标，说白了，就是AUC指关注排序的好坏，不关注精度啥的指标。</p>
<h3 id="PR和ROC的区别？">PR和ROC的区别？</h3>
<ol>
<li>PR<br>
P-R曲线就是精确率precision vs 召回率recall 曲线，以recall作为横坐标轴，precision作为纵坐标轴。当我们对样本预测后得到概率，通过置信度就可以对所有样本进行排序，再逐个样本的选择阈值，在该样本之前的都属于正例，该样本之后的都属于负例。得到的PR曲线大概长下面这个样子。P-R曲线肯定会经过（0,0）点，比如讲所有的样本全部判为负例，则TP=0，那么P=R=0，因此会经过（0,0）点，但随着阈值点左移，precision初始很接近1，recall很接近0，因此有可能从（0,0）上升的线和坐标重合，不易区分。如果最前面几个点都是负例，那么曲线会从（0,0）点开始逐渐上升，但曲线最终不会到（1,0）点。</li>
</ol>
<p><img src="https://s21.ax1x.com/2024/03/23/pFhTOV1.png" alt="image"></p>
<ol start="2">
<li>ROC<br>
ROC的全称是Receiver Operating Characteristic Curve，中文名字叫“受试者工作特征曲线”，顾名思义，其主要的分析方法就是画这条特征曲线。该曲线的横坐标为假阳性率（False Positive Rate, FPR）,纵坐标为真阳性率（True Positive Rate, TPR）。</li>
</ol>
<p><img src="https://s21.ax1x.com/2024/03/23/pFhTj56.png" alt="image"></p>
<p>根据上述的定义，ROC最直观的应用就是能反映模型在选取不同阈值的时候其敏感性（sensitivity, FPR）和其精确性（specificity, TPR）的趋势走向。不过，相比于上面说的P-R曲线（精确度和召回率），ROC曲线有一个巨大的优势就是，当正负样本的分布发生变化时，其形状能够基本保持不变，而P-R曲线的形状一般会发生剧烈的变化，因此该评估指标能降低不同测试集带来的干扰，更加客观的衡量模型本身的性能。</p>
<h3 id="为啥方差的计算公式分母为n-1">为啥方差的计算公式分母为n-1?</h3>
<p>首先我们解释下自由度的定义，自由度在英文中是这么解释的，In statistics, the number of degrees of freedom is the number of values in the final calculation of a statistic that are free to vary.通俗的来说就是，n个样本，如果在某种条件下，样本均值是先定的固定的，那么只剩个n-1样本的值是可以变化的，那么自由度就是n-1。</p>
<p>假设现在有3个样本，分别是${X_1}{X_2}{X_3}$。因为样本具有随机性，所以它们取值不定。但是假设出于某种原因，我们需要让样本均值固定，比如说是$\hat X$， 此时&quot;有随机性&quot;的样本只有2个。一旦均值固定了，只要知道其中的两个，剩下的一个肯定可以自动求出来。剩下的那个被求出来的就可以理解为被剥夺了一个自由度。所以就这个例子而言，3个样本最终&quot;自由&quot;的只有其中的 2 个。</p>
<p>实上，计算样本方差时，样本均值就需要给定。计算样本均值也就是维基百科里提到的 ‘intermediate step’。如果你去观察计算样本方差的一系列表达式，比如往往最常会被介绍的方差的无偏估计 （样本方差）$\frac{1}{{n - 1}}\sum\nolimits_{i = 1}^n {{{({X_i} - \hat X)}^2}}$.其实发现样本均值这一项都包含在内。考虑到方差是衡量数据偏差程度的统计量，计算一下样本均值作为中间步骤的中间量，也不失其合理性。于是，为计算样本方差，样本里原有的n个自由度，有一个自由度被分配给计算样本均值，剩下自由度即为n-1。</p>
<h3 id="为什么使用标准差？">为什么使用标准差？</h3>
<p>方差是衡量随机变量或一组数据时离散程度的度量。方差用来度量随机变量和其数学期望（即均值）之间的偏离程度。统计中的方差（样本方差）是各个样本数据和平均数之差的平方和的平均数。在许多实际问题中，研究方差即偏离程度有着重要意义。方差公式的计算公式如下：</p>
$$
S^2_{N}=\frac{1}{N}\sum_{i=1}^{N}(x_{i}-\bar{x})^{2}
$$
<p>标准差又称均方差，是方差的算数平方根，标准差的公式如下：</p>
$$
S_{N}=\sqrt{\frac{1}{N}\sum_{i=1}^{N}(x_{i}-\bar{x})^{2}}
$$
<p>样本标准差的计算公式为：</p>
$$
S_{N}=\sqrt{\frac{1}{N-1}\sum_{i=1}^{N}(x_{i}-\bar{x})^{2}}
$$
<p>可以看到标准差的概念是基于方差的，仅仅是求了一个平方根而已。那么为什么要造出标准差这样一个概念呢？简单来说，方差单位和数据的单位不一致，没法使用，虽然能很好的描述数据与均值的偏离程度，但是处理结果是不符合我们的直观思维的。而标准差和数据的单位一致，使用起来方便。内在原因就是方差开了一个平方，而标准差通过加了一个根号使得和均值的量纲（单位）保持了一致，在描述一个波动范围时标准差比方差更方便。</p>
<p>与方差相比，使用标准差来表示数据点的离散程度有3个好处：<br>
1、表示离散程度的数字与样本数据点的数量级一致，更适合对数据样本形成感性认知。<br>
2、表示离散程度的数字单位与样本数据的单位一致，更方便做后续的分析运算。<br>
3、在样本数据大致符合正态分布的情况下，标准差具有方便估算的特性：68%的数据点落在平均值前后1个标准差的范围内、95%的数据点落在平均值前后2个标准差的范围内，而99%的数据点将会落在平均值前后3个标准差的范围内。</p>
<h3 id="回归问题的评价指标有哪些？">回归问题的评价指标有哪些？</h3>
<p>回归问题五大评价指标分别为</p>
<ul>
<li>皮尔逊相关系数</li>
<li>解释方差分数（explained_varience_score）</li>
<li>平均绝对误差（mean_absolute_error）</li>
<li>均方差(mean_square_error)</li>
<li>r2分数（r2_score）</li>
<li>调整r2分数（r2_score_adjust）</li>
</ul>
<h3 id="皮尔逊相关系数怎么算的？">皮尔逊相关系数怎么算的？</h3>
<p>公式计算如下：</p>
$$
{\rho _{X,Y}} = \frac{{Cov(X,Y)}}{{{\sigma _X}{\sigma _Y}}}
$$
<p>主要有以下两个步骤：</p>
<ol>
<li>计算协方差</li>
<li>计算标准差</li>
</ol>
<h3 id="参考-6">参考</h3>
<blockquote>
<p><a href="https://www.zhihu.com/question/20534502/answer/2028365946">https://www.zhihu.com/question/20534502/answer/2028365946</a><br>
<a href="https://www.cnblogs.com/13224ACMer/p/11799030.html">https://www.cnblogs.com/13224ACMer/p/11799030.html</a><br>
<a href="https://zhuanlan.zhihu.com/p/386064764">https://zhuanlan.zhihu.com/p/386064764</a><br>
<a href="https://blog.csdn.net/dylan_young/article/details/121222221">https://blog.csdn.net/dylan_young/article/details/121222221</a></p>
</blockquote>
<h2 id="数据治理">数据治理</h2>
<h3 id="机器学习中如何处理类别型特征？">机器学习中如何处理类别型特征？</h3>
<p>类别型特征指的是如性别(男、女)，身高(高、矮)等非连续型的数据，这些数据需要经过处理才可以进入到算法模型中<br>
在机器学习中，一般可以按照如下进行处理：</p>
<ul>
<li>序号编码<br>
序号编码（Ordinal Encoding）通常用于处理类别间具有大小关系的数据。如成绩有“高、中、低”，并且存在“高&gt;中&gt;低”的关系，可以按照大小关系赋予数值ID：3，2，1。</li>
<li>独热编码<br>
独热编码（One-hot Encoding）通常用于处理类别间不具有大小关系的特征，每个类别对应一维编码，如大和小两个特征值可以变为[0,1]和[1,0]</li>
<li>二进制编码<br>
二进制编码（Binary Encoding）是指使用二进制来表示映射关系的编码方式。<br>
1）先将类别特征赋予一个数值型的唯一ID（十进制的整数）<br>
2）将每个类别特征对应的数值型的唯一ID转换成二进制</li>
</ul>
<h3 id="机器学习中的异常值如何处理？">机器学习中的异常值如何处理？</h3>
<p>异常点的检测按照处理方式可以分为图形法和模型法。图形法主要是借助箱线图或者正态分布图来判断，而模型法主要是建立总体模型，偏离模型的鉴定为异常点。</p>
<ul>
<li>数据错误<br>
不符合直观的数据，如升高为10m,这种数据需要去除，或者使用均值等方法填充。</li>
<li>箱线图<br>
我们常用的分位点为上四分位数q1（数据的75%分位点所对应的值）、中位数（数据的50%分位点所对应的值）和下四分位数q3（数据的25%分位点所对应的值），上下四分位数差值被称为四分位差，即q1-q3。异常点为上须和下须之外的数据点，其中上须=q1+1.5*(q1-q3)，下须=q3-1.5*(q1-q3)。图中中间部分的两个点分别为中位数和均值，可以反映数据的集中趋势。</li>
<li>正态分布图<br>
在数据服从正态分布的情况下，可以借助3∂原则来对异常值进行检测</li>
<li>模型方法<br>
可以使用一些异常检测的方法来进行检测，如AutoEncoder等</li>
</ul>
<h3 id="缺失值的处理方法有哪些？">缺失值的处理方法有哪些？</h3>
<ul>
<li>不做任何处理<br>
不对丢失的数据做任何事情。一方面，有一些算法有处理缺失值的能力，此时我们可以将完全控制权交给算法来控制它如何响应数据，如xgboos等。另一方面，各种算法对缺失数据的反应不同。例如，一些算法基于训练损失减少来确定缺失数据的最佳插补值。</li>
<li>不使用时将其删除<br>
排除具有缺失数据的记录是一个最简单的方法。但可能会因此而丢失一些关键数据点。</li>
<li>均值插补<br>
使用这种方法，可以先计算列的非缺失值的均值，然后分别替换每列中的缺失值，并独立于其他列。最大的缺点是它只能用于数值数据。这是一种简单快速的方法，适用于小型数值数据集。但是，存在例如忽略特征相关性的事实的限制等。每次填补仅适用于其中某一独立的列。<br>
此外，如果跳过离群值处理，几乎肯定会替换一个倾斜的平均值，从而降低模型的整体质量。</li>
<li>中位数插补<br>
解决上述方法中的异常值问题的另一种插补技术是利用中值。排序时，它会忽略异常值的影响并更新该列中出现的中间值。</li>
<li>众数插补<br>
这种方法可应用于具有有限值集的分类变量。有些时候，可以使用最常用的值来填补缺失值。</li>
<li>分类值的插补<br>
当分类列有缺失值时，可以使用最常用的类别来填补空白。如果有很多缺失值，可以创建一个新类别来替换它们。</li>
<li>前一次观测结果<br>
这是一种常见的统计方法，用于分析纵向重复测量数据时，一些后续观察缺失。</li>
<li>线性插值<br>
这是一种近似于缺失值的方法，沿着直线将点按递增顺序连接起来。简而言之，它以与在它之前出现的值相同的升序计算未知值。因为线性插值是默认的方法，我们不需要在使用它的时候指定它。这种方法常用于时间序列数据集。</li>
<li>KNN 插补<br>
一种基本的分类方法是 k 最近邻 (kNN) 算法。类成员是 k-NN 分类的结果。<br>
项目的分类取决于它与训练集中的点的相似程度，该对象将进入其 k 个最近邻中成员最多的类。如果 k = 1，则该项目被简单地分配给该项目最近邻居的类。使用缺失数据找到与观测值最近的 k 邻域，然后根据邻域中的非缺失值对它们进行插补可能有助于生成关于缺失值的预测。</li>
</ul>
<h3 id="如何进行连续特征离散化？">如何进行连续特征离散化？</h3>
<p>无监督学习方法：</p>
<ol>
<li>等宽法</li>
<li>等频法</li>
<li>基于聚类的方法</li>
</ol>
<p>有监督学习方法：</p>
<ol>
<li>1R方法</li>
<li>基于信息熵的方法</li>
<li>基于卡方的方法</li>
</ol>
<h3 id="什么是特征工程？">什么是特征工程？</h3>
<p>特征工程，是指用一系列工程化的方式从原始数据中筛选出更好的数据特征，以提升模型的训练效果。业内有一句广为流传的话是：数据和特征决定了机器学习的上限，而模型和算法是在逼近这个上限而已。由此可见，好的数据和特征是模型和算法发挥更大的作用的前提。</p>
<h3 id="特征工程的步骤有哪些？">特征工程的步骤有哪些？</h3>
<p>一般包括三个子模块：特征构建-&gt;特征提取-&gt;特征选择</p>
<p>特征构建：根据原始数据构建新的特征，需要找出一些具有物理意义的特征。<br>
特征提取：自动地构建新的特征，将原始特征转换为一组具有明显物理意义或者统计意义或核的特征。例如 Gabor、几何特征、纹理等。常用的方法有：PCA、ICA、LDA等。<br>
特征选择：从特征集合中挑选一组最具统计意义的特征子集，把无关的特征删掉，从而达到降维的效果</p>
<h3 id="特征离散化有什么好处？">特征离散化有什么好处？</h3>
<p>在工业界，很少直接将连续值作为逻辑回归模型的特征输入，而是将连续特征离散化为一系列0、1特征交给逻辑回归模型，这样做的优势有以下几点：</p>
<ol>
<li>离散特征的增加和减少都很容易，易于模型的快速迭代；</li>
<li>稀疏向量内积乘法运算速度快，计算结果方便存储，容易扩展；</li>
<li>离散化后的特征对异常数据有很强的鲁棒性：比如一个特征是年龄&gt;30是1，否则0。如果特征没有离散化，一个异常数据“年龄300岁”会给模型造成很大的干扰；</li>
<li>逻辑回归属于广义线性模型，表达能力受限；单变量离散化为N个后，每个变量有单独的权重，相当于为模型引入了非线性，能够提升模型表达能力，加大拟合；</li>
<li>离散化后可以进行特征交叉，由M+N个变量变为M*N个变量，进一步引入非线性，提升表达能力；</li>
<li>特征离散化后，模型会更稳定，比如如果对用户年龄离散化，20-30作为一个区间，不会因为一个用户年龄长了一岁就变成一个完全不同的人。当然处于区间相邻处的样本会刚好相反，所以怎么划分区间是门学问；</li>
<li>特征离散化以后，起到了简化了逻辑回归模型的作用，降低了模型过拟合的风险。</li>
</ol>
<h3 id="特征归一化有哪些方法？">特征归一化有哪些方法？</h3>
<ol>
<li>线性归一化<br>
也称min-max标准化、离差标准化；是对原始数据的线性变换，使得结果值映射到[0,1]之间。转换函数如下：</li>
</ol>
$$
x' = \frac{{x - \min (x)}}{{\max (x) - \min (x)}}
$$
<p>这种归一化比较适用在数值较集中的情况。但是这种方法有一个缺陷，就是如果max和min不稳定的时候，很容易使得归一化的结果不稳定，易受极值影响，影响后续使用效果。所以在实际应用中，我们一般用经验常量来替代max和min。</p>
<ol start="2">
<li>标准差归一化<br>
也叫Z-score标准化，这种方法给予原始数据的均值（mean，μ）和标准差（standard deviation，σ）进行数据的标准化。经过处理后的数据符合标准正态分布，即均值为0，标准差为1，转化函数为：</li>
</ol>
$$
{x^*} = \frac{{x - u}}{\sigma }
$$
<ol start="3">
<li>非线性归一化<br>
这种方法一般使用在数据分析比较大的场景，有些数值很大，有些很小，通过一些数学函数，将原始值进行映射。一般使用的函数包括log、指数、正切等，需要根据数据分布的具体情况来决定非线性函数的曲线。</li>
</ol>
<h3 id="特征选择有哪些方法？">特征选择有哪些方法？</h3>
<p>筛选特征的方法：过滤式(filter)、包裹式(wrapper)、嵌入式(embedding)</p>
<ol>
<li>过滤式(filter)<br>
先对数据集进行特征选择，其过程与后续学习器无关，即设计一些统计量来过滤特征，并不考虑后续学习器问题。如方差选择、卡方检验、互信息</li>
<li>包裹式(wrapper)<br>
实际上就是一个分类器，如Las Vagas 算法；包裹式特征选择直接把最终将要使用的学习器的性能作为特征子集的评价原则。其目的就是为给定学习器选择最有利于其性能、量身定做的特征子集。</li>
<li>嵌入式(embedding)<br>
实际上是学习器自主选择特征。如基于惩罚项的选择、基于树的选择GBDT；嵌入式特征选择是将特征选择与学习器训练过程融为一体，两者在同一个优化过程中完成的。即学习器训练过程中自动进行了特征选择。</li>
</ol>
<h3 id="特征筛选如何获取高相似性特征？">特征筛选如何获取高相似性特征？</h3>
<p>在得到特征后，可以基于卡方或者皮尔逊等相关系数</p>
<h3 id="计算特征之间的相关性方法有哪些？">计算特征之间的相关性方法有哪些？</h3>
<ol>
<li>pearson系数PLCC<br>
对定距连续变量的数据进行计算。是介于-1和1之间的值</li>
<li>Spearman秩相关系数SRCC<br>
该系数是度量两个变量之间的统计相关性的指标，用来评估当前单调函数来描述俩个变量之间的关系有多相关</li>
<li>Kendall（肯德尔等级）相关系数<br>
该相关系数是一个用来测量两个随机变量相关性的统计值。</li>
</ol>
<h3 id="如何检查数据中的噪声？">如何检查数据中的噪声？</h3>
<ol>
<li>通过寻找数据集中与其他观测值及均值差距最大的点作为异常</li>
<li>聚类方法检测：将类似的取值组织成“群”或“簇”，落在“簇”集合之外的值被视为离群点。</li>
</ol>
<h3 id="什么是组合特征？">什么是组合特征？</h3>
<p>为了提高复杂关系的拟合能力，在特征工程中经常会把一阶离散特征两两组合，构成高级特征。例如，特征a有m个取值，特别b 有n个取值，将二者组合就有m*n个组成情况。这时需要学习的参数个数就是 m×n 个。一些常见的算法如FM就可以用来对高维系数特征的交叉进行学习，且在高维情况下可以高效。</p>
<h3 id="如何处理高维特征？">如何处理高维特征？</h3>
<ol>
<li>高维连续特征<br>
这种情况可以使用降维方法将维度降低下来然后进行模型的训练，或者对特征进行选择性的筛选得到重要特征后再进行算法开发。</li>
<li>高维离散特征<br>
目前主流的方法是使用Embedding技术进行获取离散特征对应的稠密特征，然后在上层进行特征的融合。</li>
</ol>
<h2 id="不平衡问题">不平衡问题</h2>
<h3 id="如何处理类别不均衡问题？">如何处理类别不均衡问题？</h3>
<ol>
<li>采样<br>
这里的采样可以分为上采样和下采样，简单说就是从类别少的多采样或者类别多的少采样。对于上采样，如SMOTE算法。</li>
<li>转化为One-class问题<br>
把它看做一分类（One Class Learning）或异常检测（Novelty Detection）问题。这类方法的重点不在于捕捉类间的差别，而是为其中一类进行建模，经典的工作包括One-class SVM等</li>
<li>聚类+采样<br>
对数据先进行聚类，再将大的簇进行随机欠采样或者小的簇进行数据生成，注意了，这里不是简单的上面所说的下采样，而是先聚类后再采样。</li>
<li>模型惩罚<br>
简单说就是对分类器的小类样本数据增加权值，降低大类样本的权值。</li>
<li>换模型<br>
使用一些如Bagging和Boosting的方法,</li>
</ol>
<h3 id="分类问题中如何解决正负样本比较大的情况？">分类问题中如何解决正负样本比较大的情况？</h3>
<p>1.随机欠采样（RandomUnder-Sampling）<br>
2.随机过采样（RandomOver-Sampling）<br>
3.基于聚类的过采样（Cluster-BasedOver Sampling）<br>
在这种情况下，K-均值聚类算法独立地被用于少数和多数类实例。这是为了识别数据集中的聚类。随后，每一个聚类都被过采样以至于相同类的所有聚类有着同样的实例数量，且所有的类有着相同的大小。<br>
4.信息性过采样：合成少数类过采样技术（SMOTE）<br>
这一技术可用来避免过拟合——当直接复制少数类实例并将其添加到主数据集时。从少数类中把一个数据子集作为一个实例取走，接着创建相似的新合成的实例。这些合成的实例接着被添加进原来的数据集。新数据集被用作样本以训练分类模型。<br>
5.改进的合成少数类过采样技术（MSMOTE）<br>
6.算法集成技术（AlgorithmicEnsemble Techniques）如 Bagging boosting</p>
<h3 id="采样后如何计算指标？">采样后如何计算指标？</h3>
<p>比如采样前的正负样本比例是100:1, 采样后是1:1，使用采样后的数据训练好的模型后，不是在1:1的数据上验证指标的好坏，而是要在原始的数据上验证precision和recall等。</p>
<h3 id="如果把不平衡的训练集采样到平衡，计算的AUC和Precision会右什么变化？">如果把不平衡的训练集采样到平衡，计算的AUC和Precision会右什么变化？</h3>
<p>对于正负样本比为1：100，经过采样后训练得到的模型，在采样后的得到平衡的数据上，相比于之前的不平衡的情况，AUC不会变，这是我们在之前说到的，但是Precision会变大，因为正样本的比例变大了。</p>
<h3 id="class-weight的思想是什么？">class_weight的思想是什么？</h3>
<p>就是简单的类权重，对于不平衡的问题的话，可以给不同比例的样本在损失函数函数上加以权重，保持后续在梯度更新上，模型的学习不会偏向于多类的样本，这点在sklearn中的很多模型中都自带的有参数设置。</p>
<h3 id="讲讲smote算法的原理">讲讲smote算法的原理?</h3>
<p>SMOTE的全称是Synthetic Minority Over-Sampling Technique 即“人工少数类过采样法”，非直接对少数类进行重采样，而是设计算法来人工合成一些新的少数样本。</p>
<p>主要步骤如下：</p>
<ol>
<li>选一个正样本</li>
<li>找到该正样本的K个近邻（假设K = 3）</li>
<li>随机从K个近邻中选出一个样本</li>
<li>在正样本和随机选出的这个近邻之间的连线上，随机找一点。这个点就是人工合成的新正样本了</li>
</ol>
<h3 id="smote的缺点以及为啥在业界用的不多？">smote的缺点以及为啥在业界用的不多？</h3>
<p>SMOTE是基于距离的度量，然后生成少数类样本。这样生成的数据很大可能是噪音数据，是不利于学习的。<br>
原因是：</p>
<ol>
<li>如果小样本数据之间生成新的小样本数据，没有揭示太多信息，意义不大。</li>
<li>如果小样本数据生成的数据散布在大样本数据里，则很有可能是噪音，意义也不大。</li>
</ol>
<p>而且工业界的数据量都特别大，对于这种方法需要进行合成数据的效率问题来说，是很难接受的。</p>
<h3 id="过采样和生成样本的区别？">过采样和生成样本的区别？</h3>
<p>上采样不一定是生成具体的样本，例如简单的重复的进行数据的采样，通过这种采样来说它是不涉及样本生成的过程，但生成样本一定是一种上采样的过程。</p>
<h3 id="参考-7">参考</h3>
<blockquote>
<p><a href="https://blog.csdn.net/m0_38068876/article/details/122736423">https://blog.csdn.net/m0_38068876/article/details/122736423</a><br>
<a href="https://zhuanlan.zhihu.com/p/457807729">https://zhuanlan.zhihu.com/p/457807729</a><br>
<a href="https://zhuanlan.zhihu.com/p/91125751">https://zhuanlan.zhihu.com/p/91125751</a><br>
<a href="https://blog.csdn.net/weixin_46838716/article/details/124424903">https://blog.csdn.net/weixin_46838716/article/details/124424903</a><br>
<a href="https://blog.csdn.net/cc13186851239/article/details/114336039#69__76">https://blog.csdn.net/cc13186851239/article/details/114336039#69__76</a><br>
<a href="https://zhuanlan.zhihu.com/p/36503570">https://zhuanlan.zhihu.com/p/36503570</a></p>
</blockquote>
</1$,因此在梯度下降过程中，权重$w$将逐渐减小，趋向于0但不等于0。这也就是权重衰减（weight></p>]]></content>
      <categories>
        <category>算法面试</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>刷八股</tag>
      </tags>
  </entry>
  <entry>
    <title>推荐系统常见模型</title>
    <url>/2024/03/19/machine_learning/rec_common_mod/</url>
    <content><![CDATA[<h1>推荐系统</h1>
<h2 id="推荐理论">推荐理论</h2>
<h2 id="算法模型">算法模型</h2>
<h3 id="简单介绍下GBDT-LR模型？">简单介绍下GBDT+LR模型？</h3>
<p>GBDT+LR利用GBDT进行“自动化”的特征组合，将原始特征向量转换成离散型特征向量，并输入逻辑回归模型，进行最终的CTR预估。</p>
<p>相比深度模型，GBDT+LR模型在架构而言十分的简洁。GBDT部分通过多颗回归树将输入特征重新筛选组合后为新的特征离散，LR部分则通过读取GBDT的输出特征进行模型训练。</p>
<h3 id="GBDT-LR组合模型的步骤是什么？">GBDT+LR组合模型的步骤是什么？</h3>
<p>GBDT+LR 由两部分组成，其中GBDT用来对训练集提取特征作为新的训练输入数据，LR作为新训练输入数据的分类器。</p>
<p>具体来讲，有以下几个步骤：</p>
<ol>
<li>
<p>GBDT首先对原始训练数据做训练，得到一个二分类器，当然这里也需要利用网格搜索寻找最佳参数组合。</p>
</li>
<li>
<p>与通常做法不同的是，当GBDT训练好做预测的时候，输出的并不是最终的二分类概率值，而是要把模型中的每棵树计算得到的预测概率值所属的叶子结点位置记为1，这样，就构造出了新的训练数据。</p>
</li>
<li>
<p>新的训练数据构造完成后，下一步就要与原始的训练数据中的label(输出)数据一并输入到Logistic Regression分类器中进行最终分类器的训练。</p>
</li>
</ol>
<h3 id="为什么GBDT-LR模型中建树采用ensemble决策树？">为什么GBDT+LR模型中建树采用ensemble决策树？</h3>
<p>一棵树的表达能力很弱，不足以表达多个有区分性的特征组合，多棵树的表达能力更强一些。GBDT每棵树都在学习前面棵树尚存的不足，迭代多少次就会生成多少颗树。按paper以及Kaggle竞赛中的GBDT+LR融合方式，多棵树正好满足LR每条训练样本可以通过GBDT映射成多个特征的需求。</p>
<h3 id="为什么建树采用GBDT而非RF？">为什么建树采用GBDT而非RF？</h3>
<p>RF也是多棵树，但从效果上有实践证明不如GBDT。且GBDT前面的树，特征分裂主要体现对多数样本有区分度的特征；后面的树，主要体现的是经过前N颗树，残差仍然较大的少数样本。优先选用在整体上有区分度的特征，再选用针对少数样本有区分度的特征，思路更加合理，这应该也是用GBDT的原因。</p>
<h3 id="为什么GBDT可用于特征选择和特征组合？">为什么GBDT可用于特征选择和特征组合？</h3>
<p>GBDT是由多颗回归树组成的树林，后一棵树以前面树林的结果与真实结果的残差为拟合目标。每棵树生成的过程是一课标准的回归树生成过程，因此回归树中每个节点的分裂是一个自然的特征选择过程，而多层节点的结构则对特征进行了有效的自动组合，也就非常高效地解决了特征选择和特征组合的问题。</p>
<h3 id="GBDT的叶子节点能够表示多个特征的组合？">GBDT的叶子节点能够表示多个特征的组合？</h3>
<p>GBDT中的CART回归树的深度决定了特征交叉的阶数。如果决策树的深度为4，则通过3次节点分裂，最终的叶节点实际上是进行三阶特征组合后的结果。</p>
<p>所以我们说可以用GBDT自动进行特征（一阶、二阶、三阶…）筛选和组合。</p>
<h3 id="GBDT-LR的缺点是什么？">GBDT+LR的缺点是什么？</h3>
<p>GBDT容易产生过拟合，以及GBDT的特征转换方式实际上丢失了大量特征的数值信息，因此在模型的选择和调试上，永远都是多种因素综合作用的结果。</p>
<h3 id="GBDT-LR在工程上使用需要注意哪些点？">GBDT+LR在工程上使用需要注意哪些点？</h3>
<p>在实际应用中，需要注意模型训练，通常在海量特征的情况下，按照大厂的做法，GBDT是每个一周跑一次，而LR是每天跑一次，这样可以保证模型的有效性，从本质上说，因为GBDT在海量的特征维度的下跑的比较慢而已，一般小厂可以再资源不够的情况下用。</p>
<h3 id="GBDT-LR是分阶段的吗？">GBDT+LR是分阶段的吗？</h3>
<p>用GBDT构建特征工程，利用LR预估CTR这两步是独立训练的，所以不存在如何将LR的梯度回传到GBDT这类复杂的问题。LR训练时候的特征维度是由GBDT训练出来的多棵回归树的叶子节点总数决定的。</p>
<p><a href="https://zhuanlan.zhihu.com/p/400403326">https://zhuanlan.zhihu.com/p/400403326</a><br>
<a href="https://blog.csdn.net/qq_43827595/article/details/12373526">https://blog.csdn.net/qq_43827595/article/details/12373526</a></p>
]]></content>
      <categories>
        <category>算法面试</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>刷八股</tag>
      </tags>
  </entry>
  <entry>
    <title>树模型</title>
    <url>/2024/03/19/machine_learning/tree_model/</url>
    <content><![CDATA[<h1>树模型</h1>
<h2 id="基础树">基础树</h2>
<h3 id="介绍下ID3和C4-5">介绍下ID3和C4.5?</h3>
<p>构造决策树有多种算法，国际上最早的、具有影响力的决策树是由Quinlan于1986年提出的ID3算法，是基于信息熵的决策树分类算法。该算法是决策树的一个经典的构造算法，内部使用信息熵以及信息增益来进行构建；每次迭代选择信息增益最大的特征属性作为分割属性。</p>
<h3 id="ID3的优缺点？">ID3的优缺点？</h3>
<p>优点:<br>
决策树构建速度快；实现简单；</p>
<p>缺点：</p>
<ul>
<li>ID3算法避免了搜索不完整假设空间的一个主要风险：假设空间可能不包含目标函数。</li>
<li>ID3算法在搜索的每一步都使用当前的所有训练样例，大大降低了对个别训练样例错误的敏感性。</li>
<li>ID3算法在搜索过程中不进行回溯。所以，它易受无回溯的爬山搜索中的常见风险影响：收敛到局部最优而不是全局最优。</li>
<li>ID3算法只能处理离散值的属性。</li>
<li>信息增益度量存在一个内在偏置，它偏袒具有较多值的属性。</li>
<li>ID3算法增长树的每一个分支的深度，直到恰好能对训练样例完美地分类，存在决策树过度拟合。</li>
<li>ID3算法没有考虑缺失值的情况</li>
</ul>
<h3 id="ID3划分特征的标准是什么？">ID3划分特征的标准是什么？</h3>
<p>ID3 使用的分类标准是信息增益，它表示得知特征 A 的信息而使得样本集合不确定性减少的程度。信息增益=信息熵-条件熵：</p>
 $$
G{\rm{ai}}n(D,A) = H(D) - H(D|A)
$$ 
<p>信息增益越大表示使用特征 A 来划分所获得的“纯度提升越大”。</p>
<h3 id="介绍下C4-5算法？">介绍下C4.5算法？</h3>
<p>算法发明者Quinlan于1993年又提出了ID3的改进版本C4.5算法，C4.5算法用信息增益率来选择决策属性，它继承了ID3算法的全部优点，在ID3的基础上还增加了对连续属性的离散化、对未知属性的处理和产生规则等功能。</p>
<h3 id="C4-5的划分标准是什么？">C4.5的划分标准是什么？</h3>
<p>利用信息增益比可以克服信息增益的缺点，其公式为:</p>
 $$
I(D,A) = \frac{{I(D,A)}}{{H(D)}}
$$ 
<p>这里是特征熵，特征越多对应的特征熵越大，它作为分母，可以校正信息增益容易偏向取值较多的特征的问题。</p>
<h3 id="CART是如何处理类别不平衡问题的？">CART是如何处理类别不平衡问题的？</h3>
<p>CART 的一大优势在于：无论训练数据集有多失衡，它都可以将其自动消除，而不需要建模人员采取其他操作。</p>
<p>CART 使用了一种先验机制，其作用相当于对类别进行加权。这种先验机制嵌入于 CART 算法判断分裂优劣的运算里，在 CART 默认的分类模式中，总是要计算每个节点关于根节点的类别频率的比值，这就相当于对数据自动重加权，对类别进行均衡。</p>
<p>对于一个二分类问题，节点 node 被分成类别 1 当且仅当：</p>
 $$
\frac{{{N_1}(node)}}{{{N_1}(root)}} > \frac{{{N_0}(node)}}{{{N_0}(root)}}
$$ 
<p>比如二分类，根节点属于 1 类和 0 类的分别有 20 和 80 个。在子节点上有 30 个样本，其中属于 1 类和 0 类的分别是 10 和 20 个。如果 10/20&gt;20/80，该节点就属于 1 类。</p>
<p>通过这种计算方式就无需管理数据真实的类别分布。假设有 K 个目标类别，就可以确保根节点中每个类别的概率都是 1/K。这种默认的模式被称为“先验相等”。先验设置和加权不同之处在于先验不影响每个节点中的各类别样本的数量或者份额。先验影响的是每个节点的类别赋值和树生长过程中分裂的选择。</p>
<h3 id="C4-5划分标准的缺陷是什么？">C4.5划分标准的缺陷是什么？</h3>
<p>采用的是信息增益比，信息增益率对可取值较少的特征有所偏好（分母越小，整体越大），因此 C4.5 并不是直接用增益率最大的特征进行划分，而是使用一个启发式方法：先从候选划分特征中找到信息增益高于平均值的特征，再从中选择增益率最高的。</p>
<h3 id="C4-5算法的优缺点？">C4.5算法的优缺点？</h3>
<p>C4.5算法的优点是产生的分类规则易于理解，准确率较高。缺点就是在构造树的过程中，需要对数据集进行多次的顺序扫描和排序，因而导致算法的低效。此外，C4.5算法只适合于能够驻留于内存的数据集，当训练集大得无法在内存容纳时，程序无法运行。</p>
<h3 id="C4-5如何处理缺失值？">C4.5如何处理缺失值？</h3>
<p>C4.5对于缺失值的处理主要有以下步骤：<br>
对于具有缺失值特征，用没有缺失的样本子集所占比重来折算；选定该划分特征，对于缺失该特征值的样本同时划分到所有子节点，不过要调整样本的权重值，其实也就是以不同概率划分到不同节点中。</p>
<h3 id="ID3和C4-5区别？">ID3和C4.5区别？</h3>
<p>相比于之前的ID3算法，C4.5进行了改进。主要如下</p>
<ul>
<li>用信息增益率来选择划分特征，克服了用信息增益选择的不足，但信息增益率对可取值数目较少的属性有所偏好；</li>
<li>能够处理离散型和连续型的属性类型，即将连续型的属性进行离散化处理；</li>
<li>能够处理具有缺失属性值的训练数据；</li>
<li>在构造树的过程中进行剪枝；</li>
</ul>
<h3 id="CART是如何对连续值处理的？">CART是如何对连续值处理的？</h3>
<p>对于连续值的处理，CART分类树采用基尼系数的大小来度量特征的各个划分点。在回归模型中，我们使用常见的和方差度量方式，对于任意划分特征 A，对应的任意划分点 s 两边划分成的数据集和D1和D2，求出使各自集合的均方差最小，同时两个的均方差之和最小所对应的特征和特征值划分点。表达式为：</p>
 $$
{\min _{a,s}}[{\min _{{c_1}}}\sum\limits_{{x_i} \in {D_1}} {{{({y_i} - {c_1})}^2}}  + {\min _{{c_2}}}\sum\limits_{{x_i} \in {D_2}} {{{({y_i} - {c_2})}^2}} ]
$$ 
<p>其中，为数据集得到样本输出均值，为数据集的样本输出均值。</p>
<h3 id="CART算法为什么选用gini指数？">CART算法为什么选用gini指数？</h3>
<p>介绍下熵的公式：</p>
 $$
H(x) =  - \sum\limits_{k = 1}^K {{p_k}\ln ({p_k})}
$$ 
<p>将其在x=1处进行泰勒展开</p>
 $$
H(x) =  - \sum\limits_{k = 1}^K {{p_k}\ln ({p_k})}  =  - \sum\limits_{k = 1}^K {{p_k}(1 - {p_k})}
$$ 
<p>比较一下的结果如下，别人总结的</p>
<p><img src="d6fe6db604230ea2506263149d660e3c.png" alt="加载不了请走VPN哈"></p>
<h3 id="基尼系数的的定义及其优势是什么？">基尼系数的的定义及其优势是什么？</h3>
<p>熵模型拥有大量耗时的对数运算，基尼指数在简化模型的同时还保留了熵模型的优点。</p>
<p>基尼系数的计算公式如下所示：</p>
 $$
G{\rm{i}}ni(p) = \sum\limits_{k - 1}^K {{p_k}(1 - {p_k}) = 1 - \sum\limits_{k = 1}^K {{p^2}_k} } 
$$ 
<p>代表了模型的不纯度，基尼系数越小，不纯度越低，特征越好。这和信息增益（率）正好相反。</p>
<p>基尼系数的优点：在保证准确率的情况下大大减小了计算量。</p>
<p>基尼指数反映了从数据集中随机抽取两个样本，其类别标记不一致的概率。因此基尼指数越小，则数据集纯度越高。基尼指数偏向于特征值较多的特征，类似信息增益。基尼指数可以用来度量任何不均匀分布，是介于 0~1 之间的数，0是完全相等，1是完全不相等</p>
<h3 id="CART是如何在特征值缺失的情况下进行划分特征的选择？">CART是如何在特征值缺失的情况下进行划分特征的选择？</h3>
<p>CART 一开始严格要求分裂特征评估时只能使用在该特征上没有缺失值的那部分数据，在后续版本中，CART 算法使用了一种惩罚机制来抑制提升值，从而反映出缺失值的影响（例如，如果一个特征在节点的 20% 的记录是缺失的，那么这个特征就会减少 20% 或者其他数值）。</p>
<h3 id="CART模型对于缺失该特征值的样本该进行怎样处理？">CART模型对于缺失该特征值的样本该进行怎样处理？</h3>
<p>CART 算法的机制是为树的每个节点都找到代理分裂器，无论在训练数据上得到的树是否有缺失值都会这样做。在代理分裂器中，特征的分值必须超过默认规则的性能才有资格作为代理（即代理就是代替缺失值特征作为划分特征的特征），当 CART 树中遇到缺失值时，这个实例划分到左边还是右边是决定于其排名最高的代理，如果这个代理的值也缺失了，那么就使用排名第二的代理，以此类推，如果所有代理值都缺失，那么默认规则就是把样本划分到较大的那个子节点。代理分裂器可以确保无缺失训练数据上得到的树可以用来处理包含确实值的新数据。</p>
<h3 id="决策树出现过拟合的原因及其解决办法？">决策树出现过拟合的原因及其解决办法？</h3>
<p>对训练数据预测效果很好，但是测试数据预测效果较差的现象称为过拟合。</p>
<p>原因：</p>
<p>在决策树构建的过程中，对决策树的生长没有进行合理的限制（剪枝）；<br>
样本中有一些噪声数据，没有对噪声数据进行有效的剔除；<br>
在构建决策树过程中使用了较多的输出变量，变量较多也容易产生过拟合<br>
解决办法</p>
<p>选择合理的参数进行剪枝，可以分为预剪枝和后剪枝，我们一般采用后剪枝的方法；<br>
利用K−folds交叉验证，将训练集分为K份，然后进行K次交叉验证，每次使用K−1份作为训练样本数据集，另外一份作为测试集；<br>
减少特征，计算每一个特征和响应变量的相关性，常见得为皮尔逊相关系数，将相关性较小的变量剔除；当然还有一些其他的方法来进行特征筛选，比如基于决策树的特征筛选，通过正则化的方式来进行特征选取等（决策的正则化）。</p>
<h3 id="为什么C4-5能处理连续特征而ID3不行？">为什么C4.5能处理连续特征而ID3不行？</h3>
<p>这是因为ID3在设计的时候根本就没考虑过要处理连续特征，所以它自然就不能处理连续特征。那为什么ID3不考虑连续特征？这是因为任何研究都是循循渐进的，每一个研究只会将精力放在当前最重要的研究点之上。ID3与C4.5都是Quinlan 的作品，而ID3的研究重点是如何设计高效的节点分裂方法来生长决策树，因此它并不太在意如何去处理连续特征。为此，ID3提出了使用信息增益来衡量一次节点分裂的优劣，它是第一个成功将信息论相关理论使用到决策树算法中的，从这点来看它的时代意义比较重要。因此从学术贡献来看，它确实也没有必要再去处理一些琐碎而简单的问题了。而C4.5的重点则是将ID3的成果工程化，让决策树能真正解决实际中的复杂问题，所以C4.5设计了详细的连续特征处理方法和剪枝算法。以现在的眼光来看，只要你愿意，可以很容易地将ID3改造为有能力处理连续特征的决策树。</p>
<h3 id="剪枝的策略是啥">剪枝的策略是啥?</h3>
<p>在决策树算法中，为了尽可能正确分类训练样本， 节点划分过程不断重复， 有时候会造成决策树分支过多，以至于将训练样本集自身特点当作泛化特点， 而导致过拟合。因此可以采用剪枝处理来去掉一些分支来降低过拟合的风险。</p>
<p>剪枝的基本策略有预剪枝（pre-pruning）和后剪枝（post-pruning）。</p>
<p>预剪枝：在决策树生成过程中，在每个节点划分前先估计其划分后的泛化性能， 如果不能提升，则停止划分，将当前节点标记为叶结点。</p>
<p>后剪枝：生成决策树以后，再自下而上对非叶结点进行考察， 若将此节点标记为叶结点可以带来泛化性能提升，则修改之。</p>
<h3 id="树模型one-hot有哪些问题？">树模型one_hot有哪些问题？</h3>
<p>one-hot coding是类别特征的一种通用解决方法，然而在树模型里面，这并不是一个比较好的方案，尤其当类别特征维度很高的时候。主要的问题是：</p>
<p>1.可能无法在这个类别特征上进行切分。使用one-hot coding的话，意味着在每一个决策节点上只能用 one-vs-rest (例如是不是狗，是不是猫，等等) 的切分方式。当特征纬度高时，每个类别上的数据都会比较少，这时候产生的切分不平衡，切分增益（split gain）也会很小（比较直观的理解是，不平衡的切分和不切分几乎没有区别）。<br>
2.会影响决策树的学习。因为就算可以在这个类别特征进行切分，也会把数据切分到很多零散的小空间上，如图1左所示。而决策树学习时利用的是统计信息，在这些数据量小的空间上，统计信息不准确，学习会变差。但如果使用图1右边的切分方法，数据会被切分到两个比较大的空间，进一步的学习也会更好。</p>
<p><img src="41dd460bbcd146abb0fbba9916d8d49f.png" alt="加载不了请走VPN哈"></p>
<h3 id="如何解决树模型中one-hot的问题">如何解决树模型中one_hot的问题?</h3>
<p>1.类别特征的最优切分。这个方法需要对应工具的支持，我所知的支持这个方法的工具有h2o.gbm和LightGBM,用LightGBM可以直接输入类别特征，并产生同图1右边的最优切分。在一个k维的类别特征寻找最优切分，朴素的枚举算法的复杂度是指数的 O(2^k)。LightGBM 用了一个 O(klogk)[1] 的算法。算法流程如图2所示：在枚举分割点之前，先把直方图按照每个类别对应的label均值进行排序；然后按照排序的结果依次枚举最优分割点。当然，这个方法很容易过拟合，所以LightGBM里面还增加了很多对于这个方法的约束和正则化。图3是一个简单的对比实验，可以看到Optimal的切分方法在AUC提高了1.5个点，并且时间只多了20% 。</p>
<p>2.转成数值特征。在使用 sklearn 或 XGBoost 等不支持类别特征的最优切分工具时，可以用这个方法。常见的转换方法有: a) 把类别特征转成one-hot coding扔到NN里训练个embedding；b) 类似于CTR特征，统计每个类别对应的label(训练目标)的均值。统计的时候有一些小技巧，比如不把自身的label算进去(leave-me-out, leave-one-out)统计， 防止信息泄露。</p>
<p>3.其他的编码方法，比如binary coding等等，同样可以用于不支持类别特征的算法。这里有一个比较好的开源项目，封装了常见的各种编码方法: <a href="https://github.com/scikit-learn-contrib/category_encoders">https://github.com/scikit-learn-contrib/category_encoders</a></p>
<h3 id="为啥决策树后剪枝比预剪枝要好？">为啥决策树后剪枝比预剪枝要好？</h3>
<ul>
<li>
<p>预剪枝<br>
预剪枝使得决策树的很多分支没有展开，也就是没有一步一步计算然后分裂下去了，这不仅降低了过拟合的风险，还显著减少了树模型的训练时间开销。但是另一方面，有些分支的当前划分虽不能提升泛化性能、甚至可能导致泛化性能暂时下降，但是在其基础上进行的后续划分有可能导致性能显著提升(但是我们简单嘛，就不继续划分了)。预剪枝基于贪心本质，抱着能多剪就多剪枝从而招来欠拟合的风险。采用这种方法得到的决策树可能就是如下这种：<br>
<img src="984eef32683a46c389f6e824772773eb.png" alt="加载不了请走VPN哈"><br>
可以看到在这棵树比价简单，泛化性能比较好，也不会过拟合，但是就是太太简单了，会导致预测的时候偏差较大，也是我们说的欠拟合。</p>
</li>
<li>
<p>后剪枝<br>
在决策树生成后进行剪枝，这也符合我们做事的逻辑和条理。后剪枝决策树通常比预剪枝决策树保留了更多的分支(所以说计算开销还是比较大滴)。一般情况下，后剪枝决策树的欠拟合风险很小，泛化性能往往优于预剪枝决策树。所以剪枝后的树大概就是你看到的下面的这个样子：<br>
<img src="d263dde49a5b40cab90c86f11297ed08.png" alt="加载不了请走VPN哈"></p>
</li>
</ul>
<h3 id="决策树中有哪些剪枝算法">决策树中有哪些剪枝算法</h3>
<p>决策树中常见的剪枝算法有：<br>
Reduced-Error Pruning（REP,错误率降低剪枝）<br>
Pesimistic-Error Pruning（PEP,悲观错误剪枝）<br>
Cost-Complexity Pruning（CCP，代价复杂度剪枝）<br>
Minimum Error Pruning （MEP, 最小误差剪枝）</p>
<p>REP：通过一个新的验证集来纠正树的过拟合问题。对于决策树中的每一个非叶子节点的子树，我们将它替换成一个叶子节点，该叶子节点的类别用大多数原则来确定，这样就产生了一个新的相对简化决策树，然后比较这两个决策树在验证集中的表现。如果新的决策树在验证集中的正确率较高，那么该子树就可以替换成叶子节点，从而达到决策树剪枝的目的。</p>
<p>PEP：这个算法和REP差不多，和REP不同之处在于：PEP不需要新的验证集，并且PEP是自上而下剪枝的。由于我们还是用生成决策树时相同的训练样本，那么对于每个节点剪枝后的错分率一定是会上升的，因此在计算错分率时需要加一个惩罚因子0.5。</p>
<p>CPC：CCP算法为子树 $T_i$ 定义了代价和复杂度，以及一个衡量代价与复杂度之间关系的参数 $\alpha$ 。代价指的是在剪枝过程中因子树 $T_i$ 被叶节点替代而增加的错分样本;复杂度表示剪枝后子树 $T_i$ 减少的叶结点数; 从下到上计算每一个非叶节点的 $\alpha$ 值，然后每一次都剪掉具有最小值的子树 ${T_0}{T_1} \cdots {T_n}$ ，最后得到,其中是 $T_0$ 完整的数， $T_n$ 表示根节点，然后根据真实的错误率在 ${T_0}{T_1} \cdots {T_n}$ 中选择一个最好的。</p>
<p>MEP：此方法的基本思路是采用自底向上的方式，对于树中每个非叶节点。首先计算该节点的误差,然后，计算该节点每个分支的误差,并且加权相加，权为每个分支拥有的训练样本比例。如果大于,则保留该子树；否则就剪裁。<br>
<img src="373937826586452cad330f80876e589a.png" alt="加载不了请走VPN哈"><br>
详细的结果如上图所示</p>
<h3 id="C4-5采用的剪枝方法是什么？">C4.5采用的剪枝方法是什么？</h3>
<p>C4.5 采用的悲观剪枝方法，用递归的方式从低往上针对每一个非叶子节点，评估用一个最佳叶子节点去代替这课子树是否有益。如果剪枝后与剪枝前相比其错误率是保持或者下降，则这棵子树就可以被替换掉。C4.5 通过训练数据集上的错误分类数量来估算未知样本上的错误率。</p>
<h3 id="CART是如何处理类别不平衡问题的？-2">CART是如何处理类别不平衡问题的？</h3>
<p>CART 的一大优势在于：无论训练数据集有多失衡，它都可以将其自动消除，而不需要建模人员采取其他操作。</p>
<p>CART 使用了一种先验机制，其作用相当于对类别进行加权。这种先验机制嵌入于 CART 算法判断分裂优劣的运算里，在 CART 默认的分类模式中，总是要计算每个节点关于根节点的类别频率的比值，这就相当于对数据自动重加权，对类别进行均衡。</p>
<h3 id="说一下ID3、C4-5和CART三者之间的差异？">说一下ID3、C4.5和CART三者之间的差异？</h3>
<p>划分标准的差异：ID3 使用信息增益偏向特征值多的特征，C4.5 使用信息增益率克服信息增益的缺点，偏向于特征值小的特征，CART 使用基尼指数克服 C4.5 需要求 log 的巨大计算量，偏向于特征值较多的特征。<br>
使用场景的差异：ID3 和 C4.5 都只能用于分类问题，CART 可以用于分类和回归问题；ID3 和 C4.5 是多叉树，速度较慢，CART 是二叉树，计算速度很快；<br>
样本数据的差异：ID3 只能处理离散数据且缺失值敏感，C4.5 和 CART 可以处理连续性数据且有多种方式处理缺失值；从样本量考虑的话，小样本建议 C4.5、大样本建议 CART。C4.5 处理过程中需对数据集进行多次扫描排序，处理成本耗时较高，而 CART 本身是一种大样本的统计方法，小样本处理下泛化误差较大 ；<br>
样本特征的差异：ID3 和 C4.5 层级之间只使用一次特征，CART 可多次重复使用特征；<br>
剪枝策略的差异：ID3 没有剪枝策略，C4.5 是通过悲观剪枝策略来修正树的准确性，而 CART 是通过代价复杂度剪枝。</p>
<h3 id="拥有很多特征的决策树最后没有用到的特征一定是无用吗？">拥有很多特征的决策树最后没有用到的特征一定是无用吗？</h3>
<p>不是无用的，从两个角度考虑:</p>
<p>一是特征替代性，如果可以已经使用的特征A和特征B可以提点特征C，特征C可能就没有被使用，但是如果把特征C单独拿出来进行训练，依然有效.</p>
<p>其二，决策树的每一条路径就是计算条件概率的条件，前面的条件如果包含了后面的条件，只是这个条件在这棵树中是无用的，如果把这个条件拿出来也是可以帮助分析数据.</p>
<p>决策树需要进行归一化处理吗？<br>
概率模型不需要归一化，因为他们不关心变量的值，而是关心变量的分布和变量之间的条件概率。决策树是一种概率模型，数值缩放，不影响分裂点位置，对树模型的结构不造成影响。所以一般不对其进行归一化处理。</p>
<p>按照特征值进行排序的，排序的顺序不变，那么所属的分支以及分裂点就不会有不同。</p>
<p>树模型是不能进行梯度下降的，因为构建树模型（回归树）寻找最优点时是通过寻找最优分裂点完成的，因此树模型是阶跃的，阶跃点是不可导的，并且求导没意义，也就不需要归一化。</p>
<h3 id="参考">参考</h3>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/89901519">https://zhuanlan.zhihu.com/p/89901519</a><br>
<a href="https://ask.csdn.net/questions/377838">https://ask.csdn.net/questions/377838</a><br>
<a href="https://zhuanlan.zhihu.com/p/404072623">https://zhuanlan.zhihu.com/p/404072623</a><br>
<a href="https://zhuanlan.zhihu.com/p/481321311">https://zhuanlan.zhihu.com/p/481321311</a><br>
<a href="https://www.jianshu.com/p/2abc638490e3">https://www.jianshu.com/p/2abc638490e3</a></p>
</blockquote>
<h2 id="提升树">提升树</h2>
<h3 id="简单介绍下GBDT的基本原理？">简单介绍下GBDT的基本原理？</h3>
<p>GBDT是一种基于boosting集成思想的加法模型，训练时采用前向分布算法进行贪婪的学习，每次迭代都学习一棵CART树来拟合之前 t-1 棵树的预测结果与训练样本真实值的残差。</p>
<h3 id="什么是梯度提升？">什么是梯度提升？</h3>
<p>首先，梯度提升是一种基于函数梯度信息的Boosting方法，与梯度下降有异曲同工之妙。<br>
在每一轮迭代时，我们生成一个基学习器，基学习器的拟合目标是当前模型Loss的负梯度。<br>
当训练完成后，我们将该基学习器加入至模型。<br>
重复上述，继续训练基学习器，直至迭代次数达到目标。<br>
梯度提升的优化原理伪代码如下(图中Loss的负梯度使用了残差，即MSE的负梯度)：</p>
<h3 id="为什么用Loss的负梯度来拟合下一棵树？">为什么用Loss的负梯度来拟合下一棵树？</h3>
<p>将函数进行泰勒展开，使Loss朝着当前最小化的方向优化，在函数空间上求解出下一棵树拟合的目标，即Loss的负梯度。梯度下降法通过不断的迭代优化参数，让参数朝着下降速度最快的方向不断下降，逐步达到Loss最小化的目标</p>
<h3 id="为什么GBDT的树深度较RF通常都比较浅？">为什么GBDT的树深度较RF通常都比较浅？</h3>
<p>对于机器学习来说，泛化误差可以理解为两部分，分别是偏差（bias）和方差（variance）；偏差指的是算法的期望预测与真实预测之间的偏差程度，反应了模型本身的拟合能力；方差度量了同等大小的训练集的变动导致学习性能的变化，刻画了数据扰动所导致的影响。当模型越复杂时，拟合的程度就越高，模型的训练偏差就越小；但此时如果换一组数据可能模型的变化就会很大，即模型的方差很大，所以模型过于复杂的时候会导致过拟合。</p>
<p>对于RF来说由于并行训练很多不同的分类器的目的就是降低这个方差（variance）。所以对于每个基分类器来说，目标就是如何降低这个偏差（bias），所以我们会采用深度很深甚至不剪枝的决策树。而对于GBDT来说由于利用的是残差逼近的方式，即在上一轮的基础上更加拟合原数据，所以可以保证偏差（bias），所以对于每个基分类器来说，问题就在于如何选择 variance 更小的分类器，即更简单的分类器，所以我们选择了深度很浅的决策树。</p>
<h3 id="GBDT构建的分类树和回归树的区别是什么？">GBDT构建的分类树和回归树的区别是什么？</h3>
<p>GBDT构建CART树，无论是分类还是回归，都是使用的回归树，因为分类树无法处理连续值。那么接下来说区别：</p>
<p>1.CART里分类节点分裂时特征选择用gini, 回归用均方差mse，度量目标是对于划分特征A，对应划分点s两边的数据集D1和D2，求出使D1和D2各自集合的均方差最小，同时D1和D2的均方差之和最小。</p>
<p>2.对于决策树建立后做预测的方式，CART分类树采用叶子节点里概率最大的类别作为当前节点的预测类别。回归树输出不是类别，采用叶子节点的均值或者中位数来预测输出结果。</p>
<h3 id="GBDT构建回归和分类的第一颗树是什么？">GBDT构建回归和分类的第一颗树是什么？</h3>
<p>对于回归树：</p>
 ${F_0} = avg(y)$ 
<p>对应分类树</p>
 ${F_0}(x) = \log \frac{{P(Y = 1|x)}}{{1 - P(Y = 1|x)}}$ 
<p>其中， $P(Y = 1|x)$ 是训练样本中 $Y=1$ 的比例，利用先验信息来初始化学习器。</p>
<h3 id="GBDT如何进行多分类的学习？">GBDT如何进行多分类的学习？</h3>
<p>多分类的伪代码如下：<br>
<img src="ab0ec907d1ca4655ae9f66716cdb5978.png" alt="加载不了请走VPN哈"></p>
<p>根据上面的伪代码具体到多分类这个任务上面来，我们假设总体样本共有  $K$  类。来了一个样本  $x$  ，我们需要使用GBDT来判断 $x$ 属于样本的哪一类。</p>
<p>第一步我们在训练的时候，是针对样本 $x$ 每个可能的类都训练一个分类回归树。举例说明，目前样本有三类，也就是 $K=3$  ，样本 $x$ 属于第二类。那么针对该样本的分类标签，其实可以用一个三维向量 [0,1,0]来表示。 0表示样本不属于该类， 1表示样本属于该类。由于样本已经属于第二类了，所以第二类对应的向量维度为 1 ，其它位置为 0 。</p>
<p>针对样本有三类的情况，我们实质上在每轮训练的时候是同时训练三颗树。第一颗树针对样本  $x$  的第一类，输入为  $(x,0)$  。第二颗树输入针对样本  $x$ 的第二类，输入为  $(x,1)$  。第三颗树针对样本 $x$ 的第三类，输入为  $(x,0) $ 。这里每颗树的训练过程其实就CART树的生成过程。在此我们参照CART生成树的步骤即可解出三颗树，以及三颗树对  $x$  类别的预测值  $F_{1}(x), F_{2}(x), F_{3}(x)$  , 那么在此类训练中，我们仿照多分类的逻辑回归 ，使用Softmax 来产生概率，则属于类别 1 的概率为：</p>
 $$
{p_1}(x) = \frac{{\exp ({F_1}(x))}}{{\sum\limits_{k = 1}^3 {\exp ({F_k}(x))} }}
$$ 
<p>并且我们可以针对类别 1 求出残差  ${\tilde y_1} = 0 - {p_1}(x)$  ；类别 2  求出残差  ${\tilde y_2} = 0 - {p_2}(x)$ ；类别  3  求出残差  ${\tilde y_3} = 0 - {p_3}(x)$ 。</p>
<p>然后开始第二轮训练，针对第一类输入为  $(x,{\tilde y_1})$ , 针对第二类输入为  $(x,{\tilde y_2})$  ，针对第三类输入为  $(x,{\tilde y_3})$ 。继续训练出三颗树。一直迭代M轮。每轮构建3颗树。</p>
<h3 id="GBDT常用损失函数有哪些？">GBDT常用损失函数有哪些？</h3>
<p>MSE(Mean Square Error)均方误差<br>
RMSE(Root Mean Square Error)均方根误差<br>
MAE(Mean Absolute Error)平均绝对误差<br>
Huber Loss(MAE和MSE结合)</p>
<h3 id="为什么GBDT不适合使用高维稀疏特征？">为什么GBDT不适合使用高维稀疏特征？</h3>
<p>高维稀疏的ID类特征会使树模型的训练变得极为低效，且容易过拟合。</p>
<p>树模型训练过程是一个贪婪选择特征的算法，要从候选特征集合中选择一个使分裂后收益函数增益最大的特征来分裂，按照高维的ID特征做分裂时，子树数量非常多，计算量会非常大，训练会非常慢。<br>
同时，按ID分裂得到的子树的泛化能力比较弱，由于只包含了对应ID值的样本，样本稀疏时也很容易过拟合。</p>
<h3 id="GBDT算法的优缺点？">GBDT算法的优缺点？</h3>
<p>优点：<br>
预测阶段的计算速度快，树与树之间可并行化计算（注意预测时可并行）；<br>
在分布稠密的数据集上，泛化能力和表达能力都很好；<br>
采用决策树作为弱分类器使得GBDT模型具有：</p>
<ol>
<li>较好的解释性和鲁棒性；</li>
<li>能够自动发现特征间的高阶关系；</li>
<li>不需要对数据进行特殊的预处理，如归一化等。</li>
</ol>
<p>缺点：<br>
GBDT在高维稀疏的数据集上表现不佳；<br>
训练过程需要串行训练，只能在决策树内部采用一些局部并行的手段提高训练速度。</p>
<h3 id="GBDT有哪些参数？">GBDT有哪些参数？</h3>
<ul>
<li>GBDT框架参数</li>
</ul>
<p>n_estimators:代表弱学习器的最大个数，即最多训练多少棵树。这个值过大导致过拟合，过小导致欠拟合.默认值为100.</p>
<p>learning_rate：每个弱学习器都有一个权重参数，默认值0.1，取值范围0-1。 learning_rate和n_estimators同时决定着模型的拟合效果，因此要同时调整，建议从一个小一点的学习率开始。</p>
<p>subsample:子采样比例，默认1.0，是不放回的采样，与随机森林的有放回采样不一样。如果为1.0，表示每轮采用全部数据生成决策树，容易过拟合，方差容易比较大。但是如果过小，容易造成高偏差，所以这个值需要这种，建议0.5-0.8之间。</p>
<p>init:初始学习器的值，在有一定先验知识的情况下可以自己设定，但是一般不用。</p>
<p>loss：损失函数的选择，对于分类和回归是有区别的。<br>
分类：可选项有{‘deviance’,‘exponential’}，&quot;deviance&quot;对数似然损失函数和’exponential’指数损失函数,默认对数似然损失函数，对于二分类以及多分类问题采用对数似然损失函数比较好，这种损失函数用的也比较多。而指数损失函数，让我们想到的是Adaboost,即改变本轮错误训练的数据在下一轮训练中的权值，使错误分类的样本得到更多重视。<br>
回归：可选项有{‘ls’, ‘lad’, ‘huber’, ‘quantile’},ls是均方，lad是绝对误差，huber是抗噪音损失函数。当残差大于delta，应当采用L1（对较大的异常值不那么敏感）来最小化，而残差小于超参数，则用L2来最小化。本质上，Huber损失是绝对误差，只是在误差很小时，就变为平方误差。它对数据中的异常点没有平方误差损失那么敏感。它在0也可微分。使用MAE训练神经网络最大的一个问题就是不变的大梯度，这可能导致在使用梯度下降快要结束时，错过了最小点。而对于MSE，梯度会随着损失的减小而减小，使结果更加精确。在这种情况下，Huber损失就非常有用。它会由于梯度的减小而落在最小值附近。比起MSE，它对异常点更加鲁棒。因此，Huber损失结合了MSE和MAE的优点。但是，Huber损失的问题是我们可能需要不断调整超参数delta。</p>
<p>alpha:这个参数只有GradientBoostingRegressor有，当我们使用Huber损失&quot;huber&quot;和分位数损失“quantile”时，需要指定分位数的值。默认是0.9，如果噪音点较多，可以适当降低这个分位数的值。</p>
<ul>
<li>弱学习器参数</li>
</ul>
<p>max_features：划分时考虑的特征数量。当特征数量并不多，小于50，可以None,即默认使用全部特征。也可以是如下几个。</p>
<p>max_depth：每棵子树的深度，默认为3.如果数据量和特征都不多，可以不管这个参数。但是当较大时，建议限制深度，10-100之间。</p>
<p>min_samples_split：子树继续划分的条件，默认为2.当一个节点内的样本数量少于该值时，该节点不再拆分，当作叶节点。当数据量小不用管，数据量大可以增大该值。</p>
<p>min_samples_leaf：叶子节点最少的样本数，默认1.如果叶节点的样本数少于该值，会和兄弟节点一起被剪纸，相当于不需要对上层的样本再做细分，因为叶节点中只有一个样本，分支意义不大。当数量级大，可以增大这个值。由此可见gbdt生成的树不是完全二叉树，是有可能出现左右子树高度不同的情况的。</p>
<p>min_weight_fraction_leaf：限制了叶子节点所有样本权重和的最小值。如果小于这个值，则会和兄弟节点一起被剪枝。默认是0，即不考虑。如果我们有较多样本有缺失值，或者分类树样本的分布类别偏差很大，就会引入样本权重，这时我们就要注意这个值了。</p>
<p>max_leaf_nodes：最大叶子节点数量，默认为None,在限制的叶节点数之内生成最优决策树，可以防止过拟合。当数量级较大，可以限制这个数。</p>
<p>min_impurity_split：最小基尼不纯度，如果某个节点的基尼不纯度小于该值，则不再划分，视为叶节点，默认1e-7，一般不修改。</p>
<h3 id="GBDT如何调参？">GBDT如何调参？</h3>
<ol>
<li>
<p>先对提升框架内的，迭代次数和学习率做调整，选一个较小的学习率，对迭代次数网格化调参。</p>
</li>
<li>
<p>接下来对决策树调参，先一起调整max_depth和min_samples_split，根据输出的最优值将max_depth定下俩，后续再调整最小划分样本数。</p>
</li>
<li>
<p>再对内部节点再划分所需最小样本数min_samples_split和叶子节点最少样本数min_samples_leaf一起调参。看二者的最优值是否在边界上，如果在边界上，就进一步改变参数范围再网格化调餐。</p>
</li>
<li>
<p>再对max_features和subsample进行网格化。</p>
</li>
<li>
<p>最后可以通过，减小学习率，增大迭代次数，增加泛化能力，防止过拟合。保持两者的乘积基本不变，但步长设定过小，会导致拟合效果反而变差，应适当减小学习率。</p>
</li>
</ol>
<h3 id="关于Shrinkage的原理是什么？">关于Shrinkage的原理是什么？</h3>
<p>Shrinkage（缩减）的思想认为，每次走一小步逐渐逼近结果的效果，要比每次迈一大步很快逼近结果的方式更容易避免过拟合。在GBDT中同样利用了Shrinkage的思想，通过对初始树除外的每一棵树给予一个较小的学习率，让整个模型换慢迭代逼近结果，以避免过拟合。</p>
<h3 id="GBDT为什么使用cart回归树而不是使用分类树">GBDT为什么使用cart回归树而不是使用分类树?</h3>
<p>GBDT主要是利用残差逼近的方式，这就意味每棵树的值是连续的可叠加的，这一点和回归树输出连续值不谋而合，如果采用分类树，那么残差逼近进行叠加就会使得这种叠加没有意义，比如男+男+女=到底是男是女。这个是GBDT基本原理决定的。</p>
<h3 id="GBDT哪些部分可以并行？">GBDT哪些部分可以并行？</h3>
<p>1、计算每个样本的负梯度；<br>
2、分裂挑选最佳特征及其分割点时，对特征计算相应的误差及均值时；<br>
3、更新每个样本的负梯度时；<br>
4、最后预测过程中，每个样本将之前的所有树的结果累加的时候。</p>
<h3 id="GBDT与RF的区别？">GBDT与RF的区别？</h3>
<p>相同点：<br>
1、GBDT与RF都是采用多棵树组合作为最终结果；这是两者共同点。<br>
不同点：<br>
1、RF的树可以是回归树也可以是分类树，而GBDT只能是回归树。<br>
2、RF中树是独立的，相互之间不影响，可以并行；而GBDT树之间有依赖，是串行。<br>
3、RF最终的结果是有多棵树表决决定，而GBDT是有多棵树叠加组合最终的结果。<br>
4、RF对异常值不敏感，原因是多棵树表决，而GBDT对异常值比较敏感，原因是当前的错误会延续给下一棵树。<br>
5、RF是通过减少模型的方差来提高性能，而GBDT是减少模型的偏差来提高性能的。</p>
<h3 id="GBDT和AdaBoost的异同？">GBDT和AdaBoost的异同？</h3>
<p>相似之处：<br>
都是基于Boosting思想的融合算法<br>
默认的基分类器都是决策树<br>
Adaboost其实是GBDT的一个特例</p>
<p>不同点：<br>
Adaboost的基分类器可以选择更多的算法，而GBDT只能选决策树<br>
GBDT的模型提升方法与Adaboost不同，Adaboost是通过不断加强对错判断数据的权重学习来提升模型的预测效果，而GBDT则是通过不断降低模型误差的思想来提升模型的预测效果。</p>
<h3 id="为什么GBDT中要拟合残差？">为什么GBDT中要拟合残差？</h3>
<p>首先，GBDT拟合的不是残差，而是负梯度。只是当损失函数为平方损失的时候，负梯度正好为残差。</p>
<h3 id="GBDT是否需要进行归一化操作？">GBDT是否需要进行归一化操作？</h3>
<p>概率模型不需要归一化，因为它们不关心变量的值，而是关心变量的分布和变量之间的条件概率，如决策树、rf。而像adaboost、svm、lr、KNN、KMeans之类的最优化问题就需要归一化。</p>
<h3 id="为什么树模型不需要归一化？">为什么树模型不需要归一化？</h3>
<p>因为数值缩放不影响分裂点位置，对树模型的结构不造成影响，而且是不能进行梯度下降的，因为构建树模型（回归树）寻找最优点时是通过寻找最优分裂点完成的，因此树模型是阶跃的，阶跃点是不可导的，并且求导没意义，也就不需要归一化 。</p>
<h3 id="GBDT的优缺点是什么？">GBDT的优缺点是什么？</h3>
<ul>
<li>
<p>GBDT主要的优点有：<br>
可以灵活处理各种类型的数据，包括连续值和离散值。<br>
在相对少的调参时间情况下，预测的准确率也可以比较高。这个是相对SVM来说的。<br>
使用一些健壮的损失函数，对异常值的鲁棒性非常强。比如 Huber损失函数和Quantile损失函数。<br>
预测阶段的计算速度快， 树与树之间可并行化计算。所有的树一旦建好，用它来预测时是并行的，最终的预测值就是所有树的预测值之和。​​​​​​​<br>
在分布稠密的数据集上， 泛化能力和表达能力都很好， 这使得GBDT在Kaggle的众多竞赛中， 经常名列榜首。<br>
采用决策树作为弱分类器使得GBDT模型具有较好的解释性和鲁棒性，能够自动发现特征间的高阶关系， 并且也不需要对数据进行特殊的预处理如归一化等。</p>
</li>
<li>
<p>GBDT的主要缺点有：<br>
由于弱学习器之间存在依赖关系，难以并行训练数据。不过可以通过自采样的SGBT来达到部分并行。<br>
GBDT在高维稀疏的数据集上， 表现不如支持向量机或者神经网络。<br>
GBDT在处理文本分类特征问题上， 相对其他模型的优势不如它在处理数值特征时明显。<br>
训练过程需要串行训练， 只能在决策树内部采用一些局部并行的手段提高训练速度。</p>
</li>
</ul>
<h3 id="GBDT的预测结果有负数，为啥？">GBDT的预测结果有负数，为啥？</h3>
<p>这里不是严格意义上说GBDT的预测结果一定为负数，而指的是训练集的结果中GBDT拟合的label都为正数，而在测试集中却出现了负数的情况。<br>
是可能会出现负值的，出现的情况原因可能有如下：<br>
如果在loss函数中没有加对负数输出的惩罚项（regularization），就有可能得到负数输出。<br>
首先要看得到负数的的输入值是否在training data中出现过，如果没出现过，并且这种数据点很少，可以认为这些是outlier。也可以把负数变为0。<br>
training data里很多输出接近于0，testing里出现一些接近于0的负数也很正常。<br>
样本较少，特征较少的情况可能会出现，因为GBDT是加法模型，然后下一轮都是上一轮预测值和实际值的残差作为label继续拟合，最后将结果相加，这样最后可能会出现负值。<br>
我说个比较简单的理解思路，GBDT你拟合的是残差，这个残差可正可负，第一棵树得到的预测值偏大，那么后续拟合的就是负值，如果拟合的不好，多棵树相加的结果还是一个负数(越界的数)。</p>
<h3 id="为什么GBDT的树深度较RF通常都比较浅？-2">为什么GBDT的树深度较RF通常都比较浅？</h3>
<p>对于机器学习来说，泛化误差可以理解为两部分，分别是偏差（bias）和方差（variance）；偏差指的是算法的期望预测与真实预测之间的偏差程度，反应了模型本身的拟合能力；方差度量了同等大小的训练集的变动导致学习性能的变化，刻画了数据扰动所导致的影响。当模型越复杂时，拟合的程度就越高，模型的训练偏差就越小；但此时如果换一组数据可能模型的变化就会很大，即模型的方差很大，所以模型过于复杂的时候会导致过拟合。</p>
<p>对于RF来说由于并行训练很多不同的分类器的目的就是降低这个方差（variance）。所以对于每个基分类器来说，目标就是如何降低这个偏差（bias），所以我们会采用深度很深甚至不剪枝的决策树。</p>
<p>而对于GBDT来说由于利用的是残差逼近的方式，即在上一轮的基础上更加拟合原数据，所以可以保证偏差（bias），所以对于每个基分类器来说，问题就在于如何选择 variance 更小的分类器，即更简单的分类器，所以我们选择了深度很浅的决策树。</p>
<h3 id="RF算法思想？">RF算法思想？</h3>
<p>随机森林使用多个CART决策树作为弱学习期，不同决策树之间没有关联。当我们进行分类任务时，新的输入样本进入，就让森林中的每一棵决策树分别进行判断和分类，每个决策树会得到一个自己的分类结果，决策树的分类结果中哪一个分类最多，那么随机森林就会把这个结果当作最终的结果。</p>
<h3 id="RF的建立过程说一下？">RF的建立过程说一下？</h3>
<p>第一步：原始训练集中有N个样本，且每个样本有M维特征。从数据集D中有放回的随机抽取x个样本组成训练子集（bootstrap方法），一共进行w次采样，即生成w个训练子集。</p>
<p>第二步：每个训练子集形成一棵决策树，一共w棵决策树。而每一次未被抽到的样本则组成了w个oob（用来做预估）。</p>
<p>第三步：对于单个决策树，树的每个节点处从M个特征中随机挑选m（n &lt; M） 个特征， 按照节点不纯度最小原则进行分裂。每棵树都一直这样分裂下去，直到该节点的所有训练样例都属于同一类。在决策树的分裂过程中不需要剪枝。</p>
<p>第四步：根据生成的多个决策树分类起对需要进行预测的数据进行预测。根据每棵决策树的投票结果，如果是分类树的话，最后取票数最高的一个类别；如果是回归树的话，利用简单的平均得到最终结果。</p>
<h3 id="RF为什么要有放回的抽样？">RF为什么要有放回的抽样？</h3>
<p>保证样本集间有重叠，若不放回，每个训练样本集及其分布都不一样，可能导致训练的各决策树差异性很大，最终多数表决无法“求同”。</p>
<h3 id="为什RF的训练效率优于bagging">为什RF的训练效率优于bagging?</h3>
<p>因为在个体决策树的构建过程中，Bagging使用的是“确定型”决策树，Bagging在选择划分属性时要对每棵树对所有特征进行考察，而随机森林仅仅考察一个特征子集。</p>
<h3 id="RF需要剪枝吗？">RF需要剪枝吗？</h3>
<p>不需要，后剪枝是为了避免过拟合，随机森林选择变量与树的数量，已经避免了过拟合，没必要去剪枝了。一般随机森林要控制的是树的规模，而不是树的置信度，剩下的每棵树需要做的就是尽可能的在自己所对应的数据（特征）集情况下尽可能的做到最好的预测结果。剪枝的作用其实被集成方法消解了，所以作用不大。</p>
<h3 id="RF需要交叉验证吗？">RF需要交叉验证吗？</h3>
<p>随机森林是不需要的，它属于bagging集成算法，采用Bootstrap，理论和实践可以发现Bootstrap每次约有1/3的样本不会出现在Bootstrap所采集的样本集合中。故没有参加决策树的建立，这些数据称为袋外数据oob，歪点子来了，这些袋外数据可以用于取代测试集误差估计方法，可用于模型的验证。</p>
<h3 id="RF为什么不能用全样本取训练m棵决策树？">RF为什么不能用全样本取训练m棵决策树？</h3>
<p>随机森林的基学习器是同构的，如果用全样本去训练m棵决策树的话，基模型之间的多样性减少，互相相关的程度增加，不能够有效起到减少方差的作用，对于模型的泛化能力是有害的。随机森林思想就是取一组高方差、低偏差的决策树，并将它们转换成低方差、低偏差的新模型。</p>
<h3 id="RF和GBDT的区别">RF和GBDT的区别</h3>
<p>相同点：</p>
<ul>
<li>都是由多棵树组成，最终的结果都是由多棵树一起决定。</li>
</ul>
<p>不同点：</p>
<ul>
<li>集成学习：RF属于bagging思想，而GBDT是boosting思想</li>
<li>偏差-方差权衡：RF不断的降低模型的方差，而GBDT不断的降低模型的偏差<br>
训练样本：RF每次迭代的样本是从全部训练集中有放回抽样形成的，而GBDT每次使用全部样本</li>
<li>并行性：RF的树可以并行生成，而GBDT只能顺序生成(需要等上一棵树完全生成)</li>
<li>最终结果：RF最终是多棵树进行多数表决（回归问题是取平均），而GBDT是加权融合</li>
<li>数据敏感性：RF对异常值不敏感，而GBDT对异常值比较敏感</li>
<li>泛化能力：RF不易过拟合，而GBDT容易过拟合</li>
</ul>
<h3 id="随机森林算法训练时主要需要调整哪些参数？">随机森林算法训练时主要需要调整哪些参数？</h3>
<p>**n_estimators:**随机森林建立子树的数量。<br>
较多的子树一般可以让模型有更好的性能，但同时让你的代码变慢。需要选择最佳的随机森林子树数量</p>
<p>**max_features：**随机森林允许单个决策树使用特征的最大数量。<br>
增加max_features一般能提高模型的性能，因为在每个节点上，我们有更多的选择可以考虑。然而，这未必完全是对的，因为它降低了单个树的多样性，而这正是随机森林独特的优点。但是，可以肯定，你通过增加max_features会降低算法的速度。因此，你需要适当的平衡和选择最佳max_features。</p>
<p>max_depth： 决策树最大深度</p>
<p>默认决策树在建立子树的时候不会限制子树的深度</p>
<p>**min_samples_split：**内部节点再划分所需最小样本数<br>
内部节点再划分所需最小样本数，如果某节点的样本数少于min_samples_split，则不会继续再尝试选择最优特征来进行划分。</p>
<p>min_samples_leaf： 叶子节点最少样本</p>
<p>这个值限制了叶子节点最少的样本数，如果某叶子节点数目小于样本数，则会和兄弟节点一起被剪枝。</p>
<p>max_leaf_nodes： 最大叶子节点数</p>
<p>通过限制最大叶子节点数，可以防止过拟合，默认是&quot;None”，即不限制最大的叶子节点数。如果加了限制，算法会建立在最大叶子节点数内最优的决策树。</p>
<p>min_impurity_split： 节点划分最小不纯度<br>
这个值限制了决策树的增长，如果某节点的不纯度（基于基尼系数，均方差）小于这个阈值，则该节点不再生成子节点。即为叶子节点。一般不推荐改动默认值1e-7。</p>
<h3 id="RF为什么比Bagging效率高？">RF为什么比Bagging效率高？</h3>
<p>Bagging无随机特征，使得训练决策树时效率更低</p>
<h3 id="RF的优缺点？">RF的优缺点？</h3>
<p>优点</p>
<ol>
<li>训练可以高度并行化，对于大数据时代的大样本训练速度有优势。个人觉得这是的最主要的优点。</li>
<li>由于可以随机选择决策树节点划分特征，这样在样本特征维度很高的时候，仍然能高效的训练模型。</li>
<li>在训练后，可以给出各个特征对于输出的重要性</li>
<li>由于采用了随机采样，训练出的模型的方差小，泛化能力强。</li>
<li>相对于Boosting系列的Adaboost和GBDT， RF实现比较简单。</li>
<li>对部分特征缺失不敏感。</li>
</ol>
<p>缺点</p>
<ol>
<li>在某些噪音比较大的样本集上，RF模型容易陷入过拟合。</li>
<li>取值划分比较多的特征容易对RF的决策产生更大的影响，从而影响拟合的模型的效果</li>
</ol>
<h3 id="简单介绍一下XGBoost？">简单介绍一下XGBoost？</h3>
<p>首先需要说一说GBDT，它是一种基于boosting增强策略的加法模型，训练的时候采用前向分布算法进行贪婪的学习，每次迭代都学习一棵CART树来拟合之前 t-1 棵树的预测结果与训练样本真实值的残差。<br>
XGBoost对GBDT进行了一系列优化，比如损失函数进行了二阶泰勒展开、目标函数加入正则项、支持并行和默认缺失值处理等，在可扩展性和训练速度上有了巨大的提升，但其核心思想没有大的变化。</p>
<h3 id="XGBoost与GBDT的联系和区别有哪些？">XGBoost与GBDT的联系和区别有哪些？</h3>
<p>（1）GBDT是机器学习算法，XGBoost是该算法的工程实现。<br>
（2）正则项：在使用CART作为基分类器时，XGBoost显式地加入了正则项来控制模型的复杂度，有利于防止过拟合，从而提高模型的泛化能力。<br>
（3）导数信息：GBDT在模型训练时只使用了代价函数的一阶导数信息，XGBoost对代价函数进行二阶泰勒展开，可以同时使用一阶和二阶导数。<br>
（4）基分类器：传统的GBDT采用CART作为基分类器，XGBoost支持多种类型的基分类器，比如线性分类器。<br>
（5）子采样：传统的GBDT在每轮迭代时使用全部的数据，XGBoost则采用了与随机森林相似的策略，支持对数据进行采样。<br>
（6）缺失值处理：传统GBDT没有设计对缺失值进行处理，XGBoost能够自动学习出缺失值的处理策略。<br>
（7）并行化：传统GBDT没有进行并行化设计，注意不是tree维度的并行，而是特征维度的并行。XGBoost预先将每个特征按特征值排好序，存储为块结构，分裂结点时可以采用多线程并行查找每个特征的最佳分割点，极大提升训练速度。</p>
<h3 id="为什么XGBoost泰勒二阶展开后效果就比较好呢？">为什么XGBoost泰勒二阶展开后效果就比较好呢？</h3>
<ul>
<li>从为什么会想到引入泰勒二阶的角度来说（可扩展性）：XGBoost官网上有说，当目标函数是MSE时，展开是一阶项（残差）+二阶项的形式，而其它目标函数，如logistic loss的展开式就没有这样的形式。为了能有个统一的形式，所以采用泰勒展开来得到二阶项，这样就能把MSE推导的那套直接复用到其它自定义损失函数上。简短来说，就是为了统一损失函数求导的形式以支持自定义损失函数。至于为什么要在形式上与MSE统一？是因为MSE是最普遍且常用的损失函数，而且求导最容易，求导后的形式也十分简单。所以理论上只要损失函数形式与MSE统一了，那就只用推导MSE就好了。</li>
<li>从二阶导本身的性质，也就是从为什么要用泰勒二阶展开的角度来说（精准性）：二阶信息本身就能让梯度收敛更快更准确。这一点在优化算法里的牛顿法中已经证实。可以简单认为一阶导指引梯度方向，二阶导指引梯度方向如何变化。简单来说，相对于GBDT的一阶泰勒展开，XGBoost采用二阶泰勒展开，可以更为精准的逼近真实的损失函数。</li>
</ul>
<h3 id="XGBoost对缺失值是怎么处理的？">XGBoost对缺失值是怎么处理的？</h3>
<p>在普通的GBDT策略中，对于缺失值的方法是先手动对缺失值进行填充，然后当做有值的特征进行处理，但是这样人工填充不一定准确，而且没有什么理论依据。</p>
<ul>
<li>
<p>在特征k上寻找最佳 split point 时，不会对该列特征 missing 的样本进行遍历，而只对该列特征值为 non-missing 的样本上对应的特征值进行遍历，通过这个技巧来减少了为稀疏离散特征寻找 split point 的时间开销。</p>
</li>
<li>
<p>在逻辑实现上，为了保证完备性，会将该特征值missing的样本分别分配到左叶子结点和右叶子结点，两种情形都计算一遍后，选择分裂后增益最大的那个方向（左分支或是右分支），作为预测时特征值缺失样本的默认分支方向。</p>
</li>
<li>
<p>如果在训练中没有缺失值而在预测中出现缺失，那么会自动将缺失值的划分方向放到右子结点。</p>
</li>
</ul>
<h3 id="XGBoost为什么快？">XGBoost为什么快？</h3>
<ul>
<li>
<p>分块并行：训练前每个特征按特征值进行排序并存储为Block结构，后面查找特征分割点时重复使用，并且支持并行查找每个特征的分割点</p>
</li>
<li>
<p>候选分位点：每个特征采用常数个分位点作为候选分割点</p>
</li>
<li>
<p>CPU cache 命中优化： 使用缓存预取的方法，对每个线程分配一个连续的buffer，读取每个block中样本的梯度信息并存入连续的Buffer中。</p>
</li>
<li>
<p>Block 处理优化：Block预先放入内存；Block按列进行解压缩；将Block划分到不同硬盘来提高吞吐</p>
</li>
</ul>
<h3 id="XGBoost防止过拟合的方法">XGBoost防止过拟合的方法</h3>
<p>XGBoost在设计时，为了防止过拟合做了很多优化，具体如下：</p>
<ul>
<li>目标函数添加正则项：叶子节点个数+叶子节点权重的L2正则化</li>
<li>列抽样：训练的时候只用一部分特征（不考虑剩余的block块即可）</li>
<li>子采样：每轮计算可以不使用全部样本，使算法更加保守</li>
<li>shrinkage: 可以叫学习率或步长，为了给后面的训练留出更多的学习空间</li>
</ul>
<h3 id="XGBoost为什么若模型决策树的叶子节点值越大，越容易过拟合呢？">XGBoost为什么若模型决策树的叶子节点值越大，越容易过拟合呢？</h3>
<p>xgb最终的决策就是wx,如果某个w太大，则显然w对应叶子结点对最终的输出起到绝大部分的贡献，那么如果第一个叶子结点对应的基树拟合的过头，很容易导致整体的输出方差增大引发过拟合。更小的w表示更小的模型复杂度，因此来说w小点是好的。</p>
<h3 id="XGBoost为什么可以并行训练？">XGBoost为什么可以并行训练？</h3>
<ul>
<li>XGBoost的并行，并不是说每棵树可以并行训练，XGBoost本质上仍然采用boosting思想，每棵树训练前需要等前面的树训练完成才能开始训练。</li>
<li>XGBoost的并行，指的是特征维度的并行：在训练之前，每个特征按特征值对样本进行预排序，并存储为Block结构，在后面查找特征分割点时可以重复使用，而且特征已经被存储为一个个block结构，那么在寻找每个特征的最佳分割点时，可以利用多线程对每个block并行计算。</li>
</ul>
<h3 id="XGBoost中叶子结点的权重如何计算出来">XGBoost中叶子结点的权重如何计算出来</h3>
<p>利用一元二次函数求最值的知识，当目标函数达到最小值Obj<em>时，每个叶子结点的权重为wj</em>。</p>
 $$
w_j^* = -G_j/(H_j+\lambda)
$$ 
<h3 id="XGBoost中的一棵树的停止生长条件">XGBoost中的一棵树的停止生长条件</h3>
<ul>
<li>
<p>当新引入的一次分裂所带来的增益Gain&lt;0时，放弃当前的分裂。这是训练损失和模型结构复杂度的博弈过程。</p>
</li>
<li>
<p>当树达到最大深度时，停止建树，因为树的深度太深容易出现过拟合，这里需要设置一个超参数max_depth。</p>
</li>
<li>
<p>当引入一次分裂后，重新计算新生成的左、右两个叶子结点的样本权重和。如果任一个叶子结点的样本权重低于某一个阈值，也会放弃此次分裂。这涉及到一个超参数:最小样本权重和，是指如果一个叶子节点包含的样本数量太少也会放弃分裂，防止树分的太细。</p>
</li>
</ul>
<h3 id="Xboost中的min-child-weight是什么意思">Xboost中的min_child_weight是什么意思</h3>
<p>一般来说，我们定义的不带正则项的损失函数是这个</p>
 $$
\frac{1}{2} (y_i-\hat y_i^2)
$$ 
<p>那么hi=1，Hj即叶子节点上的样本数，min_child_weight就是叶子上的最小样本数，不最小样本总数啊，只是在这个情况下是。</p>
<h3 id="Xgboost中的gamma是什么意思">Xgboost中的gamma是什么意思</h3>
<p>指的是叶节点需要分裂需要的最小损失减少量，也就是<img src="https://img-blog.csdn.net/20180819171358821?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI0NTE5Njc3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="image">公式中的r。</p>
<h3 id="Xgboost中的参数有哪些？">Xgboost中的参数有哪些？</h3>
<ol>
<li>通用参数：宏观函数控制</li>
</ol>
<ul>
<li>booster[默认gbtree]<br>
选择每次迭代的模型，有两种选择：<br>
gbtree：基于树的模型<br>
gbliner：线性模型</li>
<li>silent[默认0]<br>
当这个参数值为1时，静默模式开启，不会输出任何信息。<br>
一般这个参数就保持默认的0，因为这样能帮我们更好地理解模型。</li>
<li>nthread[默认值为最大可能的线程数]<br>
这个参数用来进行多线程控制，应当输入系统的核数。<br>
如果你希望使用CPU全部的核，那就不要输入这个参数，算法会自动检测它。</li>
</ul>
<ol start="2">
<li>Booster参数：控制每一步的booster(tree/regression)<br>
尽管有两种booster可供选择，我这里只介绍tree booster，因为它的表现远远胜过linear booster，所以linear booster很少用到。</li>
</ol>
<ul>
<li>eta[默认0.3]<br>
和GBM中的 learning rate 参数类似。<br>
通过减少每一步的权重，可以提高模型的鲁棒性。<br>
典型值为0.01-0.2。</li>
<li>min_child_weight[默认1]<br>
决定最小叶子节点样本权重和。<br>
和GBM的 min_child_leaf 参数类似，但不完全一样。XGBoost的这个参数是最小样本权重的和，而GBM参数是最小样本总数。<br>
这个参数用于避免过拟合。当它的值较大时，可以避免模型学习到局部的特殊样本。<br>
但是如果这个值过高，会导致欠拟合。这个参数需要使用CV来调整。</li>
<li>max_depth[默认6]<br>
和GBM中的参数相同，这个值为树的最大深度。<br>
这个值也是用来避免过拟合的。max_depth越大，模型会学到更具体更局部的样本。<br>
需要使用CV函数来进行调优。<br>
典型值：3-10</li>
<li>max_leaf_nodes<br>
树上最大的节点或叶子的数量。<br>
可以替代max_depth的作用。因为如果生成的是二叉树，一个深度为n的树最多生成n 2 n^2n<br>
2个叶子。如果定义了这个参数，GBM会忽略max_depth参数。</li>
<li>gamma[默认0]<br>
在节点分裂时，只有分裂后损失函数的值下降了，才会分裂这个节点。Gamma指定了节点分裂所需的最小损失函数下降值。<br>
这个参数的值越大，算法越保守。这个参数的值和损失函数息息相关，所以是需要调整的。</li>
<li>max_delta_step[默认0]<br>
这参数限制每棵树权重改变的最大步长。如果这个参数的值为0，那就意味着没有约束。如果它被赋予了某个正值，那么它会让这个算法更加保守。<br>
通常，这个参数不需要设置。但是当各类别的样本十分不平衡时，它对逻辑回归是很有帮助的。<br>
这个参数一般用不到，但是你可以挖掘出来它更多的用处。</li>
<li>subsample[默认1]<br>
和GBM中的subsample参数一模一样。这个参数控制对于每棵树，随机采样的比例。<br>
减小这个参数的值，算法会更加保守，避免过拟合。但是，如果这个值设置得过小，它可能会导致欠拟合。<br>
典型值：0.5-1</li>
<li>colsample_bytree[默认1]<br>
和GBM里面的max_features参数类似。用来控制每棵随机采样的列数的占比(每一列是一个特征)。<br>
典型值：0.5-1</li>
<li>colsample_bylevel[默认1]<br>
用来控制树的每一级的每一次分裂，对列数的采样的占比。<br>
我个人一般不太用这个参数，因为subsample参数和colsample_bytree参数可以起到相同的作用。但是如果感兴趣，可以挖掘这个参数更多的用处。</li>
<li>lambda[默认1]<br>
权重的L2正则化项。(和Ridge regression类似)。<br>
这个参数是用来控制XGBoost的正则化部分的。虽然大部分数据科学家很少用到这个参数，但是这个参数在减少过拟合上还是可以挖掘出更多用处的。</li>
<li>alpha[默认1]<br>
权重的L1正则化项。(和Lasso regression类似)。<br>
可以应用在很高维度的情况下，使得算法的速度更快。</li>
<li>scale_pos_weight[默认1]<br>
在各类别样本十分不平衡时，把这个参数设定为一个正值，可以使算法更快收敛。</li>
</ul>
<ol start="3">
<li>学习目标参数：控制训练目标的表现<br>
这个参数用来控制理想的优化目标和每一步结果的度量方法。</li>
</ol>
<ul>
<li>objective[默认reg:linear]<br>
这个参数定义需要被最小化的损失函数。最常用的值有：<br>
binary:logistic 二分类的逻辑回归，返回预测的概率(不是类别)。<br>
multi:softmax 使用softmax的多分类器，返回预测的类别(不是概率)。<br>
在这种情况下，你还需要多设一个参数：num_class(类别数目)。<br>
multi:softprob 和multi:softmax参数一样，但是返回的是每个数据属于各个类别的概率。</li>
<li>eval_metric[默认值取决于objective参数的取值]<br>
对于有效数据的度量方法。<br>
对于回归问题，默认值是rmse，对于分类问题，默认值是error。</li>
<li>seed(默认0)<br>
随机数的种子<br>
设置它可以复现随机数据的结果，也可以用于调整参数</li>
</ul>
<h3 id="xgboost本质上是树模型，能进行线性回归拟合么">xgboost本质上是树模型，能进行线性回归拟合么</h3>
<p>Xgboost中可以使用的，gbliner这个参数，那么它就使用线性基学习器来进行学习了。</p>
<h3 id="Xgboos是如何调参的">Xgboos是如何调参的</h3>
<p>一般来说主要调节的几个参数有如下</p>
<ul>
<li>max_depth</li>
<li>learning_rate</li>
<li>n_estimators</li>
<li>min_child_weight</li>
<li>subsample</li>
<li>colsample_bytree</li>
</ul>
<p>XGBoost的作者把所有的参数分成了三类：<br>
1、通用参数：宏观函数控制。<br>
2、Booster参数：控制每一步的booster(tree/regression)。<br>
3、学习目标参数：控制训练目标的表现。</p>
<p>调参主要由一下步骤</p>
<ol>
<li>确定数据的的情况，设置好相应的参数</li>
<li>调参方法1：
<ol>
<li>选择较高的学习速率(learning rate)。一般情况下，学习速率的值为0.1。但是，对于不同的问题，理想的学习速率有时候会在0.05到0.3之间波动。选择对应于此学习速率的理想决策树数量。XGBoost有一个很有用的函数“cv”，这个函数可以在每一次迭代中使用交叉验证，并返回理想的决策树数量。</li>
<li>对于给定的学习速率和决策树数量，进行决策树特定参数调优(max_depth, min_child_weight, gamma, subsample, colsample_bytree)。在确定一棵树的过程中，我们可以选择不同的参数，待会儿我会举例说明。</li>
<li>xgboost的正则化参数的调优。(lambda, alpha)。这些参数可以降低模型的复杂度，从而提高模型的表现。4. 降低学习速率，确定理想参数。</li>
</ol>
</li>
<li>调参方法2：<br>
使用网格搜索</li>
<li>调参方法3：<br>
使用随机搜索</li>
<li>调参方法4：<br>
使用贝叶斯调参方法</li>
</ol>
<h3 id="为什么xgboost-gbdt在调参时为什么树的深度很少就能达到很高的精度？">为什么xgboost/gbdt在调参时为什么树的深度很少就能达到很高的精度？</h3>
<p>Boosting主要关注降低偏差，因此Boosting能基于泛化性能相当弱的学习器构建出很强的集成；Bagging主要关注降低方差，因此它在不剪枝的决策树、神经网络等学习器上效用更为明显。</p>
<p>gbdt属于boosting的方法，其主要关注的是减少偏差，多棵树进行叠加后可以保证较高的精度。</p>
<h3 id="为什么常规的gbdt和xgboost不适用于类别特别多的特征">为什么常规的gbdt和xgboost不适用于类别特别多的特征?</h3>
<p>one-hot coding是类别特征的一种通用解决方法，然而在树模型里面，这并不是一个比较好的方案，尤其当类别特征维度很高的时候。主要的问题是：</p>
<ul>
<li>可能无法在这个类别特征上进行切分<br>
使用one-hot coding的话，意味着在每一个决策节点上只能用 one-vs-rest (例如是不是狗，是不是猫，等等) 的切分方式。当特征纬度高时，每个类别上的数据都会比较少，这时候产生的切分不平衡，切分增益（split gain）也会很小（比较直观的理解是，不平衡的切分和不切分几乎没有区别）。</li>
<li>会影响决策树的学习<br>
因为就算可以在这个类别特征进行切分，也会把数据切分到很多零散的小空间上，如图1左所示。而决策树学习时利用的是统计信息，在这些数据量小的空间上，统计信息不准确，学习会变差。但如果使用图1右边的切分方法，数据会被切分到两个比较大的空间，进一步的学习也会更好。</li>
</ul>
<p><img src="v2-17fc885c67ae576937533c7bda71a83f_720w.png" alt="加载不了请走VPN哈"></p>
<h3 id="简述一下Adaboost原理">简述一下Adaboost原理</h3>
<p>Adaboost算法利用同一种基分类器（弱分类器），基于分类器的错误率分配不同的权重参数，最后累加加权的预测结果作为输出。</p>
<p>Adaboost算法流程：<br>
样本赋予权重，得到第一个分类器。<br>
计算该分类器的错误率，根据错误率赋予分类器权重（注意这里是分类器的权重）。<br>
增加分错样本的权重，减小分对样本的权重（注意这里是样本的权重）。<br>
然后再用新的样本权重训练数据，得到新的分类器。<br>
多次迭代，直到分类器错误率为0或者整体弱分类器错误为0，或者到达迭代次数。<br>
将所有弱分类器的结果加权求和，得到一个较为准确的分类结果。错误率低的分类器获得更高的决定系数，从而在对数据进行预测时起关键作用。</p>
<h3 id="AdaBoost的优点和缺点">AdaBoost的优点和缺点</h3>
<p>优点</p>
<ol>
<li>Adaboost提供一种框架，在框架内可以使用各种方法构建子分类器。可以使用简单的弱分类器，不用对特征进行筛选，也不存在过拟合的现象。</li>
<li>Adaboost算法不需要弱分类器的先验知识，最后得到的强分类器的分类精度依赖于所有弱分类器。无论是应用于人造数据还是真实数据，Adaboost都能显著的提高学习精度。</li>
<li>Adaboost算法不需要预先知道弱分类器的错误率上限，且最后得到的强分类器的分类精度依赖于所有弱分类器的分类精度，可以深挖分类器的能力。</li>
<li>Adaboost可以根据弱分类器的反馈，自适应地调整假定的错误率，执行的效率高。</li>
<li>Adaboost对同一个训练样本集训练不同的弱分类器，按照一定的方法把这些弱分类器集合起来，构造一个分类能力很强的强分类器，即“三个臭皮匠赛过一个诸葛亮&quot;”。</li>
</ol>
<p>缺点</p>
<ol>
<li>在Adaboost训练过程中，Adaboost会使得难于分类样本的权值呈指数增长，训练将会过于偏向这类困难的样本，导致Adaboost算法易受噪声干扰。</li>
<li>Adaboost依赖于弱分类器，而弱分类器的训练时间往往很长。</li>
</ol>
<h3 id="Adaboost对噪声敏感吗？">Adaboost对噪声敏感吗？</h3>
<p>在Adaboost训练过程中，Adaboost会使得难于分类样本的权值呈指数增长，训练将会过于偏向这类困难的样本，导致Adaboost算法易受噪声干扰。</p>
<h3 id="怎么处理类别特征在树模型下？">怎么处理类别特征在树模型下？</h3>
<ul>
<li>可以使用lightGBM模型</li>
<li>可以用embedding</li>
<li>其他的编码方法，比如binary coding</li>
</ul>
<h3 id="LGBM简单介绍下？">LGBM简单介绍下？</h3>
<p>LightGBM是微软2017年新提出的，比Xgboost更强大、速度更快的模型，性能上有很大的提升，与传统算法相比具有的优点：</p>
<ol>
<li>更快的训练效率</li>
<li>低内存使用</li>
<li>更高的准确率</li>
<li>支持并行化学习</li>
<li>可处理大规模数据</li>
<li>原生支持类别特征，不需要对类别特征再进行0-1编码这类的</li>
</ol>
<h3 id="LGBM相比于之前的GBDT做了哪些改进？">LGBM相比于之前的GBDT做了哪些改进？</h3>
<p>对训练效率上进行了大量的改进，主要还是比GBDT快很多，GBDT的训练受到特征数量和数据量的双重影响，所以LightGBM就是从这几个方面入手来对GBDT进行改进。</p>
<ul>
<li>
<p>提出了GOSS算法</p>
</li>
<li>
<p>进行特征绑定将大量的可以合并的特征进行合并以加快计算。</p>
</li>
<li>
<p>通过leaf-wise策略来生长树。</p>
</li>
<li>
<p>采用直方图来优化最优分割点寻找的过程</p>
</li>
</ul>
<h3 id="简单介绍下直方图算法？">简单介绍下直方图算法？</h3>
<p>直方图算法的基本思想是先把连续的浮点特征值离散化成k个整数，同时构造一个宽度为k的直方图。在遍历数据的时候，根据离散化后的值作为索引在直方图中累积统计量，当遍历一次数据后，直方图累积了需要的统计量，然后根据直方图的离散值，遍历寻找最优的分割点</p>
<p>使用直方图算法有很多优点。首先，最明显就是内存消耗的降低，直方图算法不仅不需要额外存储预排序的结果，而且可以只保存特征离散化后的值，而这个值一般用 8 位整型存储就足够了，内存消耗可以降低为原来的1/8。</p>
<h3 id="Histogram-算法的优缺点">Histogram 算法的优缺点</h3>
<p>Histogram算法并不是完美的。由于特征被离散化后，找到的并不是很精确的分割点，所以会对结果产生影响。但在实际的数据集上表明，离散化的分裂点对最终的精度影响并不大，甚至会好一些。原因在于decision tree本身就是一个弱学习器，采用Histogram算法会起到正则化的效果，有效地防止模型的过拟合。</p>
<p>时间上的开销由原来的O(#data * #features)降到O(k * #features)。由于离散化，#bin远小于#data，因此时间上有很大的提升。</p>
<h3 id="介绍下GOSS算法？">介绍下GOSS算法？</h3>
<p>该技术是去掉了很大一部分梯度很小的数据，只使用剩下的去估计信息增益，避免低梯度长尾部分的影响。由于梯度大的数据在计算信息增益的时候更重要，所以GOSS在小很多的数据上仍然可以取得相当准确的估计值。</p>
<h3 id="传统树模型如何处理离散特征？">传统树模型如何处理离散特征？</h3>
<p>一般使用独热编码的形式来处理，但是这样会存在问题，当类别的数量很多，会导致计算的复杂度增加，除此之外，还存在相关算法方面的问题。</p>
<ol>
<li>
<p>可能无法在这个类别特征上进行切分（即浪费了这个特征）。使用one-hot编码的话，意味着在每一个决策节点上只能使用one vs rest（例如是不是狗，是不是猫等）的切分方式。当类别值很多时，每个类别上的数据可能会比较少，这时候切分会产生不平衡，这意味着切分增益也会很小（比较直观的理解是，不平衡的切分和不切分没有区别）。</p>
</li>
<li>
<p>会影响决策树的学习。因为就算可以在这个类别特征进行切分，也会把数据切分到很多零碎的小空间上，如图1左边所示。而决策树学习时利用的是统计信息，在这些数据量小的空间上，统计信息不准确，学习会变差。但如果使用如图1右边的分裂方式，数据会被切分到两个比较大的空间，进一步的学习也会更好。</p>
</li>
</ol>
<p>图右边叶子节点的含义是X=A或者X=C放到左孩子，其余放到右孩子。<br>
<img src="20181022170102610.jpg" alt="加载不了请走VPN哈"></p>
<h3 id="LGBM如何处理离散特征？">LGBM如何处理离散特征？</h3>
<p>为了解决one-hot编码处理类别特征的不足。LGBM采用了Many vs many的切分方式，实现了类别特征的最优切分。用Lightgbm可以直接输入类别特征，并产生如上面图右边的效果。在1个k维的类别特征中寻找最优切分，朴素的枚举算法的复杂度是 $2^k$ ，而LGBM实现了的算法复杂度为 $nlogn$ 。</p>
<p>算法流程瑞霞：在枚举分割点之前，先把直方图按每个类别的均值进行排序；然后按照均值的结果依次枚举最优分割点。其中计算的Sum(y)/Count(y)为类别的均值。当然，这个方法很容易过拟合，所以在LGBM中加入了很多对这个方法的约束和正则化。</p>
<h3 id="LGBM如何处理缺失值？">LGBM如何处理缺失值？</h3>
<p>和 xgboost 的处理方式是一样，zero_as_missing=true 会将 0 也当作缺失值处理，因此在用的时候要注意，有的是偶缺失值和0不是一个意思。</p>
<h3 id="LGBM-与-XGBoost-的不同点？">LGBM 与 XGBoost 的不同点？</h3>
<ol>
<li>由于在决策树在每一次选择节点特征的过程中，要遍历所有的属性的所有取值并选择一个较好的。XGBoost 使用的是近似算法，先对特征值进行预排序 Pre-sort，然后根据二阶梯度进行分桶，能够更精确的找到数据分隔点；但是复杂度较高。LightGBM 使用的是 histogram 算法，这种只需要将数据分割成不同的段即可，不需要进行预先的排序。占用的内存更低，数据分割的复杂度更低。</li>
<li>决策树生长策略，XGBoost 采用的是 Level-wise 的树生长策略，LightGBM 采用的是 leaf-wise 的生长策略，以最大信息增益为导向。后者进度更高，容易过拟合，所以要控制最大深度。</li>
<li>并行策略对比，XGBoost 的并行主要集中在特征并行上，而 LightGBM 的并行策略分特征并行，数据并行以及投票并行。</li>
<li>在树方面，提出了直方图算法寻找最佳分裂点，而且还采用Leaf-wise树生长策略。不过后面改进版的xgb也使用到了。</li>
<li>在样本数上，使用GOSS保留所有大梯度样本但随机采样小梯度样本，减少训练样本量。</li>
<li>在特征数上，使用EFB捆绑互斥特征，将特征变稠密。此外，作者还采用GS编码，在GBDT一类模型中，这是第一次能直接支持类别型特征，不需要提前独热编码后再输入至模型中。最后，同样地，LightGBM也跟XGBoost一样进行了工程优化，使得训练能高效并行且增加Cache命中率。</li>
</ol>
<h3 id="树模型怎么查看特征重要性？">树模型怎么查看特征重要性？</h3>
<ol>
<li>通过OOB<br>
OOB是怎么做到可以对特征重要性进行排序的呢，先用训练好的模型对OOB数据进行打分，计算出AUC或其他业务定义的评估指标；接着对OOB数据中的每个特征：(1) 随机shuffle当前特征的取值；(2) 重新对当前数据进行打分，计算评估指标；(3)计算指标变化率。按照上面方式，对每个特征都会得到一个变化率，最后按照变化率排序来量化特征重要性。</li>
<li>通过Gini<br>
说白了就是看看每个特征在随机森林中的每颗树上做了多大的贡献，然后取个平均值，最后比一比特征之间的贡献大小。对于生成的每棵树，计算每个分裂节点的Gini指数,特征 Xj 在节点m的重要性可以通过分裂前后的特征 GIm 的差值来表示。</li>
</ol>
<h3 id="测试">测试</h3>
<h3 id="参考-2">参考</h3>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/83901304">https://zhuanlan.zhihu.com/p/83901304</a><br>
<a href="https://zhuanlan.zhihu.com/p/77473961">https://zhuanlan.zhihu.com/p/77473961</a><br>
<a href="https://www.zhihu.com/question/277638585/answer/522272201">https://www.zhihu.com/question/277638585/answer/522272201</a><br>
<a href="https://www.zhihu.com/question/359567100">https://www.zhihu.com/question/359567100</a><br>
<a href="https://blog.csdn.net/weixin_37933986/article/details/69681671">https://blog.csdn.net/weixin_37933986/article/details/69681671</a><br>
<a href="https://www.zhihu.com/question/68621766/answer/336096221">https://www.zhihu.com/question/68621766/answer/336096221</a><br>
<a href="https://blog.csdn.net/han_xiaoyang/article/details/52665396">https://blog.csdn.net/han_xiaoyang/article/details/52665396</a><br>
<a href="https://zhuanlan.zhihu.com/p/29649128">https://zhuanlan.zhihu.com/p/29649128</a><br>
<a href="https://www.jianshu.com/p/9423b3e41e14">https://www.jianshu.com/p/9423b3e41e14</a><br>
<a href="https://blog.csdn.net/weixin_44507034/article/details/109757064">https://blog.csdn.net/weixin_44507034/article/details/109757064</a><br>
<a href="https://www.zhihu.com/question/266195966">https://www.zhihu.com/question/266195966</a><br>
<a href="https://www.icode9.com/content-4-689535.html">https://www.icode9.com/content-4-689535.html</a><br>
<a href="https://juejin.cn/post/6844903798603776014">https://juejin.cn/post/6844903798603776014</a><br>
<a href="https://blog.csdn.net/maqunfi/article/details/82219999">https://blog.csdn.net/maqunfi/article/details/82219999</a><br>
<a href="https://zhuanlan.zhihu.com/p/65597945">https://zhuanlan.zhihu.com/p/65597945</a><br>
<a href="https://blog.csdn.net/cranberrycookie/article/details/79834884">https://blog.csdn.net/cranberrycookie/article/details/79834884</a><br>
<a href="https://blog.csdn.net/Heitao5200/article/details/103758643">https://blog.csdn.net/Heitao5200/article/details/103758643</a><br>
<a href="https://blog.csdn.net/Daverain/article/details/96702696">https://blog.csdn.net/Daverain/article/details/96702696</a></p>
</blockquote>
]]></content>
      <categories>
        <category>算法面试</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>刷八股</tag>
      </tags>
  </entry>
  <entry>
    <title>非监督学习</title>
    <url>/2024/03/19/machine_learning/uns_learning/</url>
    <content><![CDATA[<h1>非监督学习</h1>
<h2 id="相关概念">相关概念</h2>
<h3 id="什么是非监督学习？">什么是非监督学习？</h3>
<p>非监督学习是机器学习任务的一种。它从无标记的训练数据中推断结论。最典型的无监督学习就是聚类分析，它可以在探索性数据分析阶段用于发现隐藏的模式或者对数据进行分组。一句话：给定数据，寻找隐藏的结构。</p>
<h3 id="常见的非监督学习包括哪些？">常见的非监督学习包括哪些？</h3>
<p>无监督学习算法有几种类型，以下是其中最重要的12种:</p>
<ol>
<li>聚类算法<br>
k-means聚类是一种流行的聚类算法，它将数据划分为k组。</li>
<li>降维算法<br>
降低了数据的维数，使其更容易可视化和处理主成分分析(PCA)是一种降维算法，将数据投影到低维空间，PCA可以用来将数据降维到其最重要的特征。</li>
<li>异常检测算法<br>
支持向量机是可以用于异常检测(示例)。异常检测算法用于检测数据集中的异常点，异常检测的方法有很多，但大多数可以分为有监督和无监督两种。监督方法需要标记数据集，而无监督方法不需要。无监督异常检测算法通常基于密度估计，试图找到数据空间中密集的区域外的点。一个简单的方法是计算每个点到k个最近邻居的平均距离。距离相邻点非常远的点很可能是异常点。还有很多基于密度的异常检测算法，包括局部离群因子(Local Outlier Factor,LOF)和支持向量数据描述(Support Vector Domain Description,SVDD)。这些算法比简单的k近邻方法更复杂，通常可以检测到更细微的异常。大多数异常检测算法都需要进行调整，例如指定一个参数来控制算法对异常的敏感程度。如果参数过低，算法可能会漏掉一些异常。如果设置过高，算法可能会产生误报(将正常点识别为异常点)。</li>
<li>分割算法<br>
分割算法可以将图像分割为前景和背景。这些算法可以在不需要人工监督的情况下自动将数据集分割成有意义的组。这个领域中比较知名的一个算法是k-means算法。该算法通过最小化组内距离平方和将数据点分成k组。另一种流行的分割算法是mean shift算法。该算法通过迭代地将每个数据点移向其局部邻域的中心来实现。mean shift对异常值具有较强的鲁棒性，可以处理密度不均匀的数据集。但是在大型数据集上运行它的计算成本可能很高。高斯混合模型(GMM)是一种可用于分割的概率模型。以前gmm需要大量的计算来训练，但最近的研究进展使其更快。gmm非常灵活，可以用于任何类型的数据。但是它们有时并不能总是产生最好的结果。对于简单的数据集，k-means是一个很好的选择，而gmm则更适合于复杂的数据集。mean shift可以用于任何一种情况，但在大型数据集上计算的成本会很高。</li>
<li>去噪算法<br>
小波变换可以用于图像去噪。但是各种来源可能会产生噪声，包括数据损坏、缺失值和异常值。去噪算法通过减少数据中的噪声量来提高无监督学习模型的准确性。现有的去噪算法有多种，包括主成分分析(PCA)、独立成分分析(ICA)和非负矩阵分解(NMF)。</li>
<li>链接预测算法预测数据点之间的未来连接<br>
例如，网络中两个节点之间的未来交互，链接预测可用于预测哪些人将成为社交网络中的朋友。 更常用的链接预测算法之一是优先连接算法，它预测如果两个节点有许多现有连接，则它们更有可能被连接。另一种流行的链路预测算法是局部路径算法，它预测如果两个节点共享一个共同的邻居，那么它们更有可能被关联。该算法可以捕获“结构等价”的概念，因此在生物网络中经常使用。最后，random walk with restart算法也是一种链路预测算法，它模拟网络上的一个随机走动的人，在随机节点处重新启动步行者。然后，步行者到达特定节点的概率被用来衡量两个节点之间存在连接的可能性。</li>
<li>强化学习算法<br>
通过反复试验来进行学习Q-learning是基于值的学习算法的一个例子;它实现简单并且通用。但是Q-learning有时会收敛到次优解。另一个例子是TD learning，它在计算上Q-learning学习要求更高，但通常可以找到更好的解决方案。</li>
<li>生成模型<br>
算法使用训练数据生成新的数据自编码器是生成模型，可用于从图像数据集创建独特的图像。在机器学习中，生成模型是一种捕捉一组数据的统计属性的模型。这些模型可以用来生成新的数据，就像它们所用的训练的数据一样。生成模型用于各种任务，如无监督学习，数据压缩和去噪。生成模型有很多种，比如隐马尔可夫模型和玻尔兹曼机。每种模型都有其优缺点，并且适用于不同的任务。隐马尔可夫模型擅长对顺序数据建模，而玻尔兹曼机器更擅长对高维数据建模。通过在无标记数据上训练它们，生成模型可以用于无监督学习。一旦模型经过训练，就可以用来生成新的数据。然后这些生成的数据可以由人类或其他机器学习算法进行标记。这个过程可以重复，直到生成模型学会生成数据，就像想要的输出。</li>
</ol>
<h3 id="非监督学习的主要特点？">非监督学习的主要特点？</h3>
<ol>
<li>
<p>无标签</p>
</li>
<li>
<p>无反馈</p>
</li>
<li>
<p>寻找隐藏的结构</p>
</li>
</ol>
<h3 id="什么是非监督学习的功能？">什么是非监督学习的功能？</h3>
<ol>
<li>求数据的集群</li>
<li>求出数据的低维表达</li>
<li>查找数据有趣的方向</li>
<li>有趣的坐标和相关性</li>
<li>发现显著的观测值和数据集清理</li>
</ol>
<h3 id="参考">参考</h3>
<blockquote>
<p><a href="https://www.zhihu.com/question/24448657/answer/616164140">https://www.zhihu.com/question/24448657/answer/616164140</a><br>
<a href="https://www.zhihu.com/question/23194489/answer/41744596">https://www.zhihu.com/question/23194489/answer/41744596</a></p>
</blockquote>
<h2 id="聚类算法">聚类算法</h2>
<h3 id="介绍下Kmeans算法？">介绍下Kmeans算法？</h3>
<p>是一直监督的学习方法，主要用于聚类，通过方法将数据分为K个类。</p>
<h3 id="聚类算法的分类">聚类算法的分类</h3>
<p>聚类算法一般可以用基于划分、基于层次、基于密度、基于网格、基于模型、基于图等方式来进行分类。</p>
<h3 id="Kmeans如何选择初始点？">Kmeans如何选择初始点？</h3>
<p>常见的方法是随机的选取初始质心，但是这样簇的质量常常很差。处理选取初始质心问题的一种常用技术是：多次运行，每次使用一组不同的随机初始质心，然后选取具有最小SSE（误差的平方和）的簇集。这种策略简单，但是效果可能不好，这取决于数据集和寻找的簇的个数。</p>
<p>第二种有效的方法是，取一个样本，并使用层次聚类技术对它聚类。从层次聚类中提取K个簇，并用这些簇的质心作为初始质心。该方法通常很有效，但仅对下列情况有效：（1）样本相对较小，例如数百到数千（层次聚类开销较大）；（2）K相对于样本大小较小</p>
<p>第三种选择初始质心的方法，随机地选择第一个点，或取所有点的质心作为第一个点。然后，对于每个后继初始质心，选择离已经选取过的初始质心最远的点。使用这种方法，确保了选择的初始质心不仅是随机的，而且是散开的。但是，这种方法可能选中离群点。此外，求离当前初始质心集最远的点开销也非常大。为了克服这个问题，通常<br>
该方法用于点样本。由于离群点很少（多了就不是离群点了），它们多半不会在随机样本中出现。计算量也大幅减少。</p>
<h3 id="大体流程描述一下">大体流程描述一下</h3>
<ol>
<li>随机选择k个点作为中心点</li>
<li>分簇：利用定义好的距离（可以是欧式或者其他）对比每个点到k个点哪个近，则为哪个簇</li>
<li>更新：将第k个簇取平均得到新的中心点</li>
<li>循环23步骤直到中心点不变（可以设定收敛的最小误差或者设置迭代轮数）</li>
</ol>
<h3 id="Kmeans有哪些不同距离度量方式？">Kmeans有哪些不同距离度量方式？</h3>
<ul>
<li>
<p>欧几里得距离</p>
</li>
<li>
<p>曼哈顿距离</p>
</li>
<li>
<p>余弦距离</p>
</li>
</ul>
<h3 id="如何选取k？">如何选取k？</h3>
<ol>
<li>
<p>手肘法<br>
核心指标是SSE误差平方和，外面是对k求和，里面是对簇求和，求和内容是每个样本和他所属簇的均值的差的平方。核心思想就是随着聚类数k增大，样本划分更加精细，SSE会越来越小，曲线呈现下降趋势，找到一个点是骤降的，即下降幅度最大，也即是最后是在手肘地方</p>
</li>
<li>
<p>Gap Static<br>
不需要像上述手肘一样还需要画出来去判断，只需计算值，当这个值最大时，它所对应的k就是最好的，方便批量化作业</p>
</li>
<li>
<p>根据业务选取</p>
</li>
</ol>
<h3 id="为什么会产生空簇？">为什么会产生空簇？</h3>
<p>这就要从簇中元素的分配说起。设当前的簇数为n，那么依次计算n个簇的质心，然后依次遍历所有元素，将其分配到到距其最近的一个质心簇中。在这个分配过程中，就可能存在没有一个点被分配到该质心中，这就产生了空簇。</p>
<h3 id="如何对空簇进行处理？">如何对空簇进行处理？</h3>
<p>如果可以减少聚类的类数，那么就可以尝试直接放弃该空簇。<br>
重新运行算法再次随机分类<br>
将离其所属簇最远的点分配给空簇</p>
<h3 id="K-means对异常值是否敏感？为什么？">K-means对异常值是否敏感？为什么？</h3>
<p>K-means对异常值较为敏感，因为一个集合内的元素均值易受到一个极大值的影响。当存在异常值的情况下，均值所计算出来的中心位置很可能不能够反映真实的类别中心。</p>
<h3 id="如何评估聚类效果？">如何评估聚类效果？</h3>
<p>聚类往往不像分类一样有一个最优化目标和学习过程，聚类更像一个统计方法，将相似的数据和不相似的数据分开。所以，评估聚类效果可以从以下维度下手：</p>
<p>（1）聚类趋势（对数据进行评估）<br>
霍普金斯统计量(Hopkins Statistic)评估给定数据集是否存在有意义的可聚类的非随机结构。如果一个数据集是由随机的均匀的点生成的，虽然也可以产生聚类结果，但该结果没有意义，聚类的前提是需要数据非均匀分布的。</p>
<p>（2）判断聚类的簇数是否为最佳<br>
可用业务分析法、观察法、Gap Statistic方法等找到最佳的分类数与实际簇数做比较（见第四点）。</p>
<p>（3）聚类质量<br>
因为是无监督学习，所以一般通过评估类的分离情况来决定聚类质量。类内越紧密，类间距离越小则质量越高。</p>
<h3 id="Kmeans优缺点？">Kmeans优缺点？</h3>
<ul>
<li>
<p>优点<br>
时间复杂度低，NKt，样本数乘以簇数乘以迭代轮数，接近线性</p>
</li>
<li>
<p>缺点</p>
</li>
</ul>
<ol>
<li>对数值敏感（因此需要做预处理、归一化处理），对异常值敏感（因此需要做离散点处理）</li>
<li>k难以选取</li>
<li>聚类效果依赖于中心初始化</li>
<li>局部最优</li>
</ol>
<h3 id="Kmeans-相比于Kmeans做的优化？">Kmeans++相比于Kmeans做的优化？</h3>
<p>假设已经选取了n个初始聚类中心，则在选择n+1个聚类中心时，距离当前n个聚类中心越远的点会有更好的概率被选择为第n+1类聚类的中心。聚类中心当然是互相隔离的越远越好，之后的算法步骤同于k-means。（第一个点仍然是随机初始化）</p>
<h3 id="Kmeans和EM算法的联系？">Kmeans和EM算法的联系？</h3>
<p>Kmeans等价于用EM算法求解以下含隐变量的最大似然问题，（c就是取的k，从1到K）。</p>
<p>E步求上述给定x和mui下c的条件概率期望，这里条件概率可以定义为如果分到最小类则为1，到其他类距离比最小的大，则为0。求期望也即是使P概率最大化。相当于先固定好了质心mui，然后将每个点找到离它最近的簇c。</p>
<p>M步，更新mui参数，此时是每个簇c已确定，对应于kmeans里更新聚类中心。</p>
<h3 id="介绍西喜爱DBSCAN算法？">介绍西喜爱DBSCAN算法？</h3>
<p>DBSCAN（Density-Based Spatial Clustering of Applications with Noise），具有噪声的基于密度的聚类方法）是一种基于密度的空间聚类算法。 该算法将具有足够密度的区域划分为簇，并在具有噪声的空间数据库中发现任意形状的簇，它将簇定义为密度相连的点的最大集合。</p>
<h3 id="DBSCAN算法流程是什么样的？">DBSCAN算法流程是什么样的？</h3>
<p>（1）从数据集中任选一个未访问过的点作为初始点，这个点称为“种子“，”。以该初始点为圆心，以e为半径画一个圆，圆形区域即为该点的邻域<br>
（2）如果在该初始点的邻域中至少含有MinPts个点，则该点是一个核心对象（core object），聚类开始，该点成为新聚类中的第一个点。否则，该点将被标记为噪声点（noise）。在这两种情况下，这一点都被标记为“已访问（visited）”。<br>
（3）对于新聚类中的第一个点，其距离内的点都成为同一聚类中的一部分。<br>
（4）若核心对象邻域内的点满足步骤（2）的条件，则成为新的核心对象，并吸纳其距离内的点为同一聚类中的一部分，不断重复此过程，直到该聚类附近的所有点都已被访问。<br>
（5）当完成当前的聚类时，重新检索下一个新的未访问点，重复步骤（1）~（4），直到所有点都被标记为“已访问”。</p>
<h3 id="DBSCAN中的参数如何确定？">DBSCAN中的参数如何确定？</h3>
<p>DBSCAN也是一种较为常用的算法，DBSCAN中重要的参数是Eps和MinPts，那么这两个参数该如何确定呢？</p>
<p>(1)  Eps的值可以使用绘制k-距离曲线(k-distance graph)方法得当，在k-距离曲线图明显拐点位置为对应较好的参数。若参数设置过小，大部分数据不能聚类；若参数设置过大，多个簇和大部分对象会归并到同一个簇中。</p>
<p>K-距离：K距离的定义在DBSCAN算法原文中给出了详细解说，给定K邻域参数k,对于数据中的每个点，计算对应的第k个最近邻域距离，并将数据集所有点对应的最近邻域距离按照降序方式排序，称这幅图为排序的k距离图，选择该图中第一个谷值点位置对应的k距离值设定为Eps。一般将k值设为4。</p>
<p>(2)  MinPts的选取有一个指导性的原则（a rule of thumb），MinPts≥dim+1,其中dim表示待聚类数据的维度。MinPts设置为1是不合理的，因为设置为1，则每个独立点都是一个簇，MinPts≤2时，与层次距离最近邻域结果相同，因此，MinPts必须选择大于等于3的值。若该值选取过小，则稀疏簇中结果由于密度小于MinPts，从而被认为是边界点儿不被用于在类的进一步扩展；若该值过大，则密度较大的两个邻近簇可能被合并为同一簇。因此，该值是否设置适当会对聚类结果造成较大影响。</p>
<h3 id="DBSCAN的主要参数是？">DBSCAN的主要参数是？</h3>
<p>邻域半径R和最少点数目minpoints</p>
<h3 id="解释下密度直达，密度可达，密度相连，非密度相连的关系？">解释下密度直达，密度可达，密度相连，非密度相连的关系？</h3>
<p>如果P为核心点，Q在P的R邻域内，那么称P到Q密度直达。任何核心点到其自身密度直达，密度直达不具有对称性，如果P到Q密度直达，那么Q到P不一定密度直达。</p>
<p>如果存在核心点P2，P3，……，Pn，且P1到P2密度直达，P2到P3密度直达，……，P(n-1)到Pn密度直达，Pn到Q密度直达，则P1到Q密度可达。密度可达也不具有对称性。</p>
<p>如果存在核心点S，使得S到P和Q都密度可达，则P和Q密度相连。密度相连具有对称性，如果P和Q密度相连，那么Q和P也一定密度相连。密度相连的两个点属于同一个聚类簇。</p>
<p>如果两个点不属于密度相连关系，则两个点非密度相连。非密度相连的两个点属于不同的聚类簇，或者其中存在噪声点。</p>
<h3 id="DBSCAN算法优缺点">DBSCAN算法优缺点</h3>
<p>和传统的 k-means 算法相比，DBSCAN 算法不需要输入簇数 k 而且可以发现任意形状的聚类簇，同时，在聚类时可以找出异常点。</p>
<p>DBSCAN 算法的主要优点如下。</p>
<p>1）可以对任意形状的稠密数据集进行聚类，而 k-means 之类的聚类算法一般只适用于凸数据集。</p>
<p>2）可以在聚类的同时发现异常点，对数据集中的异常点不敏感。</p>
<p>3）聚类结果没有偏倚，而 k-means 之类的聚类算法的初始值对聚类结果有很大影响。</p>
<p>DBSCAN 算法的主要缺点如下。</p>
<p>1）样本集的密度不均匀、聚类间距差相差很大时，聚类质量较差，这时用 DBSCAN 算法一般不适合。</p>
<p>2）样本集较大时，聚类收敛时间较长，此时可以对搜索最近邻时建立的 KD 树或者球树进行规模限制来进行改进。</p>
<p>3）调试参数比较复杂时，主要需要对距离阈值 Eps，邻域样本数阈值 MinPts 进行联合调参，不同的参数组合对最后的聚类效果有较大影响。</p>
<p>4）对于整个数据集只采用了一组参数。如果数据集中存在不同密度的簇或者嵌套簇，则 DBSCAN 算法不能处理。为了解决这个问题，有人提出了 OPTICS 算法。</p>
<p>5）DBSCAN 算法可过滤噪声点，这同时也是其缺点，这造成了其不适用于某些领域，如对网络安全领域中恶意攻击的判断。</p>
<h3 id="解释下你知道的聚类算法以及他们之间的区别？">解释下你知道的聚类算法以及他们之间的区别？</h3>
<p>各个聚类算法的对比如下：<br>
<img src="be63d6ad2f5f4406b9fe884f0be62f66.png" alt="无法加载请走VPN"></p>
<h3 id="介绍下层次聚类算法">介绍下层次聚类算法?</h3>
<p>根据层次分解的顺序是自底向上的还是自上向下的，层次聚类算法分为凝聚的层次聚类算法和分裂的层次聚类算法。　凝聚型层次聚类的策略是先将每个对象作为一个簇，然后合并这些原子簇为越来越大的簇，直到所有对象都在一个簇中，或者某个终结条件被满足。绝大多数层次聚类属于凝聚型层次聚类，它们只是在簇间相似度的定义上有所不同。</p>
<p>算法流程主要如下所示：<br>
(1) 将每个对象看作一类，计算两两之间的最小距离；<br>
(2) 将距离最小的两个类合并成一个新类；<br>
(3) 重新计算新类与所有类之间的距离；<br>
(4) 重复(2)、(3)，直到所有类最后合并成一类。</p>
<h3 id="参考-2">参考</h3>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/542290564">https://zhuanlan.zhihu.com/p/542290564</a><br>
<a href="https://blog.csdn.net/Chenzhi_2016/article/details/79451201">https://blog.csdn.net/Chenzhi_2016/article/details/79451201</a><br>
<a href="https://blog.csdn.net/qq_43550820/article/details/108802267">https://blog.csdn.net/qq_43550820/article/details/108802267</a><br>
<a href="https://blog.csdn.net/weixin_44507034/article/details/110010543">https://blog.csdn.net/weixin_44507034/article/details/110010543</a><br>
<a href="https://blog.csdn.net/hansome_hong/article/details/107596543">https://blog.csdn.net/hansome_hong/article/details/107596543</a></p>
</blockquote>
<h2 id="降维">降维</h2>
<h3 id="降维的必要性和目的是什么？">降维的必要性和目的是什么？</h3>
<p>降维的必要性：</p>
<p>多重共线性和预测变量之间相互关联。多重共线性会导致解空间的不稳定，从而可能导致结果的不连贯。<br>
高维空间本身具有稀疏性。一维正态分布有68%的值落于正负标准差之间，而在十维空间上只有2%。<br>
过多的变量，对查找规律造成冗余麻烦。<br>
仅在变量层面上分析可能会忽略变量之间的潜在联系。例如几个预测变量可能落入仅反映数据某一方面特征的一个组内。</p>
<p>降维的目的：</p>
<p>减少预测变量的个数。<br>
确保这些变量是相互独立的。<br>
提供一个框架来解释结果。相关特征，特别是重要特征更能在数据中明确的显示出来；如果只有两维或者三维的话，更便于可视化展示。<br>
数据在低维下更容易处理、更容易使用。<br>
去除数据噪声。<br>
降低算法运算开销。</p>
<h3 id="PCA介绍下？">PCA介绍下？</h3>
<p>PCA(Principal Component Analysis)是一种常用的数据分析方法。PCA通过线性变换将原始数据变换为一组各维度线性无关的表示，可用于提取数据的主要特征分量，常用于高维数据的降维。数据降维是无监督学习的另外一个常见问题。</p>
<h3 id="PCA算法流程？">PCA算法流程？</h3>
<ol>
<li>对所有的样本进行中心化</li>
<li>计算样本的协方差矩阵</li>
<li>求出协方差矩阵的特征值及对应的特征向量</li>
<li>将特征向量按对应特征值大小从上到下按行排列成矩阵，取前k行组成矩阵P</li>
<li>Y=PX即为降维到k维后的数据</li>
</ol>
<h3 id="PCA如何解决非线性降维？">PCA如何解决非线性降维？</h3>
<p>想解决非线性问题，就需要做一些调整。PCA也是一种线性变换。核主成分分析（Kernel PCA）可以处理非线性问题。数据先通过核函数（kernel function）转换成一个新空间，然后再用PCA处理。</p>
<h3 id="降维之后的维度怎么确定？">降维之后的维度怎么确定？</h3>
<p>可以利用交叉验证，再选择一个很简单的分类器，来选择比较好的 k‘ 的值<br>
可以设置一个比重阈值 t，比如 95%，然后选择满足阈值的最小的 k‘：</p>
<h3 id="LDA和PCA区别？">LDA和PCA区别？</h3>
<p>相同点<br>
(1) 两者的作用是用来降维的<br>
(2) 两者都假设符合高斯分布</p>
<p>不同点<br>
(1) LDA是有监督的降维方法，PCA是无监督的。<br>
(2) LDA降维最多降到类别数K-1的维数，PCA没有这个限制。<br>
(3) LDA更依赖均值，如果样本信息更依赖方差的话，效果将没有PCA好。<br>
(4) LDA可能会过拟合数据。</p>
<h3 id="PCA算法优缺点？">PCA算法优缺点？</h3>
<p>PCA算法的主要优点有：</p>
<ul>
<li>仅仅需要以方差衡量信息量，不受数据集以外的因素影响。</li>
<li>各主成分之间正交，可消除原始数据成分间的相互影响的因素。<br>
计算方法简单，主要运算是特征值分解，易于实现。</li>
</ul>
<p>PCA算法的主要缺点有：<br>
主成分各个特征维度的含义具有一定的模糊性，不如原始样本特征的解释性强。<br>
方差小的非主成分也可能含有对样本差异的重要信息，因降维丢弃可能对后续数据处理有影响。</p>
<h3 id="PCA和SVD的联系和区别？">PCA和SVD的联系和区别？</h3>
<ol>
<li>两者都是矩阵分解的技术，一个直接分解SVD，一个是对协方差矩阵操作后分解PCA</li>
<li>奇异值和特征向量存在关系，即有</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;\lambda _i&#125; = &#123;s_i&#125;^2/(n - 1)</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>SVD可以获取另一个方向上的主成分，而PCA只能获得单个方向上的主成分，PCA只与SVD的右奇异向量的压缩效果相同</li>
<li>通过SVD可以得到PCA相同的结果，但是SVD通常比直接使用PCA更稳定。因为在PCA求协方差时很可能会丢失一些精度。例如Lauchli矩阵</li>
</ol>
<h3 id="除了PCA你还知道哪些降维方法">除了PCA你还知道哪些降维方法</h3>
<p>当然PCA是众所周知的降维方法，SVD也是一种，除此之外，还有如LDA、LLE以及LE。</p>
<ul>
<li>PCA<br>
PCA也就是主成份分析，Principal Component Analysis(PCA)是现如今最流行的无监督线性降维方法之一了，其主要思想是数据经过某种投影，或者说乘以一个矩阵之后，得到的新的矩阵在所投影的维度上数据的方差最大，以此使用较少的数据维度，同时保留住较多的原数据点的特性。PCA的目标主要如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\mathop &#123;\max &#125;\limits_w \frac&#123;1&#125;&#123;m&#125;\sum\limits_&#123;i = 1&#125;^m &#123;&#123;&#123;(&#123;w^T&#125;(&#123;x_i&#125; - \bar x))&#125;^2&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>PCA追求的是在降维之后能够最大化保持数据的内在信息，并通过衡量在投影方向上的数据方差的大小来衡量该方向的重要性。但是这样投影以后对数据 的区分作用并不大，反而可能使得数据点揉杂在一起无法区分。这也是PCA存在的最大一个问题，这导致使用PCA在很多情况下的分类效果并不好。具体可以看下图所示，若使用PCA将数据点投影至一维空间上时，PCA会选择2轴，这使得原本很容易区分的两簇点被揉杂在一起变得无法区分；而这时若选择1轴将会得 到很好的区分结果。而下面所说的LDA就将数据映射到轴1上的。<br>
<img src="https://img-blog.csdnimg.cn/ab9392f7a7dc4931b59295671a2a9cbb.png" alt="image"><br>
(2) LDA<br>
Linear Discriminant Analysis(也有叫做Fisher Linear Discriminant)是一种有监督的（supervised）线性降维算法。与PCA保持数据信息不同，LDA是为了使得降维后的数据点尽可能地容易被区分，如上图投影导轴1上，这里的公式推导就不说明。<br>
(3) LLE<br>
上面说到了线性降维方法，当然还有非线性降维方法，这里介绍下LLE，也就是局部线性嵌入，它能够使降维后的数据较好地保持原有流形结构 。LLE可以说是流形学习方法最经典的工作之一。很多后续的流形学习、降维方法都与LLE有密切联系。下图给了一个典型的例子，看到降维后数据还保持了流形的结构。<br>
<img src="https://www.icode9.com/i/ll/?i=20200316212600332.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODA1Mzg4Nw==,size_1,color_FFFFFF,t_70#pic_center" alt="image"><br>
(4) LE<br>
Laplacian Eigenmaps 是用局部的角度去构建数据之间的关系。具体来讲，拉普拉斯特征映射是一种基于图的降维算法，它希望相互间有关系的点（在图中相连的点）在降维后的空间中尽可能的靠近，从而在降维后仍能保持原有的数据结构。 如果两个数据实例i和j很相似，那么i和j在降维后目标子空间中应该尽量接近。Laplacian Eigenmaps可以反映出数据内在的流形结构。<br>
拉普拉斯特征映射通过构建邻接矩阵为W的图来重构数据流形的局部结构特征。其主要思想是，如果两个数据实例i和j很相似，那么i和j在降维后目标子空间中应该尽量接近。<br>
<img src="https://img-blog.csdnimg.cn/20191215213534273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgwMTM2NA==,size_16,color_FFFFFF,t_70" alt="image"></p>
<h3 id="介绍下LDA算法？">介绍下LDA算法？</h3>
<p>LDA是一种特征抽取的技术，用于分类任务的降维方法，其目标是向最大化类间差异，最小化类内差异的方向投影。</p>
<h3 id="LDA的优缺点？">LDA的优缺点？</h3>
<p>LDA算法的主要优点有：</p>
<ol>
<li>
<p>在降维过程中可以使用类别的先验知识经验，而像PCA这样的无监督学习则无法使用类别先验知识。</p>
</li>
<li>
<p>LDA在样本分类信息依赖均值而不是方差的时候，比PCA之类的算法较优。</p>
</li>
</ol>
<p>LDA算法的主要缺点有：</p>
<ol>
<li>
<p>LDA不适合对非高斯分布样本进行降维，PCA也有这个问题。</p>
</li>
<li>
<p>LDA降维最多降到类别数k-1的维数，如果我们降维的维度大于k-1，则不能使用LDA。当然目前有一些LDA的进化版算法可以绕过这个问题。</p>
</li>
<li>
<p>LDA在样本分类信息依赖方差而不是均值的时候，降维效果不好。</p>
</li>
<li>
<p>LDA可能过度拟合数据。</p>
</li>
</ol>
<h3 id="LDA和PCA的异同？">LDA和PCA的异同？</h3>
<p>首先我们看看相同点：</p>
<ol>
<li>
<p>两者均可以对数据进行降维。</p>
</li>
<li>
<p>两者在降维时均使用了矩阵特征分解的思想。</p>
</li>
<li>
<p>两者都假设数据符合高斯分布。</p>
</li>
</ol>
<p>我们接着看看不同点：</p>
<ol>
<li>
<p>LDA是有监督的降维方法，而PCA是无监督的降维方法</p>
</li>
<li>
<p>LDA降维最多降到类别数k-1的维数，而PCA没有这个限制。</p>
</li>
<li>
<p>LDA除了可以用于降维，还可以用于分类。</p>
</li>
<li>
<p>LDA选择分类性能最好的投影方向，而PCA选择样本点投影具有最大方差的方向。</p>
</li>
</ol>
<h3 id="协方差与相关系数的区别和联系是什么？">协方差与相关系数的区别和联系是什么？</h3>
<p>协方差：</p>
<p>协方差表示的是两个变量的总体的误差，这与只表示一个变量误差的方差不同。 如果两个变量的变化趋势一致，也就是说如果其中一个大于自身的期望值，另外一个也大于自身的期望值，那么两个变量之间的协方差就是正值。 如果两个变量的变化趋势相反，即其中一个大于自身的期望值，另外一个却小于自身的期望值，那么两个变量之间的协方差就是负值。</p>
<p>相关系数：</p>
<p>研究变量之间线性相关程度的量，取值范围是[-1,1]。相关系数也可以看成协方差：一种剔除了两个变量量纲影响、标准化后的特殊协方差。</p>
<h3 id="参考-3">参考</h3>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/32412043">https://zhuanlan.zhihu.com/p/32412043</a><br>
<a href="https://blog.csdn.net/u013719780/article/details/51767341">https://blog.csdn.net/u013719780/article/details/51767341</a><br>
<a href="https://www.it610.com/article/1535554599291744256.htm">https://www.it610.com/article/1535554599291744256.htm</a><br>
<a href="https://zhuanlan.zhihu.com/p/57156916/">https://zhuanlan.zhihu.com/p/57156916/</a><br>
<a href="https://blog.csdn.net/weixin_43758551/article/details/88691607">https://blog.csdn.net/weixin_43758551/article/details/88691607</a></p>
</blockquote>
]]></content>
      <categories>
        <category>算法面试</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>刷八股</tag>
      </tags>
  </entry>
</search>
