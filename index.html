<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="fonts.lug.ustc.edu.cn/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="算法工程师的日常">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="算法工程师的日常">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Tom">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>算法工程师的日常</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">算法工程师的日常</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/19/deep_learning/ch10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tom">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="算法工程师的日常">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/19/deep_learning/ch10/" class="post-title-link" itemprop="url">强化学习面试题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-19 23:29:20" itemprop="dateCreated datePublished" datetime="2024-03-19T23:29:20+08:00">2024-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-24 10:13:59" itemprop="dateModified" datetime="2024-03-24T10:13:59+08:00">2024-03-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">算法面试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">深度学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>强化学习</h1>
<h2 id="10-1-强化学习的主要特点？">10.1 强化学习的主要特点？</h2>
<p>其他许多机器学习算法中学习器都是学得怎样做，而RL是在尝试的过程中学习到在特定的情境下选择哪种行动可以得到最大的回报。在很多场景中，当前的行动不仅会影响当前的rewards，还会影响之后的状态和一系列的rewards。RL最重要的3个特定在于：<br>
(1)	基本是以一种闭环的形式；<br>
(2)	不会直接指示选择哪种行动（actions）；<br>
(3)	一系列的actions和奖励信号（reward signals）都会影响之后较长的时间。</p>
<h3 id="10-1-1-定义">10.1.1 定义</h3>
<p>强化学习是机器学习的一个重要分支，是多学科多领域交叉的一个产物，它的本质是解决 decision making 问题，即自动进行决策，并且可以做连续决策。<br>
它主要包含四个元素，agent，环境状态，行动，奖励, 强化学习的目标就是获得最多的累计奖励。<br>
我们列举几个形象的例子：<br>
小孩想要走路，但在这之前，他需要先站起来，站起来之后还要保持平衡，接下来还要先迈出一条腿，是左腿还是右腿，迈出一步后还要迈出下一步。<br>
小孩就是 agent，他试图通过采取行动（即行走）来操纵环境（行走的表面），并且从一个状态转变到另一个状态（即他走的每一步），当他完成任务的子任务（即走了几步）时，孩子得到奖励（给巧克力吃），并且当他不能走路时，就不会给巧克力。</p>
<p><img src="10-1.png" alt></p>
<p>上图中agent代表自身，如果是自动驾驶，agent就是车；如果你玩游戏它就是你当前控制的游戏角色，如马里奥，马里奥往前走时环境就一直在发生变化，有小怪物或者障碍物出现，它需要通过跳跃来进行躲避，就是要做action（如向前走和跳起的动作）；无人驾驶的action就是车左转、右转或刹车等等，它无时无刻都在与环境产生交互，action会反馈给环境，进而改变环境，如果自动驾驶的车行驶目标是100米，它向前开了10米，那环境就发生了变化，所以每次产生action都会导致环境改变，环境的改变会反馈给自身（agent），就是这样的一个循环；反馈又两种方式：1、做的好（reward）即正反馈，2、做得不好（punishment惩罚）即负反馈。Agent可能做得好，也可能做的不好，环境始终都会给它反馈，agent会尽量去做对自身有利的决策，通过反反复复这样的一个循环，agent会越来越做的好，就像孩子在成长过程中会逐渐明辨是非，这就是强化学习。</p>
<h2 id="10-2-强化学习应用实例">10.2 强化学习应用实例</h2>
<p>（1）Manufacturing</p>
<p>例如一家日本公司 Fanuc，工厂机器人在拿起一个物体时，会捕捉这个过程的视频，记住它每次操作的行动，操作成功还是失败了，积累经验，下一次可以更快更准地采取行动。</p>
<p><img src="10-2.png" alt></p>
<p>（2）Inventory Management</p>
<p>在库存管理中，因为库存量大，库存需求波动较大，库存补货速度缓慢等阻碍使得管理是个比较难的问题，可以通过建立强化学习算法来减少库存周转时间，提高空间利用率。</p>
<p>（3）Dynamic pricing</p>
<p>强化学习中的 Q-learning 可以用来处理动态定价问题。</p>
<p>（4）Customer Delivery</p>
<p>制造商在向各个客户运输时，想要在满足客户的所有需求的同时降低车队总成本。通过 multi-agents 系统和 Q-learning，可以降低时间，减少车辆数量。</p>
<p>（5）ECommerce Personalization</p>
<p>在电商中，也可以用强化学习算法来学习和分析顾客行为，定制产品和服务以满足客户的个性化需求。</p>
<p>（6）Ad Serving</p>
<p>例如算法 LinUCB （属于强化学习算法 bandit 的一种算法），会尝试投放更广范围的广告，尽管过去还没有被浏览很多，能够更好地估计真实的点击率。<br>
再如双 11 推荐场景中，阿里巴巴使用了深度强化学习与自适应在线学习，通过持续机器学习和模型优化建立决策引擎，对海量用户行为以及百亿级商品特征进行实时分析，帮助每一个用户迅速发现宝贝，提高人和商品的配对效率。还有，利用强化学习将手机用户点击率提升了 10-20%。</p>
<p>（7）Financial Investment Decisions</p>
<p>例如这家公司 <a target="_blank" rel="noopener" href="http://Pit.ai">Pit.ai</a>，应用强化学习来评价交易策略，可以帮助用户建立交易策略，并帮助他们实现其投资目标。</p>
<p>（8）Medical Industry</p>
<p>动态治疗方案（DTR）是医学研究的一个主题，是为了给患者找到有效的治疗方法。 例如癌症这种需要长期施药的治疗，强化学习算法可以将患者的各种临床指标作为输入 来制定治疗策略。</p>
<h2 id="10-3-强化学习和监督式学习、非监督式学习的区别">10.3 强化学习和监督式学习、非监督式学习的区别</h2>
<p>在机器学习中，我们比较熟知的是监督式学习，非监督学习，此外还有一个大类就是强化学习：<br>
当前的机器学习算法可以分为3种：有监督的学习（Supervised Learning）、无监督的学习（Unsupervised Learning）和强化学习（Reinforcement Learning），结构图如下所示：</p>
<p><img src="10-3.png" alt></p>
<h3 id="10-3-1-强化学习和监督式学习的区别：">10.3.1 强化学习和监督式学习的区别：</h3>
<p>监督式学习就好比你在学习的时候，有一个导师在旁边指点，他知道怎么是对的怎么是错的，但在很多实际问题中，例如 chess，go，这种有成千上万种组合方式的情况，不可能有一个导师知道所有可能的结果。</p>
<p>而这时，强化学习会在没有任何标签的情况下，通过先尝试做出一些行为得到一个结果，通过这个结果是对还是错的反馈，调整之前的行为，就这样不断的调整，算法能够学习到在什么样的情况下选择什么样的行为可以得到最好的结果。</p>
<p>就好比你有一只还没有训练好的小狗，每当它把屋子弄乱后，就减少美味食物的数量（惩罚），每次表现不错时，就加倍美味食物的数量（奖励），那么小狗最终会学到一个知识，就是把客厅弄乱是不好的行为。</p>
<p>两种学习方式都会学习出输入到输出的一个映射，监督式学习出的是之间的关系，可以告诉算法什么样的输入对应着什么样的输出，强化学习出的是给机器的反馈 reward function，即用来判断这个行为是好是坏。<br>
另外强化学习的结果反馈有延时，有时候可能需要走了很多步以后才知道以前的某一步的选择是好还是坏，而监督学习做了比较坏的选择会立刻反馈给算法。</p>
<p>而且强化学习面对的输入总是在变化，每当算法做出一个行为，它影响下一次决策的输入，而监督学习的输入是独立同分布的。</p>
<p>通过强化学习，一个 agent 可以在探索和开发（exploration and exploitation）之间做权衡，并且选择一个最大的回报。</p>
<p>exploration 会尝试很多不同的事情，看它们是否比以前尝试过的更好。</p>
<p>exploitation 会尝试过去经验中最有效的行为。</p>
<p>一般的监督学习算法不考虑这种平衡，就只是是 exploitative。</p>
<h3 id="10-3-2-强化学习和非监督式学习的区别：">10.3.2 强化学习和非监督式学习的区别：</h3>
<p>非监督式不是学习输入到输出的映射，而是模式。例如在向用户推荐新闻文章的任务中，非监督式会找到用户先前已经阅读过类似的文章并向他们推荐其一，而强化学习将通过向用户先推荐少量的新闻，并不断获得来自用户的反馈，最后构建用户可能会喜欢的文章的“知识图”。</p>
<p>对非监督学习来说，它通过对没有概念标记的训练例进行学习，以发现训练例中隐藏的结构性知识。这里的训练例的概念标记是不知道的，因此训练样本的歧义性最高。对强化学习来说，它通过对没有概念标记、但与一个延迟奖赏或效用（可视为延迟的概念标记）相关联的训练例进行学习，以获得某种从状态到行动的映射。这里本来没有概念标记的概<br>
念，但延迟奖赏可被视为一种延迟概念标记，因此其训练样本的歧义性介于监督学习和非监督学习之间。</p>
<p>需要注意的是，监督学习和非监督学习从一开始就是相对的，而强化学习在提出时并没有从训练样本歧义性的角度考虑其与监督学习和非监督学习的区别，因此，一些早期的研究中把强化学习视为一种特殊的非监督学习。事实上，对强化学习的定位到目前仍然是有争议的，有的学者甚至认为它是与“从例子中学习”同一级别的概念。</p>
<p>从训练样本歧义性角度进行的分类体系，在近几年可望有一些扩展，例如多示例学习（multi-instancelearning）等从训练样本歧义性方面来看很特殊的新的学习框架有可能会进入该体系。但到目前为止，没有任何新的框架得到了公认的地位。另外，半监督学习（semi-supervisedlearning）也有一定希望，它的障碍是半监督学习中的歧义性并不是与生俱来的，而是人为的，即用户期望用未标记的样本来辅助对已标记样本的学习。这与监督学习、非监督学习、强化学习等天生的歧义性完全不同。半监督学习中人为的歧义性在解决工程问题上是需要的、有用的（对大量样本进行标记的代价可能是极为昂贵的），但可能不太会导致方法学或对学习问题视点的大的改变。</p>
<p><strong>强化学习和前二者的本质区别</strong>:没有前两者具有的明确数据概念，它不知道结果，只有目标。数据概念就是大量的数据，有监督学习、无监督学习需要大量数据去训练优化你建立的模型，就像猫狗识别，用n多张猫狗图片去训练模型，经过训练优化后，你用一张崭新的猫狗图片让模型作出判断，这个模型就知道是猫还是狗。</p>
<h2 id="10-4-强化学习主要有哪些算法？">10.4 强化学习主要有哪些算法？</h2>
<p>强化学习不需要监督信号,可以在模型未知的环境中平衡探索和利用, 其主要算法有蒙特卡罗强化学习, 时间差分(temporal difference: TD)学习, 策略梯度等。典型的深度强化学习算法特点及性能比较如下图所示：</p>
<p><img src="10-4.png" alt></p>
<p>除了上述深度强化学习算法，还有深度迁移强化学习、分层深度强化学习、深度记忆强化学习以及多智能体强化学习等算法。</p>
<h2 id="10-5-深度迁移强化学习算法">10.5 深度迁移强化学习算法</h2>
<p>传统深度强化学习算法每次只能解决一种游戏任务, 无法在一次训练中完成多种任务. 迁移学习和强化学习的结合也是深度强化学习的一种主要思路。</p>
<p>Parisotto等提出了一种基于行为模拟的深度迁移强化学习算法. 该算法通过监督信号的指导, 使得单一的策略网络学习各自的策略, 并将知识迁移到新任务中. Rusa等提出策略蒸馏(policy distillation)深度迁移强化学习算法. 策略蒸馏算法中分为学习网络和指导网络, 通过这两个网络Q值的偏差来确定目标函数,引导学习网络逼近指导网络的值函数空间. 此后,Rusa等又提出了一种基于渐进神经网络(progressive neural networks, PNN)的深度迁移强化学习算法.PNN是一种把神经网络和神经网络连起来的算法. 它在一系列序列任务中, 通过渐进的方式来存储知识和提取特征, 完成了对知识的迁移. PNN最终实现多个独立任务的训练, 通过迁移加速学习过程, 避免灾难性遗忘. Fernando 等提出了路径网络(PathNet)[45].PathNet可以说是PNN的进阶版. PathNet把网络中每一层都看作一个模块, 把构建一个网络看成搭积木,也就是复用积木. 它跟PNN非常类似, 只是这里不再有列, 而是不同的路径. PathNet将智能体嵌入到神经网络中, 其中智能体的任务是为新任务发现网络中可以复用的部分. 智能体是网络之中的路径, 其决定了反向传播过程中被使用和更新的参数范围. 在一系列的Atari强化学习任务上, PathNet都实现了正迁移, 这表明PathNet在训练神经网络上具有通用性应用能力.PathNet也可以显著提高A3C算法超参数选择的鲁棒性. Schaul等提出了一种通用值函数逼近器(universalvalue function approximators, UVFAs)来泛化状态和目标空间．UVFAs可以将学习到的知识迁移到环境动态特性相同但目标不同的新任务中.</p>
<h2 id="10-6-分层深度强化学习算法">10.6 分层深度强化学习算法</h2>
<p>分层强化学习可以将最终目标分解为多个子任务来学习层次化的策略, 并通过组合多个子任务的策略形成有效的全局策略. Kulkarni等提出了分层DQN(hierarchical deep Q-network, h–DQN) 算法. h–DQN基于时空抽象和内在激励分层, 通过在不同的时空尺度上设置子目标对值函数进行层次化处理. 顶层的值函数用于确定宏观决策, 底层的值函数用于确定具体行动．Krishnamurthy等在h–DQN的基础上提出了基于内部选择的分层深度强化学习算法. 该模型结合时空抽象和深度神经网络, 自动地完成子目标的学习, 避免了特定的内在激励和人工设定中间目标,加速了智能体的学习进程, 同时也增强了模型的泛化能力. Kulkarni等基于后续状态表示法提出了深度后续强化学习(deep successor reinforcement learning,DSRL)．DSRL通过阶段性地分解子目标和学习子目标策略, 增强了对未知状态空间的探索, 使得智能体更加适应那些存在延迟反馈的任务．Vezhnevets等受封建(feudal)强化学习算法的启发, 提出一种分层深度强化学习的架构FeUdal网络(FuNs)[49]. FuNs框架使用一个管理员模块和一个工人模块. 管理员模块在较低的时间分辨率下工作, 设置抽象目标并传递给工人模块去执行. FuNs框架创造了一个稳定的自然层次结构, 并且允许两个模块以互补的方式学习. 实验证明, FuNs有助于处理长期信用分配和记忆任务,在Atari视频游戏和迷宫游戏中都取得了不错的效果。</p>
<h2 id="10-7-深度记忆强化学习算法">10.7 深度记忆强化学习算法</h2>
<p>传统的深度强化学习模型不具备记忆、认知、推理等高层次的能力, 尤其是在面对状态部分可观察和延迟奖赏的情形时. Junhyuk等通过在传统的深度强化学习模型中加入外部的记忆网络部件和反馈控制机制, 提出反馈递归记忆Q网络(feedback recurrent memory Q-network, FRMQN)). FRMQN模型具备了一定的记忆与推理功能, 通过反馈控制机制,FRMQN整合过去存储的有价值的记忆和当前时刻的上下文状态, 评估动作值函数并做出决策. FRMQN初步模拟了人类的主动认知与推理能力, 并完成了一些高层次的认知任务. 在一些未经过训练的任务中,FRMQN模型表现出了很强的泛化能力．Blundell等设计出一种模型无关的情节控制算法(model-free episode control, MFEC). MFEC可以快速存储和回放状态转移序列, 并将回放的序列整合到结构化知识系统中, 使得智能体在面对一些复杂的决策任务时, 能快速达到人类玩家的水平．MFEC通过反向经验回放, 使智能体拥有初步的情节记忆. 实验表明, 基于MFEC算法的深度强化学习不仅可以在Atari游戏中学习到有效策略, 还可以处理一些三维场景的复杂任务. Pritzel等在MFEC的基础上进一步提出了神经情节控制(neural episodic control, NEC),有效提高了深度强化学习智能体的记忆能力和学习效率[53]. NEC能快速吸收新经验并依据新经验来采取行动. 价值函数包括价值函数渐变状态表示和价值函数快速更新估计两部分. 大量场景下的研究表明,NEC的学习速度明显快于目前最先进的通用深度强化学习智能体.</p>
<h2 id="10-8-多智能体深度强化学习算法">10.8 多智能体深度强化学习算法</h2>
<p>在一些复杂场景中, 涉及到多智能体的感知决策问题, 这时需要将单一模型扩展为多个智能体之间相互合作、通信及竞争的多智能体深度强化学习系统.Foerster等提出了一种称为分布式深度递归Q网络(deep distributed recurrent Q-networks, DDRQN) 的模型, 解决了状态部分可观测状态下的多智能体通信与合作的挑战性难题[54]. 实验表明, 经过训练的DDRQN模型最终在多智能体之间达成了一致的通信协1536 控制理论与应用第34 卷议, 成功解决了经典的红蓝帽子问题.让智能体学会合作与竞争一直以来都是人工智能领域内的一项重要研究课题, 也是实现通用人工智能的必要条件. Lowe等提出了一种用于合作–竞争混合环境的多智能体actor-critic 算法(multi-agent deepdeterministic policy gradient, MADDPG)[55]. MADDPG对DDPG强化学习算法进行了延伸, 可实现多智能体的集中式学习和分布式执行, 让智能体学习彼此合作和竞争. 在多项测试任务中, MADDPG的表现都优于DDPG.</p>
<h2 id="10-9-强化学习开源框架">10.9 强化学习开源框架</h2>
<p>谷歌TensorFlow Agents —TensorFlow的加强版,它提供许多工具，通过强化学习可以实现各类智能应用程序的构建与训练。这个框架能够将OpoenAI Gym接口扩展至多个并行环境，并允许各代理立足TensorFlow之内实现以执行批量计算。其面向OpoenAI Gy环境的批量化接口可与TensorFlow实现全面集成，从而高效执行各类算法。该框架还结合有BatchPPO，一套经过优化的近端策略优化算法实现方案。其核心组件包括一个环境打包器，用于在外部过程中构建OpenAI Gym环境; 一套批量集成，用于实现TensorFlow图步并以强化学习运算的方式重置函数; 外加用于将TensorFlow图形批处理流程与强化学习算法纳入训练特内单一却步的组件。</p>
<p>Roboschool：Roboschool 提供开源软件以通过强化学习构建并训练机器人模拟。其有助于在同一环境当中对多个代理进行强化学习训练。通过多方训练机制，您可以训练同一代理分别作为两方玩家（因此能够自我对抗）、使用相同算法训练两套代理，或者设置两种算法进行彼此对抗。Roboschool由OpenAI开发完成，这一非营利性组织的背后赞助者包括Elon Musk、Sam Altman、Reid Hoffman以及Peter Thiel。其与OpenAI Gym相集成，后者是一套用于开发及评估强化学习算法的开源工具集。OpenAI Gym与TensorFlow、Theano以及其它多种深度学习库相兼容。OpenAI Gym当中包含用于数值计算、游戏以及物理引擎的相关代码。Roboschool基于Bullet物理引擎，这是一套开源许可物理库，并被其它多种仿真软件——例如Gazebo与Virtual Robot Experimentation Platform（简称V-REP）所广泛使用。其中包含多种强化学习算法，具体以怨报德 异步深度强化学习方法、Actor-Critic with Experience Replay、Actor- Critic using Kronecker-Factored Trust Region、深度确定性策略梯度、近端策略优化以及信任域策略优化等等。</p>
<p>Coach：英特尔公司的开源强化学习框架，可以对游戏、机器人以及其它基于代理的智能应用进行智能代理的建模、训练与评估。Coach 提供一套模块化沙箱、可复用组件以及用于组合新强化学习算法并在多种应用领域内训练新智能应用的Python API。该框架利用OpenAI Gym作为主工具，负责与不同强化学习环境进行交换。其还支持其它外部扩展，具体包括Roboschool、gym-extensions、PyBullet以及ViZDoom。Coach的环境打包器允许用户向其中添加自定义强化学习环境，从而解决其它学习问题。该框架能够在桌面计算机上高效训练强化学习代理，并利用多核CPU处理相关任务。其能够为一部分强化学习算法提供单线程与多线程实现能力，包括异步优势Actor-Critic、深度确定性策略梯度、近端策略优化、直接未来预测以及规范化优势函数。所有算法皆利用面向英特尔系统作出优化的TensorFLow完成，其中部分算法亦适用于英特尔的Neon深度学习框架。Coach 当中包含多种强化学习代理实现方案，具体包括从单线程实现到多线程实现的转换。其能够开发出支持单与多工作程序（同步或异步）强化学习实现方法的新代理。此外，其还支持连续与离散操作空间，以及视觉观察空间或仅包含原始测量指标的观察空间。</p>
<h2 id="10-10-深度强化学习算法小结">10.10 深度强化学习算法小结</h2>
<p>基于值函数概念的DQN及其相应的扩展算法在离散状态、离散动作的控制任务中已经表现了卓越的性能, 但是受限于值函数离散型输出的影响, 在连续型控制任务上显得捉襟见肘. 基于策略梯度概念的,以DDPG, TRPO等为代表的策略型深度强化学习算法则更适用于处理基于连续状态空间的连续动作的控制输出任务, 并且算法在稳定性和可靠性上具有一定的理论保证, 理论完备性较强. 采用actor-critic架构的A3C算法及其扩展算法, 相比于传统DQN算法, 这类算法的数据利用效率更高, 学习速率更快, 通用性、可扩展应用性更强, 达到的表现性能更优, 但算法的稳定性无法得到保证. 而其他的如深度迁移强化学习、分层深度强化学习、深度记忆强化学习和多智能体深度强化学习等算法都是现在的研究热点, 通过这些算法能应对更为复杂的场景问题、系统环境及控制任务, 是目前深度强化学习算法研究的前沿领域.</p>
<p>展望未来，人工智能开发者们需要尽可能掌握上述框架以及其中所使用的各类强化学习算法。此外，还需要强化自身对于多代理强化学习架构的理解，因为其中多种框架都大量利用前沿博弈论研究成果。最后，还需要熟悉深度强化学习知识。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/19/deep_learning/ch1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tom">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="算法工程师的日常">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/19/deep_learning/ch1/" class="post-title-link" itemprop="url">数学基础面试题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-19 23:29:20" itemprop="dateCreated datePublished" datetime="2024-03-19T23:29:20+08:00">2024-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-24 10:13:33" itemprop="dateModified" datetime="2024-03-24T10:13:33+08:00">2024-03-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">算法面试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">深度学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>数学基础</h1>
<p>深度学习通常又需要哪些数学基础？深度学习里的数学到底难在哪里？通常初学者都会有这些问题，在网络推荐及书本推荐里，经常看到会列出一系列数学科目，比如微积分、线性代数、概率论、复变函数、数值计算、优化理论、信息论等等。这些数学知识有相关性，但实际上按照这样的知识范围来学习，学习成本会很久，而且会很枯燥，本章我们通过选举一些数学基础里容易混淆的一些概念做以介绍，帮助大家更好的理清这些易混淆概念之间的关系。</p>
<h2 id="1-1-向量和矩阵">1.1 向量和矩阵</h2>
<h3 id="1-1-1-标量、向量、矩阵、张量之间的联系">1.1.1 标量、向量、矩阵、张量之间的联系</h3>
<p><strong>标量（scalar）</strong><br>
一个标量表示一个单独的数，它不同于线性代数中研究的其他大部分对象（通常是多个数的数组）。我们用斜体表示标量。标量通常被赋予小写的变量名称。</p>
<p><strong>向量（vector）</strong><br>
​一个向量表示一组有序排列的数。通过次序中的索引，我们可以确定每个单独的数。通常我们赋予向量粗体的小写变量名称，比如xx。向量中的元素可以通过带脚标的斜体表示。向量 $X$ 的第一个元素是 $X_1$ ，第二个元素是 $X_2$ ，以此类推。我们也会注明存储在向量中的元素的类型（实数、虚数等）。</p>
<p><strong>矩阵（matrix）</strong><br>
​矩阵是具有相同特征和纬度的对象的集合，表现为一张二维数据表。其意义是一个对象表示为矩阵中的一行，一个特征表示为矩阵中的一列，每个特征都有数值型的取值。通常会赋予矩阵粗体的大写变量名称，比如 $A$ 。</p>
<p><strong>张量（tensor）</strong><br>
​在某些情况下，我们会讨论坐标超过两维的数组。一般地，一个数组中的元素分布在若干维坐标的规则网格中，我们将其称之为张量。使用  $A$  来表示张量“A”。张量 $A$ 中坐标为 $(i,j,k)$ 的元素记作 $A_{(i,j,k)}$ 。</p>
<p><strong>四者之间关系</strong></p>
<blockquote>
<p>标量是0阶张量，向量是一阶张量。举例：<br>
​标量就是知道棍子的长度，但是你不会知道棍子指向哪儿。<br>
​向量就是不但知道棍子的长度，还知道棍子指向前面还是后面。<br>
​张量就是不但知道棍子的长度，也知道棍子指向前面还是后面，还能知道这棍子又向上/下和左/右偏转了多少。</p>
</blockquote>
<h3 id="1-1-2-张量与矩阵的区别">1.1.2 张量与矩阵的区别</h3>
<ul>
<li>从代数角度讲， 矩阵它是向量的推广。向量可以看成一维的“表格”（即分量按照顺序排成一排）， 矩阵是二维的“表格”（分量按照纵横位置排列）， 那么 $n$ 阶张量就是所谓的 $n$ 维的“表格”。 张量的严格定义是利用线性映射来描述。</li>
<li>从几何角度讲， 矩阵是一个真正的几何量，也就是说，它是一个不随参照系的坐标变换而变化的东西。向量也具有这种特性。</li>
<li>张量可以用3×3矩阵形式来表达。</li>
<li>表示标量的数和表示向量的三维数组也可分别看作1×1，1×3的矩阵。</li>
</ul>
<h3 id="1-1-3-矩阵和向量相乘结果">1.1.3 矩阵和向量相乘结果</h3>
<p>若使用爱因斯坦求和约定（Einstein summation convention），矩阵 $A$ ,  $B$ 相乘得到矩阵 $C$ 可以用下式表示：</p>
 $$ a_{ik}*b_{kj}=c_{ij} \tag{1.3-1} $$  
<p>其中， $a_{ik}$ ,  $b_{kj}$ ,  $c_{ij}$ 分别表示矩阵 $A, B, C$ 的元素， $k$ 出现两次，是一个哑变量（Dummy Variables）表示对该参数进行遍历求和。<br>
而矩阵和向量相乘可以看成是矩阵相乘的一个特殊情况，例如：矩阵 $B$ 是一个 $n \times 1$ 的矩阵。</p>
<h3 id="1-1-4-向量和矩阵的范数归纳">1.1.4 向量和矩阵的范数归纳</h3>
<p><strong>向量的范数(norm)</strong><br>
​	定义一个向量为： $\vec{a}=[-5, 6, 8, -10]$ 。任意一组向量设为 $\vec{x}=(x_1,x_2,...,x_N)$ 。其不同范数求解如下：</p>
<ul>
<li>向量的1范数：向量的各个元素的绝对值之和，上述向量 $\vec{a}$ 的1范数结果就是：29。</li>
</ul>
 $$
\Vert\vec{x}\Vert_1=\sum_{i=1}^N\vert{x_i}\vert
$$ 
<ul>
<li>向量的2范数：向量的每个元素的平方和再开平方根，上述 $\vec{a}$ 的2范数结果就是：15。</li>
</ul>
 $$
\Vert\vec{x}\Vert_2=\sqrt{\sum_{i=1}^N{\vert{x_i}\vert}^2}
$$ 
<ul>
<li>向量的负无穷范数：向量的所有元素的绝对值中最小的：上述向量 $\vec{a}$ 的负无穷范数结果就是：5。</li>
</ul>
 $$
\Vert\vec{x}\Vert_{-\infty}=\min{|{x_i}|}
$$ 
<ul>
<li>向量的正无穷范数：向量的所有元素的绝对值中最大的：上述向量 $\vec{a}$ 的正无穷范数结果就是：10。</li>
</ul>
 $$
\Vert\vec{x}\Vert_{+\infty}=\max{|{x_i}|}
$$ 
<ul>
<li>向量的p范数：</li>
</ul>
 $$
L_p=\Vert\vec{x}\Vert_p=\sqrt[p]{\sum_{i=1}^{N}|{x_i}|^p}
$$ 
<p><strong>矩阵的范数</strong></p>
<p>定义一个矩阵 $A=[-1, 2, -3; 4, -6, 6]$ 。 任意矩阵定义为： $A_{m\times n}$ ，其元素为  $a_{ij}$ 。</p>
<p>矩阵的范数定义为</p>
 $$
\Vert{A}\Vert_p :=\sup_{x\neq 0}\frac{\Vert{Ax}\Vert_p}{\Vert{x}\Vert_p}
$$ 
<p>当向量取不同范数时, 相应得到了不同的矩阵范数。</p>
<ul>
<li>
<p><strong>矩阵的1范数（列范数）</strong>：矩阵的每一列上的元</p>
<p>素绝对值先求和，再从中取个最大的,（列和最大），上述矩阵 $A$ 的1范数先得到 $[5,8,9]$ ，再取最大的最终结果就是：9。</p>
</li>
</ul>
 $$
\Vert A\Vert_1=\max_{1\le j\le n}\sum_{i=1}^m|{a_{ij}}|
$$ 
<ul>
<li><strong>矩阵的2范数</strong>：矩阵 $A^TA$ 的最大特征值开平方根，上述矩阵 $A$ 的2范数得到的最终结果是：10.0623。</li>
</ul>
 $$
\Vert A\Vert_2=\sqrt{\lambda_{max}(A^T A)}
$$ 
<p>其中，  $\lambda_{max}(A^T A)$  为  $A^T A​$  的特征值绝对值的最大值。</p>
<ul>
<li><strong>矩阵的无穷范数（行范数）</strong>：矩阵的每一行上的元素绝对值先求和，再从中取个最大的，（行和最大），上述矩阵 $A$ 的行范数先得到 $[6；16]$ ，再取最大的最终结果就是：16。</li>
</ul>
 $$
\Vert A\Vert_{\infty}=\max_{1\le i \le m}\sum_{j=1}^n |{a_{ij}}|
$$ 
<ul>
<li>
<p><strong>矩阵的核范数</strong>：矩阵的奇异值（将矩阵svd分解）之和，这个范数可以用来低秩表示（因为最小化核范数，相当于最小化矩阵的秩——低秩），上述矩阵A最终结果就是：10.9287。</p>
</li>
<li>
<p><strong>矩阵的L0范数</strong>：矩阵的非0元素的个数，通常用它来表示稀疏，L0范数越小0元素越多，也就越稀疏，上述矩阵 $A$ 最终结果就是：6。</p>
</li>
<li>
<p><strong>矩阵的L1范数</strong>：矩阵中的每个元素绝对值之和，它是L0范数的最优凸近似，因此它也可以表示稀疏，上述矩阵 $A$ 最终结果就是：22。</p>
</li>
<li>
<p><strong>矩阵的F范数</strong>：矩阵的各个元素平方之和再开平方根，它通常也叫做矩阵的L2范数，它的优点在于它是一个凸函数，可以求导求解，易于计算，上述矩阵A最终结果就是：10.0995。</p>
</li>
</ul>
 $$
\Vert A\Vert_F=\sqrt{(\sum_{i=1}^m\sum_{j=1}^n{| a_{ij}|}^2)}
$$ 
<ul>
<li><strong>矩阵的L21范数</strong>：矩阵先以每一列为单位，求每一列的F范数（也可认为是向量的2范数），然后再将得到的结果求L1范数（也可认为是向量的1范数），很容易看出它是介于L1和L2之间的一种范数，上述矩阵 $A$ 最终结果就是：17.1559。</li>
<li><strong>矩阵的 p范数</strong></li>
</ul>
 $$
\Vert A\Vert_p=\sqrt[p]{(\sum_{i=1}^m\sum_{j=1}^n{| a_{ij}|}^p)}
$$ 
<h3 id="1-1-5-如何判断一个矩阵为正定">1.1.5 如何判断一个矩阵为正定</h3>
<p>判定一个矩阵是否为正定，通常有以下几个方面：</p>
<ul>
<li>顺序主子式全大于0；</li>
<li>存在可逆矩阵 $C$ 使 $C^TC$ 等于该矩阵；</li>
<li>正惯性指数等于 $n$ ；</li>
<li>合同于单位矩阵 $E$ （即：规范形为 $E$ ）</li>
<li>标准形中主对角元素全为正；</li>
<li>特征值全为正；</li>
<li>是某基的度量矩阵。</li>
</ul>
<h2 id="1-2-导数和偏导数">1.2 导数和偏导数</h2>
<h3 id="1-2-1-导数偏导计算">1.2.1 导数偏导计算</h3>
<p><strong>导数定义</strong>:</p>
<p>导数(derivative)代表了在自变量变化趋于无穷小的时候，函数值的变化与自变量的变化的比值。几何意义是这个点的切线。物理意义是该时刻的（瞬时）变化率。<br>
​</p>
<p><em>注意</em>：在一元函数中，只有一个自变量变动，也就是说只存在一个方向的变化率，这也就是为什么一元函数没有偏导数的原因。在物理学中有平均速度和瞬时速度之说。平均速度有</p>
 $$
v=\frac{s}{t}
$$ 
<p>其中 $v$ 表示平均速度， $s$ 表示路程， $t$ 表示时间。这个公式可以改写为</p>
 $$
\bar{v}=\frac{\Delta s}{\Delta t}=\frac{s(t_0+\Delta t)-s(t_0)}{\Delta t}
$$ 
<p>其中 $\Delta s$ 表示两点之间的距离，而 $\Delta t$ 表示走过这段距离需要花费的时间。当 $\Delta t$ 趋向于0（ $\Delta t \to 0$ ）时，也就是时间变得很短时，平均速度也就变成了在 $t_0$ 时刻的瞬时速度，表示成如下形式：</p>
 $$
v(t_0)=\lim_{\Delta t \to 0}{\bar{v}}=\lim_{\Delta t \to 0}{\frac{\Delta s}{\Delta t}}=\lim_{\Delta t \to 0}{\frac{s(t_0+\Delta t)-s(t_0)}{\Delta t}}
$$ 
<p>实际上，上式表示的是路程 $s$ 关于时间 $t$ 的函数在 $t=t_0$ 处的导数。一般的，这样定义导数：如果平均变化率的极限存在，即有</p>
 $$
\lim_{\Delta x \to 0}{\frac{\Delta y}{\Delta x}}=\lim_{\Delta x \to 0}{\frac{f(x_0+\Delta x)-f(x_0)}{\Delta x}}
$$ 
<p>则称此极限为函数  $y=f(x)$  在点  $x_0$  处的导数。记作  $f'(x_0)$  或  $y'\vert_{x=x_0}$  或  $\frac{dy}{dx}\vert_{x=x_0}$  或  $\frac{df(x)}{dx}\vert_{x=x_0}$ 。</p>
<p>通俗地说，导数就是曲线在某一点切线的斜率。</p>
<p><strong>偏导数</strong>:</p>
<p>既然谈到偏导数(partial derivative)，那就至少涉及到两个自变量。以两个自变量为例， $z=f(x,y)​$ ，从导数到偏导数，也就是从曲线来到了曲面。曲线上的一点，其切线只有一条。但是曲面上的一点，切线有无数条。而偏导数就是指多元函数沿着坐标轴的变化率。</p>
<p><em>注意</em>：直观地说，偏导数也就是函数在某一点上沿坐标轴正方向的的变化率。</p>
<p>设函数 $z=f(x,y)​$ 在点 $(x_0,y_0)​$ 的领域内有定义，当 $y=y_0​$ 时， $z​$ 可以看作关于 $x​$ 的一元函数 $f(x,y_0)​$ ，若该一元函数在 $x=x_0​$ 处可导，即有</p>
 $$
\lim_{\Delta x \to 0}{\frac{f(x_0+\Delta x,y_0)-f(x_0,y_0)}{\Delta x}}=A
$$ 
<p>函数的极限 $A$ 存在。那么称 $A$ 为函数 $z=f(x,y)$ 在点 $(x_0,y_0)$ 处关于自变量 $x$ 的偏导数，记作 $f_x(x_0,y_0)$ 或 $\frac{\partial z}{\partial x}\vert_{y=y_0}^{x=x_0}$ 或 $\frac{\partial f}{\partial x}\vert_{y=y_0}^{x=x_0}$ 或 $z_x\vert_{y=y_0}^{x=x_0}$ 。</p>
<p>偏导数在求解时可以将另外一个变量看做常数，利用普通的求导方式求解，比如 $z=3x^2+xy$ 关于 $x$ 的偏导数就为 $z_x=6x+y$ ，这个时候 $y$ 相当于 $x$ 的系数。</p>
<p>某点 $(x_0,y_0)$ 处的偏导数的几何意义为曲面 $z=f(x,y)$ 与面 $x=x_0$ 或面 $y=y_0$ 交线在 $y=y_0$ 或 $x=x_0$ 处切线的斜率。</p>
<h3 id="1-2-2-导数和偏导数有什么区别？">1.2.2 导数和偏导数有什么区别？</h3>
<p>导数和偏导没有本质区别，如果极限存在，都是当自变量的变化量趋于0时，函数值的变化量与自变量变化量比值的极限。</p>
<blockquote>
<ul>
<li>一元函数，一个 $y$ 对应一个 $x$ ，导数只有一个。</li>
<li>二元函数，一个 $z$ 对应一个 $x$ 和一个 $y$ ，有两个导数：一个是 $z$ 对 $x$ 的导数，一个是 $z$ 对 $y$ 的导数，称之为偏导。</li>
<li>求偏导时要注意，对一个变量求导，则视另一个变量为常数，只对改变量求导，从而将偏导的求解转化成了一元函数的求导。</li>
</ul>
</blockquote>
<h2 id="1-3-特征值和特征向量">1.3 特征值和特征向量</h2>
<h3 id="1-3-1-特征值分解与特征向量">1.3.1 特征值分解与特征向量</h3>
<ul>
<li>
<p>特征值分解可以得到特征值(eigenvalues)与特征向量(eigenvectors)；</p>
</li>
<li>
<p>特征值表示的是这个特征到底有多重要，而特征向量表示这个特征是什么。</p>
<p>如果说一个向量 $\vec{v}$ 是方阵 $A$ 的特征向量，将一定可以表示成下面的形式：</p>
</li>
</ul>
 $$
A\nu = \lambda \nu
$$ 
 $\lambda$ 为特征向量 $\vec{v}$ 对应的特征值。特征值分解是将一个矩阵分解为如下形式： 
 $$
A=Q\sum Q^{-1}
$$ 
<p>其中， $Q$ 是这个矩阵 $A$ 的特征向量组成的矩阵， $\sum$ 是一个对角矩阵，每一个对角线元素就是一个特征值，里面的特征值是由大到小排列的，这些特征值所对应的特征向量就是描述这个矩阵变化方向（从主要的变化到次要的变化排列）。也就是说矩阵 $A$ 的信息可以由其特征值和特征向量表示。</p>
<h3 id="1-3-2-奇异值与特征值有什么关系">1.3.2 奇异值与特征值有什么关系</h3>
<p>那么奇异值和特征值是怎么对应起来的呢？我们将一个矩阵 $A$ 的转置乘以 $A$ ，并对 $A^TA​$ 求特征值，则有下面的形式：</p>
 $$
(A^TA)V = \lambda V
$$ 
<p>这里 $V​$ 就是上面的右奇异向量，另外还有：</p>
 $$
\sigma_i = \sqrt{\lambda_i}, u_i=\frac{1}{\sigma_i}AV
$$ 
<p>这里的 $\sigma​$ 就是奇异值， $u​$ 就是上面说的左奇异向量。【证明那个哥们也没给】<br>
​奇异值 $\sigma​$ 跟特征值类似，在矩阵 $\sum​$ 中也是从大到小排列，而且 $\sigma​$ 的减少特别的快，在很多情况下，前10%甚至1%的奇异值的和就占了全部的奇异值之和的99%以上了。也就是说，我们也可以用前 $r​$ （ $r​$ 远小于 $m、n​$ ）个的奇异值来近似描述矩阵，即部分奇异值分解：</p>
 $$
A_{m\times n}\approx U_{m \times r}\sum_{r\times r}V_{r \times n}^T
$$ 
<p>右边的三个矩阵相乘的结果将会是一个接近于 $A$ 的矩阵，在这儿， $r$ 越接近于 $n$ ，则相乘的结果越接近于 $A$ 。</p>
<h2 id="1-4-概率分布与随机变量">1.4 概率分布与随机变量</h2>
<h3 id="1-4-1-机器学习为什么要使用概率">1.4.1 机器学习为什么要使用概率</h3>
<p>事件的概率是衡量该事件发生的可能性的量度。虽然在一次随机试验中某个事件的发生是带有偶然性的，但那些可在相同条件下大量重复的随机试验却往往呈现出明显的数量规律。<br>
​机器学习除了处理不确定量，也需处理随机量。不确定性和随机性可能来自多个方面，使用概率论来量化不确定性。<br>
​概率论在机器学习中扮演着一个核心角色，因为机器学习算法的设计通常依赖于对数据的概率假设。</p>
<blockquote>
<p>​	例如在机器学习（Andrew Ng）的课中，会有一个朴素贝叶斯假设就是条件独立的一个例子。该学习算法对内容做出假设，用来分辨电子邮件是否为垃圾邮件。假设无论邮件是否为垃圾邮件，单词x出现在邮件中的概率条件独立于单词y。很明显这个假设不是不失一般性的，因为某些单词几乎总是同时出现。然而，最终结果是，这个简单的假设对结果的影响并不大，且无论如何都可以让我们快速判别垃圾邮件。</p>
</blockquote>
<h3 id="1-4-2-变量与随机变量有什么区别">1.4.2 变量与随机变量有什么区别</h3>
<p><strong>随机变量</strong>（random variable）</p>
<p>表示随机现象（在一定条件下，并不总是出现相同结果的现象称为随机现象）中各种结果的实值函数（一切可能的样本点）。例如某一时间内公共汽车站等车乘客人数，电话交换台在一定时间内收到的呼叫次数等，都是随机变量的实例。<br>
​随机变量与模糊变量的不确定性的本质差别在于，后者的测定结果仍具有不确定性，即模糊性。</p>
<p><strong>变量与随机变量的区别：</strong><br>
​当变量的取值的概率不是1时,变量就变成了随机变量；当随机变量取值的概率为1时,随机变量就变成了变量。</p>
<blockquote>
<p>比如：<br>
​	当变量 $x$ 值为100的概率为1的话,那么 $x=100$ 就是确定了的,不会再有变化,除非有进一步运算.<br>
​	当变量 $x$ 的值为100的概率不为1,比如为50的概率是0.5,为100的概率是0.5,那么这个变量就是会随不同条件而变化的,是随机变量,取到50或者100的概率都是0.5,即50%。</p>
</blockquote>
<h3 id="1-4-3-随机变量与概率分布的联系">1.4.3 随机变量与概率分布的联系</h3>
<p>一个随机变量仅仅表示一个可能取得的状态，还必须给定与之相伴的概率分布来制定每个状态的可能性。用来描述随机变量或一簇随机变量的每一个可能的状态的可能性大小的方法，就是 <strong>概率分布(probability distribution)</strong>.</p>
<p>随机变量可以分为离散型随机变量和连续型随机变量。</p>
<p>相应的描述其概率分布的函数是</p>
<p>概率质量函数(Probability Mass Function, PMF):描述离散型随机变量的概率分布，通常用大写字母  $P$ 表示。</p>
<p>概率密度函数(Probability Density Function, PDF):描述连续型随机变量的概率分布，通常用小写字母 $p$ 表示。</p>
<h3 id="1-4-4-离散型随机变量和概率质量函数">1.4.4 离散型随机变量和概率质量函数</h3>
<p>PMF 将随机变量能够取得的每个状态映射到随机变量取得该状态的概率。</p>
<ul>
<li>一般而言， $P(x)​$  表示时 $X=x​$ 的概率.</li>
<li>有时候为了防止混淆，要明确写出随机变量的名称 $P(​$ x $=x)​$</li>
<li>有时候需要先定义一个随机变量，然后制定它遵循的概率分布x服从 $P(​$ x​ $)​$</li>
</ul>
<p>PMF 可以同时作用于多个随机变量，即联合概率分布(joint probability distribution)  $P(X=x,Y=y)$ *表示  $X=x$ 和 $Y=y$ 同时发生的概率，也可以简写成  $P(x,y)$ .</p>
<p>如果一个函数 $P​$ 是随机变量  $X​$  的 PMF， 那么它必须满足如下三个条件</p>
<ul>
<li>
$P​$ 的定义域必须是的所有可能状态的集合
</li>
<li>
$∀x∈​$ x,  $0 \leq P(x) \leq 1 ​$ . 
</li>
<li>
$∑_{x∈X} P(x)=1$ . 我们把这一条性质称之为 归一化的(normalized)
</li>
</ul>
<h3 id="1-4-5-连续型随机变量和概率密度函数">1.4.5 连续型随机变量和概率密度函数</h3>
<p>如果一个函数 $p​$ 是x的PDF，那么它必须满足如下几个条件</p>
<ul>
<li>
$p$ 的定义域必须是x的所有可能状态的集合。
</li>
<li>
$∀x∈X,p(x)≥0$ . 注意，我们并不要求 $ p(x)≤1$ ，因为此处  $p(x)$ 不是表示的对应此状态具体的概率，而是概率的一个相对大小(密度)。具体的概率，需要积分去求。
</li>
<li>
$∫p(x)dx=1$ , 积分下来，总和还是1，概率之和还是1.
</li>
</ul>
<p>注：PDF $p(x)$ 并没有直接对特定的状态给出概率，给出的是密度，相对的，它给出了落在面积为  $δx$ 的无线小的区域内的概率为 $ p(x)δx$ . 由此，我们无法求得具体某个状态的概率，我们可以求得的是 某个状态  $x$  落在 某个区间 $[a,b]$ 内的概率为 $ \int_{a}^{b}p(x)dx$ .</p>
<h3 id="1-4-6-举例理解条件概率">1.4.6 举例理解条件概率</h3>
<p>条件概率公式如下：</p>
 $$
P(A|B) = P(A\cap B) / P(B)
$$ 
<p>说明：在同一个样本空间 $\Omega$ 中的事件或者子集 $A$ 与 $B$ ，如果随机从 $\Omega$ 中选出的一个元素属于 $B$ ，那么下一个随机选择的元素属于 $A$  的概率就定义为在 $B$ 的前提下 $A$ 的条件概率。条件概率文氏图示意如图1.1所示。<br>
<img src="conditional_probability.jpg" alt="条件概率"></p>
<p>图1.1 条件概率文氏图示意</p>
<p>根据文氏图，可以很清楚地看到在事件B发生的情况下，事件A发生的概率就是 $P(A\bigcap B)$ 除以 $P(B)$ 。<br>
​举例：一对夫妻有两个小孩，已知其中一个是女孩，则另一个是女孩子的概率是多少？（面试、笔试都碰到过）<br>
​<strong>穷举法</strong>：已知其中一个是女孩，那么样本空间为男女，女女，女男，则另外一个仍然是女生的概率就是1/3。<br>
​<strong>条件概率法</strong>： $P(女|女)=P(女女)/P(女)$ ,夫妻有两个小孩，那么它的样本空间为女女，男女，女男，男男，则 $P(女女)$ 为1/4， $P（女）= 1-P(男男)=3/4$ ,所以最后 $1/3$ 。<br>
这里大家可能会误解，男女和女男是同一种情况，但实际上类似姐弟和兄妹是不同情况。</p>
<h3 id="1-4-7-联合概率与边缘概率联系区别">1.4.7 联合概率与边缘概率联系区别</h3>
<p><strong>区别：</strong><br>
​联合概率：联合概率指类似于 $P(X=a,Y=b)$ 这样，包含多个条件，且所有条件同时成立的概率。联合概率是指在多元的概率分布中多个随机变量分别满足各自条件的概率。<br>
​边缘概率：边缘概率是某个事件发生的概率，而与其它事件无关。边缘概率指类似于 $P(X=a)$ ， $P(Y=b)$ 这样，仅与单个随机变量有关的概率。</p>
<p><strong>联系：</strong><br>
​联合分布可求边缘分布，但若只知道边缘分布，无法求得联合分布。</p>
<h3 id="1-4-8-条件概率的链式法则">1.4.8 条件概率的链式法则</h3>
<p>由条件概率的定义，可直接得出下面的乘法公式：<br>
​乘法公式 设 $A, B$ 是两个事件，并且 $P(A) > 0$ , 则有</p>
 $$
P(AB) = P(B|A)P(A)
$$ 
<p>推广</p>
 $$
P(ABC)=P(C|AB)P(B|A)P(A)
$$ 
<p>一般地，用归纳法可证：若 $P(A_1A_2...A_n)>0$ ，则有</p>
 $$
P(A_1A_2...A_n)=P(A_n|A_1A_2...A_{n-1})P(A_{n-1}|A_1A_2...A_{n-2})...P(A_2|A_1)P(A_1)
=P(A_1)\prod_{i=2}^{n}P(A_i|A_1A_2...A_{i-1})
$$ 
<p>任何多维随机变量联合概率分布，都可以分解成只有一个变量的条件概率相乘形式。</p>
<h3 id="1-4-9-独立性和条件独立性">1.4.9 独立性和条件独立性</h3>
<p><strong>独立性</strong><br>
​两个随机变量 $x$ 和 $y$ ，概率分布表示成两个因子乘积形式，一个因子只包含 $x$ ，另一个因子只包含 $y$ ，两个随机变量相互独立(independent)。<br>
​条件有时为不独立的事件之间带来独立，有时也会把本来独立的事件，因为此条件的存在，而失去独立性。<br>
​举例： $P(XY)=P(X)P(Y)$ , 事件 $X$ 和事件 $Y$ 独立。此时给定 $Z$ ，</p>
 $$
P(X,Y|Z) \not = P(X|Z)P(Y|Z)
$$ 
<p>事件独立时，联合概率等于概率的乘积。这是一个非常好的数学性质，然而不幸的是，无条件的独立是十分稀少的，因为大部分情况下，事件之间都是互相影响的。</p>
<p><strong>条件独立性</strong><br>
​给定 $Z$ 的情况下, $X$ 和 $Y$ 条件独立，当且仅当</p>
 $$
X\bot Y|Z \iff P(X,Y|Z) = P(X|Z)P(Y|Z)
$$ 
 $X$ 和 $Y$ 的关系依赖于 $Z$ ，而不是直接产生。  
<blockquote>
<p><strong>举例</strong>定义如下事件：</p>
 $X$ ：明天下雨；  
 $Y$ ：今天的地面是湿的；  
 $Z$ ：今天是否下雨；  
 $Z$ 事件的成立，对 $X$ 和 $Y$ 均有影响，然而，在 $Z$ 事件成立的前提下，今天的地面情况对明天是否下雨没有影响。 
</blockquote>
<h2 id="1-5-常见概率分布">1.5 常见概率分布</h2>
<h3 id="1-5-1-Bernoulli分布">1.5.1 Bernoulli分布</h3>
<p><strong>Bernoulli分布</strong>(伯努利分布，0-1分布)是单个二值随机变量分布, 单参数 $\phi$ ∈[0,1]控制, $\phi$ 给出随机变量等于1的概率. 主要性质有:</p>
 $$
\begin{align*}
P(x=1) &= \phi \\
P(x=0) &= 1-\phi  \\
概率质量函数：P(x=x) &= \phi^x(1-\phi)^{1-x} \\
\end{align*}
$$ 
<p>其期望和方差为：</p>
 $$
\begin{align*}
E_x[x] &= \phi \\
Var_x(x) &= \phi{(1-\phi)}
\end{align*}
$$ 
<p><strong>适用范围</strong>: <strong>伯努利分布</strong>适合对<strong>离散型</strong>随机变量建模.</p>
<p><strong>Multinoulli分布</strong>也叫<strong>范畴分布</strong>, 是单个<em>k</em>值随机分布,经常用来表示<strong>对象分类的分布</strong>. 其中 $k$ 是有限值.Multinoulli分布由向量 $\vec{p}\in[0,1]^{k-1}$ 参数化,每个分量 $p_i$ 表示第 $i$ 个状态的概率, 且 $p_k=1-1^Tp$ .这里 $1^T$ 表示元素全为1的列向量的转置，其实就是对于向量p中除了k的概率之和。可以重写为 $p_k=1-\sum_{0}^{k-1}p_i$  。</p>
<p>补充二项分布、多项分布：</p>
<p>二项分布，通俗点硬币抛多次。二项分布(Binomial distribution)是<strong>n重伯努利试验</strong>成功次数的离散概率分布。</p>
<p>多项式分布(Multinomial Distribution)是二项式分布的推广。二项式做n次伯努利实验，规定了每次试验的结果只有两个，如果现在还是做n次试验，只不过每次试验的结果可以有多m个，且m个结果发生的概率互斥且和为1，则发生其中一个结果X次的概率就是多项式分布。</p>
<h3 id="1-5-2-高斯分布">1.5.2 高斯分布</h3>
<p>高斯也叫正态分布(Normal Distribution), 概率度函数如下:</p>
 $$
N(x;\mu,\sigma^2) = \sqrt{\frac{1}{2\pi\sigma^2}}exp\left ( -\frac{1}{2\sigma^2}(x-\mu)^2 \right )
$$ 
<p>其中,  $\mu​$ 和 $\sigma​$ 分别是均值和标准差, 中心峰值x坐标由 $\mu​$ 给出, 峰的宽度受 $\sigma​$ 控制, 最大点在 $x=\mu​$ 处取得, 拐点为 $x=\mu\pm\sigma​$</p>
<p>正态分布中，±1 $\sigma$ 、±2 $\sigma$ 、±3 $\sigma$ 下的概率分别是68.3%、95.5%、99.73%，这3个数最好记住。</p>
<p>此外, 令 $\mu=0,\sigma=1​$ 高斯分布即简化为标准正态分布:</p>
 $$
N(x;\mu,\sigma^2) = \sqrt{\frac{1}{2\pi}}exp\left ( -\frac{1}{2}x^2 \right )
$$ 
<p>对概率密度函数高效求值:</p>
 $$
N(x;\mu,\beta^{-1})=\sqrt{\frac{\beta}{2\pi}}exp\left(-\frac{1}{2}\beta(x-\mu)^2\right)
$$ 
<p>其中， $\beta=\frac{1}{\sigma^2}$ 通过参数 $\beta∈（0，\infty）​$ 来控制分布精度。</p>
<h3 id="1-5-3-何时采用正态分布">1.5.3 何时采用正态分布</h3>
<p>问: 何时采用正态分布?<br>
答: 缺乏实数上分布的先验知识, 不知选择何种形式时, 默认选择正态分布总是不会错的, 理由如下:</p>
<ol>
<li>中心极限定理告诉我们, 很多独立随机变量均近似服从正态分布, 现实中很多复杂系统都可以被建模成正态分布的噪声, 即使该系统可以被结构化分解.</li>
<li>正态分布是具有相同方差的所有概率分布中, 不确定性最大的分布, 换句话说, 正态分布是对模型加入先验知识最少的分布.</li>
</ol>
<p>正态分布的推广:<br>
正态分布可以推广到 $R^n$ 空间, 此时称为<strong>多位正态分布</strong>, 其参数是一个正定对称矩阵 $\Sigma​$ :</p>
 $$
N(x;\vec\mu,\Sigma)=\sqrt{\frac{1}{(2\pi)^ndet(\Sigma)}}exp\left(-\frac{1}{2}(\vec{x}-\vec{\mu})^T\Sigma^{-1}(\vec{x}-\vec{\mu})\right)
$$ 
<p>对多为正态分布概率密度高效求值:</p>
 $$
N(x;\vec{\mu},\vec\beta^{-1}) = \sqrt{det(\vec\beta)}{(2\pi)^n}exp\left(-\frac{1}{2}(\vec{x}-\vec\mu)^T\beta(\vec{x}-\vec\mu)\right)
$$ 
<p>此处， $\vec\beta$ 是一个精度矩阵。</p>
<h3 id="1-5-4-指数分布">1.5.4 指数分布</h3>
<p>深度学习中, 指数分布用来描述在 $x=0​$ 点处取得边界点的分布, 指数分布定义如下:</p>
 $$
p(x;\lambda)=\lambda I_{x\geq 0}exp(-\lambda{x})
$$ 
<p>指数分布用指示函数 $I_{x\geq 0}​$ 来使 $x​$ 取负值时的概率为零。</p>
<h3 id="1-5-5-Laplace-分布（拉普拉斯分布）">1.5.5 Laplace 分布（拉普拉斯分布）</h3>
<p>一个联系紧密的概率分布是 Laplace 分布（Laplace distribution），它允许我们在任意一点  $\mu$ 处设置概率质量的峰值</p>
 $$
Laplace(x;\mu;\gamma)=\frac{1}{2\gamma}exp\left(-\frac{|x-\mu|}{\gamma}\right)
$$ 
<h3 id="1-5-6-Dirac分布和经验分布">1.5.6 Dirac分布和经验分布</h3>
<p>Dirac分布可保证概率分布中所有质量都集中在一个点上. Diract分布的狄拉克 $\delta​$ 函数(也称为<strong>单位脉冲函数</strong>)定义如下:</p>
 $$
p(x)=\delta(x-\mu), x\neq \mu
$$ 
 $$
\int_{a}^{b}\delta(x-\mu)dx = 1, a < \mu < b
$$ 
<p>Dirac 分布经常作为 经验分布（empirical distribution）的一个组成部分出现</p>
 $$
\hat{p}(\vec{x})=\frac{1}{m}\sum_{i=1}^{m}\delta(\vec{x}-{\vec{x}}^{(i)})
$$ 
<p>, 其中, m个点 $x^{1},...,x^{m}$ 是给定的数据集, <strong>经验分布</strong>将概率密度 $\frac{1}{m}​$ 赋给了这些点.</p>
<p>当我们在训练集上训练模型时, 可以认为从这个训练集上得到的经验分布指明了<strong>采样来源</strong>.</p>
<p><strong>适用范围</strong>: 狄拉克δ函数适合对<strong>连续型</strong>随机变量的经验分布.</p>
<blockquote></blockquote>
<h2 id="1-6-期望、方差、协方差、相关系数">1.6 期望、方差、协方差、相关系数</h2>
<h3 id="1-6-1-期望">1.6.1 期望</h3>
<p>在概率论和统计学中，数学期望（或均值，亦简称期望）是试验中每次可能结果的概率乘以其结果的总和。它反映随机变量平均取值的大小。</p>
<ul>
<li>线性运算：  $E(ax+by+c) = aE(x)+bE(y)+c$</li>
<li>推广形式：  $E(\sum_{k=1}^{n}{a_ix_i+c}) = \sum_{k=1}^{n}{a_iE(x_i)+c}$</li>
<li>函数期望：设 $f(x)$ 为 $x$ 的函数，则 $f(x)$ 的期望为
<ul>
<li>离散函数：  $E(f(x))=\sum_{k=1}^{n}{f(x_k)P(x_k)}$</li>
<li>连续函数：  $E(f(x))=\int_{-\infty}^{+\infty}{f(x)p(x)dx}$</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：</p>
<ul>
<li>函数的期望大于等于期望的函数（Jensen（詹森）不等式，即 $E(f(x))\geqslant f(E(x))$</li>
<li>一般情况下，乘积的期望不等于期望的乘积。</li>
<li>如果 $X$ 和 $Y$ 相互独立，则 $E(xy)=E(x)E(y)​$ 。</li>
</ul>
</blockquote>
<h3 id="1-6-2-方差">1.6.2 方差</h3>
<p>概率论中方差用来度量随机变量和其数学期望（即均值）之间的偏离程度。方差是一种特殊的期望。定义为：</p>
 $$
Var(x) = E((x-E(x))^2)
$$ 
<blockquote>
<p>方差性质：</p>
<p>1） $Var(x) = E(x^2) -E(x)^2$<br>
2）常数的方差为0;<br>
3）方差不满足线性性质;<br>
4）如果 $X$ 和 $Y$ 相互独立,  $Var(ax+by)=a^2Var(x)+b^2Var(y)$</p>
</blockquote>
<h3 id="1-6-3-协方差">1.6.3 协方差</h3>
<p>协方差是衡量两个变量线性相关性强度及变量尺度。  两个随机变量的协方差定义为：</p>
 $$
Cov(x,y)=E((x-E(x))(y-E(y)))
$$ 
<p>方差是一种特殊的协方差。当 $X=Y$ 时， $Cov(x,y)=Var(x)=Var(y)$ 。</p>
<blockquote>
<p>协方差性质：</p>
<p>1）独立变量的协方差为0。<br>
2）协方差计算公式：</p>
</blockquote>
 $$
Cov(\sum_{i=1}^{m}{a_ix_i}, \sum_{j=1}^{m}{b_jy_j}) = \sum_{i=1}^{m} \sum_{j=1}^{m}{a_ib_jCov(x_iy_i)}
$$ 
<blockquote>
<p>3）特殊情况：</p>
</blockquote>
 $$
Cov(a+bx, c+dy) = bdCov(x, y)
$$ 
<h3 id="1-6-4-相关系数">1.6.4 相关系数</h3>
<p>相关系数是研究变量之间线性相关程度的量。两个随机变量的相关系数定义为：</p>
 $$
Corr(x,y) = \frac{Cov(x,y)}{\sqrt{Var(x)Var(y)}}
$$ 
<blockquote>
<p>相关系数的性质：<br>
1）有界性。相关系数的取值范围是 [-1,1]，可以看成无量纲的协方差。<br>
2）值越接近1，说明两个变量正相关性（线性）越强。越接近-1，说明负相关性越强，当为0时，表示两个变量没有相关性。</p>
</blockquote>
<h2 id="参考文献">参考文献</h2>
<p>[1]Ian，Goodfellow，Yoshua，Bengio，Aaron…深度学习[M]，人民邮电出版，2017</p>
<p>[2]周志华.机器学习[M].清华大学出版社，2016.</p>
<p>[3]同济大学数学系.高等数学（第七版）[M]，高等教育出版社，2014.</p>
<p>[4]盛骤，试式千，潘承毅等编. 概率论与数理统计（第4版）[M]，高等教育出版社，2008</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/19/deep_learning/ch11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tom">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="算法工程师的日常">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/19/deep_learning/ch11/" class="post-title-link" itemprop="url">迁移学习面试题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-19 23:29:20" itemprop="dateCreated datePublished" datetime="2024-03-19T23:29:20+08:00">2024-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-24 10:14:01" itemprop="dateModified" datetime="2024-03-24T10:14:01+08:00">2024-03-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">算法面试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">深度学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>迁移学习</h1>
<p>​	本章主要简明地介绍了迁移学习的基本概念、迁移学习的必要性、研究领域和基本方法。重点介绍了几大类常用的迁移学习方法：数据分布自适应方法、特征选择方法、子空间学习方法、以及目前最热门的深度迁移学习方法。除此之外，我们也结合最近的一些研究成果对未来迁移学习进行了一些展望。并提供了一些迁移学习领域的常用学习资源，以方便感兴趣的读者快速开始学习。</p>
<h2 id="11-1-迁移学习基础知识">11.1 迁移学习基础知识</h2>
<h3 id="11-1-1-什么是迁移学习？">11.1.1 什么是迁移学习？</h3>
<p>找到目标问题的相似性，迁移学习任务就是从相似性出发，将旧领域(domain)学习过的模型应用在新领域上。</p>
<h3 id="11-1-2-为什么需要迁移学习？">11.1.2 为什么需要迁移学习？</h3>
<ol>
<li><strong>大数据与少标注的矛盾</strong>：虽然有大量的数据，但往往都是没有标注的，无法训练机器学习模型。人工进行数据标定太耗时。</li>
<li><strong>大数据与弱计算的矛盾</strong>：普通人无法拥有庞大的数据量与计算资源。因此需要借助于模型的迁移。</li>
<li><strong>普适化模型与个性化需求的矛盾</strong>：即使是在同一个任务上，一个模型也往往难以满足每个人的个性化需求，比如特定的隐私设置。这就需要在不同人之间做模型的适配。</li>
<li><strong>特定应用（如冷启动）的需求</strong>。</li>
</ol>
<h3 id="11-1-3-迁移学习的基本问题有哪些？">11.1.3 迁移学习的基本问题有哪些？</h3>
<p>基本问题主要有3个：</p>
<ul>
<li><strong>How to transfer</strong>： 如何进行迁移学习？（设计迁移方法）</li>
<li><strong>What to transfer</strong>： 给定一个目标领域，如何找到相对应的源领域，然后进行迁移？（源领域选择）</li>
<li><strong>When to transfer</strong>： 什么时候可以进行迁移，什么时候不可以？（避免负迁移）</li>
</ul>
<h3 id="11-1-4-迁移学习有哪些常用概念？">11.1.4 迁移学习有哪些常用概念？</h3>
<ul>
<li>基本定义
<ul>
<li><strong>域(Domain)</strong>：数据特征和特征分布组成，是学习的主体
<ul>
<li><strong>源域 (Source domain)</strong>：已有知识的域</li>
<li><strong>目标域 (Target domain)</strong>：要进行学习的域</li>
</ul>
</li>
<li><strong>任务 (Task)</strong>：由目标函数和学习结果组成，是学习的结果</li>
</ul>
</li>
<li>按特征空间分类
<ul>
<li><strong>同构迁移学习（Homogeneous TL）</strong>： 源域和目标域的特征空间相同， $D_s=D_t$</li>
<li><strong>异构迁移学习（Heterogeneous TL）</strong>：源域和目标域的特征空间不同， $D_s\ne D_t$</li>
</ul>
</li>
<li>按迁移情景分类
<ul>
<li><strong>归纳式迁移学习（Inductive TL）</strong>：源域和目标域的学习任务不同</li>
<li><strong>直推式迁移学习（Transductive TL)</strong>：源域和目标域不同，学习任务相同</li>
<li><strong>无监督迁移学习（Unsupervised TL)</strong>：源域和目标域均没有标签</li>
</ul>
</li>
<li>按迁移方法分类
<ul>
<li><strong>基于实例的迁移 (Instance based TL)</strong>：通过权重重用源域和目标域的样例进行迁移</li>
<li><strong>基于特征的迁移 (Feature based TL)</strong>：将源域和目标域的特征变换到相同空间</li>
<li><strong>基于模型的迁移 (Parameter based TL)</strong>：利用源域和目标域的参数共享模型</li>
<li><strong>基于关系的迁移 (Relation based TL)</strong>：利用源域中的逻辑网络关系进行迁移</li>
</ul>
</li>
</ul>
<p><img src="1542972502781.png" alt="1542972502781"></p>
<p><img src="1542974131814.png" alt="1542974131814"></p>
<h3 id="11-1-5-迁移学习与传统机器学习有什么区别？">11.1.5 迁移学习与传统机器学习有什么区别？</h3>
<table>
<thead>
<tr>
<th></th>
<th>迁移学习</th>
<th>传统机器学习</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据分布</td>
<td>训练和测试数据不需要同分布</td>
<td>训练和测试数据同分布</td>
</tr>
<tr>
<td>数据标签</td>
<td>不需要足够的数据标注</td>
<td>足够的数据标注</td>
</tr>
<tr>
<td>建模</td>
<td>可以重用之前的模型</td>
<td>每个任务分别建模</td>
</tr>
</tbody>
</table>
<p><img src="1542973960796.png" alt="1542973960796"></p>
<h3 id="11-1-6-迁移学习的核心及度量准则？">11.1.6 迁移学习的核心及度量准则？</h3>
<p><strong>迁移学习的总体思路可以概括为</strong>：开发算法来最大限度地利用有标注的领域的知识，来辅助目标领域的知识获取和学习。</p>
<p><strong>迁移学习的核心是</strong>：找到源领域和目标领域之间的相似性，并加以合理利用。这种相似性非常普遍。比如，不同人的身体构造是相似的；自行车和摩托车的骑行方式是相似的；国际象棋和中国象棋是相似的；羽毛球和网球的打球方式是相似的。这种相似性也可以理解为不变量。以不变应万变，才能立于不败之地。</p>
<p>**有了这种相似性后，下一步工作就是， 如何度量和利用这种相似性。**度量工作的目标有两点：一是很好地度量两个领域的相似性，不仅定性地告诉我们它们是否相似，更定量地给出相似程度。二是以度量为准则，通过我们所要采用的学习手段，增大两个领域之间的相似性，从而完成迁移学习。</p>
<p><strong>一句话总结： 相似性是核心，度量准则是重要手段。</strong></p>
<h3 id="11-1-7-迁移学习与其他概念的区别？">11.1.7 迁移学习与其他概念的区别？</h3>
<ol>
<li>迁移学习与多任务学习关系：
<ul>
<li><strong>多任务学习</strong>：多个相关任务一起协同学习；</li>
<li><strong>迁移学习</strong>：强调信息复用，从一个领域(domain)迁移到另一个领域。</li>
</ul>
</li>
<li>迁移学习与领域自适应：<strong>领域自适应</strong>：使两个特征分布不一致的domain一致。</li>
<li>迁移学习与协方差漂移：<strong>协方差漂移</strong>：数据的条件概率分布发生变化。</li>
</ol>
<p>Reference：</p>
<ol>
<li><a href="https%EF%BC%9A//github.com/jindongwang/transferlearning-tutorial">王晋东，迁移学习简明手册</a></li>
<li>Ben-David, S., Blitzer, J., Crammer, K., Kulesza, A., Pereira, F., &amp; Vaughan, J. W. (2010). A theory of learning from different domains. Machine learning, 79(1-2), 151-175.</li>
<li>Tan, B., Song, Y., Zhong, E. and Yang, Q., 2015, August. Transitive transfer learning. In Proceedings of the 21th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining (pp. 1155-1164). ACM.</li>
</ol>
<h3 id="11-1-8-什么是负迁移？产生负迁移的原因有哪些？">11.1.8 什么是负迁移？产生负迁移的原因有哪些？</h3>
<p>负迁移(Negative Transfer)指的是，在源域上学习到的知识，对于目标域上的学习产生负面作用。</p>
<p>产生负迁移的原因主要有：</p>
<ul>
<li>数据问题：源域和目标域压根不相似，谈何迁移？</li>
<li>方法问题：源域和目标域是相似的，但是，迁移学习方法不够好，没找到可迁移的成分。</li>
</ul>
<p>负迁移给迁移学习的研究和应用带来了负面影响。在实际应用中，找到合理的相似性，并且选择或开发合理的迁移学习方法，能够避免负迁移现象。</p>
<h3 id="11-1-9-迁移学习的基本思路？">11.1.9 迁移学习的基本思路？</h3>
<p>迁移学习的总体思路可以概括为：开发算法来最大限度地利用有标注的领域的知识，来辅助目标领域的知识获取和学习。</p>
<ol>
<li>找到目标问题的相似性，迁移学习任务就是从相似性出发，将旧领域(domain)学习过的模型应用在新领域上。</li>
<li>迁移学习，是指利用数据、任务、或模型之间的相似性，将在旧领域学习过的模型，应用于新领域的一种学习过程。</li>
<li>迁移学习<strong>最有用的场合</strong>是，如果你尝试优化任务B的性能，通常这个任务数据相对较少。<br>
例如，在放射科中你知道很难收集很多射线扫描图来搭建一个性能良好的放射科诊断系统，所以在这种情况下，你可能会找一个相关但不同的任务，如图像识别，其中你可能用 1 百万张图片训练过了，并从中学到很多低层次特征，所以那也许能帮助网络在任务在放射科任务上做得更好，尽管任务没有这么多数据。</li>
<li>迁移学习什么时候是有意义的？它确实可以<strong>显著提高</strong>你的<strong>学习任务的性能</strong>，但我有时候也见过有些场合使用迁移学习时，任务实际上数据量比任务要少， 这种情况下增益可能不多。</li>
</ol>
<blockquote>
<p>什么情况下可以使用迁移学习？</p>
<p>假如两个领域之间的区别特别的大，<strong>不可以直接采用迁移学习</strong>，因为在这种情况下效果不是很好。在这种情况下，推荐使用[3]的工作，在两个相似度很低的domain之间一步步迁移过去（踩着石头过河）。</p>
</blockquote>
<blockquote>
<ol>
<li>迁移学习主要解决方案有哪些？</li>
<li>除直接看infer的结果的Accurancy以外，如何衡量迁移学习学习效果？</li>
<li>对抗网络是如何进行迁移的？</li>
</ol>
</blockquote>
<p>Reference：</p>
<ol>
<li><a href="https%EF%BC%9A//github.com/jindongwang/transferlearning-tutorial">王晋东，迁移学习简明手册</a></li>
<li>Ben-David, S., Blitzer, J., Crammer, K., Kulesza, A., Pereira, F., &amp; Vaughan, J. W. (2010). A theory of learning from different domains. Machine learning, 79(1-2), 151-175.</li>
<li>Tan, B., Song, Y., Zhong, E. and Yang, Q., 2015, August. Transitive transfer learning. In Proceedings of the 21th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining (pp. 1155-1164). ACM.</li>
</ol>
<h2 id="11-2-迁移学习的基本思路有哪些？">11.2 迁移学习的基本思路有哪些？</h2>
<p>​	迁移学习的基本方法可以分为四种。这四种基本的方法分别是：基于样本的迁移， 基于模型 的迁移， 基于特征的迁移，及基于关系的迁移。</p>
<h3 id="11-2-1-基于样本迁移">11.2.1 基于样本迁移</h3>
<p>​	基于样本的迁移学习方法 (Instance based Transfer Learning) 根据一定的权重生成规则，对数据样本进行重用，来进行迁移学习。图<a href="#bookmark90">14</a>形象地表示了基于样本迁移方法的思想源域中存在不同种类的动物，如狗、鸟、猫等，目标域只有狗这一种类别。在迁移时，为了最大限度地和目标域相似，我们可以人为地提高源域中属于狗这个类别的样本权重。</p>
<p><img src="631e5aab4e0680c374793804817bfbb6.jpg" alt></p>
<center>图 14: 基于样本的迁移学习方法示意图
<p>​	在迁移学习中，对于源域D~s~和目标域D~t~，通常假定产生它们的概率分布是不同且未知的(P(X~s~) =P(X~t~))。另外，由于实例的维度和数量通常都非常大，因此，直接对 P(X~s~) 和P(X~t~) 进行估计是不可行的。因而，大量的研究工作 [<a href="#bookmark267">Khan and Heisterkamp,2016</a>, <a href="#bookmark319">Zadrozny, 2004</a>, <a href="#bookmark242">Cortes et al.,2008</a>, <a href="#bookmark243">Dai et al., 2007</a>, <a href="#bookmark302">Tan et al.,2015</a>, <a href="#bookmark303">Tan et al., 2017</a>] 着眼于对源域和目标域的分布比值进行估计(P(<strong>X</strong>t)/P(<strong>X</strong>s))。所估计得到的比值即为样本的权重。这些方法通常都假设P(<strong>x</strong>s) &lt;并且源域和目标域的条件概率分布相同(P(y|x~s~)=<em>P</em>(y|x~t~))。特别地，上海交通大学Dai等人[<a href="#bookmark243">Dai et al.,2007</a>]提出了 TrAdaboost方法，将AdaBoost的思想应用于迁移学习中，提高有利于目标分类任务的实例权重、降低不利于目标分类任务的实例权重，并基于PAC理论推导了模型的泛化误差上界。TrAdaBoost方法是此方面的经典研究之一。文献 [<a href="#bookmark264">Huang et al., 2007</a>]提出核均值匹配方法 (Kernel Mean atching, KMM)对于概率分布进行估计，目标是使得加权后的源域和目标域的概率分布尽可能相近。在最新的研究成果中，香港科技大学的Tan等人扩展了实例迁移学习方法的应用场景，提出 了传递迁移学习方法(Transitive Transfer Learning, TTL) [<a href="#bookmark302">Tan etal., 2015</a>] 和远域迁移学习 (Distant Domain Transfer Learning,DDTL) [<a href="#bookmark303">Tan et al., 2017</a>]，利用联合矩阵分解和深度神经网络，将迁移学习应用于多个不相似的领域之间的知识共享，取得了良好的效果。</p>
<p>​	虽然实例权重法具有较好的理论支撑、容易推导泛化误差上界，但这类方法通常只在领域间分布差异较小时有效，因此对自然语言处理、计算机视觉等任务效果并不理想。而基于特征表示的迁移学习方法效果更好,是我们研究的重点。</p>
<h3 id="11-2-2-基于特征迁移">11.2.2 基于特征迁移</h3>
<p>​	基于特征的迁移方法 (Feature based Transfer Learning) 是指将通过特征变换的方式互相迁移 [<a href="#bookmark272">Liu et al., 2011</a>, <a href="#bookmark327">Zheng et al.,2008</a>, <a href="#bookmark263">Hu and Yang, 2011</a>],来减少源域和目标域之间的差距；或者将源域和目标域的数据特征变换到统一特征空间中 [<a href="#bookmark288">Pan et al.,2011</a>, <a href="#bookmark278">Long et al., 2014b</a>, <a href="#bookmark248">Duan et al.,2012</a>],然后利用传统的机器学习方法进行分类识别。根据特征的同构和异构性,又可以分为同构和异构迁移学习。图<a href="#bookmark93">15</a>很形象地表示了两种基于特 征的迁移学习方法。</p>
<p><img src="fa08900e89bfd53cc28345d21bc6aca0.jpg" alt></p>
<center>图 15: 基于特征的迁移学习方法示意图
<p>​	基于特征的迁移学习方法是迁移学习领域中最热门的研究方法,这类方法通常假设源域和目标域间有一些交叉的特征。香港科技大学的 Pan 等人 [<a href="#bookmark288">Pan et al.,2011</a>] 提出的迁移 成分分析方法 (Transfer Component Analysis, TCA)是其中较为典型的一个方法。该方法的 核心内容是以最大均值差异 (Maximum MeanDiscrepancy, MMD) [<a href="#bookmark236">Borgwardt et al., 2006</a>]作为度量准则,将不同数据领域中的分布差异最小化。加州大学伯克利分校的 Blitzer 等人 [<a href="#bookmark235">Blitzer et al., 2006</a>] 提出了一种基于结构对应的学习方法(Structural Corresponding Learning,SCL),该算法可以通过映射将一个空间中独有的一些特征变换到其他所有空间中的轴特征上,然后在该特征上使用机器学习的算法进行分类预测。清华大学龙明盛等人[<a href="#bookmark278">Long et al.,2014b</a>]提出在最小化分布距离的同时，加入实例选择的迁移联合匹配(Tran-fer Joint Matching, TJM) 方法,将实例和特征迁移学习方法进行了有机的结合。澳大利亚卧龙岗大学的 Jing Zhang 等人 [<a href="#bookmark321">Zhang et al., 2017a</a>]提出对于源域和目标域各自训练不同 的变换矩阵,从而达到迁移学习的目标。</p>
<h3 id="11-2-3-基于模型迁移">11.2.3 基于模型迁移</h3>
<p>​	基于模型的迁移方法 (Parameter/Model based Transfer Learning) 是指从源域和目标域中找到他们之间共享的参数信息,以实现迁移的方法。这种迁移方式要求的假设条件是： 源域中的数据与目标域中的数据可以共享一些模型的参数。其中的代表性工作主要有［<a href="#bookmark324">Zhao et al., 2010</a>, <a href="#bookmark325">Zhao et al., 2011</a>, <a href="#bookmark287">Panet al., 2008b</a>, <a href="#bookmark286">Pan et al., 2008a</a>］。图<a href="#bookmark96">16</a>形象地 表示了基于模型的迁移学习方法的基本思想。</p>
<p><img src="602723a1d3ce0f3abe7c591a8e4bb6ec.jpg" alt></p>
<center>图 16: 基于模型的迁移学习方法示意图
<p>​	其中，中科院计算所的Zhao等人[<a href="#bookmark325">Zhao et al., 2011</a>]提出了TransEMDT方法。该方法首先针对已有标记的数据，利用决策树构建鲁棒性的行为识别模型，然后针对无标定数据，利用K-Means聚类方法寻找最优化的标定参数。西安邮电大学的Deng等人[<a href="#bookmark245">Deng et al.,2014</a>] 也用超限学习机做了类似的工作。香港科技大学的Pan等人[<a href="#bookmark286">Pan etal., 2008a</a>]利用HMM，针对Wifi室内定位在不同设备、不同时间和不同空间下动态变化的特点，进行不同分布下的室内定位研究。另一部分研究人员对支持向量机 SVM 进行了改进研究 [<a href="#bookmark285">Nater et al.,2011</a>, <a href="#bookmark269">Li et al., 2012</a>]。这些方法假定 SVM中的权重向量 <strong>w</strong> 可以分成两个部分： <strong>w</strong> = <strong>wo</strong>+<strong>v</strong>， 其中 <strong>w</strong>0代表源域和目标域的共享部分， <strong>v</strong> 代表了对于不同领域的特定处理。在最新的研究成果中，香港科技大学的 Wei 等人 [<a href="#bookmark313">Wei et al., 2016b</a>]将社交信息加入迁移学习方法的 正则项中，对方法进行了改进。清华大学龙明盛等人[<a href="#bookmark275">Long et al., 2015a</a>, <a href="#bookmark276">Long et al., 2016</a>, <a href="#bookmark280">Long etal., 2017</a>]改进了深度网络结构，通过在网络中加入概率分布适配层，进一步提高了深度迁移学习网络对于大数据的泛化能力。</p>
<h3 id="11-2-4-基于关系迁移">11.2.4 基于关系迁移</h3>
<p>​	基于关系的迁移学习方法 (Relation Based Transfer Learning) 与上述三种方法具有截然不同的思路。这种方法比较关注源域和目标域的样本之间的关系。图<a href="#bookmark82">17</a>形象地表示了不 同领域之间相似的关系。</p>
<p>​	就目前来说，基于关系的迁移学习方法的相关研究工作非常少，仅有几篇连贯式的文章讨论： [<a href="#bookmark283">Mihalkova et al., 2007</a>, <a href="#bookmark284">Mihalkova and Mooney,2008</a>, <a href="#bookmark244">Davis and Domingos, 2009</a>]。这些文章都借助于马尔科夫逻辑网络(Markov Logic Net)来挖掘不同领域之间的关系相似性。</p>
<p>​	我们将重点讨论基于特征和基于模型的迁移学习方法，这也是目前绝大多数研究工作的热点。</p>
<p><img src="aa10d36f758430dd4ff72d2bf6a76a6c.jpg" alt></p>
<center>图 17: 基于关系的迁移学习方法示意图
<p><img src="1542812440636.png" alt="1542812440636"></p>
<center>图 18: 基于马尔科夫逻辑网的关系迁移
<h2 id="11-3-迁移学习的常用方法">11.3 迁移学习的常用方法</h2>
<h3 id="11-3-1-数据分布自适应">11.3.1 数据分布自适应</h3>
<p>​	数据分布自适应 (Distribution Adaptation) 是一类最常用的迁移学习方法。这种方法的基本思想是,由于源域和目标域的数据概率分布不同,那么最直接的方式就是通过一些变换,将不同的数据分布的距离拉近。</p>
<p>​	图 <a href="#bookmark84">19</a>形象地表示了几种数据分布的情况。简单来说，数据的边缘分布不同，就是数据整体不相似。数据的条件分布不同，就是数据整体相似，但是具体到每个类里，都不太相似。</p>
<p><img src="1542812748062.png" alt="1542812748062"></p>
<center>图 19: 不同数据分布的目标域数据
<p>​	根据数据分布的性质,这类方法又可以分为边缘分布自适应、条件分布自适应、以及联合分布自适应。下面我们分别介绍每类方法的基本原理和代表性研究工作。介绍每类研究工作时,我们首先给出基本思路,然后介绍该类方法的核心,最后结合最近的相关工作介绍该类方法的扩展。</p>
<h3 id="11-3-2-边缘分布自适应">11.3.2 边缘分布自适应</h3>
<p>​	边缘分布自适应方法 (Marginal Distribution Adaptation) 的目标是减小源域和目标域的边缘概率分布的距离,从而完成迁移学习。从形式上来说,边缘分布自适应方法是用P(X~s~)和 P(X~t~)之间的距离来近似两个领域之间的差异。即：</p>
<p>​	 $DISTANCE(D~s~,D~t~)\approx\lVert P(X_s)-P(X_t)\Vert$  (6.1)</p>
<p>​	边缘分布自适应对应于图<a href="#bookmark84">19</a>中由图<a href="#bookmark101">19(a)</a>迁移到图<a href="#bookmark83">19(b)</a>的情形。</p>
<h3 id="11-3-3-条件分布自适应">11.3.3 条件分布自适应</h3>
<p>​	条件分布自适应方法 (Conditional Distribution Adaptation) 的目标是减小源域和目标域的条件概率分布的距离，从而完成迁移学习。从形式上来说，条件分布自适应方法是用  P(y~s~|X~s~) 和 P (y~t~|X~t~) 之间的距离来近似两个领域之间的差异。即：</p>
<p>​	 $DISTANCE(D~s~,D~t~)\approx\lVert P(y_s|X_s)-P(y_t|X_t)\Vert$ (6.8)</p>
<p>​	条件分布自适应对应于图<a href="#bookmark84">19</a>中由图<a href="#bookmark101">19(a)</a>迁移到图<a href="#bookmark85">19©</a>的情形。</p>
<p>​	目前单独利用条件分布自适应的工作较少，这些工作主要可以在 [<a href="#bookmark292">Saito et al.,2017</a>] 中找到。最近，中科院计算所的 Wang 等人提出了 STL 方法(Stratified Transfer Learn­ing) [<a href="#bookmark309">Wang tal.,2018</a>]。作者提出了类内迁移 (Intra-class Transfer)的思想。指出现有的 绝大多数方法都只是学习一个全局的特征变换(Global DomainShift)，而忽略了类内的相 似性。类内迁移可以利用类内特征，实现更好的迁移效果。</p>
<p>​	STL 方法的基本思路如图所示。首先利用大多数投票的思想，对无标定的位置行为生成伪标；然后在再生核希尔伯特空间中，利用类内相关性进行自适应地空间降维，使得不同情境中的行为数据之间的相关性增大；最后，通过二次标定，实现对未知标定数据的精准标定。</p>
<p><img src="1542817481582.png" alt="1542817481582"></p>
<center>图 21: STL 方法的示意图
### 11.3.4 联合分布自适应
<p>​	联合分布自适应方法 (Joint Distribution Adaptation) 的目标是减小源域和目标域的联合概率分布的距离，从而完成迁移学习。从形式上来说，联合分布自适应方法是用<em>P</em>(<strong>x</strong>s) 和P(<strong>x</strong>t)之间的距离、以及P(ys|<strong>x</strong>s)和P(yt|<strong>x</strong>t)之间的距离来近似两个领域之间的差异。即:</p>
<p>​	 $DISTANCE(D~s~,D~t~)\approx\lVert P(X_s)-P(X_t)\Vert-\lVert P(y_s|X_s)-P(y_t|X_t)\Vert​$ (6.10)</p>
<p>​	联合分布自适应对应于图<a href="#bookmark84">19</a>中由图<a href="#bookmark101">19(a)</a>迁移到图<a href="#bookmark83">19(b)</a>的情形、以及图<a href="#bookmark101">19(a)</a>迁移到<br>
图<a href="#bookmark85">19©</a>的情形。</p>
<h3 id="11-3-4-概率分布自适应方法优劣性比较">11.3.4 概率分布自适应方法优劣性比较</h3>
<p>综合上述三种概率分布自适应方法，我们可以得出如下的结论：</p>
<ol>
<li>精度比较： BDA &gt;JDA &gt;TCA &gt;条件分布自适应。</li>
<li>将不同的概率分布自适应方法用于神经网络，是一个发展趋势。图<a href="#bookmark119">23</a>展示的结果表明将概率分布适配加入深度网络中，往往会取得比非深度方法更好的结果。</li>
</ol>
<p><img src="1542823019007.png" alt="1542823019007"></p>
<center>图 22: BDA 方法的效果第二类方法：特征选择
### 11.3.6 特征选择
<p>​	特征选择法的基本假设是：源域和目标域中均含有一部分公共的特征，在这部分公共的特征，源领域和目标领域的数据分布是一致的。因此，此类方法的目标就是，通过机器学习方法，选择出这部分共享的特征，即可依据这些特征构建模型。</p>
<p>​	图 <a href="#bookmark122">24</a>形象地表示了特征选择法的主要思路。</p>
<p><img src="1542823210556.png" alt="1542823210556"></p>
<center>图 23: 不同分布自适应方法的精度比较
<p><img src="a3db84158d9b6454adff88dbe4fa5d28.jpg" alt></p>
<center>图 24: 特征选择法示意图
<p>​	这这个领域比较经典的一个方法是发表在 2006 年的 ECML-PKDD 会议上,作者提出了一个叫做 SCL 的方法 (Structural Correspondence Learning) [<a href="#bookmark235">Blitzer et al.,2006</a>]。这个方法的目标就是我们说的,找到两个领域公共的那些特征。作者将这些公共的特征叫做Pivot feature。找出来这些Pivot feature,就完成了迁移学习的任务。</p>
<p><img src="4abacd82901988c3e0a98bdb07b2abc6.jpg" alt></p>
<center>图 25: 特征选择法中的 Pivot feature 示意图
<p>​	图 <a href="#bookmark124">25</a>形象地展示了 Pivot feature 的含义。 Pivot feature指的是在文本分类中,在不同领域中出现频次较高的那些词。总结起来：</p>
<ul>
<li>特征选择法从源域和目标域中选择提取共享的特征,建立统一模型</li>
<li>通常与分布自适应方法进行结合</li>
<li>通常采用稀疏表示 ||<strong>A</strong>||2,1 实现特征选择</li>
</ul>
<h3 id="11-3-5-统计特征对齐方法">11.3.5 统计特征对齐方法</h3>
<p>​	统计特征对齐方法主要将数据的统计特征进行变换对齐。对齐后的数据，可以利用传统机器学习方法构建分类器进行学习。SA方法(Subspace Alignment，子空间对齐)[<a href="#bookmark249">Fernando et al.,2013</a>]是其中的代表性成果。SA方法直接寻求一个线性变换<strong>M</strong>，将不同的数据实现变换对齐。SA方法的优化目标如下：</p>
<p><img src="1542823438846.png" alt="1542823438846"></p>
<p>则变换 <strong>M</strong> 的值为：</p>
<p><img src="1542823455820.png" alt="1542823455820"></p>
<p>可以直接获得上述优化问题的闭式解：</p>
<p><img src="1542823474720.png" alt="1542823474720"></p>
<p>​	SA 方法实现简单，计算过程高效，是子空间学习的代表性方法。</p>
<h3 id="11-3-6-流形学习方法">11.3.6 流形学习方法</h3>
<p><strong>什么是流形学习</strong></p>
<p>​	流形学习自从 2000 年在 Science 上被提出来以后,就成为了机器学习和数据挖掘领域的热门问题。它的基本假设是,现有的数据是从一个高维空间中采样出来的,所以,它具有高维空间中的低维流形结构。流形就是是一种几何对象（就是我们能想像能观测到的）。通俗点说就是,我们无法从原始的数据表达形式明显看出数据所具有的结构特征,那我把它想像成是处在一个高维空间,在这个高维空间里它是有个形状的。一个很好的例子就是星座。满天星星怎么描述？我们想像它们在一个更高维的宇宙空间里是有形状的,这就有了各自星座,比如织女座、猎户座。流形学习的经典方法有Isomap、locally linear embedding、 laplacian eigenmap 等。</p>
<p>​	流形空间中的距离度量：两点之间什么最短？在二维上是直线（线段）,可在三维呢？地球上的两个点的最短距离可不是直线,它是把地球展开成二维平面后画的那条直线。那条线在三维的地球上就是一条曲线。这条曲线就表示了两个点之间的最短距离,我们叫它测地线。更通俗一点, 两点之间，测地线最短。在流形学习中,我们遇到测量距离的时候更多的时候用的就是这个测地线。在我们要介绍的 GFK 方法中,也是利用了这个测地线距离。比如在下面的图中,从 A 到 C 最短的距离在就是展开后的线段,但是在三维球体上看它却是一条曲线。</p>
<p><img src="fcbe02803e45f6455a4602b645b472c5.jpg" alt></p>
<center>图 28: 三维空间中两点之间的距离示意图
<p>​	由于在流形空间中的特征通常都有着很好的几何性质,可以避免特征扭曲,因此我们首先将原始空间下的特征变换到流形空间中。在众多已知的流形中, Grassmann 流形G（d） 可以通过将原始的 d 维子空间 （特征向量）看作它基础的元素,从而可以帮助学习分类 器。在 Grassmann流形中,特征变换和分布适配通常都有着有效的数值形式,因此在迁移学习问题中可以被很高效地表示和求解 [<a href="#bookmark260">Hamm and Lee,2008</a>]。因此,利用 Grassmann流形空间中来进行迁移学习是可行的。现存有很多方法可以将原始特征变换到流形空间 中[<a href="#bookmark257">Gopalan et al., 2011</a>, <a href="#bookmark230">Baktashmotlagh et al.,2014</a>]。</p>
<p>​	在众多的基于流形变换的迁移学习方法中，GFK(Geodesic Flow Kernel)方法[<a href="#bookmark255">Gong et<br>
al., 2012</a>]是最为代表性的一个。GFK是在2011年发表在ICCV上的SGF方法[<a href="#bookmark257">Gopalan et al.,<br>
2011</a>]发展起来的。我们首先介绍SGF方法。</p>
<p>​	SGF 方法从增量学习中得到启发：人类从一个点想到达另一个点，需要从这个点一步一步走到那一个点。那么，如果我们把源域和目标域都分别看成是高维空间中的两个点，由源域变换到目标域的过程不就完成了迁移学习吗？也就是说， 路是一步一步走出来的。</p>
<p>​	于是 SGF 就做了这个事情。它是怎么做的呢？把源域和目标域分别看成高维空间 (即Grassmann流形)中的两个点，在这两个点的测地线距离上取d个中间点，然后依次连接起来。这样，源域和目标域就构成了一条测地线的路径。我们只需要找到合适的每一步的变换，就能从源域变换到目标域了。图 <a href="#bookmark133">29</a>是 SGF 方法的示意图。</p>
<p><img src="103de3658cbb97ad4c24bafe28f9d957.jpg" alt></p>
<center>图 29: SGF 流形迁移学习方法示意图
<p>​	SGF 方法的主要贡献在于：提出了这种变换的计算及实现了相应的算法。但是它有很明显的缺点：到底需要找几个中间点？ SGF也没能给出答案，就是说这个参数d是没法估计的，没有一个好的方法。这个问题在 GFK 中被回答了。</p>
<p>​	GFK方法首先解决SGF的问题：如何确定中间点的个数d。它通过提出一种核学习的方法，利用路径上的无穷个点的积分，把这个问题解决了。这是第一个贡献。然后，它又解决了第二个问题：当有多个源域的时候，我们如何决定使用哪个源域跟目标域进行迁移？ GFK通过提出Rank of Domain度量，度量出跟目标域最近的源域，来解决这个问题。图 <a href="#bookmark134">30</a>是 GFK 方法的示意图。</p>
<p><img src="e654d14df0b44ee4e8a0e505c654044b.jpg" alt></p>
<center>图 30: GFK 流形迁移学习方法示意图
<p>​	用Ss和St分别表示源域和目标域经过主成分分析(PCA)之后的子空间，则G可以视为所有的d维子空间的集合。每一个d维的原始子空间都可以被看作G上的一个点。因此，在两点之间的测地线｛\ $(t) :0 \< t \<1｝可以在两个子空间之间构成一条路径。如果我 们令ss="\$" (0)，st="\" $(1)，则寻找一条从\$ (0)到\ $(1)的测地线就等同于将原始的特征变换到一个无穷维度的空间中，最终减小域之间的漂移现象。这种方法可以被看作是一种从\$ $(1)的増量式“行走”方法。 ​ 特别地，流形空间中的特征可以被表示为**z**="\$" (t)t<strong>x。变换后的特征<strong>Z</strong>i和<strong>Z</strong>j的内积定义了一个半正定 (positive semidefinite) 的测地线流式核</1｝可以在两个子空间之间构成一条路径。如果我></p>
<p><img src="1542823895008.png" alt="1542823895008"></p>
<p>​	GFK 方法详细的计算过程可以参考原始的文章，我们在这里不再赘述。</p>
<h3 id="11-3-7-什么是finetune？">11.3.7 什么是finetune？</h3>
<p>​	深度网络的finetune也许是最简单的深度网络迁移方法。<strong>Finetune</strong>,也叫微调、fine-tuning, 是深度学习中的一个重要概念。简而言之，finetune就是利用别人己经训练好的网络，针对自己的任务再进行调整。从这个意思上看，我们不难理解finetune是迁移学习的一部分。</p>
<p><strong>为什么需要已经训练好的网络？</strong></p>
<p>​	在实际的应用中,我们通常不会针对一个新任务,就去从头开始训练一个神经网络。这样的操作显然是非常耗时的。尤其是，我们的训练数据不可能像ImageNet那么大，可以训练出泛化能力足够强的深度神经网络。即使有如此之多的训练数据,我们从头开始训练,其代价也是不可承受的。</p>
<p>​	那么怎么办呢？迁移学习告诉我们,利用之前己经训练好的模型,将它很好地迁移到自己的任务上即可。</p>
<p><strong>为什么需要 finetune？</strong></p>
<p>​	因为别人训练好的模型,可能并不是完全适用于我们自己的任务。可能别人的训练数据和我们的数据之间不服从同一个分布；可能别人的网络能做比我们的任务更多的事情；可能别人的网络比较复杂,我们的任务比较简单。</p>
<p>​	举一个例子来说,假如我们想训练一个猫狗图像二分类的神经网络,那么很有参考价值的就是在 CIFAR-100 上训练好的神经网络。但是 CIFAR-100 有 100 个类别,我们只需要 2个类别。此时,就需要针对我们自己的任务,固定原始网络的相关层,修改网络的输出层以使结果更符合我们的需要。</p>
<p>​	图<a href="#bookmark148">36</a>展示了一个简单的finetune过程。从图中我们可以看到，我们采用的预训练好的网络非常复杂,如果直接拿来从头开始训练,则时间成本会非常高昂。我们可以将此网络进行改造,固定前面若干层的参数,只针对我们的任务,微调后面若干层。这样,网络训练速度会极大地加快,而且对提高我们任务的表现也具有很大的促进作用。</p>
<p><img src="b1630ca5d004d4b430672c8b8ce7fb90.jpg" alt></p>
<center>图 36: 一个简单的 finetune 示意图
**Finetune 的优势**
<p>​	Finetune 的优势是显然的，包括:</p>
<ul>
<li>不需要针对新任务从头开始训练网络，节省了时间成本；</li>
<li>预训练好的模型通常都是在大数据集上进行的，无形中扩充了我们的训练数据，使得模型更鲁棒、泛化能力更好；</li>
<li>Finetune 实现简单，使得我们只关注自己的任务即可。</li>
</ul>
<p><strong>Finetune 的扩展</strong></p>
<p>​	在实际应用中，通常几乎没有人会针对自己的新任务从头开始训练一个神经网络。Fine-tune 是一个理想的选择。</p>
<p>​	Finetune 并不只是针对深度神经网络有促进作用，对传统的非深度学习也有很好的效果。例如， finetune对传统的人工提取特征方法就进行了很好的替代。我们可以使用深度网络对原始数据进行训练，依赖网络提取出更丰富更有表现力的特征。然后，将这些特征作为传统机器学习方法的输入。这样的好处是显然的: 既避免了繁复的手工特征提取，又能自动地提取出更有表现力的特征。</p>
<p>​	比如，图像领域的研究，一直是以 SIFT、SURF 等传统特征为依据的，直到 2014 年，伯克利的研究人员提出了 DeCAF特征提取方法［<a href="#bookmark246">Donahue et al.,2014</a>］，直接使用深度卷积神经网络进行特征提取。实验结果表明，该特征提取方法对比传统的图像特征，在精度上有着无可匹敌的优势。另外，也有研究人员用卷积神经网络提取的特征作为SVM分类器的输 入［<a href="#bookmark291">Razavian et al.,014</a>］，显著提升了图像分类的精度。</p>
<h3 id="11-3-8-finetune为什么有效？">11.3.8 finetune为什么有效？</h3>
<p>​	随着 AlexNet [<a href="#bookmark268">Krizhevsky et al., 2012</a>] 在 2012 年的 ImageNet大赛上获得冠军，深度学习开始在机器学习的研究和应用领域大放异彩。尽管取得了很好的结果，但是神经网络本身就像一个黑箱子，看得见，摸不着，解释性不好。由于神经网络具有良好的层次结构很自然地就有人开始关注，能否通过这些层次结构来很好地解释网络？于是，有了我们熟知的例子：假设一个网络要识别一只猫，那么一开始它只能检测到一些边边角角的东西，和猫根本没有关系；然后可能会检测到一些线条和圆形；慢慢地，可以检测到有猫的区域；接着是猫腿、猫脸等等。图 <a href="#bookmark137">32</a>是一个简单的示例。</p>
<p><img src="1542824195602.png" alt="1542824195602"></p>
<center>图 32: 深度神经网络进行特征提取到分类的简单示例
<p>​	这表达了一个什么事实呢？概括来说就是：前面几层都学习到的是通用的特征（general feature）；随着网络层次的加深，后面的网络更偏重于学习任务特定的特征（specific feature）。<br>
这非常好理解，我们也都很好接受。那么问题来了：如何得知哪些层能够学习到 general feature，哪些层能够学习到specific feature。更进一步：如果应用于迁移学习，如何决定该迁移哪些层、固定哪些层？</p>
<p>​	这个问题对于理解神经网络以及深度迁移学习都有着非常重要的意义。</p>
<p>​	来自康奈尔大学的 Jason Yosinski 等人 [<a href="#bookmark318">Yosinski et al., 2014</a>]率先进行了深度神经网络可迁移性的研究，将成果发表在2014年机器学习领域顶级会议NIPS上并做了口头汇报。该论文是一篇实验性质的文章（通篇没有一个公式）。其目的就是要探究上面我们提到的几个关键性问题。因此，文章的全部贡献都来自于实验及其结果。（别说为啥做实验也能发文章：都是高考，我只上了个普通一本，我高中同学就上了清华）</p>
<p>​	在ImageNet的1000类上，作者把1000类分成两份（A和B），每份500个类别。然后，分别对A和B基于Caffe训练了一个AlexNet网络。一个AlexNet网络一共有8层， 除去第8层是类别相关的网络无法迁移以外，作者在 1 到 7这 7层上逐层进行 finetune 实验，探索网络的可迁移性。</p>
<p>​	为了更好地说明 finetune 的结果，作者提出了有趣的概念： AnB 和 BnB。</p>
<p>​	迁移A网络的前n层到B （AnB） vs固定B网络的前n层（BnB）</p>
<p>​	简单说一下什么叫AnB:（所有实验都是针对数据B来说的）将A网络的前n层拿来并将它frozen，剩下的8 - n层随机初始化，然后对B进行分类。</p>
<p>​	相应地，有BnB:把训练好的B网络的前n层拿来并将它frozen，剩下的8 - n层随机初始化，然后对 B 进行分类。</p>
<p>​	<strong>实验结果</strong></p>
<p>​	实验结果如下图（图<a href="#bookmark145">33</a>） 所示:</p>
<p>​	这个图说明了什么呢？我们先看蓝色的BnB和BnB+（就是BnB加上finetune）。对 BnB而言，原训练好的 B 模型的前 3 层直接拿来就可以用而不会对模型精度有什么损失到了第4 和第5 层，精度略有下降，不过还是可以接受。然而到了第6 第第7层，精度居然奇迹般地回升了！这是为什么？原因如下:对于一开始精度下降的第4 第 5 层来说，确</p>
<p><img src="1542824318155.png" alt="1542824318155"></p>
<center>图 33: 深度网络迁移实验结果 1
<p>实是到了这一步，feature变得越来越specific,所以下降了。那对于第6第7层为什么精度又不变了？那是因为，整个网络就8层，我们固定了第6第7层，这个网络还能学什么呢？所以很自然地，精度和原来的 B 网络几乎一致！</p>
<p>​	对 BnB+ 来说，结果基本上都保持不变。说明 finetune 对模型结果有着很好的促进作用！</p>
<p>​	我们重点关注AnB和AnB+。对AnB来说，直接将A网络的前3层迁移到B,貌似不会有什么影响，再一次说明，网络的前3层学到的几乎都是general feature!往后，到了第4第5层的时候，精度开始下降，我们直接说：一定是feature不general 了！然而，到了第6第7层，精度出现了小小的提升后又下降，这又是为什么？作者在这里提出两点co-adaptation和feature representation。就是说，第4第5层精度下降的时候，主要是由于A和B两个数据集的差异比较大，所以会下降；至I」了第6第7层，由于网络几乎不迭代了，学习能力太差，此时 feature 学不到，所以精度下降得更厉害。</p>
<p>​	再看AnB+。加入了 finetune以后，AnB+的表现对于所有的n几乎都非常好，甚至 比baseB<br>
（最初的B）还要好一些！这说明：finetune对于深度迁移有着非常好的促进作用!</p>
<p>​	把上面的结果合并就得到了下面一张图 （图<a href="#bookmark138">34</a>）：</p>
<p>​	至此， AnB 和 BnB 基本完成。作者又想，是不是我分 A 和 B 数据的时候，里面存在一些比较相似的类使结果好了？比如说A里有猫，B里有狮子，所以结果会好？为了排除这些影响，作者又分了一下数据集，这次使得A和B里几乎没有相似的类别。在这个条件下再做AnB,与原来精度比较（0%为基准）得到了下图（图<a href="#bookmark139">35</a>）:</p>
<p>​	这个图说明了什么呢？简单：随着可迁移层数的增加，模型性能下降。但是，前3层仍然还是可以迁移的！同时,与随机初始化所有权重比较,迁移学习的精度是很高的!总之：</p>
<ul>
<li>
<p>深度迁移网络要比随机初始化权重效果好；</p>
</li>
<li>
<p>网络层数的迁移可以加速网络的学习和优化。</p>
</li>
</ul>
<h3 id="11-3-9-什么是深度网络自适应？">11.3.9 什么是深度网络自适应？</h3>
<p><strong>基本思路</strong></p>
<p>​	深度网络的 finetune 可以帮助我们节省训练时间，提高学习精度。但是 finetune 有它的先天不足:它无法处理训练数据和测试数据分布不同的情况。而这一现象在实际应用中比比皆是。因为 finetune 的基本假设也是训练数据和测试数据服从相同的数据分布。这在迁移学习中也是不成立的。因此，我们需要更进一步，针对深度网络开发出更好的方法使之更好地完成迁移学习任务。</p>
<p>​	以我们之前介绍过的数据分布自适应方法为参考，许多深度学习方法［<a href="#bookmark307">Tzeng et al.,2014</a>, <a href="#bookmark275">Long et al.,2015a</a>］都开发出了自适应层(AdaptationLayer)来完成源域和目标域数据的自适应。自适应能够使得源域和目标域的数据分布更加接近，从而使得网络的效果更好。</p>
<p>​	从上述的分析我们可以得出，深度网络的自适应主要完成两部分的工作:</p>
<p>​	一是哪些层可以自适应，这决定了网络的学习程度；</p>
<p>​	二是采用什么样的自适应方法 (度量准则)，这决定了网络的泛化能力。</p>
<p>​	深度网络中最重要的是网络损失的定义。绝大多数深度迁移学习方法都采用了以下的损失定义方式:</p>
<p><img src="1542824918145.png" alt="1542824918145"></p>
<p>​	其中，I表示网络的最终损失，lc(Ds,<strong>y</strong>s)表示网络在有标注的数据(大部分是源域)上的常规分类损失(这与普通的深度网络完全一致)，Ia(Ds,Dt)表示网络的自适应损失。最后一部分是传统的深度网络所不具有的、迁移学习所独有的。此部分的表达与我们先前讨论过的源域和目标域的分布差异，在道理上是相同的。式中的A是权衡两部分的权重参数。</p>
<p>​	上述的分析指导我们设计深度迁移网络的基本准则：决定自适应层，然后在这些层加入自适应度量，最后对网络进行 finetune。</p>
<h3 id="11-3-10-GAN在迁移学习中的应用">11.3.10 GAN在迁移学习中的应用</h3>
<p>生成对抗网络 GAN(Generative Adversarial Nets) [<a href="#bookmark256">Goodfellow et al.,2014</a>] 是目前人工智能领域最炙手可热的概念之一。其也被深度学习领军人物 Yann Lecun 评为近年来最令人欣喜的成就。由此发展而来的对抗网络，也成为了提升网络性能的利器。本小节介绍深度对抗网络用于解决迁移学习问题方面的基本思路以及代表性研究成果。</p>
<p><strong>基本思路</strong></p>
<p>​	GAN 受到自博弈论中的二人零和博弈 (two-player game) 思想的启发而提出。它一共包括两个部分：一部分为生成网络(Generative Network)，此部分负责生成尽可能地以假乱真的样本，这部分被成为生成器(Generator)；另一部分为判别网络(Discriminative Network), 此部分负责判断样本是真实的，还是由生成器生成的，这部分被成为判别器(Discriminator) 生成器和判别器的互相博弈，就完成了对抗训练。</p>
<p>​	GAN 的目标很明确：生成训练样本。这似乎与迁移学习的大目标有些许出入。然而，由于在迁移学习中，天然地存在一个源领域，一个目标领域，因此，我们可以免去生成样本的过程，而直接将其中一个领域的数据 (通常是目标域) 当作是生成的样本。此时，生成器的职能发生变化，不再生成新样本，而是扮演了特征提取的功能：不断学习领域数据的特征使得判别器无法对两个领域进行分辨。这样，原来的生成器也可以称为特征提取器<br>
(Feature Extractor)。</p>
<p>​	通常用 Gf 来表示特征提取器，用 Gd 来表示判别器。正是基于这样的领域对抗的思想，深度对抗网络可以被很好地运用于迁移学习问题中。与深度网络自适应迁移方法类似，深度对抗网络的损失也由两部分构成：网络训练的损失lc*和领域判别损失Id：</p>
<p><img src="1542826334834.png" alt="1542826334834"></p>
<p><strong>DANN</strong></p>
<p>Yaroslav Ganin 等人 [<a href="#bookmark251">Ganin et al., 2016</a>]首先在神经网络的训练中加入了对抗机制，作者将他们的网络称之为DANN(Domain-Adversarial Neural Network)。在此研宄中，网络的学习目标是：生成的特征尽可能帮助区分两个领域的特征，同时使得判别器无法对两个领域的差异进行判别。该方法的领域对抗损失函数表示为：</p>
<p><img src="1542826461988.png" alt="1542826461988"></p>
<p>Id = max 其中的 Ld 表示为</p>
<p><img src="1542826475517.png" alt="1542826475517"></p>
<h2 id="参考文献">参考文献</h2>
<p>王晋东，迁移学习简明手册</p>
<p>[Baktashmotlagh et al., 2013] Baktashmotlagh, M., Harandi, M. T., Lovell, B. C.,and Salz- mann, M. (2013). Unsupervised domain adaptation by domain invariant projection. In <em>ICCV,</em> pages 769-776.</p>
<p>[Baktashmotlagh et al., 2014] Baktashmotlagh, M., Harandi, M. T., Lovell, B. C., and Salz- mann, M. (2014). Domain adaptation on the statistical manifold. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition*,pages 2481-2488.</p>
<p>[Ben-David et al., 2010] Ben-David, S., Blitzer, J., Crammer, K., Kulesza, A., Pereira, F., and Vaughan, J. W. (2010). A theory of learning from different domains. <em>Machine learning,</em> 79(1-2):151-175.</p>
<p>[Ben-David et al., 2007] Ben-David, S., Blitzer, J., Crammer, K., and Pereira, F. (2007). Analysis of representations for domain adaptation. In <em>NIPS</em>, pages 137-144.</p>
<p>[Blitzer et al., 2008] Blitzer, J., Crammer, K., Kulesza, A., Pereira, F., and Wortman, J. (2008). Learning bounds for domain adaptation. In <em>Advances in neural information processing systems</em>, pages 129-136.</p>
<p>[Blitzer et al., 2006] Blitzer, J., McDonald, R., and Pereira, F. (2006). Domain adaptation with structural correspondence learning. In <em>Proceedings of the 2006 conference on empiri­cal methods in natural language processing</em>, pages 120-128. Association for Computational Linguistics.</p>
<p>[Borgwardt et al., 2006] Borgwardt, K. M., Gretton, A., Rasch, M. J., Kriegel, H.-P., Scholkopf, B., and Smola, A. J. (2006). Integrating structured biological data by kernel maximum mean discrepancy. <em>Bioinformatics</em>, 22(14):e49-e57.</p>
<p>[Bousmalis et al., 2016] Bousmalis, K., Trigeorgis, G., Silberman, N., Krishnan, D., and Erhan, D. (2016). Domain separation networks. In <em>Advances in Neural Information Processing Systems</em>, pages 343-351.</p>
<p>[Cai et al., 2011] Cai, D., He, X., Han, J., and Huang, T. S. (2011). Graph regularized nonnegative matrix factorization for data representation. <em>IEEE Transactions on Pattern Analysis and Machine Intelligence</em>, 33(8):1548-1560.</p>
<p>[Cao et al., 2017] Cao, Z., Long, M., Wang, J., and Jordan, M. I. (2017). Partial transfer learning with selective adversarial networks. <em>arXiv preprint arXiv:1707.07901</em>.</p>
<p>[Carlucci et al., 2017] Carlucci, F. M., Porzi, L., Caputo, B., Ricci, E., and Bulo, S. R. (2017). Autodial: Automatic domain alignment layers. In International Conference on* Computer Vision.</p>
<p>[Cook et al., 2013] Cook, D., Feuz, K. D., and Krishnan, N. C. (2013). Transfer learning for activity recognition: A survey. <em>Knowledge and information systems</em>, 36(3):537-556.</p>
<p>[Cortes et al., 2008] Cortes, C., Mohri, M., Riley, M., and Rostamizadeh, A. (2008). Sample selection bias correction theory. In <em>International Conference on Algorithmic Learning Theory</em>, pages 38-53, Budapest, Hungary. Springer.</p>
<p>[Dai et al., 2007] Dai, W., Yang, Q., Xue, G.-R., and Yu, Y. (2007). Boosting for transfer learning. In <em>ICML</em>, pages 193-200. ACM.</p>
<p>[Davis and Domingos, 2009] Davis, J. and Domingos, P. (2009). Deep transfer via second- order markov logic. In <em>Proceedings of the 26th annual international conference on machine learning</em>, pages 217-224. ACM.</p>
<p>[Denget al., 2014] Deng,W.,Zheng,Q.,andWang,Z.(2014).Cross-personactivityrecog-nition using reduced kernel extreme learning machine. <em>Neural Networks,</em> 53:1-7.</p>
<p>[Donahue et al., 2014] Donahue, J., Jia, Y., et al. (2014). Decaf: A deep convolutional activation feature for generic visual recognition. In <em>ICML</em>, pages 647-655.</p>
<p>[Dorri and Ghodsi, 2012] Dorri, F. and Ghodsi, A. (2012). Adapting component analysis. In <em>Data Mining (ICDM), 2012 IEEE 12th International Conference on</em>, pages 846-851. IEEE.</p>
<p>[Duan et al., 2012] Duan, L., Tsang, I. W., and Xu, D. (2012). Domain transfer multi­ple kernel learning. <em>IEEE Transactions on Pattern Analysis and Machine Intelligence</em>, 34(3):465-479.</p>
<p>[Fernando et al., 2013] Fernando, B., Habrard, A., Sebban, M., and Tuytelaars, T. (2013). Unsupervised visual domain adaptation using subspace alignment. In ICCV*, pages 2960­2967.</p>
<p>[Fodor, 2002] Fodor, I. K. (2002). A survey of dimension reduction techniques. Center for Applied Scientific Computing, Lawrence Livermore National Laboratory*, 9:1-18.</p>
<p>[Ganin et al., 2016] Ganin, Y., Ustinova, E., Ajakan, H., Germain, P., Larochelle, H., Lavi- olette, F., Marchand, M., and Lempitsky, V. (2016).Domain-adversarial training of neural networks. <em>Journal of Machine Learning<br>
Research</em>, 17(59):1-35.</p>
<p>[Gao et al., 2012] Gao, C., Sang, N., and Huang, R. (2012). Online transfer boosting for object tracking. In <em>Pattern Recognition (ICPR), 2012 21st International Conference on</em>, pages 906-909. IEEE.</p>
<p>[Ghifary et al., 2017] Ghifary, M., Balduzzi, D., Kleijn, W. B., and Zhang, M. (2017). Scat­ter component analysis: A unified framework for domain adaptation and domain general­ization. <em>IEEE transactions on pattern analysis and machine intelligence</em>, 39(7):1414-1430.</p>
<p>[Ghifary et al., 2014] Ghifary, M., Kleijn, W. B., and Zhang, M. (2014). Domain adaptive neural networks for object recognition. In <em>PRICAI</em>, pages 898-904.</p>
<p>[Gong et al., 2012] Gong, B., Shi, Y., Sha, F., and Grauman, K. (2012). Geodesic flow kernel for unsupervised domain adaptation. In <em>CVPR</em>, pages 2066-2073.</p>
<p>[Goodfellow et al., 2014] Goodfellow, I., Pouget-Abadie, J., Mirza, M., Xu, B.,  Warde- Farley, D., Ozair, S., Courville, A., and Bengio, Y. (2014). Generative adversarial nets. In <em>Advances in neural information processing systems</em>, pages 2672-2680.</p>
<p>[Gopalan et al., 2011] Gopalan, R., Li, R., and Chellappa, R. (2011). Domain adaptation for object recognition: An unsupervised approach. In <em>ICCV</em>, pages 999-1006. IEEE.</p>
<p>[Gretton et al., 2012] Gretton, A., Sejdinovic, D., Strathmann, H., Balakrishnan, S., Pontil, M., Fukumizu, K., and Sriperumbudur, B. K. (2012). Optimal kernel choice for large- scale two-sample tests. In <em>Advances in neural information processing systems</em>, pages 1205-1213.</p>
<p>[Gu et al., 2011] Gu, Q., Li, Z., Han, J., et al. (2011). Joint feature selection and subspace learning. In <em>IJCAI Proceedings-International Joint Conference on Artificial Intel ligence</em>, volume 22, page 1294.</p>
<p>[Hamm and Lee, 2008] Hamm, J. and Lee, D. D. (2008). Grassmann discriminant analysis: a unifying view on subspace-based learning. In <em>ICML</em>, pages 376-383. ACM.</p>
<p>[Hou et al., 2015] Hou, C.-A., Yeh, Y.-R., and Wang, Y.-C. F. (2015). An unsupervised domain adaptation approach for cross-domain visual classification. In <em>Advanced Video and Signal Based Surveil lance (AVSS), 2015 12th IEEE International Conference on</em>,pages 1-6. IEEE.</p>
<p>[Hsiao et al., 2016] Hsiao, P.-H., Chang, F.-J., and Lin, Y.-Y. (2016). Learning discrim­inatively reconstructed source data for object recognition with few examples. <em>IEEE</em>Transactions on Image Processing*, 25(8):3518-3532.</p>
<p>[Hu and Yang, 2011] Hu, D. H. and Yang, Q. (2011). Transfer learning for activity recog­nition via sensor mapping. In <em>IJCAI Proceedings-International Joint Conference on Artificial Intelligence</em>, volume 22, page 1962, Barcelona, Catalonia, Spain. IJCAI.</p>
<p>[Huang et al., 2007] Huang, J., Smola, A. J., Gretton, A., Borgwardt, K. M., Scholkopf, B., et al. (2007). Correcting sample selection bias by unlabeled  data. <em>Advances in neural information processing systems</em>, 19:601.</p>
<p>[Jaini et al., 2016] Jaini, P., Chen, Z., Carbajal, P., Law, E., Middleton, L., Regan, K., Schaekermann, M., Trimponias, G., Tung, J., and Poupart, P. (2016). Online bayesian transfer learning for sequential data modeling. In <em>ICLR 2017</em>.</p>
<p>[Kermany et al., 2018] Kermany, D. S., Goldbaum, M., Cai, W., Valentim, C. C., Liang, H., Baxter, S. L., McKeown, A., Yang, G., Wu, X., Yan, F., et al. (2018). Identifying medical diagnoses and treatable diseases by image-based deep learning. <em>Cell</em>, 172(5):1122-1131.</p>
<p>[Khan and Heisterkamp, 2016] Khan, M. N. A. and Heisterkamp, D. R. (2016). Adapting instance weights for unsupervised domain adaptation using quadratic mutual informa­tion and subspace learning. In <em>Pattern Recognition (ICPR), 2016 23rd International Conference on</em>, pages 1560-1565, Mexican City. IEEE.</p>
<p>[Krizhevsky et al., 2012] Krizhevsky, A., Sutskever, I., and Hinton, G. E. (2012). Imagenet classification with deep convolutional neural networks. In Advances in neural information processing systems*, pages 1097-1105.</p>
<p>[Li et al., 2012] Li, H., Shi, Y., Liu, Y., Hauptmann, A. G., and Xiong, Z. (2012). Cross­domain video concept detection: A joint discriminative and generative active learning approach. <em>Expert Systems with Applications</em>,<br>
39(15):12220-12228.</p>
<p>[Li et al., 2016] Li, J., Zhao, J., and Lu, K. (2016). Joint feature selection and structure preservation for domain adaptation. In <em>Proceedings of the Twenty-Fifth International Joint Conference on Artificial Intelligence</em>, pages<br>
1697-1703. AAAI Press.</p>
<p>[Li et al., 2018] Li, Y., Wang, N., Shi, J., Hou, X., and Liu, J. (2018). Adaptive batch normalization for practical domain adaptation. <em>Pattern Recognition</em>, 80:109-117.</p>
<p>[Liu et al., 2011] Liu, J., Shah, M., Kuipers, B., and Savarese, S. (2011). Cross-view action recognition via view knowledge transfer. In <em>Computer Vision and Pattern Recognition (CVPR), 2011 IEEE Conference on</em>, pages 3209-3216, Colorado Springs, CO, USA. IEEE.</p>
<p>[Liu and Tuzel, 2016] Liu, M.-Y. and Tuzel, O. (2016). Coupled generative adversarial networks. In <em>Advances in neural information processing systems</em>, pages 469-477.</p>
<p>[Liu et al., 2017] Liu, T., Yang, Q., and Tao, D. (2017). Understanding how  feature struc­ture transfers in transfer learning. In <em>IJCAI</em>.</p>
<p>[Long et al., 2015a] Long, M., Cao, Y., Wang, J., and Jordan, M. (2015a). Learning trans­ferable features with deep adaptation networks. In <em>ICML</em>, pages 97-105.</p>
<p>[Long et al., 2016] Long, M., Wang, J., Cao, Y., Sun, J., and Philip, S. Y. (2016). Deep learning of transferable representation for scalable domain  adaptation. <em>IEEE Transac­tions on Knowledge and Data Engineering</em>,<br>
28(8):2027-2040.</p>
<p>[Long et al., 2014a] Long, M., Wang, J., Ding, G., Pan, S. J., and Yu, P. S. (2014a). Adaptation regularization: A general framework for transfer learning.*IEEE TKDE, 26(5):1076-1089.</p>
<p>[Long et al., 2014b] Long, M., Wang, J., Ding, G., Sun, J., and Yu, P. S. (2014b). Transfer joint matching for unsupervised domain adaptation. In *CVPR ,pages 1410-1417.</p>
<p>[Long et al., 2013] Long, M., Wang, J., et al. (2013). Transfer feature learning with joint distribution adaptation. In <em>ICCV</em>, pages 2200-2207.</p>
<p>[Long et al., 2017] Long, M., Wang, J., and Jordan, M. I. (2017). Deep transfer learning with joint adaptation networks. In <em>ICML</em>, pages 2208-2217.</p>
<p>[Long et al., 2015b] Long, M., Wang, J., Sun, J., and Philip, S. Y. (2015b). Domain invari­ant transfer kernel learning. <em>IEEE Transactions on Knowledge and Data Engineering</em>, 27(6):1519-1532.</p>
<p>[Luo et al., 2017] Luo, Z., Zou, Y., Hoffman, J., and Fei-Fei, L. F. (2017). Label efficient learning of transferable representations acrosss domains and tasks. In <em>Advances in Neural Information Processing Systems</em>, pages 164-176.</p>
<p>[Mihalkova et al., 2007] Mihalkova, L., Huynh, T., and Mooney, R. J. (2007). Mapping and revising markov logic networks for transfer learning. In <em>AAAI</em>, volume 7, pages 608-614.</p>
<p>[Mihalkova and Mooney, 2008] Mihalkova, L. and Mooney, R. J. (2008). Transfer learning by mapping with minimal target data. In <em>Proceedings of the AAAI-08 workshop on transfer learning for complex tasks</em>.</p>
<p>[Nater et al., 2011] Nater, F., Tommasi, T., Grabner, H., Van Gool, L., and Caputo, B. (2011). Transferring activities: Updating human behavior analysis. In <em>Computer Vision Workshops (ICCV Workshops), 2011 IEEE International Conference on</em>, pages 1737­1744, Barcelona, Spain. IEEE.</p>
<p>[Pan et al., 2008a] Pan, S. J., Kwok, J. T., and Yang, Q. (2008a). Transfer learning via dimensionality reduction. In <em>Proceedings of the 23rd AAAI conference on Artificial in­telligence</em>, volume 8, pages 677-682.</p>
<p>[Pan et al., 2008b] Pan, S. J., Shen, D., Yang, Q., and Kwok, J. T. (2008b). Transferring localization models across space. In <em>Proceedings of the 23rd AAAI Conference on Artificial Intelligence</em>, pages 1383-1388.</p>
<p>[Pan et al., 2011] Pan, S. J., Tsang, I. W., Kwok, J. T., and Yang, Q. (2011). Domain adaptation via transfer component analysis. <em>IEEE TNN</em>, 22(2):199-210.</p>
<p>[PanandYang, 2010] Pan,S.J.andYang,Q.(2010). A survey on transfer learning. IEEE TKDE*, 22(10):1345-1359.</p>
<p>[Patil and Phursule, 2013] Patil, D. M. and Phursule, R. (2013). Knowledge transfer using cost sensitive online learning classification. <em>International Journal of Science and Research</em>, pages 527-529.</p>
<p>[Razavian et al., 2014] Razavian, A. S., Azizpour, H., Sullivan, J., and Carlsson, S. (2014). Cnn features off-the-shelf: an astounding baseline for recognition. In <em>Computer Vision and Pattern Recognition Workshops (CVPRW), 2014 IEEE Conference on</em>, pages 512­519. IEEE.</p>
<p>[Saito et al., 2017] Saito, K., Ushiku, Y., and Harada, T. (2017). Asymmetric tri-training for unsupervised domain adaptation. In <em>International Conference on Machine Learning</em>.</p>
<p>[Sener et al., 2016] Sener, O., Song, H. O., Saxena, A., and Savarese, S. (2016). Learning transferrable representations for unsupervised domain adaptation. In <em>Advances in Neural Information Processing Systems</em>, pages 2110-2118.</p>
<p>[Shen et al., 2018] Shen, J., Qu, Y., Zhang, W., and Yu, Y. (2018). Wasserstein distance guided representation learning for domain adaptation. In <em>AAAI</em>.</p>
<p>[Si et al., 2010] Si, S., Tao, D., and Geng, B. (2010). Bregman divergence-based regu­larization for transfer subspace learning. <em>IEEE Transactions on Knowledge and Data Engineering</em>, 22(7):929-942.</p>
<p>[Silver et al., 2017] Silver, D., Schrittwieser, J., Simonyan, K., Antonoglou, I., Huang, A., Guez, A., Hubert, T., Baker, L., Lai, M., Bolton, A., et al. (2017). Mastering the game of go without human knowledge. <em>Nature</em>, 550(7676):354.</p>
<p>[Stewart and Ermon, 2017] Stewart, R. and Ermon, S. (2017). Label-free supervision of neural networks with physics and domain knowledge. In <em>AAAI</em>, pages 2576-2582.</p>
<p>[Sun et al., 2016] Sun, B., Feng, J., and Saenko, K. (2016). Return of frustratingly easy domain adaptation. In <em>AAAI</em>, volume 6, page 8.</p>
<p>[Sun and Saenko, 2015] Sun, B. and Saenko, K. (2015). Subspace distribution alignment for unsupervised domain adaptation. In <em>BMVC</em>, pages 24-1.</p>
<p>[Sun and Saenko, 2016] Sun, B. and Saenko, K. (2016). Deep coral: Correlation alignment for deep domain adaptation. In <em>European Conference on Computer Vision</em>, pages 443-450. Springer.</p>
<p>[Tahmoresnezhad and Hashemi, 2016] Tahmoresnezhad, J. and Hashemi, S. (2016). Visual domain adaptation via transfer feature learning. <em>Knowledge and Information Systems</em>, pages 1-21.</p>
<p>[Tan et al., 2015] Tan, B., Song, Y., Zhong, E., and Yang, Q. (2015). Transitive trans­fer learning. In <em>Proceedings of the 21th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining</em>, pages 1155-1164. ACM.</p>
<p>[Tan et al., 2017] Tan, B., Zhang, Y., Pan, S. J., and Yang, Q. (2017). Distant domain transfer learning. In <em>Thirty-First AAAI Conference on Artificial Intelligence</em>.</p>
<p>[Taylor and Stone, 2009] Taylor, M. E. and Stone, P. (2009). Transfer learning for reinforce­ment learning domains: A survey. <em>Journal of Machine Learning Research</em>, 10(Jul):1633- 1685.</p>
<p>[Tzeng et al., 2015] Tzeng, E., Hoffman, J., Darrell, T., and Saenko, K. (2015). Simulta­neous deep transfer across domains and tasks. In <em>Proceedings of the IEEE International Conference on Computer Vision</em>, pages 4068-4076, Santiago, Chile. IEEE.</p>
<p>[Tzeng et al., 2017] Tzeng, E., Hoffman, J., Saenko, K., and Darrell, T. (2017). Adversarial discriminative domain adaptation. In <em>CVPR</em>, pages 2962-2971.</p>
<p>[Tzeng et al., 2014] Tzeng, E., Hoffman, J., Zhang, N., et al. (2014). Deep domain confu­sion: Maximizing for domain invariance. <em>arXiv preprint arXiv:1412.3474</em>.</p>
<p>[Wang et al., 2017] Wang, J., Chen, Y., Hao, S., et al. (2017). Balanced distribution adap­tation for transfer learning. In <em>ICDM</em>, pages 1129-1134.</p>
<p>[Wang et al., 2018] Wang, J., Chen, Y., Hu, L., Peng, X., and Yu, P. S. (2018). Strati­fied transfer learning for cross-domain activity recognition. In <em>2018 IEEE International Conference on Pervasive Computing and Communications (PerCom)</em>.</p>
<p>[Wang et al., 2014] Wang, J., Zhao, P., Hoi, S. C., and Jin, R. (2014). Online feature selection and its applications. <em>IEEE Transactions on Knowledge and Data Engineering</em>, 26(3):698-710.</p>
<p>[Wei et al., 2016a] Wei, P., Ke, Y., and Goh, C. K. (2016a). Deep nonlinearfeature coding for unsupervised domain adaptation. In <em>IJCAI</em>, pages 2189-2195.</p>
<p>[Wei et al., 2017] Wei, Y., Zhang, Y., and Yang, Q. (2017). Learning totransfer. <em>arXiv</em> preprint arXiv:1708.05629*.</p>
<p>[Wei et al., 2016b] Wei, Y., Zhu, Y., Leung, C. W.-k., Song, Y., and Yang, Q. (2016b). Instilling social to physical: Co-regularized heterogeneous transfer learning. In <em>Thirtieth</em> AAAI Conference on Artificial Intelligence*.</p>
<p>[Weiss et al., 2016] Weiss, K., Khoshgoftaar, T. M., and Wang, D. (2016). A survey of transfer learning. <em>Journal of Big Data</em>, 3(1):1-40.</p>
<p>[Wu et al., 2017] Wu, Q., Zhou, X., Yan, Y., Wu, H., and Min, H. (2017). Online transfer learning by leveraging multiple source domains. <em>Knowledge and Information Systems</em>, 52(3):687-707.</p>
<p>[xinhua, 2016] xinhua (2016). <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MjM5ODYzNzAyMQ==&amp;">http://mp.weixin.qq.com/s?__biz=MjM5ODYzNzAyMQ==&amp;</a> mid=2651933920&amp;idx=1\&amp;sn=ae2866bd12000f1644eae1094497837e.</p>
<p>[Yan et al., 2017] Yan, Y., Wu, Q., Tan, M., Ng, M. K., Min, H., and Tsang, I. W. (2017). Online heterogeneous transfer by hedge ensemble of offline and online decisions. <em>IEEE transactions on neural networks and learning systems</em>.</p>
<p>[Yosinski et al., 2014] Yosinski, J., Clune, J., Bengio, Y., and Lipson, H. (2014). How transferable are features in deep neural networks? In <em>Advances in neural information processing systems</em>, pages 3320-3328.</p>
<p>[Zadrozny, 2004] Zadrozny, B. (2004). Learning and evaluating classifiers under sample selection bias. In <em>Proceedings of the twenty-first international conference on Machine learning</em>, page 114, Alberta, Canada. ACM.</p>
<p>[Zellinger et al., 2017] Zellinger, W., Grubinger, T., Lughofer, E., Natschlager, T., and Saminger-Platz, S. (2017). Central moment discrepancy (cmd) for domain-invariant rep­resentation learning. <em>arXiv preprint arXiv:1702.08811</em>.</p>
<p>[Zhang et al., 2017a] Zhang, J., Li, W., and Ogunbona, P. (2017a). Joint geometrical and statistical alignment for visual domain adaptation. In <em>CVPR</em>.</p>
<p>[Zhang et al., 2017b] Zhang, X., Zhuang, Y., Wang, W., and Pedrycz, W. (2017b). On­line feature transformation learning for cross-domain object category recognition. <em>IEEE transactions on neural networks and learning systems</em>.</p>
<p>[Zhao and Hoi, 2010] Zhao, P. and Hoi, S. C. (2010). Otl: A framework of online transfer learning. In <em>Proceedings of the 27th international conference on machine learning (ICML- 10)</em>, pages 1231-1238.</p>
<p>[Zhao et al., 2010] Zhao, Z., Chen, Y., Liu, J., and Liu, M. (2010). Cross-mobile elm based activity recognition. <em>International Journal of Engineering and Industries</em>, 1(1):30-38.</p>
<p>[Zhao et al., 2011] Zhao, Z., Chen, Y., Liu, J., Shen, Z., and Liu, M. (2011). Cross-people mobile-phone based activity recognition. In <em>Proceedings of the Twenty-Second interna­tional joint conference on Artificial Intelligence (IJCAI)</em>, volume 11, pages 2545-2550. Citeseer.</p>
<p>[Zheng et al., 2009] Zheng, V. W., Hu, D. H., and Yang, Q. (2009). Cross-domain activity recognition. In <em>Proceedings of the 11th international conference on Ubiquitous computing</em>, pages 61-70. ACM.</p>
<p>[Zheng et al., 2008] Zheng, V. W., Pan, S. J., Yang, Q., and Pan, J. J. (2008). Transferring multi-device localization models using latent multi-task learning. In <em>AAAI</em>, volume 8, pages 1427-1432, Chicago, Illinois, USA. AAAI.</p>
<p>[Zhuang et al., 2015] Zhuang, F., Cheng, X., Luo, P., Pan, S. J., and He, Q. (2015). Su­pervised representation learning: Transfer learning with deep autoencoders. In <em>IJCAI</em>,pages 4119-4125.</p>
<p>[Zhuo et al., 2017] Zhuo, J., Wang, S., Zhang, W., and Huang, Q. (2017). Deep unsuper­vised convolutional domain adaptation. In <em>Proceedings of the 2017 ACM on Multimedia Conference</em>, pages 261-269. ACM.</p>
</center></center></center></center></center></center></center></center></center></center></center></center></center></center></center></center></center>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/19/deep_learning/ch12/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tom">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="算法工程师的日常">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/19/deep_learning/ch12/" class="post-title-link" itemprop="url">网络搭建及训练面试题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-19 23:29:20" itemprop="dateCreated datePublished" datetime="2024-03-19T23:29:20+08:00">2024-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-24 10:14:03" itemprop="dateModified" datetime="2024-03-24T10:14:03+08:00">2024-03-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">算法面试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">深度学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>网络搭建及训练</h1>
<h1>12.1 TensorFlow</h1>
<h2 id="12-1-1-TensorFlow是什么？">12.1.1 TensorFlow是什么？</h2>
<p>  TensorFlow支持各种异构平台，支持多CPU/GPU、服务器、移动设备，具有良好的跨平台的特性；TensorFlow架构灵活，能够支持各种网络模型，具有良好的通用性；此外，TensorFlow架构具有良好的可扩展性，对OP的扩展支持，Kernel特化方面表现出众。</p>
<p>  TensorFlow最初由Google大脑的研究员和工程师开发出来，用于机器学习和神经网络方面的研究，于2015.10宣布开源，在众多深度学习框架中脱颖而出，在Github上获得了最多的Star量。</p>
<h2 id="12-1-2-TensorFlow的设计理念是什么？">12.1.2 TensorFlow的设计理念是什么？</h2>
<p>TensorFlow的设计理念主要体现在两个方面：</p>
<p>（1）将图定义和图运算完全分开。<br>
  TensorFlow 被认为是一个“符号主义”的库。我们知道，编程模式通常分为命令式编程（imperative style programming）和符号式编程（symbolic style programming）。命令式编程就是编写我们理解的通常意义上的程序，很容易理解和调试，按照原有逻辑执行。符号式编程涉及很多的嵌入和优化，不容易理解和调试，但运行速度相对有所提升。现有的深度学习框架中，Torch 是典型的命令式的，Caffe、MXNet 采用了两种编程模式混合的方法，而 TensorFlow 完全采用符号式编程。</p>
<p>  符号式计算一般是先定义各种变量，然后建立一个数据流图，在数据流图中规定各个变量间的计算关系，最后需要对据流图进行编译，但此时的数据流图还是一个空壳儿，里面没有任何实际数据，只有把需要运算的输入放进去后，才能在整个模型中形成数据流，从而形成输出值。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = 8 + 9</span><br><span class="line">print(t)</span><br></pre></td></tr></table></figure>
<p>  在传统的程序操作中，定义了 t 的运算，在运行时就执行了，并输出 17。而在 TensorFlow中，数据流图中的节点，实际上对应的是 TensorFlow API 中的一个操作，并没有真正去运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line">t = tf.add(8,9)</span><br><span class="line">print(t)</span><br><span class="line"></span><br><span class="line">#输出  Tensor&#123;&quot;Add_1:0&quot;,shape=&#123;&#125;,dtype=int32&#125;</span><br></pre></td></tr></table></figure>
<p>  （2）TensorFlow 中涉及的运算都要放在图中，而图的运行只发生在会话（session）中。开启会话后，就可以用数据去填充节点，进行运算；关闭会话后，就不能进行计算了。因此，会话提供了操作运行和 Tensor 求值的环境。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line">#创建图</span><br><span class="line">a = tf.constant([4.0,5.0])</span><br><span class="line">b = tf.constant([6.0,7.0])</span><br><span class="line">c = a * b</span><br><span class="line">#创建会话</span><br><span class="line">sess  = tf.Session()</span><br><span class="line">#计算c</span><br><span class="line">print(sess.run(c))   #进行矩阵乘法，输出[24.,35.]</span><br><span class="line">sess.close()</span><br></pre></td></tr></table></figure>
<h2 id="12-1-3-TensorFlow特点有哪些？">12.1.3 TensorFlow特点有哪些？</h2>
<h3 id="1-高度的灵活性">1.高度的灵活性</h3>
<p>  TensorFlow 并不仅仅是一个深度学习库，只要可以把你的计算过程表示称一个数据流图的过程，我们就可以使用 TensorFlow 来进行计算。TensorFlow 允许我们用计算图的方式建立计算网络，同时又可以很方便的对网络进行操作。用户可以基于 TensorFlow 的基础上用 python 编写自己的上层结构和库，如果TensorFlow没有提供我们需要的API的，我们也可以自己编写底层的 C++ 代码，通过自定义操作将新编写的功能添加到 TensorFlow 中。</p>
<h3 id="2-真正的可移植性">2.真正的可移植性</h3>
<p>  TensorFlow 可以在 CPU 和 GPU 上运行，可以在台式机、服务器、移动设备上运行。你想在你的笔记本上跑一下深度学习的训练，或者又不想修改代码，想把你的模型在多个CPU上运行， 亦或想将训练好的模型放到移动设备上跑一下，这些TensorFlow都可以帮你做到。</p>
<h3 id="3-多语言支持">3.多语言支持</h3>
<p>  TensorFlow采用非常易用的python来构建和执行我们的计算图，同时也支持 C++ 的语言。我们可以直接写python和C++的程序来执行TensorFlow，也可以采用交互式的ipython来方便的尝试我们的想法。当然，这只是一个开始，后续会支持更多流行的语言，比如Lua，JavaScript 或者R语言。</p>
<h3 id="4-丰富的算法库">4.丰富的算法库</h3>
<p>  TensorFlow提供了所有开源的深度学习框架里，最全的算法库，并且在不断的添加新的算法库。这些算法库基本上已经满足了大部分的需求，对于普通的应用，基本上不用自己再去自定义实现基本的算法库了。</p>
<h3 id="5-完善的文档">5.完善的文档</h3>
<p>  TensorFlow的官方网站，提供了非常详细的文档介绍，内容包括各种API的使用介绍和各种基础应用的使用例子，也包括一部分深度学习的基础理论。</p>
<p>  自从宣布开源以来，大量人员对TensorFlow做出贡献，其中包括Google员工，外部研究人员和独立程序员，全球各地的工程师对TensorFlow的完善，已经让TensorFlow社区变成了Github上最活跃的深度学习框架。</p>
<h2 id="12-1-4-TensorFlow的系统架构是怎样的？">12.1.4 TensorFlow的系统架构是怎样的？</h2>
<h3 id="整个系统从底层到上层可分为七层：">  整个系统从底层到上层可分为七层：</h3>
<p><img src="img%5Cch12%5C1.bmp" alt></p>
<p>  设备层：硬件计算资源，支持CPU、GPU</p>
<p>  网络层：支持两种通信协议</p>
<p>  数值计算层：提供最基础的计算，有线性计算、卷积计算</p>
<p>  高维计算层：数据的计算都是以数组的形式参与计算</p>
<p>  计算图层：用来设计神经网络的结构</p>
<p>  工作流层：提供轻量级的框架调用</p>
<p>  构造层：最后构造的深度学习网络可以通过TensorBoard服务端可视化</p>
<h2 id="12-1-5-TensorFlow编程模型是怎样的？">12.1.5 TensorFlow编程模型是怎样的？</h2>
<p>TensorFlow的编程模型：让向量数据在计算图里流动。那么在编程时至少有这几个过程：1.构建图，2.启动图，3.给图输入数据并获取结果。</p>
<h3 id="1-构建图">1.构建图</h3>
<p>TensorFlow的图的类型是tf.Graph，它包含着计算节点和tensor的集合。</p>
<p>  这里引用了两个新概念：tensor和计算节点。<br>
  我们先介绍tensor，一开始我们就介绍了，我们需要把数据输入给启动的图才能获取计算结果。那么问题来了，在构建图时用什么表示中间计算结果？这个时候tensor的概念就需要引入了。<br>
  类型是tf.Tensor，代表某个计算节点的输出，一定要看清楚是“代表”。它主要有两个作用：</p>
<p>1.构建不同计算节点之间的数据流</p>
<p>2.在启动图时，可以设置某些tensor的值，然后获取指定tensor的值。这样就完成了计算的输入输出功能。</p>
<p>如下代码所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inImage = tf.placeholder(tf.float32,[32,32,3],&quot;inputImage&quot;)</span><br><span class="line">processedImage = tf.image.per_image_standardization(inImage,&quot;processedImage&quot;)</span><br></pre></td></tr></table></figure>
<p>  这里inImage和processedImage都是tensor类型。它们代表着计算节点输出的数据，数据的值具体是多少在启动图的时候才知道。上面两个方法调用都传递了一个字符串，它是计算节点的名字，最好给节点命名，这样我们可以在图上调用get_tensor_by_name(name)获取对应的tensor对象，十分方便。（tensor名字为“&lt;计算节点名字&gt;:&lt;tensor索引&gt;”）</p>
<p>  创建tensor时，需要指定类型和shape。对不同tensor进行计算时要求类型相同，可以使用 tf.cast 进行类型转换。同时也要求 shape (向量维度)满足运算的条件，我们可以使用 tf.reshape 改变shape。</p>
<p>  现在了解计算节点的概念，其功能是对tensor进行计算、创建tensor或进行其他操作，类型是tf.Operation。获取节点对象的方法为get_operation_by_name(name)。</p>
<p>构建图，如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">g=tf.Graph()</span><br><span class="line"></span><br><span class="line">with g.as_default():</span><br><span class="line">    input_data=tf.placeholder(tf.float32,[None,2],&quot;input_data&quot;)</span><br><span class="line">    input_label=tf.placeholder(tf.float32,[None,2],&quot;input_label&quot;)</span><br><span class="line"></span><br><span class="line">    W1=tf.Variable(tf.truncated_normal([2,2]),name=&quot;W1&quot;)</span><br><span class="line">    B1=tf.Variable(tf.zeros([2]),name=&quot;B1&quot;)</span><br><span class="line"></span><br><span class="line">    output=tf.add(tf.matmul(input_data,W1),B1,name=&quot;output&quot;)</span><br><span class="line">    cross_entropy=tf.nn.softmax_cross_entropy_with_logits(logits=output,labels=input_label)</span><br><span class="line"></span><br><span class="line">    train_step=tf.train.AdamOptimizer().minimize(cross_entropy,name=&quot;train_step&quot;)</span><br><span class="line"></span><br><span class="line">    initer=tf.global_variables_initializer()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  上面的代码中我们创建了一个图，并在上面添加了很多节点。我们可以通过调用get_default_graph()获取默认的图。</p>
<p>  Input_data，input_label，W1，B1，output，cross_entropy都是tensor类型，train_step，initer，是节点类型。</p>
<p>有几类tensor或节点比较重要，下面介绍一下：</p>
<h4 id="1-placeholder">1.placeholder</h4>
<p>  Tensorflow，顾名思义， tensor代表张量数据，flow代表流，其最初的设计理念就是构建一张静态的数据流图。图是有各个计算节点连接而成，计算节点之间流动的便是中间的张量数据。要想让张量数据在我们构建的静态计算图中流动起来，就必须有最初的输入数据流。而placeholder，翻译过来叫做占位符，顾名思义，是给我们的输入数据提供一个接口，也就是说我们的一切输入数据，例如训练样本数据，超参数数据等都可以通过占位符接口输送到数据流图之中。使用实例如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line">x = tf.placeholder(dtype=tf.float32,shape=[],name=&#x27;x&#x27;)</span><br><span class="line">y = tf.placeholder(dtpe=tf.float32,shape=[],nmae=&#x27;y&#x27;)</span><br><span class="line">z = x*y</span><br><span class="line">with tf.Session() as sess:</span><br><span class="line">	prod = sess.run(z,feed_dict=&#123;x:1.,y:5.2&#125;)</span><br><span class="line">	print(prod)</span><br><span class="line">[out]:5.2</span><br></pre></td></tr></table></figure>
<h4 id="2-variable">2. variable</h4>
<p>  无论是传统的机器学习算法，例如线性支持向量机（Support Vector Machine, SVM)，其数学模型为y = &lt;w,x&gt; + b，还是更先进的深度学习算法，例如卷积神经网络（Convolutional Neural Network， CNN）单个神经元输出的模型y = w*x + b。可以看到，w和b就是我们要求的模型，模型的求解是通过优化算法（对于SVM，使用<br>
SMO[1]算法，对于CNN，一般基于梯度下降法）来一步一步更新w和b的值直到满足停止条件。因此，大多数机器学习的模型中的w和b实际上是以变量的形式出现在代码中的，这就要求我们在代码中定义模型变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line">a = tf.Variable(2.)</span><br><span class="line">b = tf.Variable(3.)</span><br><span class="line">with tf.Session() as sess:</span><br><span class="line">	sess.run(tf.global_variables_initializer()) #变量初始化</span><br><span class="line">    print(sess.run(a*b))</span><br><span class="line">[out]:6.</span><br></pre></td></tr></table></figure>
<p>[1] Platt, John. “Sequential minimal optimization: A fast algorithm for training support vector machines.” (1998).</p>
<h4 id="3-initializer">3. initializer</h4>
<p>  由于tensorflow构建的是静态的计算流图，在开启会话之前，所有的操作都不会被执行。因此为了执行在计算图中所构建的赋值初始化计算节点，需要在开启会话之后，在会话环境下运行初始化。如果计算图中定义了变量，而会话环境下为执行初始化命令，则程序报错，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line">a = tf.Variable(2.)</span><br><span class="line">b = tf.Variable(3.)</span><br><span class="line">with tf.Session() as sess:</span><br><span class="line">	#sess.run(tf.global_variables_initializer()) #注释掉初始化命令</span><br><span class="line">    print(sess.run(a*b))</span><br><span class="line">[Error]: Attempting to use uninitialized value Variable</span><br></pre></td></tr></table></figure>
<h3 id="2-启动图">2.启动图</h3>
<p>  先了解session的概念，然后才能更好的理解图的启动。<br>
  图的每个运行实例都必须在一个session里，session为图的运行提供环境。Session的类型是tf.Session，在实例化session对象时我们需要给它传递一个图对象，如果不显示给出将使用默认的图。Session有一个graph属性，我们可以通过它获取session对应的图。</p>
<p>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">numOfBatch=5</span><br><span class="line">datas=np.zeros([numOfBatch,2],np.float32)</span><br><span class="line">labels=np.zeros([numOfBatch,2],np.float32)</span><br><span class="line"></span><br><span class="line">sess=tf.Session(graph=g)</span><br><span class="line">graph=sess.graph</span><br><span class="line">sess.run([graph.get_operation_by_name(&quot;initer&quot;)])</span><br><span class="line"></span><br><span class="line">dataHolder=graph.get_tensor_by_name(&quot;input_data:0&quot;)</span><br><span class="line">labelHolder=graph.get_tensor_by_name(&quot;input_label:0&quot;)</span><br><span class="line">train=graph.get_operation_by_name(&quot;train_step&quot;)</span><br><span class="line">out=graph.get_tensor_by_name(&quot;output:0&quot;)</span><br><span class="line"></span><br><span class="line">for i inrange(200):</span><br><span class="line">   result=sess.run([out,train],feed_dict=&#123;dataHolder:datas,labelHolder:labels&#125;)</span><br><span class="line">   if i%100==0:</span><br><span class="line">       saver.save(sess,&quot;./moules&quot;)</span><br><span class="line"></span><br><span class="line">sess.close()</span><br></pre></td></tr></table></figure>
<p>代码都比较简单，就不介绍了。不过要注意2点：1.别忘记运行初始化节点，2.别忘记close掉session对象以释放资源。</p>
<h4 id="3-给图输入数据并获取结果">3.给图输入数据并获取结果</h4>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for i inrange(200):</span><br><span class="line">    result=sess.run([out,train],feed_dict=&#123;dataHolder:datas,labelHolder:labels&#125;)</span><br></pre></td></tr></table></figure>
<p>  这里主要用到了session对象的run方法，它用来运行某个节点或tensor并获取对应的值。我们一般会一次传递一小部分数据进行mini-batch梯度下降来优化模型。</p>
<p>  我们需要把我们需要运行的节点或tensor放入一个列表，然后作为第一个参数(不考虑self)传递给run方法，run方法会返回一个计算结果的列表，与我们传递的参数一一对应。</p>
<p>  如果我们运行的节点依赖某个placeholder，那我们必须给这个placeholder指定值，怎么指定代码里面很清楚，给关键字参数feed_dict传递一个字典即可，字典里的元素的key是placeholder对象，value是我们指定的值。值的数据的类型必须和placeholder一致，包括shape。值本身的类型是numpy数组。</p>
<p>这里再解释一个细节，在定义placeholder时代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">input_data=tf.placeholder(tf.float32,[None,2],&quot;input_data&quot;)</span><br><span class="line">input_label=tf.placeholder(tf.float32,[None,2],&quot;input_label&quot;)</span><br></pre></td></tr></table></figure>
<p>  shape为[None,2]，说明数据第一个维度是不确定的，然后TensorFlow会根据我们传递的数据动态推断第一个维度，这样我们就可以在运行时改变batch的大小。比如一个数据是2维，一次传递10个数据对应的tensor的shape就是[10,2]。可不可以把多个维度指定为None？理论上不可以！</p>
<h2 id="12-1-6-如何基于tensorflow搭建VGG16">12.1.6 如何基于tensorflow搭建VGG16</h2>
<p>​	介绍完关于tensorflow的基础知识，是时候来一波网络搭建实战了。虽然网上有很多相关教程，但我想从最标准的tensorflow代码和语法出发（而不是调用更高级的API，失去了原来的味道），向大家展示如何搭建其标准的VGG16网络架构。话不多说，上代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_weight_variable</span>(<span class="params">shape</span>):</span><br><span class="line">    <span class="keyword">return</span> tf.get_variable(<span class="string">&#x27;weight&#x27;</span>, shape=shape, initializer=tf.truncated_normal_initializer(stddev=<span class="number">0.1</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_bias_variable</span>(<span class="params">shape</span>):</span><br><span class="line">    <span class="keyword">return</span> tf.get_variable(<span class="string">&#x27;bias&#x27;</span>, shape=shape, initializer=tf.constant_initializer(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">conv2d</span>(<span class="params">x, w, padding = <span class="string">&#x27;SAME&#x27;</span>, s=<span class="number">1</span></span>):</span><br><span class="line">    x = tf.nn.conv2d(x, w, strides=[<span class="number">1</span>, s, s, <span class="number">1</span>], padding = padding)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">maxPoolLayer</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> tf.nn.max_pool(x, ksize = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>],</span><br><span class="line">                          strides = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>], padding = <span class="string">&#x27;SAME&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">conv2d_layer</span>(<span class="params">x,in_chs, out_chs, ksize, layer_name</span>):</span><br><span class="line">    <span class="keyword">with</span> tf.variable_scope(layer_name):</span><br><span class="line">        w = get_weight_variable([ksize, ksize, in_chs, out_chs])</span><br><span class="line">        b = get_bias_variable([out_chs])</span><br><span class="line">        y = tf.nn.relu(tf.bias_add(conv2d(x,w,padding = <span class="string">&#x27;SAME&#x27;</span>, s=<span class="number">1</span>), b))</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fc_layer</span>(<span class="params">x,in_kernels, out_kernels, layer_name</span>):</span><br><span class="line">    <span class="keyword">with</span> tf.variable_scope(layer_name):</span><br><span class="line">        w = get_weight_variable([in_kernels,out_kernels])</span><br><span class="line">        b = get_bias_variable([out_kernels])</span><br><span class="line">        y = tf.nn.relu(tf.bias_add(tf.matmul(x,w),b))</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">VGG16</span>(<span class="params">x</span>):</span><br><span class="line">    conv1_1 = conv2d_layer(x,tf.get_shape(x).as_list()[-<span class="number">1</span>], <span class="number">64</span>, <span class="number">3</span>, <span class="string">&#x27;conv1_1&#x27;</span>)</span><br><span class="line">    conv1_2 = conv2d_layer(conv1_1,<span class="number">64</span>, <span class="number">64</span>, <span class="number">3</span>, <span class="string">&#x27;conv1_2&#x27;</span>)</span><br><span class="line">    pool_1 = maxPoolLayer(conv1_2)</span><br><span class="line">    </span><br><span class="line">    conv2_1 = conv2d_layer(pool1,<span class="number">64</span>, <span class="number">128</span>, <span class="number">3</span>, <span class="string">&#x27;conv2_1&#x27;</span>)</span><br><span class="line">    conv2_2 = conv2d_layer(conv2_1,<span class="number">128</span>, <span class="number">128</span>, <span class="number">3</span>, <span class="string">&#x27;conv2_2&#x27;</span>)</span><br><span class="line">    pool2 = maxPoolLayer(conv2_2)</span><br><span class="line">    </span><br><span class="line">	conv3_1 = conv2d_layer(pool2,<span class="number">128</span>, <span class="number">256</span>, <span class="number">3</span>, <span class="string">&#x27;conv3_1&#x27;</span>)</span><br><span class="line">    conv3_2 = conv2d_layer(conv3_1,<span class="number">256</span>, <span class="number">256</span>, <span class="number">3</span>, <span class="string">&#x27;conv3_2&#x27;</span>)</span><br><span class="line">	conv3_3 = conv2d_layer(conv3_2,<span class="number">256</span>, <span class="number">256</span>, <span class="number">3</span>, <span class="string">&#x27;conv3_3&#x27;</span>)</span><br><span class="line">    pool3 = maxPoolLayer(conv3_3)</span><br><span class="line">    </span><br><span class="line">	conv4_1 = conv2d_layer(pool3,<span class="number">256</span>, <span class="number">512</span>, <span class="number">3</span>, <span class="string">&#x27;conv4_1&#x27;</span>)</span><br><span class="line">    conv4_2 = conv2d_layer(conv4_1,<span class="number">512</span>, <span class="number">512</span>, <span class="number">3</span>, <span class="string">&#x27;conv4_2&#x27;</span>)</span><br><span class="line">	conv4_3 = conv2d_layer(conv4_2,<span class="number">512</span>, <span class="number">512</span>, <span class="number">3</span>, <span class="string">&#x27;conv4_3&#x27;</span>)</span><br><span class="line">    pool4 = maxPoolLayer(conv4_3)</span><br><span class="line">    </span><br><span class="line">	conv5_1 = conv2d_layer(pool4,<span class="number">512</span>, <span class="number">512</span>, <span class="number">3</span>, <span class="string">&#x27;conv5_1&#x27;</span>)</span><br><span class="line">    conv5_2 = conv2d_layer(conv5_1,<span class="number">512</span>, <span class="number">512</span>, <span class="number">3</span>, <span class="string">&#x27;conv5_2&#x27;</span>)</span><br><span class="line">	conv5_3 = conv2d_layer(conv5_1,<span class="number">512</span>, <span class="number">512</span>, <span class="number">3</span>, <span class="string">&#x27;conv5_3&#x27;</span>)</span><br><span class="line">    pool5 = maxPoolLayer(conv5_3)</span><br><span class="line">    </span><br><span class="line">	pool5_flatten_dims = <span class="built_in">int</span>(np.prod(pool5.get_shape().as_list()[<span class="number">1</span>:]))</span><br><span class="line">    pool5_flatten = tf.reshape(pool5,[-<span class="number">1</span>,pool5_flatten_dims])</span><br><span class="line">    </span><br><span class="line">    fc_6 = fc_layer(pool5_flatten, pool5_flatten_dims, <span class="number">4096</span>, <span class="string">&#x27;fc6&#x27;</span>)</span><br><span class="line">	fc_7 = fc_layer(fc_6, <span class="number">4096</span>, <span class="number">4096</span>, <span class="string">&#x27;fc7&#x27;</span>)</span><br><span class="line">	fc_8 = fc_layer(fc_7, <span class="number">4096</span>, <span class="number">10</span>, <span class="string">&#x27;fc8&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> fc_8</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<h1>12.2 Pytorch</h1>
<h2 id="12-2-1-Pytorch是什么？">12.2.1 Pytorch是什么？</h2>
<p>  Pytorch是torch的python版本，是由Facebook开源的神经网络框架，专门针对 GPU 加速的深度神经网络（DNN）编程。Torch 是一个经典的对多维矩阵数据进行操作的张量（tensor ）库，在机器学习和其他数学密集型应用有广泛应用。与Tensorflow的静态计算图不同，pytorch的计算图是动态的，可以根据计算需要实时改变计算图。但由于Torch语言采用 Lua，导致在国内一直很小众，并逐渐被支持 Python 的 Tensorflow 抢走用户。作为经典机器学习库 Torch 的端口，PyTorch 为 Python 语言使用者提供了舒适的写代码选择。</p>
<h2 id="12-2-2-为什么选择-Pytorch？">12.2.2 为什么选择 Pytorch？</h2>
<h3 id="1-简洁：">1.简洁：</h3>
<p>  PyTorch的设计追求最少的封装，尽量避免重复造轮子。不像 TensorFlow 中充斥着session、graph、operation、name_scope、variable、tensor、layer等全新的概念，PyTorch 的设计遵循tensor→variable(autograd)→nn.Module 三个由低到高的抽象层次，分别代表高维数组（张量）、自动求导（变量）和神经网络（层/模块），而且这三个抽象之间联系紧密，可以同时进行修改和操作。<br>
简洁的设计带来的另外一个好处就是代码易于理解。PyTorch的源码只有TensorFlow的十分之一左右，更少的抽象、更直观的设计使得PyTorch的源码十分易于阅读。</p>
<h3 id="2-速度：">2.速度：</h3>
<p>  PyTorch 的灵活性不以速度为代价，在许多评测中，PyTorch 的速度表现胜过 TensorFlow和Keras 等框架。框架的运行速度和程序员的编码水平有极大关系，但同样的算法，使用PyTorch实现的那个更有可能快过用其他框架实现的。</p>
<h3 id="3-易用：">3.易用：</h3>
<p>  PyTorch 是所有的框架中面向对象设计的最优雅的一个。PyTorch的面向对象的接口设计来源于Torch，而Torch的接口设计以灵活易用而著称，Keras作者最初就是受Torch的启发才开发了Keras。PyTorch继承了Torch的衣钵，尤其是API的设计和模块的接口都与Torch高度一致。PyTorch的设计最符合人们的思维，它让用户尽可能地专注于实现自己的想法，即所思即所得，不需要考虑太多关于框架本身的束缚。</p>
<h3 id="4-活跃的社区：">4.活跃的社区：</h3>
<p>  PyTorch 提供了完整的文档，循序渐进的指南，作者亲自维护的论坛 供用户交流和求教问题。Facebook 人工智能研究院对 PyTorch 提供了强力支持，作为当今排名前三的深度学习研究机构，FAIR的支持足以确保PyTorch获得持续的开发更新，不至于像许多由个人开发的框架那样昙花一现。</p>
<h2 id="12-2-3-PyTorch-的架构是怎样的？">12.2.3 PyTorch 的架构是怎样的？</h2>
<p>  PyTorch(Caffe2) 通过混合前端，分布式训练以及工具和库生态系统实现快速，灵活的实验和高效生产。PyTorch 和 TensorFlow 具有不同计算图实现形式，TensorFlow 采用静态图机制(预定义后再使用)，PyTorch采用动态图机制(运行时动态定义)。PyTorch 具有以下高级特征：</p>
<p>  混合前端:新的混合前端在急切模式下提供易用性和灵活性，同时无缝转换到图形模式，以便在C ++运行时环境中实现速度，优化和功能。<br>
  分布式训练:通过利用本地支持集合操作的异步执行和可从Python和C ++访问的对等通信，优化了性能。<br>
  Python优先: PyTorch为了深入集成到Python中而构建的，因此它可以与流行的库和Cython和Numba等软件包一起使用。<br>
  丰富的工具和库:活跃的研究人员和开发人员社区建立了丰富的工具和库生态系统，用于扩展PyTorch并支持从计算机视觉到强化学习等领域的开发。<br>
  本机ONNX支持:以标准ONNX（开放式神经网络交换）格式导出模型，以便直接访问与ONNX兼容的平台，运行时，可视化工具等。<br>
  C++前端：C++前端是PyTorch的纯C++接口，它遵循已建立的Python前端的设计和体系结构。它旨在实现高性能，低延迟和裸机C++应用程序的研究。<br>
使用GPU和CPU优化的深度学习张量库。</p>
<h2 id="12-2-4-Pytorch-与-tensorflow-之间的差异在哪里？">12.2.4 Pytorch 与 tensorflow 之间的差异在哪里？</h2>
<p>  上面也将了PyTorch 最大优势是建立的神经网络是动态的, 对比静态的 Tensorflow, 它能更有效地处理一些问题, 比如说 RNN 变化时间长度的输出。各有各的优势和劣势。两者都是大公司发布的, Tensorflow（Google）宣称在分布式训练上下了很大的功夫, 那就默认 Tensorflow 在分布式训练上要超出 Pytorch（Facebook），还有tensorboard可视化工具, 但是 Tensorflow 的静态计算图使得在 RNN 上有一点点被动 (虽然它用其他途径解决了), 不过用 PyTorch 的时候, 会对这种动态的 RNN 有更好的理解。而且 Tensorflow 的高度工业化, 它的底层代码很难看懂， Pytorch 好那么一点点, 如果深入 PytorchAPI, 至少能比看 Tensorflow 多看懂一点点 Pytorch 的底层在干啥。</p>
<h2 id="12-2-5-Pytorch有哪些常用工具包？">12.2.5 Pytorch有哪些常用工具包？</h2>
<p>  torch ：类似 NumPy 的张量库，强 GPU 支持 ；<br>
  torch.autograd ：基于 tape 的自动区别库，支持 torch 之中的所有可区分张量运行；<br>
  torch.nn ：为最大化灵活性未涉及、与 autograd 深度整合的神经网络库；<br>
  torch.optim：与 torch.nn 一起使用的优化包，包含 SGD、RMSProp、LBFGS、Adam 等标准优化方式；<br>
  torch.multiprocessing： python 多进程并发，进程之间 torch Tensors 的内存共享；<br>
  torch.utils：数据载入器。具有训练器和其他便利功能；<br>
  torch.legacy(.nn/.optim) ：处于向后兼容性考虑，从 Torch 移植来的 legacy 代码；</p>
<h1>12.3 Caffe</h1>
<h2 id="12-3-1-什么是-Caffe？">12.3.1 什么是 Caffe？</h2>
<p>  Caffe的全称应该是Convolutional Architecture for Fast Feature Embedding，它是一个清晰、高效的深度学习框架，它是开源的，核心语言是C++，它支持命令行、Python和Matlab接口，它既可以在CPU上运行也可以在GPU上运行。它的license是BSD 2-Clause。</p>
<h2 id="12-3-2-Caffe的特点是什么？">12.3.2 Caffe的特点是什么？</h2>
<p>(1)、模块化：Caffe从一开始就设计得尽可能模块化，允许对新数据格式、网络层和损失函数进行扩展。</p>
<p>(2)、表示和实现分离：Caffe的模型(model)定义是用Protocol Buffer语言写进配置文件的。以任意有向无环图的形式，Caffe支持网络架构。Caffe会根据网络的需要来正确占用内存。通过一个函数调用，实现CPU和GPU之间的切换。</p>
<p>(3)、测试覆盖：在Caffe中，每一个单一的模块都对应一个测试。</p>
<p>(4)、python和Matlab接口：同时提供Python和Matlab接口。</p>
<p>(5)、预训练参考模型：针对视觉项目，Caffe提供了一些参考模型，这些模型仅应用在学术和非商业领域，它们的license不是BSD。</p>
<h2 id="12-3-3-Caffe的设计思想是怎样的？">12.3.3 Caffe的设计思想是怎样的？</h2>
<p>  基本上，Caffe 沿用了神经网络的一个简单假设----所有的计算都是以layer的形式表示的，layer做的事情就是take一些数据，然后输出一些计算以后的结果，比如说卷积，就是输入一个图像，然后和这一层的参数（filter）做卷积，然后输出卷积的结果。每一个layer需要做两个计算：forward是从输入计算输出，然后backward是从上面给的gradient来计算相对于输入的gradient，只要这两个函数实现了以后，我们就可以把很多层连接成一个网络，这个网络做的事情就是输入我们的数据（图像或者语音或者whatever），然后来计算我们需要的输出（比如说识别的label），在training的时候，我们可以根据已有的label来计算loss和gradient，然后用gradient来update网络的参数，这个就是Caffe的一个基本流程。</p>
<p>  基本上，最简单地用Caffe上手的方法就是先把数据写成Caffe的格式，然后设计一个网络，然后用Caffe提供的solver来做优化看效果如何，如果你的数据是图像的话，可以从现有的网络，比如说alexnet或者googlenet开始，然后做fine tuning，如果你的数据稍有不同，比如说是直接的float vector，你可能需要做一些custom的configuration，Caffe的logistic regression example兴许会很有帮助。</p>
<p>  Fine tune方法：fine tuning的想法就是说，在imagenet那么大的数据集上train好一个很牛的网络了，那别的task上肯定也不错，所以我们可以把pretrain的网络拿过来，然后只重新train最后几层，重新train的意思是说，比如我以前需要classify imagenet的一千类，现在我只想识别是狗还是猫，或者是不是车牌，于是我就可以把最后一层softmax从一个4096<em>1000的分类器变成一个4096</em>2的分类器，这个strategy在应用中非常好使，所以我们经常会先在imagenet上pretrain一个网络，因为我们知道imagenet上training的大概过程会怎么样。</p>
<h2 id="12-3-4-Caffe架构是怎样的？">12.3.4 Caffe架构是怎样的？</h2>
<p>  Caffe的架构与其它的深度学习框架稍微不同，它没有根据算法实现过程的方式来进行编码，而是以系统级的抽象作为整体架构，逐层的封装实现细节，使得上层的架构变得很清晰。Caffe的整体架构如下：</p>
<h3 id="1-SyncedMem">1. SyncedMem</h3>
<p>  这个类的主要功能是封装CPU和GPU的数据交互操作。一般来说，数据的流动形式都是：硬盘-&gt;CPU内存-&gt;GPU内存-&gt;CPU内存-&gt;（硬盘），所以在写代码的过程中经常会写CPU/GPU之间数据传输的代码，同时还要维护CPU和GPU两个处理端的内存指针。这些事情处理起来不会很难，但是会很繁琐。因此SyncedMem的出现就是把CPU/GPU的数据传输操作封装起来，只需要调用简单的接口就可以获得两个处理端同步后的数据。</p>
<h3 id="2-Blob">2. Blob</h3>
<p>  Blob是用于存储数据的对象，在Caffe中各种数据(图像输入、模型参数)都是以Blob的形式在网络中传输的，Blob提供统一的存储操作接口，可用来保存训练数据、模型参数等，同时Blob还能在CPU和GPU之间进行同步以支持CPU/GPU的混合运算。<br>
  这个类做了两个封装：一个是操作数据的封装，使用Blob可以操纵高维的数据，快速访问其中的数据，变换数据的维度等；另一个是对原始数据和更新量的封装，每一个Blob中都有data和diff两个数据指针，data用于存储原始数据，diff 用于存储反向传播（Backpropagation）的梯度更新值。Blob使用了SyncedMem，这样便于访问不同的处理端。Blob基本实现了整个Caffe数据结构部分的封装，在Net类中可以看到所有的前后向数据和参数都用Blob来表示就足够了。数据的抽象到这个就可以了，接下来作层级的抽象。神经网络的前后向计算可以做到层与层之间完全独立，只要每个层按照一定的接口规则实现，就可以确保整个网络的正确性。</p>
<h3 id="3-Layer">3. Layer</h3>
<p>  Layer是网络Net的基本单元，也是Caffe中能在外部进行调整的最小网络结构单元，每个Layer都有输入Blob和输出Blob。Layer（层）是Caffe中最庞大最繁杂的模块，它是神经网络的基本计算单元。由于Caffe强调模块化设计，因此只允许每个layer完成一类特定的计算，例如convolution操作、pooling、非线性变换、内积运算，以及数据加载、归一化和损失计算等。Caffe中layer的种类有很多，具体的种类及功能请看官方文档。在创建一个Caffe模型的时候，也是以Layer为基础进行的。Layer是一个父类，它的下面还有各种实现特定功能的子类，例如data_layer，conv_layer，loss_layer等。Layer是通过LayFactory来创建的。</p>
<h3 id="4-Net">4. Net</h3>
<p>  Net是一个完整的深度网络，包含输入层、隐藏层、输出层，在Caffe中一般是一个卷积神经网络(Convolution Neural Networ，CNN)。通过定义不同类型的Layer，并用Blob将不同的Layer连接起来，就能产生一个Net。Net将数据Blob和层Layer组合起来做进一步的封装，对外提供了初始化和前后传播的接口，使得整体看上去和一个层的功能类似，但内部的组合可以是多种多样的。值得一提的是，每一层的输入输出数据统一保存在Net中，同时每个层内的参数指针也保存在Net中，不同的层可以通过WeightShare共享相同的参数，因此可以通过配置来实现多个神经网络层之间共享参数的功能。一个Net由多个Layer组成。一个典型的网络从data layer（从磁盘中载入数据）出发到loss layer结束。</p>
<h3 id="5-Solver">5. Solver</h3>
<p>  有了Net就可以进行神经网络的前后向传播计算了，但是还缺少神经网络的训练和预测功能，Solver类进一步封装了训练和预测相关的一些功能。它还提供了两个接口：一个是更新参数的接口，继承Solver可以实现不同的参数更新方法，如Momentum，Nesterov，Adagrad等，因此可以使用不同的优化算法。另一个接口是训练过程中每一轮特定状态下的可注入的一些回调函数，在代码中这个回调点的直接使用者就是多GPU训练算法。Solver定义了针对Net网络模型的求解方法，记录网络的训练过程，保存网络模型参数，中断并恢复网络的训练过程。自定义Solver能够实现不同的神经网络求解方式。阅读Solver的代码可以了解网络的求解优化过程。Solver是一个父类，它下面还有实现不同优化方法的子类，例如sgd_solver，adagrad_sovler等，Solver是通过SolverFactory来创建的。</p>
<h3 id="6-Proto">6. Proto</h3>
<p>  caffe.proto位于…/src/caffe/proto目录下，在这个文件夹下还有一个.pb.cc和一个.pb.h文件，这两个文件都是由caffe.proto编译而来的。 在caffe.proto中定义了很多结构化数据，包括：<br>
BlobProto、Datum、FillerParameter、NetParameter、SolverParameter、SolverState、LayerParameter、ConcatParameter、ConvolutionParameter、DataParameter、DropoutParameter、HDF5DataParameter、HDF5OutputParameter、ImageDataParameter、InfogainLossParameter、InnerProductParameter、LRNParameter、MemoryDataParameter、PoolingParameter、PowerParameter、WindowDataParameter、V0LayerParameter。</p>
<h3 id="7-IO">7. IO</h3>
<p>  除了上面的东西之外，还需要输入数据和参数。DataReader和DataTransformer帮助准备输入数据，Filler对参数进行初始化，一些Snapshot方法可以对模型进行持久化。</p>
<h2 id="12-3-5-Caffe的有哪些接口？">12.3.5 Caffe的有哪些接口？</h2>
<p>  Caffe深度学习框架支持多种编程接口，包括命令行、Python和Matlab,下面将介绍如何使用这些接口。</p>
<h3 id="1-Caffe-Python接口">1. Caffe Python接口</h3>
<p>  Caffe提供 Python 接口，即Pycaffe，具体实现在caffe、python文件夹内。在Python代码中import caffe，可以load models（导入模型）、forward and backward （前向、反向迭代）、handle IO（数据输入输出）、visualize networks（绘制net）和instrument model solving（自定义优化方法)。所有的模型数据、计算参数都是暴露在外、可供读写的。<br>
  (1)<a target="_blank" rel="noopener" href="http://caffe.Net">caffe.Net</a> 是主要接口，负责导入数据、校验数据、计算模型。<br>
  (2)caffe.Classsifier 用于图像分类。<br>
  (3)caffe.Detector 用于图像检测。<br>
  (4)caffe.SGDSolver 是露在外的 solver 的接口。<br>
  (5)<a target="_blank" rel="noopener" href="http://caffe.io">caffe.io</a> 处理输入输出，数据预处理。<br>
  (6)caffe.draw 可视化 net 的结构。<br>
  (7)caffe blobs 以 numpy ndarrys 的形式表示，方便而且高效。</p>
<h3 id="2-Caffe-MATLAB接口">2. Caffe MATLAB接口</h3>
<p>  MATLAB接口（Matcaffe）在 caffe/matlab 目录的 caffe 软件包。在 matcaffe 的基础上，可将Caffe整合到MATLAB代码中。<br>
  MATLAB接口包括：<br>
  (1)MATLAB 中创建多个网络结构。<br>
  (2)网络的前向传播（Forward）与反向传播（Backward）计算。<br>
  (3)网络中的任意一层以及参数的存取。<br>
  (4)网络参数保存至文件或从文件夹加载。<br>
  (5)blob 和 network 形状调整。<br>
  (6)网络参数编辑和调整。<br>
  (7)创建多个 solvers 进行训练。<br>
  (8)从solver 快照（Snapshots）恢复并继续训练。<br>
  (9)访问训练网络（Train nets）和测试网络(Test nets)。<br>
  (10)迭代后网络交由 MATLAB 控制。<br>
  (11)MATLAB代码融合梯度算法。</p>
<h3 id="3-Caffe-命令行接口">3. Caffe 命令行接口</h3>
<p>  命令行接口 Cmdcaffe 是 Caffe 中用来训练模型、计算得分以及方法判断的工具。Cmdcaffe 存放在 caffe/build/tools 目录下。</p>
<h4 id="1-caffe-train">1. caffe train</h4>
<p>  caffe train 命令用于模型学习，具体包括：<br>
  (1)caffe train 带 solver.prototxt 参数完成配置。<br>
  (2)caffe train 带 snapshot mode_iter_1000.solverstate 参数加载 solver snapshot。<br>
  (3)caffe train 带 weights 参数 model.caffemodel 完成 Fine-tuning 模型初始化。</p>
<h4 id="2-caffe-test">2. caffe test</h4>
<p>  caffe test 命令用于测试运行模型的得分，并且用百分比表示网络输出的最终结果，比如 accuracyhuoloss 作为其结果。测试过程中，显示每个 batch 的得分，最后输出全部 batch 的平均得分值。</p>
<h4 id="3-caffe-time">3. caffe time</h4>
<p>  caffe time 命令用来检测系统性能和测量模型相对执行时间，此命令通过逐层计时与同步，执行模型检测。</p>
<p>参考文献：<br>
1.深度学习：Caffe之经典模型讲解与实战/ 乐毅，王斌</p>
<h3 id="10-4-网络搭建有什么原则？">10.4 网络搭建有什么原则？</h3>
<h3 id="10-4-1新手原则。">10.4.1新手原则。</h3>
<p>刚入门的新手不建议直接上来就开始搭建网络模型。比较建议的学习顺序如下：</p>
<ul>
<li>1.了解神经网络工作原理，熟悉基本概念及术语。</li>
<li>2.阅读经典网络模型论文+实现源码(深度学习框架视自己情况而定)。</li>
<li>3.找数据集动手跑一个网络，可以尝试更改已有的网络模型结构。</li>
<li>4.根据自己的项目需要设计网络。</li>
</ul>
<h3 id="10-4-2深度优先原则。">10.4.2深度优先原则。</h3>
<p>通常增加网络深度可以提高准确率，但同时会牺牲一些速度和内存。但深度不是盲目堆起来的，一定要在浅层网络有一定效果的基础上，增加深度。深度增加是为了增加模型的准确率，如果浅层都学不到东西，深了也没效果。</p>
<h3 id="10-4-3卷积核size一般为奇数。">10.4.3卷积核size一般为奇数。</h3>
<p>卷积核为奇数有以下好处：</p>
<ul>
<li>1 保证锚点刚好在中间，方便以 central pixel为标准进行滑动卷积，避免了位置信息发生偏移 。</li>
<li>2 保证在填充（Padding）时，在图像之间添加额外的零层，图像的两边仍然对称。</li>
</ul>
<h3 id="10-4-4卷积核不是越大越好。">10.4.4卷积核不是越大越好。</h3>
<p>AlexNet中用到了一些非常大的卷积核，比如11×11、5×5卷积核，之前人们的观念是，卷积核越大，感受野越大，看到的图片信息越多，因此获得的特征越好。但是大的卷积核会导致计算量的暴增，不利于模型深度的增加，计算性能也会降低。于是在VGG、Inception网络中，利用2个3×3卷积核的组合比1个5×5卷积核的效果更佳，同时参数量（3×3×2+1=19&lt;26=5×5×1+1）被降低，因此后来3×3卷积核被广泛应用在各种模型中。</p>
<h2 id="10-5-有哪些经典的网络模型值得我们去学习的？">10.5 有哪些经典的网络模型值得我们去学习的？</h2>
<p>提起经典的网络模型就不得不提起计算机视觉领域的经典比赛：ILSVRC .其全称是 ImageNet Large Scale Visual Recognition Challenge.正是因为ILSVRC 2012挑战赛上的AlexNet横空出世，使得全球范围内掀起了一波深度学习热潮。这一年也被称作“深度学习元年”。而在历年ILSVRC比赛中每次刷新比赛记录的那些神经网络也成为了人们心中的经典，成为学术界与工业届竞相学习与复现的对象，并在此基础上展开新的研究。</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>年份</th>
<th>网络名称</th>
<th>获得荣誉</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2012</td>
<td>AlexNet</td>
<td>ILSVRC图像分类冠军</td>
</tr>
<tr>
<td>2</td>
<td>2014</td>
<td>VGGNet</td>
<td>ILSVRC图像分类亚军</td>
</tr>
<tr>
<td>3</td>
<td>2014</td>
<td>GoogLeNet</td>
<td>ILSVRC图像分类冠军</td>
</tr>
<tr>
<td>4</td>
<td>2015</td>
<td>ResNet</td>
<td>ILSVRC图像分类冠军</td>
</tr>
<tr>
<td>5</td>
<td>2017</td>
<td>SeNet</td>
<td>ILSVRC图像分类冠军</td>
</tr>
</tbody>
</table>
<blockquote>
<ul>
<li>1 AlexNet<br>
论文:<a target="_blank" rel="noopener" href="https://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf">ImageNet Classification with Deep Convolutional Neural Networks</a><br>
代码实现:<a target="_blank" rel="noopener" href="https://github.com/tensorflow/tensorflow/blob/361a82d73a50a800510674b3aaa20e4845e56434/tensorflow/contrib/slim/python/slim/nets/alexnet.py">tensorflow</a><br>
主要特点：</li>
</ul>
<blockquote>
<ul>
<li>1.第一次使用非线性激活函数ReLU。</li>
<li>2.增加防加过拟合方法：Droupout层,提升了模型鲁棒性。</li>
<li>3.首次使用数据增强。</li>
<li>4.首次使用GPU加速运算。</li>
</ul>
</blockquote>
</blockquote>
<blockquote>
<ul>
<li>2 VGGNet<br>
论文:<a target="_blank" rel="noopener" href="https://arxiv.org/abs/1409.1556">Very Deep Convolutional Networks for Large-Scale Image Recognition</a><br>
代码实现:<a target="_blank" rel="noopener" href="https://github.com/tensorflow/tensorflow/blob/361a82d73a50a800510674b3aaa20e4845e56434/tensorflow/contrib/slim/python/slim/nets/vgg.py">tensorflow</a><br>
主要特点：</li>
</ul>
<blockquote>
<ul>
<li>1.网络结构更深。</li>
<li>2.普遍使用小卷积核。</li>
</ul>
</blockquote>
</blockquote>
<blockquote>
<ul>
<li>3 GoogLeNet<br>
论文:<a target="_blank" rel="noopener" href="https://arxiv.org/abs/1409.4842">Going Deeper with Convolutions</a><br>
代码实现:<a target="_blank" rel="noopener" href="https://github.com/tensorflow/tensorflow/blob/361a82d73a50a800510674b3aaa20e4845e56434/tensorflow/contrib/slim/python/slim/nets/inception_v1.py">tensorflow</a><br>
主要特点：</li>
</ul>
<blockquote>
<ul>
<li>1.增强卷积模块功能。<br>
主要的创新在于他的Inception，这是一种网中网（Network In Network）的结构，即原来的结点也是一个网络。Inception一直在不断发展，目前已经V2、V3、V4。其中1*1卷积主要用来降维，用了Inception之后整个网络结构的宽度和深度都可扩大，能够带来2-3倍的性能提升。</li>
<li>2.连续小卷积代替大卷积，保证感受野不变的同时，减少了参数数目。</li>
</ul>
</blockquote>
<ul>
<li>4 ResNet<br>
论文:<a target="_blank" rel="noopener" href="https://arxiv.org/abs/1512.03385">Deep Residual Learning for Image Recognition</a><br>
代码实现:<a target="_blank" rel="noopener" href="https://github.com/tensorflow/tensorflow/blob/361a82d73a50a800510674b3aaa20e4845e56434/tensorflow/contrib/slim/python/slim/nets/inception_v1.py">tensorflow</a><br>
主要特点:</li>
</ul>
<blockquote>
<p>解决了“退化”问题，即当模型的层次加深时，错误率却提高了。</p>
</blockquote>
<ul>
<li>5 SeNet<br>
论文:<a target="_blank" rel="noopener" href="https://arxiv.org/abs/1709.01507">Squeeze-and-Excitation Networks</a><br>
代码实现:<a target="_blank" rel="noopener" href="https://github.com/ry/tensorflow-resnet">tensorflow</a><br>
主要特点:</li>
</ul>
<blockquote>
<p>提出了feature recalibration，通过引入 attention 重新加权，可以得到抑制无效特征，提升有效特征的权重，并很容易地和现有网络结合，提升现有网络性能，而计算量不会增加太多。</p>
</blockquote>
</blockquote>
<p><strong>CV领域网络结构演进历程：</strong><br>
<img src="%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%E6%BC%94%E8%BF%9B.png" alt="CV领域网络结构演进历程"></p>
<p><strong>ILSVRC挑战赛历年冠军:</strong><br>
<img src="%E5%8E%86%E5%B9%B4%E5%86%A0%E5%86%9B.png" alt="ILSVRC挑战赛历年冠军"></p>
<p>此后，ILSVRC挑战赛的名次一直是衡量一个研究机构或企业技术水平的重要标尺。<br>
ILSVRC 2017 已是最后一届举办.2018年起，将由WebVision竞赛（Challenge on Visual Understanding by Learning from Web Data）来接棒。因此，即使ILSVRC挑战赛停办了，但其对深度学习的深远影响和巨大贡献，将永载史册。</p>
<h2 id="10-6-网络训练有哪些技巧吗？">10.6 网络训练有哪些技巧吗？</h2>
<h3 id="10-6-1-合适的数据集。">10.6.1.合适的数据集。</h3>
<ul>
<li>1 没有明显脏数据(可以极大避免Loss输出为NaN)。</li>
<li>2 样本数据分布均匀。</li>
</ul>
<h3 id="10-6-2-合适的预处理方法。">10.6.2.合适的预处理方法。</h3>
<p>关于数据预处理，在Batch Normalization未出现之前预处理的主要做法是减去均值，然后除去方差。在Batch Normalization出现之后，减均值除方差的做法已经没有必要了。对应的预处理方法主要是数据筛查、数据增强等。</p>
<h3 id="10-6-3-网络的初始化。">10.6.3.网络的初始化。</h3>
<p>网络初始化最粗暴的做法是参数赋值为全0，这是绝对不可取的。因为如果所有的参数都是0，那么所有神经元的输出都将是相同的，那在back propagation的时候同一层内所有神经元的行为也是相同的，这可能会直接导致模型失效，无法收敛。吴恩达视频中介绍的方法是将网络权重初始化均值为0、方差为1符合的正态分布的随机数据。</p>
<h3 id="10-6-4-小规模数据试练。">10.6.4.小规模数据试练。</h3>
<p>在正式开始训练之前，可以先用小规模数据进行试练。原因如下：</p>
<ul>
<li>1 可以验证自己的训练流程对否。</li>
<li>2 可以观察收敛速度，帮助调整学习速率。</li>
<li>3 查看GPU显存占用情况，最大化batch_size(前提是进行了batch normalization，只要显卡不爆，尽量挑大的)。</li>
</ul>
<h3 id="10-6-5-设置合理Learning-Rate。">10.6.5.设置合理Learning Rate。</h3>
<ul>
<li>1 太大。Loss爆炸、输出NaN等。</li>
<li>2 太小。收敛速度过慢，训练时长大大延长。</li>
<li>3 可变的学习速率。比如当输出准确率到达某个阈值后，可以让Learning Rate减半继续训练。</li>
</ul>
<h3 id="10-6-6-损失函数">10.6.6.损失函数</h3>
<p>损失函数主要分为两大类:分类损失和回归损失</p>
<blockquote>
<p>1.回归损失：</p>
<blockquote>
<ul>
<li>1 均方误差(MSE 二次损失 L2损失)<br>
它是我们的目标变量与预测值变量差值平方。</li>
<li>2 平均绝对误差(MAE L1损失)<br>
它是我们的目标变量与预测值变量差值绝对值。<br>
关于MSE与MAE的比较。MSE更容易解决问题，但是MAE对于异常值更加鲁棒。更多关于MAE和MSE的性能，可以参考<a target="_blank" rel="noopener" href="https://rishy.github.io/ml/2015/07/28/l1-vs-l2-loss/">L1vs.L2 Loss Function</a></li>
</ul>
</blockquote>
</blockquote>
<blockquote>
<p>2.分类损失：</p>
<blockquote>
<ul>
<li>1 交叉熵损失函数。<br>
是目前神经网络中最常用的分类目标损失函数。</li>
<li>2 合页损失函数<br>
合页损失函数广泛在支持向量机中使用，有时也会在损失函数中使用。缺点:合页损失函数是对错误越大的样本施以更严重的惩罚，但是这样会导致损失函数对噪声敏感。</li>
</ul>
</blockquote>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/19/deep_learning/ch14/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tom">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="算法工程师的日常">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/19/deep_learning/ch14/" class="post-title-link" itemprop="url">超参数调整面试题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-19 23:29:20" itemprop="dateCreated datePublished" datetime="2024-03-19T23:29:20+08:00">2024-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-24 10:14:07" itemprop="dateModified" datetime="2024-03-24T10:14:07+08:00">2024-03-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">算法面试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">深度学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>超参数调整</h1>
<h2 id="14-1-写在前面">14.1 写在前面</h2>
<p>​	关于训练深度学习模型最难的事情之一是你要处理的参数的数量。无论是从网络本身的层宽（宽度）、层数（深度）、连接方式，还是损失函数的超参数设计和调试，亦或者是学习率、批样本数量、优化器参数等等。这些大量的参数都会有网络模型最终的有效容限直接或者间接的影响。面对如此众多的参数，如果我们要一一对其优化调整，所需的无论是时间、资源都是不切实际。结果证实一些超参数比其它的更为重要，因此认识各个超参数的作用和其可能会造成的影响是深度学习训练中必不可少的一项重要技能。</p>
<p>​	超参数调整可以说是深度学习中理论和实际联系最重要的一个环节。目前，深度学习仍存在很多不可解释的部分，如何设计优化出好的网络可以为深度学习理论的探索提供重要的支持。超参数调整一般分为手动调整和自动优化超参数两种。读者可先浏览思维导图，本章节不会过多阐述所有超参数的详细原理，如果需要了解这部分，您可以翻阅前面的基础章节或者查阅相关文献资料。当然，下面会讲到的一些超参数优化的建议是根据笔者们的实践以及部分文献资料得到认知建议，并不是非常严格且一定有效的，很多研究者可能会很不同意某些的观点或有着不同的直觉，这都是可保留讨论的，因为这很依赖于数据本身情况。</p>
<p><img src="img%5Cch14%5C%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.png" alt></p>
<p>​</p>
<h2 id="14-2-超参数概念">14.2 超参数概念</h2>
<h3 id="14-2-1-什么是超参数，参数和超参数的区别？">14.2.1 什么是超参数，参数和超参数的区别？</h3>
<p>​	区分两者最大的一点就是是否通过数据来进行调整，模型参数通常是有数据来驱动调整，超参数则不需要数据来驱动，而是在训练前或者训练中人为的进行调整的参数。例如卷积核的具体核参数就是指模型参数，这是有数据驱动的。而学习率则是人为来进行调整的超参数。这里需要注意的是，通常情况下卷积核数量、卷积核尺寸这些也是超参数，注意与卷积核的核参数区分。</p>
<h3 id="14-2-2-神经网络中包含哪些超参数？">14.2.2 神经网络中包含哪些超参数？</h3>
<p>通常可以将超参数分为三类：网络参数、优化参数、正则化参数。</p>
<p>​	网络参数：可指网络层与层之间的交互方式（相加、相乘或者串接等）、卷积核数量和卷积核尺寸、网络层数（也称深度）和激活函数等。</p>
<p>​	优化参数：一般指学习率（learning rate）、批样本数量（batch size）、不同优化器的参数以及部分损失函数的可调参数。</p>
<p>​	正则化：权重衰减系数，丢弃比率（dropout）</p>
<h3 id="14-2-3-为什么要进行超参数调优？">14.2.3 为什么要进行超参数调优？</h3>
<p>​	本质上，这是模型优化寻找最优解和正则项之间的关系。网络模型优化调整的目的是为了寻找到全局最优解（或者相比更好的局部最优解），而正则项又希望模型尽量拟合到最优。两者通常情况下，存在一定的对立，但两者的目标是一致的，即最小化期望风险。模型优化希望最小化经验风险，而容易陷入过拟合，正则项用来约束模型复杂度。所以如何平衡两者之间的关系，得到最优或者较优的解就是超参数调整优化的目的。</p>
<h3 id="14-2-4-超参数的重要性顺序">14.2.4 超参数的重要性顺序</h3>
<ul>
<li>
<p>首先， <strong>学习率，损失函数上的可调参数</strong>。在网络参数、优化参数、正则化参数中最重要的超参数可能就是学习率了。学习率直接控制着训练中网络梯度更新的量级，直接影响着模型的<strong>有效容限能力</strong>；损失函数上的可调参数，这些参数通常情况下需要结合实际的损失函数来调整，大部分情况下这些参数也能很直接的影响到模型的的有效容限能力。这些损失一般可分成三类，第一类辅助损失结合常见的损失函数，起到辅助优化特征表达的作用。例如度量学习中的Center loss，通常结合交叉熵损失伴随一个权重完成一些特定的任务。这种情况下一般建议辅助损失值不高于或者不低于交叉熵损失值的两个数量级；第二类，多任务模型的多个损失函数，每个损失函数之间或独立或相关，用于各自任务，这种情况取决于任务之间本身的相关性，目前笔者并没有一个普适的经验由于提供参考；第三类，独立损失函数，这类损失通常会在特定的任务有显著性的效果。例如RetinaNet中的focal loss，其中的参数γ，α，对最终的效果会产生较大的影响。这类损失通常论文中会给出特定的建议值。</p>
</li>
<li>
<p>其次，<strong>批样本数量，动量优化器（Gradient Descent with Momentum）的动量参数<em>β</em></strong>。批样本决定了数量梯度下降的方向。过小的批数量，极端情况下，例如batch size为1，即每个样本都去修正一次梯度方向，样本之间的差异越大越难以收敛。若网络中存在批归一化（batchnorm），batch size过小则更难以收敛，甚至垮掉。这是因为数据样本越少，统计量越不具有代表性，噪声也相应的增加。而过大的batch size，会使得梯度方向基本稳定，容易陷入局部最优解，降低精度。一般参考范围会取在[1:1024]之间，当然这个不是绝对的，需要结合具体场景和样本情况；动量衰减参数<em>β</em>是计算梯度的指数加权平均数，并利用该值来更新参数，设置为 0.9 是一个常见且效果不错的选择；</p>
</li>
<li>
<p>最后，<strong>Adam优化器的超参数、权重衰减系数、丢弃法比率（dropout）和网络参数</strong>。在这里说明下，这些参数重要性放在最后<strong>并不等价于这些参数不重要</strong>。而是表示这些参数在大部分实践中<strong>不建议过多尝试</strong>，例如Adam优化器中的<em>β1，β2，ϵ</em>，常设为 0.9、0.999、10−8就会有不错的表现。权重衰减系数通常会有个建议值，例如0.0005 ，使用建议值即可，不必过多尝试。dropout通常会在全连接层之间使用防止过拟合，建议比率控制在[0.2,0.5]之间。使用dropout时需要特别注意两点：一、在RNN中，如果直接放在memory cell中,循环会放大噪声，扰乱学习。一般会建议放在输入和输出层；二、不建议dropout后直接跟上batchnorm，dropout很可能影响batchnorm计算统计量，导致方差偏移，这种情况下会使得推理阶段出现模型完全垮掉的极端情况；网络参数通常也属于超参数的范围内，通常情况下增加网络层数能增加模型的容限能力，但模型真正有效的容限能力还和样本数量和质量、层之间的关系等有关，所以一般情况下会选择先固定网络层数，调优到一定阶段或者有大量的硬件资源支持可以在网络深度上进行进一步调整。</p>
</li>
</ul>
<h3 id="14-2-5-部分超参数如何影响模型性能？">14.2.5 部分超参数如何影响模型性能？</h3>
<table>
<thead>
<tr>
<th style="text-align:center">超参数</th>
<th style="text-align:center">如何影响模型容量</th>
<th style="text-align:center">原因</th>
<th style="text-align:center">注意事项</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">学习率</td>
<td style="text-align:center">调至最优，提升有效容量</td>
<td style="text-align:center">过高或者过低的学习率，都会由于优化失败而导致降低模型有效容限</td>
<td style="text-align:center">学习率最优点，在训练的不同时间点都可能变化，所以需要一套有效的学习率衰减策略</td>
</tr>
<tr>
<td style="text-align:center">损失函数部分超参数</td>
<td style="text-align:center">调至最优，提升有效容量</td>
<td style="text-align:center">损失函数超参数大部分情况都会可能影响优化，不合适的超参数会使即便是对目标优化非常合适的损失函数同样难以优化模型，降低模型有效容限。</td>
<td style="text-align:center">对于部分损失函数超参数其变化会对结果十分敏感，而有些则并不会太影响。在调整时，建议参考论文的推荐值，并在该推荐值数量级上进行最大最小值调试该参数对结果的影响。</td>
</tr>
<tr>
<td style="text-align:center">批样本数量</td>
<td style="text-align:center">过大过小，容易降低有效容量</td>
<td style="text-align:center">大部分情况下，选择适合自身硬件容量的批样本数量，并不会对模型容限造成。</td>
<td style="text-align:center">在一些特殊的目标函数的设计中，如何选择样本是很可能影响到模型的有效容限的，例如度量学习（metric learning）中的N-pair loss。这类损失因为需要样本的多样性，可能会依赖于批样本数量。</td>
</tr>
<tr>
<td style="text-align:center">丢弃法</td>
<td style="text-align:center">比率降低会提升模型的容量</td>
<td style="text-align:center">较少的丢弃参数意味着模型参数量的提升，参数间适应性提升，模型容量提升，但不一定能提升模型有效容限</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">权重衰减系数</td>
<td style="text-align:center">调至最优，提升有效容量</td>
<td style="text-align:center">权重衰减可以有效的起到限制参数变化的幅度，起到一定的正则作用</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">优化器动量</td>
<td style="text-align:center">调至最优，可能提升有效容量</td>
<td style="text-align:center">动量参数通常用来加快训练，同时更容易跳出极值点，避免陷入局部最优解。</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">模型深度</td>
<td style="text-align:center">同条件下，深度增加，模型容量提升</td>
<td style="text-align:center">同条件，下增加深度意味着模型具有更多的参数，更强的拟合能力。</td>
<td style="text-align:center">同条件下，深度越深意味着参数越多，需要的时间和硬件资源也越高。</td>
</tr>
<tr>
<td style="text-align:center">卷积核尺寸</td>
<td style="text-align:center">尺寸增加，模型容量提升</td>
<td style="text-align:center">增加卷积核尺寸意味着参数量的增加，同条件下，模型参数也相应的增加。</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h3 id="14-2-6-部分超参数合适的范围">14.2.6 部分超参数合适的范围</h3>
<table>
<thead>
<tr>
<th style="text-align:center">超参数</th>
<th style="text-align:center">建议范围</th>
<th style="text-align:center">注意事项</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">初始学习率</td>
<td style="text-align:center">SGD: [1e-2, 1e-1]<br>momentum: [1e-3, 1e-2]<br>Adagrad: [1e-3, 1e-2]<br>Adadelta: [1e-2, 1e-1]<br>RMSprop: [1e-3, 1e-2]<br>Adam: [1e-3, 1e-2]<br>Adamax: [1e-3, 1e-2]<br>Nadam: [1e-3, 1e-2]</td>
<td style="text-align:center">这些范围通常是指从头开始训练的情况。若是微调，初始学习率可在降低一到两个数量级。</td>
</tr>
<tr>
<td style="text-align:center">损失函数部分超参数</td>
<td style="text-align:center">多个损失函数之间，损失值之间尽量相近，不建议超过或者低于两个数量级</td>
<td style="text-align:center">这是指多个损失组合的情况，不一定完全正确。单个损失超参数需结合实际情况。</td>
</tr>
<tr>
<td style="text-align:center">批样本数量</td>
<td style="text-align:center">[1:1024]</td>
<td style="text-align:center">当批样本数量过大(大于6000)或者等于1时，需要注意学习策略或者内部归一化方式的调整。</td>
</tr>
<tr>
<td style="text-align:center">丢弃法比率</td>
<td style="text-align:center">[0, 0.5]</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">权重衰减系数</td>
<td style="text-align:center">[0, 1e-4]</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">卷积核尺寸</td>
<td style="text-align:center">[7x7],[5x5],[3x3],[1x1], [7x1,1x7]</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h2 id="14-3-网络训练中的超参调整策略">14.3 网络训练中的超参调整策略</h2>
<h3 id="14-3-1-如何调试模型？">14.3.1 如何调试模型？</h3>
<p>在讨论如何调试模型之前，我们先来纠正一个误区。通常理解如何调试模型的时候，我们想到一系列优秀的神经网络模型以及调试技巧。但这里需要指出的是数据才是模型的根本，如果有一批质量优秀的数据，或者说你能将数据质量处理的很好的时候，往往比挑选或者设计模型的收益来的更大。那在这之后才是模型的设计和挑选以及训练技巧上的事情。</p>
<p>1、探索和清洗数据。探索数据集是设计算法之前最为重要的一步，以图像分类为例，我们需要重点知道给定的数据集样本类别和各类别样本数量是否平衡，图像之间是否存在跨域问题（例如网上爬取的图像通常质量各异，存在噪声）。若是类别数远远超过类别样本数（比如类别10000，每个类别却只有10张图像），那通常的方法可能效果并不显著，这时候few-shot learning或者对数据集做进一步增强可能是你比较不错的选择。再如目标检测，待检测目标在数据集中的尺度范围是对检测器的性能有很大影响的部分。因此重点是检测大目标还是小目标、目标是否密集完全取决于数据集本身。所以，探索和进一步清洗数据集一直都是深度学习中最重要的一步。这是很多新手通常会忽略的一点。</p>
<p>2、探索模型结果。探索模型的结果，通常是需要对模型在验证集上的性能进行进一步的分析，这是如何进一步提升模型性能很重要的步骤。将模型在训练集和验证集都进行结果的验证和可视化，可直观的分析出模型是否存在较大偏差以及结果的正确性。以图像分类为例，若类别间样本数量很不平衡时，我们需要重点关注少样本类别在验证集的结果是否和训练集的出入较大，对出错类别可进一步进行模型数值分析以及可视化结果分析，进一步确认模型的行为。</p>
<p>3、监控训练和验证误差。首先很多情况下，我们忽略代码的规范性和算法撰写正确性验证，这点上容易产生致命的影响。在训练和验证都存在问题时，首先请确认自己的代码是否正确。其次，根据训练和验证误差进一步追踪模型的拟合状态。若训练数据集很小，此时监控误差则显得格外重要。确定了模型的拟合状态对进一步调整学习率的策略的选择或者其他有效超参数的选择则会更得心应手。</p>
<p>4、反向传播数值的计算，这种情况通常适合自己设计一个新操作的情况。目前大部分流行框架都已包含自动求导部分，但并不一定是完全符合你的要求的。验证求导是否正确的方式是比较自动求导的结果和有限差分计算结果是否一致。所谓有限差分即导数的定义，使用一个极小的值近似导数。</p>
 $$
f^{'}(x_0) = \lim_{n\rightarrow0}\frac{\Delta y}{\Delta x} = \lim_{n\rightarrow0}\frac{f(x_0+\Delta x -f(x_0))}{\Delta x}
$$ 
<h3 id="14-3-2-为什么要做学习率调整">14.3.2 为什么要做学习率调整?</h3>
<p>​	学习率可以说是模型训练最为重要的超参数。通常情况下，一个或者一组优秀的学习率既能加速模型的训练，又能得到一个较优甚至最优的精度。过大或者过小的学习率会直接影响到模型的收敛。我们知道，当模型训练到一定程度的时候，损失将不再减少，这时候模型的一阶梯度接近零，对应Hessian 矩阵通常是两种情况，一、正定，即所有特征值均为正，此时通常可以得到一个局部极小值，若这个局部极小值接近全局最小则模型已经能得到不错的性能了，但若差距很大，则模型性能还有待于提升，通常情况下后者在训练初最常见。二，特征值有正有负，此时模型很可能陷入了鞍点，若陷入鞍点，模型性能表现就很差。以上两种情况在训练初期以及中期，此时若仍然以固定的学习率，会使模型陷入左右来回的震荡或者鞍点，无法继续优化。所以，学习率衰减或者增大能帮助模型有效的减少震荡或者逃离鞍点。</p>
<h3 id="14-3-3-学习率调整策略有哪些？">14.3.3 学习率调整策略有哪些？</h3>
<p>通常情况下，大部分学习率调整策略都是衰减学习率，但有时若增大学习率也同样起到奇效。这里结合TensorFlow的内置方法来举例。</p>
<p>1、<strong>exponential_decay</strong>和<strong>natural_exp_decay</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exponential_decay(learning_rate, global_step, decay_steps, decay_rate,</span><br><span class="line">                   staircase=<span class="literal">False</span>, name=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">natural_exp_decay(learning_rate, global_step, decay_steps, decay_rate,</span><br><span class="line">                   staircase=<span class="literal">False</span>, name=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>指数衰减是最常用的衰减方式，这种方式简单直接，在训练初期衰减较大利于收敛，在后期衰减较小利于精调。以上两种均为指数衰减，区别在于后者使用以自然指数下降。</p>
<p><img src="img%5Cch14%5C%E6%8C%87%E6%95%B0%E8%A1%B0%E5%87%8F.jpeg" alt="./"></p>
<p>2、<strong>piecewise_constant</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">piecewise_constant(x, boundaries, values, name=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>分段设置学习率法，跟指数型类似，区别在于每个阶段的衰减并不是按指数调整。可在不同阶段设置手动不同的学习率。这种学习率重点在有利于精调。</p>
<p>3、<strong>polynomial_decay</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">polynomial_decay(learning_rate, global_step, decay_steps,</span><br><span class="line">                  end_learning_rate=<span class="number">0.0001</span>, power=<span class="number">1.0</span>,</span><br><span class="line">                  cycle=<span class="literal">False</span>, name=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>多项式衰减，计算如下：</p>
 $$
global setp = min(global step, decay steps)
$$ 
 $$
lr_{decayed} = (lr-lr_{end})*(1-{globalstep\over decaysteps})^{power} +lr_{end}
$$ 
<p>有别于上述两种，多项式衰减则是在每一步迭代上都会调整学习率。主要看Power参数，若Power为1，则是下图中的红色直线；若power小于1，则是开1/power次方，为蓝色线；绿色线为指数，power大于1。</p>
<p><img src="img%5Cch14%5C%E5%A4%9A%E9%A1%B9%E5%BC%8F%E8%A1%B0%E5%87%8F.jpeg" alt></p>
<p>此外，需要注意的是参数cycle，cycle对应的是一种周期循环调整的方式。这种cycle策略主要目的在后期防止在一个局部极小值震荡，若跳出该区域或许能得到更有的结果。这里说明cycle的方式不止可以在多项式中应用，可配合类似的周期函数进行衰减，如下图。</p>
<p><img src="img%5Cch14%5Ccycle%E8%A1%B0%E5%87%8F.jpeg" alt></p>
<p>4、<strong>inverse_time_decay</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inverse_time_decay(learning_rate, global_step, decay_steps, decay_rate,</span><br><span class="line">                   staircase=<span class="literal">False</span>, name=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>逆时衰减，这种方式和指数型类似。如图，<img src="img%5Cch14%5C%E9%80%86%E6%97%B6%E8%A1%B0%E5%87%8F.jpeg" alt></p>
<p>5、<strong>cosine_decay</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cosine_decay(learning_rate, global_step, decay_steps, alpha=<span class="number">0.0</span>,</span><br><span class="line">                 name=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>余弦衰减，即按余弦函数的方式衰减学习率，如图</p>
<p><img src="img%5Cch14%5C%E4%BD%99%E5%BC%A6%E8%A1%B0%E5%87%8F.jpeg" alt></p>
<p>6、<strong>cosine_decay_restarts</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cosine_decay_restarts(learning_rate, global_step, first_decay_steps,</span><br><span class="line">                           t_mul=<span class="number">2.0</span>, m_mul=<span class="number">1.0</span>, alpha=<span class="number">0.0</span>, name=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>余弦衰减，即余弦版本的cycle策略，作用与多项式衰减中的cycle相同。区别在于余弦重启衰减会重新回到初始学习率，拉长周期，而多项式版本则会逐周期衰减。</p>
<p><img src="img%5Cch14%5C%E4%BD%99%E5%BC%A6cycle%E8%A1%B0%E5%87%8F.jpeg" alt></p>
<p>7、<strong>linear_cosine_decay</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">linear_cosine_decay(learning_rate, global_step, decay_steps,</span><br><span class="line">                        num_periods=<span class="number">0.5</span>, alpha=<span class="number">0.0</span>, beta=<span class="number">0.001</span>,</span><br><span class="line">                        name=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>线性余弦衰减，主要应用于增强学习领域。</p>
<p><img src="img%5Cch14%5C%E7%BA%BF%E6%80%A7%E4%BD%99%E5%BC%A6%E8%A1%B0%E5%87%8F.jpeg" alt></p>
<p>8、<strong>noisy_linear_cosine_decay</strong></p>
<p>噪声线性余弦衰减，即在线性余弦衰减中加入随机噪声，增大寻优的随机性。</p>
<p><img src="img%5Cch14%5C%E5%99%AA%E5%A3%B0%E7%BA%BF%E6%80%A7%E4%BD%99%E5%BC%A6%E8%A1%B0%E5%87%8F.jpeg" alt></p>
<h3 id="14-3-4-极端批样本数量下，如何训练网络？">14.3.4 极端批样本数量下，如何训练网络？</h3>
<p>​	极端批样本情况一般是指batch size为1或者batch size在6000以上的情况。这两种情况，在使用不合理的情况下都会导致模型最终性能无法达到最优甚至是崩溃的情况。</p>
<p>​	在目标检测、分割或者3D图像等输入图像尺寸较大的场景，通常batch size 会非常小。而在14.2.4中，我们已经讲到这种情况会导致梯度的不稳定以及batchnorm统计的不准确。针对梯度不稳定的问题，通常不会太致命，若训练中发现梯度不稳定导致性能的严重降低时可采用累计梯度的策略，即每次计算完不反向更新，而是累计多次的误差后进行一次更新，这是一种在内存有限情况下实现有效梯度更新的一个策略。batch size过小通常对batchnorm的影响是最大的，若网络模型中存在batchnorm，batch size若只为1或者2时会对训练结果产生非常大的影响。这时通常有两种策略，一、若模型使用了预训练网络，可冻结预训练网络中batchnorm的模型参数，有效降低batch size引起的统计量变化的影响。二、在网络不是过深或者过于复杂时可直接移除batchnorm或者使用groupnorm代替batchnorm，前者不多阐释，后者是有FAIR提出的一种用于减少batch对batchnorm影响，其主要策略是先将特征在通道上进行分组，然后在组内进行归一化。即归一化操作上完全与batch size无关。这种groupnorm的策略被证实在极小批量网络训练上能达到较优秀的性能。当然这里也引入里group这个超参数，一般情况下建议不宜取group为1或者各通道单独为组的group数量，可结合实际网络稍加调试。</p>
<p>​	为了降低训练时间的成本，多机多卡的分布式系统通常会使用超大的batch size进行网络训练。同样的在14.2.4中，我们提到了超大batch size会带来梯度方向过于一致而导致的精度大幅度降低的问题。这时通常可采用层自适应速率缩放（LARS）算法。从理论认知上将，batch size增大会减少反向传播的梯度更新次数，但为了达到相同的模型效果，需要增大学习率。但学习率一旦增大，又会引起模型的不收敛。为了解决这一矛盾，LARS算法就在各层上自适应的计算一个本地学习率用于更新本层的参数，这样能有效的提升训练的稳定性。目前利用LARS算法，腾讯公司使用65536的超大batch size能将ResNet50在ImageNet在4分钟完成训练，而谷歌使用32768的batch size使用TPU能将该时间缩短至2分钟。</p>
<h2 id="14-4-合理使用预训练网络">14.4 合理使用预训练网络</h2>
<h3 id="14-4-1-什么是微调（fine-tune）">14.4.1 什么是微调（fine-tune）</h3>
<p>​	微调（fine-tune），顾名思义指稍微调整参数即可得到优秀的性能，是迁移学习的一种实现方式。微调和从头训练（train from scratch）的本质区别在于模型参数的初始化，train from scratch通常指对网络各类参数进行随机初始化（当然随机初始化也存在一定技巧），随机初始化模型通常不具有任何预测能力，通常需要大量的数据或者特定域的数据进行从零开始的训练，这样需要训练到优秀的模型通常是稍困难的。而微调的网络，网络各类参数已经在其他数据集（例如ImageNet数据集）完成较好调整的，具备了较优秀的表达能力。因此，我们只需要以较小的学习速率在自己所需的数据集领域进行学习即可得到较为优秀的模型。微调通常情况下，无须再重新设计网络结构，预训练模型提供了优秀的结构，只需稍微修改部分层即可。在小数据集上，通常微调的效果比从头训练要好很多，原因在于数据量较小的前提下，训练更多参数容易导致过度拟合。</p>
<h3 id="14-4-2-微调有哪些不同方法？">14.4.2 微调有哪些不同方法？</h3>
<p>​	以图像分类为例，通常情况下由于不同数据集需要的类别数不同，我们需要修改网络的输出顶层。这种情况下有两种微调方式：</p>
<ul>
<li>
<p>不冻结网络模型的任何层，对最后的改动层使用较大的学习率，对未改动层以较小的学习率进行训练全模型训练，进行多轮训练即可。即一步完成训练。</p>
</li>
<li>
<p>冻结除了顶部改动层以外的所有层参数，即不对冻结部分的层进行参数训练更新，进行若干轮的微调训练后，放开顶部层以下的若干层或者全部放开所有层的参数，再次进行若干轮训练即可。即分多步训练。</p>
<p>以上两种都属于微调。目前由于存在大量优秀的预训练模型，如何确定哪个模型适合自己的任务并能得到最佳性能需要花大量的时间探索。此时，上述的前者是种不错训练方式，你无须进行过多分步的操作。而当探索到一个比较适合的模型时，你不妨可以再次重新尝试下以第二种方式进行训练，或许能得到相比于前者稍高些的性能，因为小数据集上调整过多的参数过拟合的机率也会增大，当然这并不是绝对的。</p>
</li>
</ul>
<h3 id="14-4-3-微调先冻结底层，训练顶层的原因？">14.4.3 微调先冻结底层，训练顶层的原因？</h3>
<p>​	14.12中第二种冻结多步训练的方式。首先冻结除了顶部改动层以外的所有层参数，对顶层进行训练，这个过程可以理解为顶层的域适应训练，主要用来训练适应模型的现有特征空间，防止顶层糟糕的初始化，对已经具备一定表达能力的层的干扰和破坏，影响最终的性能。之后，在很多深度学习框架教程中会使用放开顶层往下一半的层数，继续进行微调。这样的好处在于越底层的特征通常是越通用的特征，越往上其整体的高层次语义越完备，这通过感受野很容易理解。所以，若预训练模型的数据和微调训练的数据语义差异越大（例如ImageNet的预模型用于医学图像的训练），那越往顶层的特征语义差异就越大，因此通常也需要进行相应的调整。</p>
<h3 id="14-4-4-不同的数据集特性下如何微调？">14.4.4 不同的数据集特性下如何微调？</h3>
<ul>
<li>数据集数据量少，数据和原数据集类似。这是通常做法只需修改最后的输出层，训练即可，训练过多参数容易过拟合。</li>
<li>数据集数据量少，数据和原数据集差异较大。由于数据差异较大，可以在完成输出顶层的微调后，微调顶层往下一半的层数，进行微调。</li>
<li>数据集数据量大，数据与原数据集差异较大。这种情况下，通常已经不需要用预训练模型进行微调，通常直接重新训练即可。</li>
<li>数据集数据量大，数据与原数据类似。这时预训练模型的参数是个很好的初始化，可利用预训练模型放开所有层以较小的学习率微调即可。</li>
</ul>
<h3 id="14-4-4-目标检测中使用预训练模型的优劣？">14.4.4 目标检测中使用预训练模型的优劣？</h3>
<p>​	目标检测中无论是一阶段的YOLO、SSD或者RetinaNet 还是二阶段的Faster R-CNN、R-FCN 和 FPN都是基于ImageNet上预训练好的分类模型。</p>
<p>​	优势在于：</p>
<p>​	1、正如大部分微调的情况一样，使用预训练网络已拥有优秀的语义特征，能有效的加快训练速度；</p>
<p>​	2、其次，对于大部分二阶段的模型来说，并未实现严格意义上的完全端对端的训练，所以使用预训练模型能直接提取到语义特征，能使两个阶段的网络更容易实现模型的优化。</p>
<p>​	劣势在于，分类模型和检测模型之间仍然存在一定任务上的差异：</p>
<p>​	1、分类模型大部分训练于单目标数据，对同时进行多目标的捕捉能力稍弱，且不关注目标的位置，在一定程度上让模型损失部分空间信息，这对检测模型通常是不利的；</p>
<p>​	2、域适应问题，若预训练模型（ImageNet）和实际检测器的使用场景（医学图像，卫星图像）差异较大时，性能会受到影响；</p>
<p>​	3、使用预训练模型就意味着难以自由改变网络结构和参数限制了应用场合。</p>
<h3 id="14-4-5-目标检测中如何从零开始训练-train-from-scratch-？">14.4.5 目标检测中如何从零开始训练(train from scratch)？</h3>
<p>​	结合FAIR相关的研究，我们可以了解目标检测和其他任务从零训练模型一样，只要拥有足够的数据以及充分而有效的训练，同样能训练出不亚于利用预训练模型的检测器。这里我们提供如下几点建议：</p>
<p>​	1、数据集不大时，同样需要进行数据集增强。</p>
<p>​	2、预训练模型拥有更好的初始化，train from scratch需要更多的迭代次数以及时间训练和优化检测器。而二阶段模型由于并不是严格的端对端训练，此时可能需要更多的迭代次数以及时间，而一阶段检测模型训练会相对更容易些（例如DSOD以ScratchDet及）。</p>
<p>​	3、目标检测中train from scratch最大的问题还是batch size过小。所以可采取的策略是增加GPU使用异步batchnorm增大batch size，若条件限制无法使用更多GPU时，可使用groupnorm代替batchnorm</p>
<p>​	4、由于分类模型存在对多目标的捕捉能力弱以及对物体空间位置信息不敏感等问题，可借鉴DetNet训练一个专属于目标检测的模型网络，增强对多目标、尺度和位置拥有更强的适应性。</p>
<h2 id="14-5-如何改善-GAN-的性能">14.5 如何改善 GAN 的性能</h2>
<p>优化GAN性能通常需要在如下几个方面进行</p>
<ul>
<li>设计或选择更适合目的代价函数。</li>
<li>添加额外的惩罚。</li>
<li>避免判别器过度自信和生成器过度拟合。</li>
<li>更好的优化模型的方法。</li>
<li>添加标签明确优化目标。</li>
</ul>
<p>GAN常用训练技巧</p>
<ul>
<li>
<p>输入规范化到（-1，1）之间，最后一层的激活函数使用tanh（BEGAN除外）</p>
</li>
<li>
<p>使用wassertein GAN的损失函数，</p>
</li>
<li>
<p>如果有标签数据的话，尽量使用标签，也有人提出使用反转标签效果很好，另外使用标签平滑，单边标签平滑或者双边标签平滑</p>
</li>
<li>
<p>使用mini-batch norm， 如果不用batch norm 可以使用instance norm 或者weight norm</p>
</li>
<li>
<p>避免使用RELU和pooling层，减少稀疏梯度的可能性，可以使用leakrelu激活函数</p>
</li>
<li>
<p>优化器尽量选择ADAM，学习率不要设置太大，初始1e-4可以参考，另外可以随着训练进行不断缩小学习率，</p>
</li>
<li>
<p>给D的网络层增加高斯噪声，相当于是一种正则</p>
</li>
</ul>
<h2 id="14-6-AutoML">14.6 AutoML</h2>
<h3 id="14-6-1-什么是AutoML？">14.6.1 什么是AutoML？</h3>
<p>​	目前一个优秀的机器学习和深度学习模型，离不开这几个方面：</p>
<p>​	一、优秀的数据预处理；</p>
<p>​	二、合适的模型结构和功能；</p>
<p>​	三、优秀的训练策略和超参数；</p>
<p>​	四、合适的后处理操作；</p>
<p>​	五、严格的结果分析。</p>
<p>​	这几方面都对最终的结果有着举足轻重的影响，这也是目前的数据工程师和学者们的主要工作。但由于这每一方面都十分繁琐，尤其是在构建模型和训练模型上。而大部分情况下，这些工作有无须过深专业知识就能使用起来。所以AutoML主要的作用就是来帮助实现高效的模型构建和超参数调整。例如深度学习网络的架构搜索、超参数的重要性分析等等。当然AutoML并不简单的进行暴力或者随机的搜索，其仍然需要机器学习方面的知识，例如贝叶斯优化、强化学习、元学习以及迁移学习等等。目前也有些不错的AutoML工具包，例如Alex Honchar的Hyperopt、微软的NNI、Autokeras等。</p>
<p>目前AutoML已经成为最新的研究热点，有兴趣的可以参考<a target="_blank" rel="noopener" href="https://www.automl.org/automl/literature-on-neural-architecture-search/">AutoML literature</a>。</p>
<h3 id="14-6-2-自动化超参数搜索方法有哪些？">14.6.2 自动化超参数搜索方法有哪些？</h3>
<p>​	目前自动化搜索主要包含网格搜索，随机搜索，基于模型的超参优化</p>
<p>​	网格搜索：</p>
<p>​		通常当超参数量较少的时候，可以使用网格搜索法。即列出每个超参数的大致候选集合。利用这些集合		进行逐项组合优化。在条件允许的情况下，重复进行网格搜索会当优秀，当然每次重复需要根据上一步得到的最优参数组合，进行进一步的细粒度的调整。网格搜索最大的问题就在于计算时间会随着超参数的数量指数级的增长。</p>
<p>​	随机搜索：</p>
<p>​		随机搜索，是一种用来替代网格搜索的搜索方式。随机搜索有别于网格搜索的一点在于，我们不需要设定一个离散的超参数集合，而是对每个超参数定义一个分布函数来生成随机超参数。随机搜索相比于网格搜索在一些不敏感超参上拥有明显优势。例如网格搜索对于批样本数量（batch size），在[16,32,64]这些范围内进行逐项调试，这样的调试显然收益更低下。当然随机搜索也可以进行细粒度范围内的重复的搜索优化。</p>
<p><img src="img%5Cch14%5C14.14.png" alt></p>
<p>​	基于模型的超参优化：</p>
<p>​		有别于上述两种的搜索策略，基于模型的超参调优问题转化为了优化问题。直觉上会考虑是否进行一个可导建模，然后利用梯度下降进行优化。但不幸的是我们的超参数通常情况下是离散的，而且其计算代价依旧很高。</p>
<p>​		基于模型的搜索算法，最常见的就是贝叶斯超参优化。有别于的网格搜索和随机搜索独立于前几次搜索结果的搜索，贝叶斯则是利用历史的搜索结果进行优化搜索。其主要有四部分组成，1.目标函数，大部分情况下就是模型验证集上的损失。2、搜索空间，即各类待搜索的超参数。3、优化策略，建立的概率模型和选择超参数的方式。4、历史的搜索结果。首先对搜索空间进行一个先验性的假设猜想，即假设一种选择超参的方式，然后不断的优化更新概率模型，最终的目标是找到验证集上误差最小的一组超参数。</p>
<h3 id="14-6-3-什么是神经网络架构搜索（NAS）">14.6.3 什么是神经网络架构搜索（NAS）</h3>
<p>2015至2017年间，是CNN网络设计最兴盛的阶段，大多都是由学者人工设计的网络结构。这个过程通常会很繁琐。其主要原因在于对不同模块组件的组成通常是个黑盒优化的问题，此外，在不同结构超参数以及训练超参数的选择优化上非凸优化问题，或者是个混合优化问题，既有离散空间又有连续空间。NAS（Neural Architecture Search）的出现就是为了解决如何通过机器策略和自动化的方式设计出优秀高效的网络。而这种策略通常不是统一的标准，不同的网络结合实际的需求通常会有不同的设计，比如移动端的模型会在效率和精度之间做平衡。目前，NAS也是AUTOML中最重要的部分。NAS通常会分为三个方面，搜索空间（在哪搜索），搜索策略（如何搜索）及评价预估。</p>
<ul>
<li>
<p>搜索空间，即在哪搜索，定义了优化问题所需变量。不同规模的搜索空间的变量其对于的难度也是不一样的。早期由于网络结构以及层数相对比较简单，参数量较少，因此会更多的使用遗传算法等进化算法对网络的超参数和权重进行优化。深度学习发展到目前，模型网络结构越来越复杂，参数量级越来越庞大，这些进化算法已经无法继续使用。但若我们先验给定一些网络结构和超参数，模型的性能已经被限制在给定的空间，此时搜索的空间已变得有限，所以只需对复杂模型的架构参数和对应的超参数进行优化即可。</p>
</li>
<li>
<p>搜索策略， 即如何搜索，定义了如何快速、准确找到最优的网络结构参数配置的策略。常见的搜索方法包括：随机搜索、贝叶斯优化、强化学习、进化算法以及基于模型的搜索算法。其中主要代表为2017年谷歌大脑的使用强化学习的搜索方法。</p>
</li>
<li>
<p>评价预估，定义了如何高效对搜索的评估策略。深度学习中，数据规模往往是庞大的，模型要在如此庞大的数据规模上进行搜索，这无疑是非常耗时的，对优化也会造成非常大的困难，所以需要一些高效的策略做近似的评估。 这里一般会有如下三种思路：</p>
<p>一、使用些低保真的训练集来训练模型。低保真在实际中可以用不同的理解，比如较少的迭代次数，用一小部分数据集或者保证结构的同时减少通道数等。这些方法都可以在测试优化结构时大大降低计算时间，当然也会存在一定的偏差。但架构搜索从来并不是要一组固定的参数，而是一种优秀的模型结构。最终选取时，只需在较优秀的几组结构中进行全集训练，进行择优选取即可。</p>
<p>二、使用代理模型。除了低保真的训练方式外，学者们提出了一种叫做代理模型的回归模型，采用例如插值等策略对已知的一些参数范围进行预测，目的是为了用尽可能少的点预测到最佳的结果。</p>
<p>三、参数级别的迁移。例如知识蒸馏等。用已训练好的模型权重参数对目标问题搜索，通常会让搜索拥有一个优秀的起点。由于积累了大量的历史寻优数据，对新问题的寻优将会起到很大的帮助。</p>
</li>
</ul>
<h3 id="14-6-4-NASNet的设计策略">14.6.4 NASNet的设计策略</h3>
<p>NASNet是最早由google brain 通过网络架构搜索策略搜索并成功训练ImageNet的网络，其性能超越所有手动设计的网络模型。关于NASNet的搜索策略，首先需要参考google brain发表在ICLR2017的论文《Neural Architecture Search with Reinforcement Learning》。该论文是最早成功通过架构搜索策略在cifar-10数据集上取得比较不错效果的工作。NASNet很大程度上是沿用该搜索框架的设计思想。</p>
<p>NASNet的核心思想是利用强化学习对搜索空间内的结构进行反馈探索。架构搜索图如下，定义了一个以RNN为核心的搜索控制器。在搜索空间以概率p对模型进行搜索采样。得到网络模型A后，对该模型进行训练，待模型收敛得到设定的准确率R后，将梯度传递给控制器RNN进行梯度更新。</p>
<p><img src="img%5Cch14%5CNAS%E6%90%9C%E7%B4%A2%E7%AD%96%E7%95%A5.png" alt></p>
<p>​									架构搜索策略流程</p>
<p>RNN控制器会对卷积层的滤波器的尺寸、数量以及滑动间隔进行预测。每次预测的结果都会作为下一级的输入，档层数达到设定的阈值时，会停止预测。而这个阈值也会随着训练的进行而增加。这里的控制器之预测了卷积，并没有对例如inception系列的分支结构或者ResNet的跳级结构等进行搜索。所以，控制器需要进一步扩展到预测这些跳级结构上，这样搜索空间相应的也会增大。为了预测这些结构，RNN控制器内每一层都增加了一个预测跳级结构的神经元，文中称为锚点，稍有不同的是该锚点的预测会由前面所有层的锚点状态决定。</p>
<p><img src="img%5Cch14%5CRNN%E6%8E%A7%E5%88%B6%E5%99%A8.png" alt></p>
<p>​									RNN控制器</p>
<p>NASNet大体沿用了上述生成网络结构的机器，并在此基础上做了如下两点改进：</p>
<p>1、先验行地加入inception系列和ResNet的堆叠模块的思想。其定义了两种卷积模块，Normal Cell和Reduction Cell，前者不进行降采样，而后者是个降采样的模块。而由这两种模块组成的结构可以很方便的通过不同数量的模块堆叠将其从小数据集搜索到的架构迁移到大数据集上，大大提高了搜索效率。</p>
<p><img src="img%5Cch14%5CNASNet%E7%9A%84RNN%E6%8E%A7%E5%88%B6%E5%99%A8.png" alt></p>
<p>​									NASNet的RNN控制器</p>
<p>2、对RNN控制进行优化，先验性地将各种尺寸和类型的卷积和池化层加入到搜索空间内，用预测一个卷积模块代替原先预测一层卷积。如图，控制器RNN不在预测单个卷积内的超参数组成，而是对一个模块内的每一个部分进行搜索预测，搜索的空间则限定在如下这些操作中：</p>
<p>​						• identity					  • 1x3 then 3x1 convolution<br>
​						• 1x7 then 7x1 convolution	  • 3x3 dilated convolution<br>
​						• 3x3 average pooling 			  • 3x3 max pooling<br>
​						• 5x5 max pooling			  • 7x7 max pooling<br>
​						• 1x1 convolution				  • 3x3 convolution<br>
​						• 3x3 depthwise-separable conv • 5x5 depthwise-seperable conv<br>
​						• 7x7 depthwise-separable conv</p>
<p>在模块内的连接方式上也提供了element-wise addition和concatenate两种方式。NASNet的搜索方式和过程对NAS的一些后续工作都具有非常好的参考借鉴意义。</p>
<h3 id="14-6-5-网络设计中，为什么卷积核设计尺寸都是奇数">14.6.5 网络设计中，为什么卷积核设计尺寸都是奇数</h3>
<p>我们发现在很多大部分网络设计时都会使用例如3x3/5x5/7x7等奇数尺寸卷积核，主要原因有两点：</p>
<ul>
<li>保证像素点中心位置，避免位置信息偏移</li>
<li>填充边缘时能保证两边都能填充，原矩阵依然对称</li>
</ul>
<h3 id="14-6-6-网络设计中，权重共享的形式有哪些，为什么要权重共享">14.6.6 网络设计中，权重共享的形式有哪些，为什么要权重共享</h3>
<p>权重共享的形式：</p>
<ul>
<li>深度学习中，权重共享最具代表性的就是卷积网络的卷积操作。卷积相比于全连接神经网络参数大大减少；</li>
<li>多任务网络中，通常为了降低每个任务的计算量，会共享一个骨干网络。</li>
<li>一些相同尺度下的结构化递归网络</li>
</ul>
<p>权重共享的好处：</p>
<p>​	权重共享一定程度上能增强参数之间的联系，获得更好的共性特征。同时很大程度上降低了网络的参数，节省计算量和计算所需内存（当然，结构化递归并不节省计算量）。此外权重共享能起到很好正则的作用。正则化的目的是为了降低模型复杂度，防止过拟合，而权重共享则正好降低了模型的参数和复杂度。</p>
<p>​	因此一个设计优秀的权重共享方式，在降低计算量的同时，通常会较独享网络有更好的效果。</p>
<p>权重共享不仅在人工设计（human-invented）的网络结构中有简化参数，降低模型复杂度的作用，在神经网络搜索（NAS）的网络结构中可以使得child model的计算效率提升，使得搜索过程可以在单卡GPU上复现，见Efficient NAS(<a target="_blank" rel="noopener" href="https://arxiv.org/abs/1802.03268">ENAS</a>)。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/19/deep_learning/ch13/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tom">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="算法工程师的日常">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/19/deep_learning/ch13/" class="post-title-link" itemprop="url">优化算法面试题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-19 23:29:20" itemprop="dateCreated datePublished" datetime="2024-03-19T23:29:20+08:00">2024-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-24 10:14:05" itemprop="dateModified" datetime="2024-03-24T10:14:05+08:00">2024-03-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">算法面试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">深度学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>优化算法</h1>
<h2 id="13-1-如何解决训练样本少的问题">13.1 如何解决训练样本少的问题</h2>
<p>目前大部分的深度学习模型仍然需要海量的数据支持。例如 ImageNet 数据就拥有1400多万的图片。而现实生产环境中，数据集通常较小，只有几万甚至几百个样本。这时候，如何在这种情况下应用深度学习呢?<br>
（1）利用预训练模型进行迁移微调（fine-tuning），预训练模型通常在特征上拥有很好的语义表达。此时，只需将模型在小数据集上进行微调就能取得不错的效果。这也是目前大部分小数据集常用的训练方式。视觉领域内，通常会ImageNet上训练完成的模型。自然语言处理领域，也有BERT模型等预训练模型可以使用。<br>
  <br>
（2）单样本或者少样本学习（one-shot，few-shot learning），这种方式适用于样本类别远远大于样本数量的情况等极端数据集。例如有1000个类别，每个类别只提供1-5个样本。少样本学习同样也需要借助预训练模型，但有别于微调的在于，微调通常仍然在学习不同类别的语义，而少样本学习通常需要学习样本之间的距离度量。例如孪生网络（Siamese Neural Networks）就是通过训练两个同种结构的网络来判别输入的两张图片是否属于同一类。<br>
​	上述两种是常用训练小样本数据集的方式。此外，也有些常用的手段，例如数据集增强、正则或者半监督学习等方式来解决小样本数据集的训练问题。</p>
<h2 id="13-2-深度学习是否能胜任所有数据集">13.2 深度学习是否能胜任所有数据集?</h2>
<p>深度学习并不能胜任目前所有的数据环境，以下列举两种情况：</p>
<p>（1）深度学习能取得目前的成果，很大一部分原因依赖于海量的数据集以及高性能密集计算硬件。因此，当数据集过小时，需要考虑与传统机器学习相比，是否在性能和硬件资源效率更具有优势。<br>
（2）深度学习目前在视觉，自然语言处理等领域都有取得不错的成果。这些领域最大的特点就是具有局部相关性。例如图像中，人的耳朵位于两侧，鼻子位于两眼之间，文本中单词组成句子。这些都是具有局部相关性的，一旦被打乱则会破坏语义或者有不同的语义。所以当数据不具备这种相关性的时候，深度学习就很难取得效果。</p>
<h2 id="13-3-有没有可能找到比已知算法更好的算法">13.3 有没有可能找到比已知算法更好的算法?</h2>
<p>在最优化理论发展中，有个没有免费午餐的定律，其主要含义在于，在不考虑具体背景和细节的情况下，任何算法和随机猜的效果期望是一样的。即，没有任何一种算法能优于其他一切算法，甚至不比随机猜好。深度学习作为机器学习领域的一个分支同样符合这个定律。所以，虽然目前深度学习取得了非常不错的成果，但是我们同样不能盲目崇拜。</p>
<p>优化算法本质上是在寻找和探索更符合数据集和问题的算法，这里数据集是算法的驱动力，而需要通过数据集解决的问题就是算法的核心，任何算法脱离了数据都会没有实际价值，任何算法的假设都不能脱离实际问题。因此，实际应用中，面对不同的场景和不同的问题，可以从多个角度针对问题进行分析，寻找更优的算法。</p>
<h2 id="13-4-什么是共线性，如何判断和解决共线性问题">13.4 什么是共线性，如何判断和解决共线性问题?</h2>
<p>对于回归算法，无论是一般回归还是逻辑回归，在使用多个变量进行预测分析时，都可能存在多变量相关的情况，这就是多重共线性。共线性的存在，使得特征之间存在冗余，导致过拟合。</p>
<p>常用判断是否存在共线性的方法有：</p>
<p>（1）相关性分析。当相关性系数高于0.8，表明存在多重共线性；但相关系数低，并不能表示不存在多重共线性；</p>
<p>（2）方差膨胀因子VIF。当VIF大于5或10时，代表模型存在严重的共线性问题；</p>
<p>（3）条件系数检验。 当条件数大于100、1000时，代表模型存在严重的共线性问题。</p>
<p>通常可通过PCA降维、逐步回归法和LASSO回归等方法消除共线性。</p>
<h2 id="13-5-权值初始化方法有哪些？">13.5 权值初始化方法有哪些？</h2>
<p>在深度学习的模型中，从零开始训练时，权重的初始化有时候会对模型训练产生较大的影响。良好的初始化能让模型快速、有效的收敛，而糟糕的初始化会使得模型无法训练。</p>
<p>目前，大部分深度学习框架都提供了各类初始化方式，其中一般常用的会有如下几种：<br>
<strong>1. 常数初始化(constant)</strong></p>
<p>​	把权值或者偏置初始化为一个常数。例如设置为0，偏置初始化为0较为常见，权重很少会初始化为0。TensorFlow中也有zeros_initializer、ones_initializer等特殊常数初始化函数。</p>
<p><strong>2. 高斯初始化(gaussian)</strong></p>
<p>​	 给定一组均值和标准差，随机初始化的参数会满足给定均值和标准差的高斯分布。高斯初始化是很常用的初始化方式。特殊地，在TensorFlow中还有一种截断高斯分布初始化（truncated_normal_initializer），其主要为了将超过两个标准差的随机数重新随机，使得随机数更稳定。</p>
<p><strong>3. 均匀分布初始化(uniform)</strong></p>
<p>​	给定最大最小的上下限，参数会在该范围内以均匀分布方式进行初始化，常用上下限为（0，1）。</p>
<p><strong>4. xavier 初始化(uniform)</strong></p>
<p>​	在batchnorm还未出现之前，要训练较深的网络，防止梯度弥散，需要依赖非常好的初始化方式。xavier 就是一种比较优秀的初始化方式，也是目前最常用的初始化方式之一。其目的是为了使得模型各层的激活值和梯度在传播过程中的方差保持一致。本质上xavier 还是属于均匀分布初始化，但与上述的均匀分布初始化有所不同，xavier 的上下限将在如下范围内进行均匀分布采样：</p>
 $$
[-\sqrt{\frac{6}{n+m}},\sqrt{\frac{6}{n+m}}]
$$ 
<p>​	其中，n为所在层的输入维度，m为所在层的输出维度。</p>
<p><strong>6. kaiming初始化（msra 初始化）</strong></p>
<p>​	kaiming初始化，在caffe中也叫msra 初始化。kaiming初始化和xavier 一样都是为了防止梯度弥散而使用的初始化方式。kaiming初始化的出现是因为xavier存在一个不成立的假设。xavier在推导中假设激活函数都是线性的，而在深度学习中常用的ReLu等都是非线性的激活函数。而kaiming初始化本质上是高斯分布初始化，与上述高斯分布初始化有所不同，其是个满足均值为0，方差为2/n的高斯分布：</p>
 $$
[0,\sqrt{\frac{2}{n}}]
$$ 
<p>​	其中，n为所在层的输入维度。</p>
<p>除上述常见的初始化方式以外，不同深度学习框架下也会有不同的初始化方式，读者可自行查阅官方文档。</p>
<h2 id="13-5-如何防止梯度下降陷入局部最优解">13.5 如何防止梯度下降陷入局部最优解?</h2>
<p>梯度下降法(GD)及其一些变种算法是目前深度学习里最常用于求解凸优化问题的优化算法。神经网络很可能存在很多局部最优解，而非全局最优解。 为了防止陷入局部最优，通常会采用如下一些方法，当然，这并不能保证一定能找到全局最优解，或许能得到一个比目前更优的局部最优解也是不错的：</p>
<p><strong>（1）stochastic GD</strong> /<strong>Mini-Batch GD</strong></p>
<p>​	在GD算法中，每次的梯度都是从所有样本中累计获取的，这种情况最容易导致梯度方向过于稳定一致，且更新次数过少，容易陷入局部最优。而stochastic GD是GD的另一种极端更新方式，其每次都只使用一个样本进行参数更新，这样更新次数大大增加也就不容易陷入局部最优。但引出的一个问题的在于其更新方向过多，导致不易于进一步优化。Mini-Batch GD便是两种极端的折中，即每次更新使用一小批样本进行参数更新。Mini-Batch GD是目前最常用的优化算法，严格意义上Mini-Batch GD也叫做stochastic GD，所以很多深度学习框架上都叫做SGD。<br>
**（2）动量 **<br>
​	动量也是GD中常用的方式之一，SGD的更新方式虽然有效，但每次只依赖于当前批样本的梯度方向，这样的梯度方向依然很可能很随机。动量就是用来减少随机，增加稳定性。其思想是模仿物理学的动量方式，每次更新前加入部分上一次的梯度量，这样整个梯度方向就不容易过于随机。一些常见情况时，如上次梯度过大，导致进入局部最小点时，下一次更新能很容易借助上次的大梯度跳出局部最小点。</p>
<p>**（3）自适应学习率 **</p>
<p>​	无论是GD还是动量重点优化角度是梯度方向。而学习率则是用来直接控制梯度更新幅度的超参数。自适应学习率的优化方法有很多，例如Adagrad和RMSprop。两种自适应学习率的方式稍有差异，但主要思想都是基于历史的累计梯度去计算一个当前较优的学习率。</p>
<h2 id="13-7-为什么需要激活函数？">13.7 为什么需要激活函数？</h2>
<p>（1）非线性：即导数不是常数。这个条件是多层神经网络的基础，保证多层网络不退化成单层线性网络。这也是激活函数的意义所在。</p>
<p>（2）几乎处处可微：可微性保证了在优化中梯度的可计算性。传统的激活函数如sigmoid等满足处处可微。对于分段线性函数比如ReLU，只满足几乎处处可微（即仅在有限个点处不可微）。对于SGD算法来说，由于几乎不可能收敛到梯度接近零的位置，有限的不可微点对于优化结果不会有很大影响[1]。</p>
<p>（3）计算简单：非线性函数有很多。极端的说，一个多层神经网络也可以作为一个非线性函数，类似于Network In Network[2]中把它当做卷积操作的做法。但激活函数在神经网络前向的计算次数与神经元的个数成正比，因此简单的非线性函数自然更适合用作激活函数。这也是ReLU之流比其它使用Exp等操作的激活函数更受欢迎的其中一个原因。</p>
<p>（4）非饱和性（saturation）：饱和指的是在某些区间梯度接近于零（即梯度消失），使得参数无法继续更新的问题。最经典的例子是Sigmoid，它的导数在x为比较大的正值和比较小的负值时都会接近于0。更极端的例子是阶跃函数，由于它在几乎所有位置的梯度都为0，因此处处饱和，无法作为激活函数。ReLU在x&gt;0时导数恒为1，因此对于再大的正值也不会饱和。但同时对于x&lt;0，其梯度恒为0，这时候它也会出现饱和的现象（在这种情况下通常称为dying ReLU）。Leaky ReLU[3]和PReLU[4]的提出正是为了解决这一问题。</p>
<p>（5）单调性（monotonic）：即导数符号不变。这个性质大部分激活函数都有，除了诸如sin、cos等。个人理解，单调性使得在激活函数处的梯度方向不会经常改变，从而让训练更容易收敛。</p>
<p>（6）输出范围有限：有限的输出范围使得网络对于一些比较大的输入也会比较稳定，这也是为什么早期的激活函数都以此类函数为主，如Sigmoid、TanH。但这导致了前面提到的梯度消失问题，而且强行让每一层的输出限制到固定范围会限制其表达能力。因此现在这类函数仅用于某些需要特定输出范围的场合，比如概率输出（此时loss函数中的log操作能够抵消其梯度消失的影响[1]）、LSTM里的gate函数。</p>
<p>（7）接近恒等变换（identity）：即约等于x。这样的好处是使得输出的幅值不会随着深度的增加而发生显著的增加，从而使网络更为稳定，同时梯度也能够更容易地回传。这个与非线性是有点矛盾的，因此激活函数基本只是部分满足这个条件，比如TanH只在原点附近有线性区（在原点为0且在原点的导数为1），而ReLU只在x&gt;0时为线性。这个性质也让初始化参数范围的推导更为简单[5][4]。额外提一句，这种恒等变换的性质也被其他一些网络结构设计所借鉴，比如CNN中的ResNet[6]和RNN中的LSTM。</p>
<p>（8）参数少：大部分激活函数都是没有参数的。像PReLU带单个参数会略微增加网络的大小。还有一个例外是Maxout[7]，尽管本身没有参数，但在同样输出通道数下k路Maxout需要的输入通道数是其它函数的k倍，这意味着神经元数目也需要变为k倍；但如果不考虑维持输出通道数的情况下，该激活函数又能将参数个数减少为原来的k倍。</p>
<p>（9）归一化（normalization）：这个是最近才出来的概念，对应的激活函数是SELU[8]，主要思想是使样本分布自动归一化到零均值、单位方差的分布，从而稳定训练。在这之前，这种归一化的思想也被用于网络结构的设计，比如Batch Normalization[9]。</p>
<h2 id="13-6-常见的损失函数有哪些">13.6 常见的损失函数有哪些?</h2>
<p>机器学习通过对算法中的目标函数进行不断求解优化，得到最终想要的结果。分类和回归问题中，通常使用损失函数或代价函数作为目标函数。</p>
<p>损失函数用来评价预测值和真实值不一样的程度。通常损失函数越好，模型的性能也越好。</p>
<p>损失函数可分为<strong>经验风险损失</strong>和<strong>结构风险损失</strong>。经验风险损失是根据已知数据得到的损失。结构风险损失是为了防止模型被过度拟合已知数据而加入的惩罚项。</p>
<p>下面介绍常用的损失函数:<br>
<strong>（1）0-1 损失函数</strong><br>
  <br>
如果预测值和目标值相等，值为 0，如果不相等，值为 1：</p>
 $$
L(Y,f(x))=
\left\{
\begin{array}{}
1\;\;\;,\;\;Y\ne f(x), \\
0\;\;\;,\;\;Y=f(x).
\end{array}
\right.
$$ 
<p>  <br>
一般的在实际使用中，相等的条件过于严格，可适当放宽条件：</p>
 $$
L(Y,f(x))=
\left\{
\begin{array}{}
1\;\;\;,\;\;|Y - f(x)| \ge T, \\
0\;\;\;,\;\;|Y-f(x)| < T.
\end{array}
\right.
$$ 
<p>  <br>
<strong>（2）绝对值损失函数</strong><br>
  <br>
和 0-1 损失函数相似，绝对值损失函数表示为：</p>
 $$
L(Y,f(x))=|Y-f(x)|.
$$ 
<p>  <br>
<strong>（3）平方损失函数</strong></p>
 $$
L(Y|f(x))=\sum_{N}(Y-f(x))^2.
$$ 
<p>  <br>
这点可从最小二乘法和欧几里得距离角度理解。最小二乘法的原理是，最优拟合曲线应该 使所有点到回归直线的距离和最小。</p>
<p>  <br>
<strong>（4）log 对数损失函数</strong></p>
 $$
L(Y,P(Y|X))=-logP(Y|X).
$$ 
<p>  <br>
常见的逻辑回归使用的就是对数损失函数，有很多人认为逻辑回归的损失函数式平方损失， 其实不然。逻辑回归它假设样本服从伯努利分布，进而求得满足该分布的似然函数，接着取对 数求极值等。逻辑回归推导出的经验风险函数是最小化负的似然函数，从损失函数的角度看， 就是 log 损失函数。</p>
<p>  <br>
<strong>（5）指数损失函数</strong><br>
  <br>
指数损失函数的标准形式为：</p>
 $$
L(Y|f(x))=exp[-yf(x)].
$$ 
<p>  <br>
例如 AdaBoost 就是以指数损失函数为损失函数。</p>
<p>  <br>
<strong>（6）Hinge 损失函数</strong><br>
  <br>
Hinge 损失函数的标准形式如下：</p>
 $$
L(y)=max(0, 1-ty).
$$ 
<p>  <br>
其中 y 是预测值，范围为(-1,1), t 为目标值，其为-1 或 1。<br>
  <br>
在线性支持向量机中，最优化问题可等价于：</p>
 $$
\underset{w,b}{min}\sum_{i=1}^{N}(1-y_i(wx_i+b))+\lambda \lVert w^2 \rVert
$$ 
<p>  </p>
 $$
\frac{1}{m}\sum_{i=1}^{N}l(wx_i+by_i))+\lVert w^2 \rVert
$$ 
<p>  <br>
其中 $l(wx_i+by_i))$ 是Hinge损失函数， $\lVert w^2 \rVert$ 可看做为正则化项。</p>
<h2 id="13-7-如何进行特征选择-feature-selection">13.7 如何进行特征选择(feature selection)?</h2>
<h3 id="13-7-1-特征类型有哪些？">13.7.1 特征类型有哪些？</h3>
<p>对象本身会有许多属性。所谓特征，即能在某方面最能表征对象的一个或者一组属性。一般地，我们可以把特征分为如下三个类型：</p>
<p>（1）相关特征：对于特定的任务和场景具有一定帮助的属性，这些属性通常能有效提升算法性能；</p>
<p>（2）无关特征：在特定的任务和场景下完全无用的属性，这些属性对对象在本目标环境下完全无用；</p>
<p>（3）冗余特征：同样是在特定的任务和场景下具有一定帮助的属性，但这类属性已过多的存在，不具有产生任何新的信息的能力。</p>
<h3 id="13-7-2-如何考虑特征选择">13.7.2 如何考虑特征选择</h3>
<p>当完成数据预处理之后，对特定的场景和目标而言很多维度上的特征都是不具有任何判别或者表征能力的，所以需要对数据在维度上进行筛选。一般地，可以从以下两个方面考虑来选择特征:</p>
<p>（1）特征是否具有发散性：某个特征若在所有样本上的都是一样的或者接近一致，即方差非常小。 也就是说所有样本的都具有一致的表现，那这些就不具有任何信息。</p>
<p>（2）特征与目标的相关性：与目标相关性高的特征，应当优选选择。</p>
<h3 id="13-7-3-特征选择方法分类">13.7.3 特征选择方法分类</h3>
<p>根据特征选择的形式又可以将特征选择方法分为 3 种:<br>
（1）过滤法：按照发散性或者相关性对各个特征进行评分，设定阈值或者待选择阈值的个数，选择特征。</p>
<p>（2）包装法：根据目标函数(通常是预测效果评分)，每次选择若干特征，或者排除若干特征。</p>
<p>（3）嵌入法：先使用某些机器学习的算法和模型进行训练，得到各个特征的权值系数，根据系数从大到小选择特征。</p>
<h3 id="13-7-4-特征选择目的">13.7.4 特征选择目的</h3>
<p>（1）减少特征维度，使模型泛化能力更强，减少过拟合;</p>
<p>（2）降低任务目标的学习难度；</p>
<p>（3）一组优秀的特征通常能有效的降低模型复杂度，提升模型效率</p>
<h2 id="13-8-梯度消失-梯度爆炸原因，以及解决方法">13.8 梯度消失/梯度爆炸原因，以及解决方法</h2>
<h3 id="13-8-1-为什么要使用梯度更新规则">13.8.1 为什么要使用梯度更新规则?</h3>
<p>目前深度学习的火热，其最大的功臣之一就是反向传播。反向传播，即根据损失评价函数计算的误差，计算得到梯度，通过梯度反向传播的方式，指导深度网络权值的更新优化。这样做的原因在于，深层网络由许多非线性层堆叠而来，每一层非线性层都可以视为是一个非线性函数，因此整个深度网络可以视为是一个复合的非线性多元函数：</p>
 $$
F(x)=f_n(\cdots f_3(f_2(f_1(x)*\theta_1+b)*\theta_2+b)\cdots)
$$ 
<p>我们最终的目的是希望这个多元函数可以很好的完成输入到输出之间的映射，假设不同的输入，输出的最优解是g(x) ，那么，优化深度网络就是为了寻找到合适的权值，满足 Loss=L(g(x),F(x))取得极小值点，比如最简单的损失函数：</p>
 $$
Loss = \lVert g(x)-f(x) \rVert^2_2.
$$ 
<p>假设损失函数的数据空间是下图这样的，我们最优的权值就是为了寻找下图中的最小值点， 对于这种数学寻找最小值问题，采用梯度下降的方法再适合不过了。</p>
<p><img src="figure_13_15_1.png" alt></p>
<center>图 13.8.1 </center>
<h3 id="13-8-2-梯度消失-爆炸产生的原因">13.8.2 梯度消失/爆炸产生的原因?</h3>
<p>本质上，梯度消失和爆炸是一种情况。在深层网络中，由于网络过深，如果初始得到的梯度过小，或者传播途中在某一层上过小，则在之后的层上得到的梯度会越来越小，即产生了梯度消失。梯度爆炸也是同样的。一般地，不合理的初始化以及激活函数，如sigmoid等，都会导致梯度过大或者过小，从而引起消失/爆炸。</p>
<p>下面分别从网络深度角度以及激活函数角度进行解释：</p>
<p>（1）网络深度</p>
<p>若在网络很深时，若权重初始化较小，各层上的相乘得到的数值都会0-1之间的小数，而激活函数梯度也是0-1之间的数。那么连乘后，结果数值就会变得非常小，导致<strong>梯度消失</strong>。若权重初始化较大，大到乘以激活函数的导数都大于1，那么连乘后，可能会导致求导的结果很大，形成<strong>梯度爆炸</strong>。</p>
<p>（2）激活函数<br>
如果激活函数选择不合适，比如使用 sigmoid，梯度消失就会很明显了，原因看下图，左图是sigmoid的函数图，右边是其导数的图像，如果使用sigmoid作为损失函数，其梯度是不可能超过0.25的，这样经过链式求导之后，很容易发生梯度消失。<br>
<img src="figure_13_15_2.png" alt></p>
<center>图 13.8.2 sigmod函数与其导数</center>
<h3 id="13-8-3-梯度消失、爆炸的解决方案">13.8.3 梯度消失、爆炸的解决方案</h3>
<p><strong>1、预训练加微调</strong><br>
此方法来自Hinton在2006年发表的一篇论文，Hinton为了解决梯度的问题，提出采取无监督逐层训练方法，其基本思想是每次训练一层隐节点，训练时将上一层隐节点的输出作为输入，而本层隐节点的输出作为下一层隐节点的输入，此过程就是逐层“预训练”（pre-training）；在预训练完成后，再对整个网络进行“微调”（fine-tunning）。Hinton在训练深度信念网络（Deep Belief Networks中，使用了这个方法，在各层预训练完成后，再利用BP算法对整个网络进行训练。此思想相当于是先寻找局部最优，然后整合起来寻找全局最优，此方法有一定的好处，但是目前应用的不是很多了。</p>
<p><strong>2、梯度剪切、正则</strong><br>
梯度剪切这个方案主要是针对梯度爆炸提出的，其思想是设置一个梯度剪切阈值，然后更新梯度的时候，如果梯度超过这个阈值，那么就将其强制限制在这个范围之内。这可以防止梯度爆炸。<br>
另外一种解决梯度爆炸的手段是采用权重正则化（weithts regularization）比较常见的是L1和L2正则。</p>
<p><strong>3、ReLu、leakReLu等激活函数</strong><br>
（1）ReLu：其函数的导数在正数部分是恒等于1，这样在深层网络中，在激活函数部分就不存在导致梯度过大或者过小的问题，缓解了梯度消失或者爆炸。同时也方便计算。当然，其也存在存在一些缺点，例如过滤到了负数部分，导致部分信息的丢失，输出的数据分布不在以0为中心，改变了数据分布。<br>
（2）leakrelu：就是为了解决relu的0区间带来的影响，其数学表达为：leakrelu=max(k*x,0)其中k是leak系数，一般选择0.01或者0.02，或者通过学习而来。</p>
<p><strong>4、batchnorm</strong><br>
Batchnorm是深度学习发展以来提出的最重要的成果之一了，目前已经被广泛的应用到了各大网络中，具有加速网络收敛速度，提升训练稳定性的效果，Batchnorm本质上是解决反向传播过程中的梯度问题。Batchnorm全名是Batch Normalization，简称BN，即批规范化，通过规范化操作将输出信号x规范化到均值为0，方差为1保证网络的稳定性。</p>
<p><strong>5、残差结构</strong><br>
残差的方式，能使得深层的网络梯度通过跳级连接路径直接返回到浅层部分，使得网络无论多深都能将梯度进行有效的回传。</p>
<p><strong>6、LSTM</strong><br>
LSTM全称是长短期记忆网络（long-short term memory networks），是不那么容易发生梯度消失的，主要原因在于LSTM内部复杂的“门”(gates)。在计算时，将过程中的梯度进行了抵消。</p>
<h2 id="13-9-深度学习为什么不用二阶优化？">13.9 深度学习为什么不用二阶优化？</h2>
<p>目前深度学习中，反向传播主要是依靠一阶梯度。二阶梯度在理论和实际上都是可以应用都网络中的，但相比于一阶梯度，二阶优化会存在以下一些主要问题：<br>
（1）计算量大，训练非常慢。<br>
（2）二阶方法能够更快地求得更高精度的解，这在浅层模型是有益的。而在神经网络这类深层模型中对参数的精度要求不高，甚至不高的精度对模型还有益处，能够提高模型的泛化能力。<br>
（3）稳定性。二阶方法能更快求高精度的解，同样对数据本身要的精度也会相应的变高，这就会导致稳定性上的问题。</p>
<h2 id="13-10-为什么要设置单一数字评估指标，设置指标的意义？">13.10 为什么要设置单一数字评估指标，设置指标的意义？</h2>
<p>在训练模型时，无论是调整超参数，还是调整不同的模型算法，我们都需要一个有效的评价指标，这个评价标准能帮助我们快速了解新的尝试后模型的性能是否更优。例如在分类时，我们通常会选择选择准确率，当样本不平衡时，查准率和查全率又会是更好的评价指标。所以在训练模型时，如果设置了单一数字的评估指标通常能很快的反应出我们模型的改进是否直接产生了收益，从而加速我们的算法改进过程。若在训练过程中，发现优化目标进一步深入，现有指标无法完全反应进一步的目标时，就需要重新选择评估指标了。</p>
<h2 id="13-11训练-验证-测试集的定义及划分">13.11训练/验证/测试集的定义及划分</h2>
<p>训练、验证、测试集在机器学习领域是非常重要的三个内容。三者共同组成了整个项目的性能的上限和走向。</p>
<p>训练集：用于模型训练的样本集合，样本占用量是最大的；</p>
<p>验证集：用于训练过程中的模型性能评价，跟着性能评价才能更好的调参；</p>
<p>测试集：用于最终模型的一次最终评价，直接反应了模型的性能。</p>
<p>在划分上，可以分两种情况：</p>
<p>1、在样本量有限的情况下，有时候会把验证集和测试集合并。实际中，若划分为三类，那么训练集：验证集：测试集=6:2:2；若是两类，则训练集：验证集=7:3。这里需要主要在数据量不够多的情况，验证集和测试集需要占的数据比例比较多，以充分了解模型的泛化性。</p>
<p>2、在海量样本的情况下，这种情况在目前深度学习中会比较常见。此时由于数据量巨大，我们不需要将过多的数据用于验证和测试集。例如拥有1百万样本时，我们按训练集：验证集：测试集=98:1:1的比例划分，1%的验证和1%的测试集都已经拥有了1万个样本。这已足够验证模型性能了。</p>
<p>此外，三个数据集的划分不是一次就可以的，若调试过程中发现，三者得到的性能评价差异很大时，可以重新划分以确定是数据集划分的问题导致还是由模型本身导致的。其次，若评价指标发生变化，而导致模型性能差异在三者上很大时，同样可重新划分确认排除数据问题，以方便进一步的优化。</p>
<h2 id="13-12-什么是TOP5错误率？">13.12 什么是TOP5错误率？</h2>
<p>通常对于分类系统而言，系统会对某个未知样本进行所有已知样本的匹配，并给出该未知样本在每个已知类别上的概率。其中最大的概率就是系统系统判定最可能的一个类别。TOP5则就是在前五个最大概率的类别。TOP5错误率，即预测最可能的五类都不是该样本类别的错误率。</p>
<p>TOP5错误率通常会用于在类别数量很多或者细粒度类别的模型系统。典型地，例如著名的ImageNet ，其包含了1000个类别。通常就会采用TOP5错误率。</p>
<h2 id="13-13-什么是泛化误差，如何理解方差和偏差？">13.13 什么是泛化误差，如何理解方差和偏差？</h2>
<p>一般情况下，我们评价模型性能时都会使用泛化误差。泛化误差越低，模型性能越好。泛化误差可分解为方差、偏差和噪声三部分。这三部分中，噪声是个不可控因素，它的存在是算法一直无法解决的问题，很难约减，所以我们更多考虑的是方差和偏差。</p>
<p>方差和偏差在泛化误差上可做如下分解，假设我们的预测值为g(x)，真实值为f(x)，则均方误差为</p>
 $$
E((g(x)−f(x))2)
$$ 
<p>这里假设不考虑噪声，g来代表预测值，f代表真实值，g¯=E(g)代表算法的期望预测，则有如下表达：</p>
 $$
\begin{align}
E(g-f)^2&=E(g^2-2gf+f^2)
\\&=E(g^2)-\bar g^2+(\bar g-f)^2
\\&=E(g^2)-2\bar g^2+\bar g^2+(\bar g-f)^2
\\&=E(g^2-2g\bar g^2+\bar g^2)+(\bar g-f)^2
\\&=\underbrace{E(g-\bar g)^2}_{var(x)}+\underbrace{(\bar g-f)^2}_{bias^2(x)}
\end{align}
$$ 
<p>有上述公式可知，方差描述是理论期望和预测值之间的关系，这里的理论期望通常是指所有适用于模型的各种不同分布类型的数据集；偏差描述为真实值和预测值之间的关系，这里的真实值通常指某一个特定分布的数据集合。</p>
<p>所以综上方差表现为模型在各类分布数据的适应能力，方差越大，说明数据分布越分散，而偏差则表现为在特定分布上的适应能力，偏差越大越偏离真实值。</p>
<h2 id="13-14-如何提升模型的稳定性？">13.14 如何提升模型的稳定性？</h2>
<p>评价模型不仅要从模型的主要指标上的性能，也要注重模型的稳定性。模型的稳定性体现在对不同样本之间的体现的差异。如模型的方差很大，那可以从如下几个方面进行考虑：</p>
<p>（1）正则化（L2, L1, dropout）：模型方差大，很可能来自于过拟合。正则化能有效的降低模型的复杂度，增加对更多分布的适应性。</p>
<p>（2）提前停止训练：提前停止是指模型在验证集上取得不错的性能时停止训练。这种方式本质和正则化是一个道理，能减少方差的同时增加的偏差。目的为了平衡训练集和未知数据之间在模型的表现差异。</p>
<p>（3）扩充训练集：正则化通过控制模型复杂度，来增加更多样本的适应性。那增加训练集让模型适应不同类型的数据本身就是一种最简单直接的方式提升模型稳定的方法，也是最可靠的一种方式。  与正则有所不同的是，扩充数据集既可以减小偏差又能减小方差。</p>
<p>（4）特征选择：过高的特征维度会使模型过拟合，减少特征维度和正则一样可能会处理好方差问题，但是同时会增大偏差。但需要注意的是若过度删减特征，很可能会删除很多有用的特征，降低模型的性能。所以需要多注意删减的特征对模型的性能的影响。</p>
<h2 id="13-15-有哪些改善模型的思路">13.15 有哪些改善模型的思路</h2>
<p>改善模型本质是如何优化模型，这本身是个很宽泛的问题。也是目前学界一直探索的目的，而从目前常规的手段上来说，一般可取如下几点。</p>
<h3 id="13-15-1-数据角度">13.15.1 数据角度</h3>
<p>增强数据集。无论是有监督还是无监督学习，数据永远是最重要的驱动力。更多的类型数据对良好的模型能带来更好的稳定性和对未知数据的可预见性。对模型来说，“看到过的总比没看到的更具有判别的信心”。但增大数据并不是盲目的，模型容限能力不高的情况下即使增大数据也对模型毫无意义。而从数据获取的成本角度，对现有数据进行有效的扩充也是个非常有效且实际的方式。良好的数据处理，常见的处理方式如数据缩放、归一化和标准化等。</p>
<h3 id="13-15-2-模型角度">13.15.2 模型角度</h3>
<p>模型的容限能力决定着模型可优化的空间。在数据量充足的前提下，对同类型的模型，增大模型规模来提升容限无疑是最直接和有效的手段。但越大的参数模型优化也会越难，所以需要在合理的范围内对模型进行参数规模的修改。而不同类型的模型，在不同数据上的优化成本都可能不一样，所以在探索模型时需要尽可能挑选优化简单，训练效率更高的模型进行训练。</p>
<h3 id="13-15-3-调参优化角度">13.15.3 调参优化角度</h3>
<p>如果你知道模型的性能为什么不再提高了，那已经向提升性能跨出了一大步。 超参数调整本身是一个比较大的问题。一般可以包含模型初始化的配置，优化算法的选取、学习率的策略以及如何配置正则和损失函数等等。这里需要提出的是对于同一优化算法，相近参数规模的前提下，不同类型的模型总能表现出不同的性能。这实际上就是模型优化成本。从这个角度的反方向来考虑，同一模型也总能找到一种比较适合的优化算法。所以确定了模型后选择一个适合模型的优化算法也是非常重要的手段。</p>
<h3 id="13-15-4-训练角度">13.15.4 训练角度</h3>
<p>很多时候我们会把优化和训练放一起。但这里我们分开来讲，主要是为了强调充分的训练。在越大规模的数据集或者模型上，诚然一个好的优化算法总能加速收敛。但你在未探索到模型的上限之前，永远不知道训练多久算训练完成。所以在改善模型上充分训练永远是最必要的过程。充分训练的含义不仅仅只是增大训练轮数。有效的学习率衰减和正则同样是充分训练中非常必要的手段。</p>
<h2 id="13-16-如何快速构建有效初始模型？">13.16 如何快速构建有效初始模型？</h2>
<p>​	构建一个有效的初始模型能帮助我们快速了解数据的质量和确定模型构建的方向。构建一个良好的初始模型，一般需要注意如下几点：</p>
<p>​	1、了解&quot;对手&quot;。这里的“对手”通常是指数据，我们在得到数据时，第一步是需要了解数据特点和使用场合。了解数据特点能帮助我们快速定位如何进行建模。确定使用场合能帮助我们进一步确定模型需要优化的方向。数据特点一般需要了解例如数据集规模、训练集和验证集是否匹配、样本的分布是否均匀、数据是否存在缺失值等等。</p>
<p>​	2、站在巨人肩膀上。根据数据特点，我们通常能匹配到一个现有比较优秀的模型。这类模型都通常能在类似数据上表现出一个比较不错的性能。</p>
<p>​	3、一切从简。初始模型的作用在于迅速了解数据质量和特点，所以模型的性能通常不需要达到很高，模型复杂度也不需要很高。例如，做图像分类时，我们在使用预训练模型时，不需要一开始就使用例如ResNet152这类模型巨大，复杂度过高的模型。这在数据量较小时，很容易造成过拟合而导致出现我们对数据产生一些误导性的判断，此外也增加了额外训练构建时间。所以使用更小更简单的模型以及损失函数来试探数据是相比更明智的选择。</p>
<p>​	4、总比瞎猜强。构建模型的意义在于建立一个高效的模型，虽然初始模型我们不对性能做过高的要求。但前提在于必须要比随机猜测好，不然构建模型的意义就不存在了。</p>
<p>​	5、解剖模型。一旦确定了一个初始模型时，无论你对该模型多熟悉，当其面对一批新数据时，你永远需要重新去认识这个模型，因为你永远不确定模型内部到底发生了些什么。解剖模型一般需要在训练时注意误差变化、注意训练和验证集的差异；出现一些NAN或者INf等情况时，需要打印观察内部输出，确定问题出现的时间和位置；在完成训练后，需要测试模型的输出是否正确合理，以确认评价指标是否符合该数据场景。无论使用任何一种模型，我们都不能把它当做黑盒去看待。</p>
<h2 id="13-17-如何通过模型重新观察数据？">13.17 如何通过模型重新观察数据？</h2>
<p>​	对于这个问题，与其说如何做，倒不如说这个问题是用来强调这样做的重要性。如何重新观察数据其实不难，而是很多读者，会忽略这一项过程的重要性。</p>
<p>​	通过模型重新观察数据，不仅能让我们了解模型情况，也能让我们对数据质量产生进一步的理解。目前深度学习在监督学习领域成就是非常显著的。监督学习需要依赖大量的人为标注，人为标注很难确定是否使用的数据中是否存在错误标注或者漏标注等问题。这无论是哪种情况都会影响我们对模型的判断。所以通过模型重新验证数据质量是非常重要的一步。很多初学者，通常会忽略这一点，而导致出现对模型的一些误判，严重时甚至会影响整个建模方向。此外，对于若出现一些过拟合的情况，我们也可以通过观察来了解模型。例如分类任务，样本严重不平衡时，模型全预测到了一边时，其正确率仍然很高，但显然模型已经出现了问题。</p>
<h2 id="13-18-如何解决数据不匹配问题？">13.18 如何解决数据不匹配问题？</h2>
<h3 id="13-18-1-如何定位数据不匹配">13.18.1 如何定位数据不匹配?</h3>
<p>​	数据不匹配问题是个不容易定位和解决的问题。这个问题出现总会和模型过拟合表现很相似,即在训练集上能体现非常不错的性能,但在测试集上表现总是差强人意但区别在于如果遇到是数据不匹配的问题,通常在用一批和训<br>
练集有看相同或者相似分布的数据上仍然能取得不错的结果。但很多时候,当测试集上结果表现很差时,很多初学<br>
者可能会直接将问题定位在模型过拟合上,最后对模型尝试各种方法后,性能却始终不能得到有效提升。当遇到这<br>
种情况时,建议先定位出是否存在数据不匹配的问题。最简单的验证方式就是可以从训练集中挑选出一部分数据作<br>
为验证集,重新划分后训练和验证模型表现。</p>
<h3 id="13-18-2-举例常见几个数据不匹配的场景">13.18.2 举例常见几个数据不匹配的场景?</h3>
<p>​	例如设计款识别物体的app时,实际场景的图片均来自于手机拍摄,而训练集确是来自于网上各类抓取下来的图<br>
片。例如在图像去噪、去模糊、去雾、超分辨率等图像处理场景时,由于大量数据的难以获取,因此都会采用人为<br>
假设合成的图像进行训练,这时候应用到实际场景中也容易出现不匹配的问题</p>
<h3 id="13-18-3-如何解决数据不匹配问题">13.18.3 如何解决数据不匹配问题?</h3>
<p>​	数据不匹配是个很难有固定方法来解决的问题。这里提供几条供参考的途径：<br>
​	1、收集更多符合实际场最需要的数据。这似乎是最简单但也最难方式<br>
​	2、对结果做错误分析。找出数据集中出错的数据和正确数据之间的特点和区别,这对你无论是进行后续模型的分析或者是数据的处理提供非常有效的思路。注意,这里的数据集包括训练集和测试集<br>
​	3、数据集增强。数据集增强并不意味看数据集越大越好,其目的是丰富数据的分布以适应更多的变化当遇到数<br>
据不匹配时,对数据处理般可以有两种方式。其一,合成或处理更多接近需要的数据特点。其二,对所有数据包<br>
括实际场景数据都进行处理,将所有数据都统一到另一个分布上,统一出一种新的特点。</p>
<h3 id="13-18-4-如何提高深度学习系统的性能">13.18.4 如何提高深度学习系统的性能</h3>
<p>​	当我们要试图提高深度学习系统的性能时，目前我们大致可以从三方面考虑：</p>
<p>​	1、提高模型的结构，比如增加神经网络的层数，或者将简单的神经元单位换成复杂的 LSTM 神经元，比如在自然语言处理领域内，利用 LSTM 模型挖掘语法分析的优势。</p>
<p>​	2、改进模型的初始化方式，保证早期梯度具有某些有益的性质，或者具备大量的稀疏性，或者利用线性代数原理的优势。</p>
<p>​	3、选择更强大的学习算法，比如对度梯度更新的方式，也可以是采用除以先前梯度 L2 范数来更新所有参数，甚至还可以选用计算代价较大的二阶算法。</p>
<h2 id="参考文献">参考文献</h2>
<p>[1] 冯宇旭, 李裕梅. 深度学习优化器方法及学习率衰减方式综述[J]. 数据挖掘, 2018, 8(4): 186-200</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/19/deep_learning/ch15/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tom">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="算法工程师的日常">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/19/deep_learning/ch15/" class="post-title-link" itemprop="url">异构计算， GPU和框架选型指南面试题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-19 23:29:20" itemprop="dateCreated datePublished" datetime="2024-03-19T23:29:20+08:00">2024-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-24 10:14:09" itemprop="dateModified" datetime="2024-03-24T10:14:09+08:00">2024-03-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">算法面试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">深度学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>异构计算， GPU和框架选型指南</h1>
<p>深度学习训练和推理的过程中，会涉及到大量的向量(vector)，矩阵(matrix)和张量(tensor)操作，通常需要大量的浮点计算，包括高精度（在训练的时候）和低精度（在推理和部署的时候）。GPU， 作为一种通用可编程的加速器，最初设计是用来进行图形处理和渲染功能，但是从2007年开始，英伟达(NVIDIA)公司提出了第一个可编程通用计算平台（GPU），同时提出了CUDA框架，从此开启了GPU用于通用计算的新纪元。此后，不计其数的科研人员和开发者，对各种不同类型的算法用CUDA进行（部分）改写，从而达到几倍到数百倍的加速效果。尤其是在机器学习，特别是深度学习的浪潮来临后，GPU加速已经是各类工具实现的基本底层构架之一。本章里，会简单介绍GPU的基本架构，性能指标，框架选择等等和深度学习相关的内容。</p>
<h2 id="15-1-什么是异构计算？">15.1 什么是异构计算？</h2>
<p>异构计算是基于一个更加朴素的概念，”异构现象“，也就是不同计算平台之间，由于硬件结构（包括计算核心和内存），指令集和底层软件实现等方面的不同而有着不同的特性。异构计算就是使用结合了两个或者多个不同的计算平台，并进行协同运算。比如，比较常见的，在深度学习和机器学习中已经比较成熟的架构：CPU和GPU的异构计算;此外还有比较新的Google推出的协处理器（TPU），根据目的而定制的ASIC，可编程的FPGA等也都是现在在异构计算中使用比较多的协处理器。而，本章中会着重介绍和深度学习共同繁荣的图形加算器，也就是常说的GPU。</p>
<h2 id="15-2-什么是GPU？">15.2 什么是GPU？</h2>
<p>GPU,就如名字所包含的内容，原本开发的目的是为了进行计算机图形渲染，而减少对于CPU的负载。由于图像的原始特性，也就是像素间的独立性，所以GPU在设计的时候就遵从了“单指令流多数据流（SIMD）”架构，使得同一个指令（比如图像的某种变换），可以同时在多一个像素点上进行计算，从而得到比较大的吞吐量，才能使得计算机可以实时渲染比较复杂的2D/3D场景。在最初的应用场景里，GPU并不是作为一种通用计算平台出现的，直到2007年左右，一家伟大的公司将GPU带到通用计算的世界里，使得其可以在相对比较友好的编程环境（CUDA/OpenCL）里加速通用程序成了可能。从此之后，GPU通用计算，也就是GPU就成了学界和工业界都频繁使用的技术，在深度学习爆发的年代里，GPU成了推动这股浪潮非常重要的力量。</p>
<h2 id="15-3-GPU架构简介">15.3 GPU架构简介</h2>
<p>GPU，图形显示芯片作为不同于CPU的设计逻辑和应用场景，有着非常不同的架构，本部分将简单介绍GPU究竟是如何架构，其中的计算核心有哪些特性。</p>
<h3 id="15-3-1-如何通俗理解GPU的架构？">15.3.1 如何通俗理解GPU的架构？</h3>
<p>首先，下图简单地展示了几个GPU不同于CPU的特性：</p>
<ul>
<li>计算核心： 图中的CPU,i7-5960，Intel的第五代Broadwell架构，其中包括了8个CPU核心(支持16线程)，也就是理论上可以有16个不同的运算同时进行。除了8个核心计算单元，大部分的芯片面积是被3级缓存，内存和控制电路占据了。同样的，来自Nvidia的GTX980GPU，在差不多的芯片面积上，大部分是计算单元，16个SM，也就是流处理单元，每个流处理单元中包含着128个CUDA计算核心，所以总共来说，有2048个GPU运算单元，相应地这颗GPU理论上可以在一个时钟周期内可以进行2048次单精度运算。</li>
</ul>
<p><img src="cpu_gpu.png" alt="CPU和GPU的简单架构对比图"></p>
<ul>
<li>计算核心频率：时钟频率，代表每一秒中内能进行同步脉冲次数，也是从一个侧面反映一个计算元件的工作速度。下图中对比了个别早期产品，比如Intel的x5650和几款Nvidia的GPU。可以看出核心频率而言，CPU要远高于GPU。对于CPU而言，在不考虑能源消耗和制程工艺限制的情况下，追求更高的主频。但，在GPU的设计中，采用了多核心设计，即使是提高一些频率，其实对于总体性能影像不会特别大。当然，其中还有能耗方面的考虑，避免发热过高，也进行了权衡。还有一个可能的原因是，在一个流处理器中的每个核心（CUDA核心）的运行共享非常有限的缓存和寄存器，由于共享内存也是有性能极限的，所以即使每个GPU核心频率提高，如果被缓存等拖累也是无法展现出高性能的。</li>
</ul>
<p><img src="cpu_specs.png" alt="CPU简单信息"></p>
<p><img src="gpu_specs.png" alt="GPU的简单信息对比"></p>
<ul>
<li>内存架构：GPU的多层内存架构包括全局内存（也就是通常意义上大部分比较关注的内存，在若干到16GB之间，截至到当前最新），2级缓存，和芯片上的存储（包括寄存器，和1级缓存共用的共享内存，只读/纹理缓存和常量缓存）。通常来说，最高速的共享内存/缓存和寄存器都是非常有限的，比如在Tesla的K20中，只有48K的缓存可以作为共享内存或者1级缓存使用，所以在很多用GPU加速算法实现的过程中，有效地利用这些高速缓存是使得性能提升的非常重要的方面。</li>
</ul>
<p><img src="gpu_memory_arch.png" alt="GPU的简单信息对比"></p>
<p><img src="gpu_memory.png" alt="GPU的内存架构容量信息"></p>
<h3 id="15-3-2-CUDA-核心是什么？">15.3.2 CUDA 核心是什么？</h3>
<p>上面提到在一个GPU芯片里，会很几千个CUDA核心，被分布在多个流处理单元（SM）中，比如上面提到早期的GTX980中的16个SM中各包含了128个CUDA核心。如下图所示，作为GPU架构中的最小单元，其实它的设计和CPU有着非常类似的结构，其中包括了一个浮点运算单元和整型运算单元，和控制单元。同一个流处理器中，所有的CUDA核心将同步执行同一个指令，但是作用于不同的数据点上。</p>
<p><img src="cudacore.jpg" alt="CUDA简单介绍"></p>
<p>一般来说，更加多的CUDA核心意味着有更多的并行执行单元，所以也就可以片面地认为是有更加高的性能。但是，其实这个也是取决于很多方面，最重要的是算法在并行实现的时候有没有高效地调度和内存的使用优化。在现在我们使用的大部分GPU加速的深度学习框架里，包括Tensorflow，PyTorch等都是依赖于底层的GPU的矩阵加速代码的实现。为此Nvidia公司也是制定和实现了统一的接口，比如cuDNN，方便上层框架更好的利用GPU的性能。</p>
<h3 id="15-3-3-为什么要使用GPU？">15.3.3 为什么要使用GPU？</h3>
<p>对于并行计算来说，可以非常粗略地分为：</p>
<ul>
<li>并行指令： 也就是多个指令可以同时分配到不同的计算核心上同时进行，而他们的操作是不同的，并且他们之间相互独立，不需要额外的同步和信息共享。</li>
<li>并行数据流： 如果数据本身存在的天然的独立性，比如图像中的每一个像素，那么在对这个图像做处理的过程中，同一个指令可以同时作用于每一个像素。在这种情况下，这个对于完整图像的操作可以并行化。理论上，如果内存不是问题，并且计算单元的数量大于整个图像中总像素点的话，这个操作可以在一个时钟周期内完成。</li>
</ul>
<p>GPU整体的架构而言，某种意义上是同时支持以上两种并行模式。在同一个流处理器中，采用了“单一指令并行数据流的模式”，而在多个流处理器中，同一时间可以派发不同的指令。从这一点出发，GPU芯片算是一个非常灵活的架构。一个芯片中，流处理器的个数和其中包含的CUDA核心的数量也是一种面向应用设计时候找到的一个平衡点。</p>
<p>基于深度学习中大部分的操作的天然并行性（大量的矩阵操作），GPU在当下还是一种非常适合的计算平台。一个非常典型的例子就是常见的矩阵相乘（如下图），要计算Z = X×Y，通过并行计算，X和Y中的行向量和列向量的逐元素相乘就可以同时进行，只要得到结果后再进行累加，而且累加的过程中也是可以进行并行化，使得效率有非常大的提高。Nvidia也是制定和开发了一套底层类库，CUBlas方便开发者。我们熟悉的几大框架(e.g. Tensorflow, PyTorch等)也是遵循和使用了这些并行类库，所以才使得训练和部署性能有了非常多的提高。</p>
<p><img src="mat_mul_gpu.png" alt="CUDA 矩阵乘法示例"></p>
<h3 id="15-3-4-深度学习中的GPU应用">15.3.4 深度学习中的GPU应用</h3>
<p>深度学习在最近几年内出现的井喷现象背后也是GPU的存在和发展作为坚实的推动力量。</p>
<p>哪些场景使用GPU</p>
<p>ImageNet的例子</p>
<h3 id="15-3-5-新图灵架构里的tensor-core对深度学习有什么作用？">15.3.5 新图灵架构里的tensor core对深度学习有什么作用？</h3>
<h2 id="15-4-CUDA-框架">15.4 CUDA 框架</h2>
<h3 id="15-4-1-做CUDA编程难不难？">15.4.1 做CUDA编程难不难？</h3>
<h3 id="15-4-2-cuDNN">15.4.2 cuDNN</h3>
<h2 id="15-5-GPU硬件环境配置推荐">15.5 GPU硬件环境配置推荐</h2>
<h3 id="15-5-1-GPU主要性能指标">15.5.1 GPU主要性能指标</h3>
<p>GPU的性能主要由以下三个参数构成：</p>
<ol>
<li>计算能力。通常我们关心的是32位浮点计算能力。16位浮点训练也开始流行，如果只做预测的话也可以用8位整数。</li>
<li>内存大小。当模型越大，或者训练时的批量越大时，所需要的GPU内存就越多。</li>
<li>内存带宽。只有当内存带宽足够时才能充分发挥计算能力。</li>
</ol>
<p>对于大部分用户来说，只要考虑计算能力就可以了。GPU内存尽量不小于4GB。但如果GPU要同时显示图形界面，那么推荐的内存大小至少为6GB。内存带宽通常相对固定，选择空间较小。</p>
<p>下图描绘了GTX 900和1000系列里各个型号的32位浮点计算能力和价格的对比。其中价格为Wikipedia的建议价格。</p>
<p><img src="gtx.png" alt="浮点计算能力和价格的对比。"></p>
<p>我们可以从图中读出两点信息：</p>
<ol>
<li>在同一个系列里面，价格和性能大体上成正比。但后发布的型号性价比更高，例如980 TI和1080 TI。</li>
<li>GTX 1000系列比900系列在性价比上高出2倍左右。</li>
</ol>
<p>如果大家继续比较GTX较早的系列，也可以发现类似的规律。据此，我们推荐大家在能力范围内尽可能买较新的GPU。</p>
<p>对于RTX系列，新增了Tensor Cores单元及支持FP16，使得显卡的可选择范围更加多元。</p>
<h3 id="15-5-2-购买建议">15.5.2 购买建议</h3>
<p>首先给出一些总体的建议：</p>
<p>性价比高但较贵：RTX 2070，GTX 1080 Ti</p>
<p>性价比高又便宜：RTX 2060，GTX 1060（6GB）</p>
<p>当使用数据集&gt; 250GB：GTX Titan X（Maxwell） ，NVIDIA Titan X Pascal或NVIDIA Titan Xp</p>
<p>没有足够的钱：GTX 1060（6GB）</p>
<p>几乎没有钱，入门级：GTX 1050 Ti（4GB）</p>
<p>做Kaggle比赛：RTX 2070、GTX 1060（6GB）适用于任何“正常”比赛，GTX 1080 Ti（预算足够可以选择RTX 2080 Ti）用于“深度学习竞赛”</p>
<p>计算机视觉研究员：RTX 2080 Ti（涡轮散热或水冷散热较好，方便后期增加新的显卡）如果网络很深可以选择Titan RTX</p>
<p>一名NLP研究人员：RTX 2080 Ti，并使用FP16来训练</p>
<p>搭建一个GPU集群：这个有点复杂，另做探讨。</p>
<p>刚开始进行深度学习研究：从RTX 2060或GTX 1060（6GB）开始，根据你下一步兴趣（入门，Kaggle比赛，研究，应用深度学习）等等，再进行选择。目前，RTX 2060和GTX 1060都比较合适入门的选择。</p>
<p>想尝试下深度学习，但没有过多要求：GTX 1050 ti（4或2GB）</p>
<p>目前独立GPU主要有AMD和Nvidia两家厂商。其中Nvidia在深度学习布局较早，对深度学习框架支持更好。因此，目前大家主要会选择Nvidia的GPU。</p>
<p>Nvidia有面向个人用户（例如GTX系列）和企业用户（例如Tesla系列）的两类GPU。这两类GPU的计算能力相当。然而，面向企业用户的GPU通常使用被动散热并增加了内存校验，从而更适合数据中心，并通常要比面向个人用户的GPU贵上10倍。</p>
<p>如果你是拥有100台机器以上的大公司用户，通常可以考虑针对企业用户的Nvidia Tesla系列。如果你是拥有10到100台机器的实验室和中小公司用户，预算充足的情况下可以考虑Nvidia DGX系列，否则可以考虑购买如Supermicro之类的性价比比较高的服务器，然后再购买安装GTX系列的GPU。</p>
<p>Nvidia一般每一两年发布一次新版本的GPU，例如2017年发布的是GTX 1000系列。每个系列中会有数个不同的型号，分别对应不同的性能。</p>
<h2 id="15-6-软件环境搭建">15.6 软件环境搭建</h2>
<p>深度学习其实就是指基于一套完整的软件系统来构建算法，训练模型。如何搭建一套完整的软件系统，比如操作系统的选择？安装环境中遇到的问题等等，本节做一个简单的总结。</p>
<h3 id="15-6-1-操作系统选择？">15.6.1 操作系统选择？</h3>
<p>针对硬件厂商来说，比如NVIDIA，对各个操作系统的支持都是比较好的 ，比如Windows系列,Linux系列，但是由于Linux系统对专业技术人员比较友好，所以目前几乎所有的深度学习系统构建都是基于Linux的，比较常用的系统如Ubuntu系列，CentOS系列等等。<br>
在构建系统的时候，如何选择合适的操作系是一个刚刚入门深度学习的工作者面临的问题，在这里给出几点建议：<br>
（1）刚刚入门，熟悉Windows系统，但是对Linux和深度学习都不太熟，这个时候可以基于windows系列系统来做入门学习<br>
（2）简单了解Linux的使用，不太懂深度学习相关知识，可以直接基于Linux系统来搭建框架，跑一些开源的项目，慢慢深入研究学习<br>
（3）熟悉Linux，不熟悉深度学习理论，毫无疑问，强烈推荐使用Linux系统，安装软件简单，工作效率高<br>
总之一句话，如果不熟悉Linux，就先慢慢熟悉，最终还是要回归到Linux系统来构建深度学习系统</p>
<h3 id="15-6-2-常用基础软件安装？">15.6.2 常用基础软件安装？</h3>
<p>目前有众多深度学习框架可供大家使用，但是所有框架基本都有一个共同的特点，目前几乎都是基于Nvidia的GPU来训练模型，要想更好的使用Nvidia的GPU，cuda和cudnn就是必备的软件安装。</p>
<ol>
<li>
<p><strong>安装cuda</strong><br>
上文中有关于cuda的介绍，这里只是简单介绍基于Linux系统安装cuda的具体步骤，可以根据自己的需要安装cuda8.0或者cuda9.0，这两种版本的安装步骤基本一致，这里以最常用的ubuntu 16.04 lts版本为例：</p>
<ol>
<li>官网下载，地址<br>
cuda8.0https://developer.nvidia.com/cuda-80-ga2-download-archive<br>
cuda9.0https://developer.nvidia.com/cuda-90-download-archive<br>
进入网址之后选择对应的系统版本即可，如下图所示：<br>
<img src="cuda8.0.png" alt="cuda8.0"></li>
</ol>
<p><img src="cuda9.0.png" alt="cuda9.0"></p>
<ol start="2">
<li>
<p>命令行中进入到cuda所在的位置，授予运行权限：<br>
cuda8.0: sudo chmod +x cuda_8.0.61_375.26_linux.run<br>
cuda9.0:sudo chmod +x cuda_9.0.176_384.81_linux.run</p>
</li>
<li>
<p>执行命令安装cuda：<br>
cuda8.0:sudo sh cuda_8.0.61_375.26_linux.run<br>
cuda9.0:sudo sh cuda_9.0.176_384.81_linux.run<br>
之后命令之后下面就是安装步骤，cuda8.0和cuda9.0几乎一致：</p>
</li>
</ol>
<ul>
<li>
<p>首先出现cuda软件的版权说明，可以直接按q键跳过阅读</p>
</li>
<li>
<p>Do you accept the previously read EULA?<br>
​accept/decline/quit: <strong>accept</strong></p>
</li>
<li>
<p>Install NVIDIA Accelerated Graphics Driver for Linux-x86_64 384.81?<br>
​(y)es/(n)o/(q)uit:<strong>no</strong></p>
</li>
<li>
<p>Install the CUDA 9.0 Toolkit?<br>
​(y)es/(n)o/(q)uit:<strong>yes</strong></p>
</li>
<li>
<p>Enter Toolkit Location<br>
​ [ default is /usr/local/cuda-9.0 ]:直接按enter键即可</p>
</li>
<li>
<p>Do you want to install a symbolic link at /usr/local/cuda?<br>
​(y)es/(n)o/(q)uit:<strong>yes</strong></p>
</li>
<li>
<p>Install the CUDA 9.0 Samples?<br>
​ (y)es/(n)o/(q)uit:<strong>yes</strong></p>
</li>
</ul>
<p>以上步骤基本就是cuda的安装步骤。</p>
</li>
<li>
<p><strong>安装cudnn</strong><br>
cudnn是Nvidia的专门针对深度学习的加速库。。。</p>
</li>
</ol>
<h3 id="15-6-3-本机安装还是使用docker？">15.6.3 本机安装还是使用docker？</h3>
<h3 id="15-6-4-GPU驱动问题">15.6.4 GPU驱动问题</h3>
<h2 id="15-7-框架选择">15.7 框架选择</h2>
<h3 id="15-7-1-主流框架比较">15.7.1 主流框架比较</h3>
<p>（一个大表格比较）</p>
<h3 id="15-7-2-框架详细信息">15.7.2 框架详细信息</h3>
<ul>
<li>
<p>Tensorflow<br>
Tensorflow是Google于2015年开源的基于数据流编程的深度学习框架，得益于Google强大的技术实力和品牌背书，目前Tensorflow发展迅猛，其用户量远远超过其它框架用户。<br>
优点：</p>
<ol>
<li>由谷歌开发、维护，因此可以保障支持、开发的持续性</li>
<li>巨大、活跃的社区</li>
<li>网络训练的低级、高级接口</li>
<li>「TensorBoard」是一款强大的可视化套件，旨在跟踪网络拓扑和性能，使调试更加简单</li>
<li>TensorFlow 不仅支持深度学习，还有支持强化学习和其他算法的工具<br>
缺点：</li>
<li>计算图是纯 Python 的，因此速度较慢</li>
<li>图构造是静态的，意味着图必须先被「编译」再运行</li>
</ol>
</li>
<li>
<p>PyTorch<br>
pytorch是Facebook于2017年才推出的深度学习框架，相对于其它框架，算是比较晚的了，但是这个同时也是优势，在设计的时候就会避免很多之前框架的问题，所以一经推出，就收到大家极大的欢迎<br>
优点：</p>
<ol>
<li>接口简洁且规范，文档齐全，和python无缝结合，</li>
<li>社区非常活跃，开源实现较多</li>
<li>提供动态计算图（意味着图是在运行时生成的），允许你处理可变长度的输入和输出，例如，在使用 RNN 时非常有用</li>
<li>易于编写自己的图层类型，易于在 GPU 上运行</li>
<li>「TensorBoard」缺少一些关键功能时，「Losswise」可以作为 Pytorch 的替代品</li>
</ol>
</li>
</ul>
<p>缺点:</p>
<ol>
<li>模型部署相对其它框架稍有劣势，不过后续的pytorch1.0版本应该会有很大改善，和caffe2合并后，caffe2的优秀的模型部署能力可以弥补这个不足</li>
<li></li>
<li></li>
</ol>
<p>相关资源链接：</p>
<ol>
<li>官网教程：<a target="_blank" rel="noopener" href="https://pytorch.org/tutorials/">https://pytorch.org/tutorials/</a></li>
<li>基于pytorch的开源项目汇总：<a target="_blank" rel="noopener" href="https://github.com/bharathgs/Awesome-pytorch-list">https://github.com/bharathgs/Awesome-pytorch-list</a></li>
<li></li>
</ol>
<ul>
<li>
<p>Keras<br>
Keras 是一个更高级、对用户最友好的 API，具有可配置的后端，由 Google Brain 团队成员 Francis Chollet 编写和维护<br>
优点：</p>
<ol>
<li>提供高级 API 来构建深度学习模型，使其易于阅读和使用</li>
<li>编写规范的文档</li>
<li>大型、活跃的社区</li>
<li>位于其他深度学习库（如 Theano 和 TensorFlow，可配置）之上</li>
<li>使用面向对象的设计，因此所有内容都被视为对象（如网络层、参数、优化器等）。所有模型参数都可以作为对象属性进行访问<br>
缺点：</li>
<li>由于用途非常普遍，所以在性能方面比较欠缺</li>
<li>与 TensorFlow 后端配合使用时会出现性能问题（因为并未针对其进行优化），但与 Theano 后端配合使用时效果良好</li>
<li>不像 TensorFlow 或 PyTorch 那样灵活</li>
</ol>
</li>
<li>
<p>Sonnet</p>
</li>
<li>
<p>Caffe<br>
caffe是第一个主流产品级深度学习库，于 2014 年由 UC Berkeley 发布开源<br>
优点：</p>
<ol>
<li>简单网络结构无需编写代码，可快速实现</li>
<li>漂亮的 Matlab 和 Python 接口</li>
<li>完全由c++编程实现，部署方便</li>
</ol>
</li>
</ul>
<p>缺点：</p>
<ol>
<li>不灵活。在 Caffe 中，每个节点被当做一个层，因此如果你想要一种新的层类型，你需要定义完整的前向、后向和梯度更新过程。这些层是网络的构建模块，你需要在无穷无尽的列表中进行选择。（相反，在 TensorFlow 中，每个节点被当做一个张量运算例如矩阵相加、相乘或卷积。你可以轻易地定义一个层作为这些运算的组合。因此 TensorFlow 的构建模块更小巧，允许更灵活的模块化。）</li>
<li>需要大量的非必要冗长代码。如果你希望同时支持 CPU 和 GPU，你需要为每一个实现额外的函数。你还需要使用普通的文本编辑器来定义你的模型。真令人头疼！几乎每个人都希望程序化地定义模型，因为这有利于不同组件之间的模块化。有趣的是，Caffe 的主要架构师现在在 TensorFlow 团队工作</li>
<li>专一性。仅定位在计算机视觉（但做得很不错）</li>
<li>不是以 Python 编写！如果你希望引入新的变动，你需要在 C++和 CUDA 上编程（对于更小的变动，你可以使用它的 Python 和 Matlab 接口）</li>
<li>糟糕的文档</li>
<li>安装比较困难！有大量的依赖包</li>
</ol>
<ul>
<li>
<p>Caffe2</p>
</li>
<li>
<p>MxNet<br>
MxNet是dmlc社区推出的深度学习框架，MXNet由学术界发起，包括数个顶尖大学的多个学科的研究人员的贡献，在2017年被亚马逊指定为官方框架。<br>
mxnet的最知名的优点就是其对多GPU的支持和扩展性强，其优秀的性能使之在工业界占有一席之地，在amazon支持之后，其文档和开发进度明显好很多。除了高可扩展性，MXNet 还提供混合编程模型（命令式和声明式），同时兼容多种编程语言（包括 Python、C ++、R、Scala、Julia、Matlab 和 JavaScript）的代码，目前主要在推python高层接口gluon</p>
</li>
</ul>
<p>优点：</p>
<ol>
<li>多GPU支持好，扩展性强，支持多种编程语言接口，主要是由华人团队开发，中文社区活跃，中文文档资源和课程丰富</li>
<li>针对两大热门领域推出gluoncv和gluonNLP模块，复现经典论文，达到State-of-the-art，接口设计简单，文档齐全，拿来就可以用<br>
缺点:</li>
<li>现在mxnet官方社区主要在推gluon接口，接口稍有混乱，坑较多，入手门槛稍高</li>
<li>偏小众，经典网络和项目的开源实现相对于tensorflow和pytorch还是比较少，很多还是需要自己手动实现<br>
相关资源链接：</li>
<li>官方教程：<a target="_blank" rel="noopener" href="http://mxnet.incubator.apache.org">http://mxnet.incubator.apache.org</a> 提供有快速入门教程和详细文档说明</li>
<li>中文教程：<a target="_blank" rel="noopener" href="http://zh.gluon.ai/">http://zh.gluon.ai/</a> 官方的中文教程，此课程有对应的中文版视频，主要由李沐大神讲课</li>
<li>中文论坛：<a target="_blank" rel="noopener" href="https://discuss.gluon.ai/">https://discuss.gluon.ai/</a> 官方发中文论坛，mxnet的主要作者都在这里，论坛比较活跃，可及时得到作者的回答</li>
<li>基于mxnet的开源项目实现：<a target="_blank" rel="noopener" href="https://github.com/chinakook/Awesome-MXNet%E8%BF%99%E9%87%8C%E4%B8%BB%E8%A6%81%E5%88%97%E4%B8%BE%E4%BA%86mxnet%E5%9C%A8%E5%90%84%E4%B8%AA%E9%A2%86%E5%9F%9F%E7%9A%84%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%BC%80%E6%BA%90%E5%AE%9E%E7%8E%B0">https://github.com/chinakook/Awesome-MXNet这里主要列举了mxnet在各个领域的项目的开源实现</a></li>
</ol>
<ul>
<li>
<p>CNTK</p>
</li>
<li>
<p>PaddlePaddle</p>
</li>
<li>
<p>其他国内自主开发开源框架</p>
</li>
</ul>
<h3 id="15-7-3-哪些框架对于部署环境友好？">15.7.3 哪些框架对于部署环境友好？</h3>
<ul>
<li>
<p>Tensorflow Serving</p>
</li>
<li>
<p>ONNX 标准</p>
</li>
<li>
<p>TensorRT</p>
</li>
<li>
<p>ONNPACK</p>
</li>
<li>
<p>Clipper</p>
</li>
</ul>
<h3 id="15-7-4-移动平台的框架如何选择？">15.7.4 移动平台的框架如何选择？</h3>
<ul>
<li>
<p>Tensorflow Lite</p>
</li>
<li>
<p>Caffe2</p>
</li>
</ul>
<h2 id="15-8-其他">15.8 其他</h2>
<h3 id="15-8-1-多GPU环境的配置">15.8.1 多GPU环境的配置</h3>
<ul>
<li>
<p>Tensorflow</p>
</li>
<li>
<p>PyTorch</p>
</li>
</ul>
<h3 id="15-8-2-是不是可以分布式训练？">15.8.2 是不是可以分布式训练？</h3>
<h3 id="15-8-3-可以在SPARK环境里训练或者部署模型吗？">15.8.3 可以在SPARK环境里训练或者部署模型吗？</h3>
<h3 id="15-8-4-怎么进一步优化性能？">15.8.4 怎么进一步优化性能？</h3>
<ul>
<li>
<p>TVM</p>
</li>
<li>
<p>nGraph</p>
</li>
</ul>
<h3 id="15-8-5-TPU和GPU的区别？">15.8.5 TPU和GPU的区别？</h3>
<h3 id="15-8-6-未来量子计算对于深度学习等AI技术的影响？">15.8.6 未来量子计算对于深度学习等AI技术的影响？</h3>
<hr>
<h2 id="15-1-GPU购买指南">15.1 GPU购买指南</h2>
<p>深度学习训练通常需要大量的计算资源。GPU目前是深度学习最常使用的计算加速硬件。相对于CPU来说，GPU更便宜且计算更加密集。一方面，相同计算能力的GPU的价格一般是CPU价格的十分之一。另一方面，一台服务器通常可以搭载8块或者16块GPU。因此，GPU数量可以看作是衡量一台服务器的深度学习计算能力的一个标准。</p>
<h3 id="15-1-1-如何选择GPU">15.1.1 如何选择GPU</h3>
<h3 id="15-1-2-GPU的主要性能指标">15.1.2 GPU的主要性能指标</h3>
<p>在选择GPU时，首先要考虑的第一个GPU性能问题是什么呢：是否为cuda核心？时钟速度多大？内存大小多少？<br>
这些都不是，对于深度学习性能而言，最重要的特征是内存带宽（memory bandwidth）。<br>
简而言之：GPU针对内存带宽进行了优化，但同时牺牲了内存访问时间（延迟）。CPU的设计恰恰相反：如果涉及少量内存（例如几个数字相乘（3 * 6 * 9）），CPU可以快速计算，但是对于大量内存（如矩阵乘法（A * B * C）则很慢。由于内存带宽的限制，当涉及大量内存的问题时，GPU快速计算的优势往往会受到限制。当然，GPU和CPU之间还有更复杂的区别，关于为何GPU如此适用于处理深度学习问题，另做探讨。</p>
<p>所以如果你想购买一个快速的GPU，首先要关注的是GPU的带宽（bandwidth）。</p>
<h3 id="15-1-3-整机配置">15.1.3 整机配置</h3>
<p>通常，我们主要用GPU做深度学习训练。因此，不需要购买高端的CPU。至于整机配置，尽量参考网上推荐的中高档的配置就好。不过，考虑到GPU的功耗、散热和体积，我们在整机配置上也需要考虑以下三个额外因素。</p>
<ol>
<li>机箱体积。GPU尺寸较大，通常考虑较大且自带风扇的机箱。</li>
<li>电源。购买GPU时需要查一下GPU的功耗，例如50W到300W不等。购买电源要确保功率足够，且不会过载机房的供电。</li>
<li>主板的PCIe卡槽。推荐使用PCIe 3.0 16x来保证充足的GPU到主内存的带宽。如果搭载多块GPU，要仔细阅读主板说明，以确保多块GPU一起使用时仍然是16x带宽。注意，有些主板搭载4块GPU时会降到8x甚至4x带宽。</li>
</ol>
<h3 id="15-1-4-小结">15.1.4 小结</h3>
<ul>
<li>在预算范围之内，尽可能买较新的GPU。</li>
<li>整机配置需要考虑到GPU的功耗、散热和体积。</li>
</ul>
<h2 id="15-2-框架选型">15.2 框架选型</h2>
<p>目前常用的框架有tensorflow,keras,pytorch,mxnet等等，各个框架的优缺点在此简单介绍：</p>
<h3 id="15-2-1-常用框架简介">15.2.1 常用框架简介</h3>
<ol>
<li>
<p>tensorflow：<br>
tensorflow由于有google的强大背书，加上其优秀的分布式设计，丰富的教程资源和论坛，工业部署方便，基本很多人都是从tensorflow入门的<br>
优点：google的强大背书，分布式训练，教程资源丰富，常见问题基本都可以在互联网中找到解决办法，工业部署方便<br>
缺点: 接口混乱，官方文档不够简洁，清晰，</p>
</li>
<li>
<p>keras:<br>
keras是一种高层编程接口，其可以选择不同的后端，比如tensorflow，therao等等<br>
优点：接口简洁，上手快，文档好，资源多<br>
缺点: 封装的太好了导致不理解其技术细节</p>
</li>
<li>
<p>pytorch:<br>
PyTorch是一个开源的Python机器学习库，基于Torch，从官方1.0版本开始已经完美结合caffe2，主要应用于人工智能领域，如自然语言处理。它最初由Facebook的人工智能研究团队开发.<br>
优点：文档清晰，兼容NumPy的张量计算，基于带基自动微分系统的深度神经网络，由Facebook开发维护，常见model都有pytorch复现版<br>
缺点：工业部署稍弱（但是合并caffe2后支持全平台部署）</p>
</li>
<li>
<p>mxnet<br>
mxnet是dmlc社区推出的深度学习框架，在2017年被亚马逊指定为官方框架<br>
优点：支持多种语言，代码设计优秀，省显存，华人团队开发，中文社区活跃，官方复现经典论文推出gluoncv和gluonNLP模块，非常方便，拿来就可以用。<br>
缺点:现在mxnet官方社区主要在推gluon接口，接口稍有混乱，坑较多，入手门槛稍高</p>
</li>
<li>
<p>caffe：<br>
目前很多做深度学习比较早的大厂基本都是在用caffe，因为在2013-2015年基本就是caffe的天下，并且caffe的代码设计很优秀，基本所有代码都被翻了很多遍了，被各种分析，大厂基本都是魔改caffe，基于caffe来进行二次开发，所在目前在很多大厂还是在使用caffe<br>
优点：资源丰富，代码容易理解，部署方便<br>
缺点：入门门槛高，文档较少</p>
</li>
</ol>
<p>框架选型总结:</p>
<ol>
<li>新手入门，首推pytorch，上手快，资源丰富,官方文档写的非常好(<a target="_blank" rel="noopener" href="https://pytorch.org/tutorials/">https://pytorch.org/tutorials/</a>)</li>
<li>目前工业部署，tensorflow是首选,资源丰富，并且在分布式训练这一块基本一家独大</li>
<li>mxnet的gluon接口有比较丰富的中文资源（教程：<a target="_blank" rel="noopener" href="http://zh.gluon.ai">zh.gluon.ai</a>，论坛：<a target="_blank" rel="noopener" href="http://discuss.gluon.ai">discuss.gluon.ai</a>）,gluoncv模块（<a target="_blank" rel="noopener" href="https://gluon-cv.mxnet.io">https://gluon-cv.mxnet.io</a>）,gluonNLP模块（<a target="_blank" rel="noopener" href="https://gluon-nlp.mxnet.io">https://gluon-nlp.mxnet.io</a>）</li>
</ol>
<h2 id="15-3-模型部署">15.3 模型部署</h2>
<p>我们一般都是通过python或者其他语言来编码训练模型，然后基于后端来进行部署<br>
一般的框架都有自身的部署框架，比如tensorflow，pytorch，caffe2，mxnet等等<br>
有一些框架是专门做推理部署使用的，比如<br>
(1)tensorRT<br>
(2)TVM<br>
(3)ONNX</p>
<h2 id="相关文献">相关文献</h2>
<p>[1] Aston Zhang, Mu Li, Zachary C. Lipton, and Alex J. Smola. <a target="_blank" rel="noopener" href="https://github.com/d2l-ai/d2l-zh/blob/master/chapter_appendix/buy-gpu.md">《动手学深度学习》附录 购买GPU</a>, 2019.<br>
[2] Tim Dettmers. <a target="_blank" rel="noopener" href="http://timdettmers.com/2019/04/03/which-gpu-for-deep-learning/">Which GPU(s) to Get for Deep Learning: My Experience and Advice for Using GPUs in Deep Learning</a>, 2019.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/19/deep_learning/ch16/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tom">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="算法工程师的日常">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/19/deep_learning/ch16/" class="post-title-link" itemprop="url">NLP面试题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-19 23:29:20" itemprop="dateCreated datePublished" datetime="2024-03-19T23:29:20+08:00">2024-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-24 10:14:13" itemprop="dateModified" datetime="2024-03-24T10:14:13+08:00">2024-03-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">算法面试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">深度学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>NLP</h1>
<h2 id="16-0-NLP-发展史简述">16.0 NLP 发展史简述</h2>
<p>50多年来 NLP 的历史发展可以分为三个浪潮，前两波以理性主义和经验主义的形式出现，为当前的深度学习浪潮铺平了道路。NLP的深层学习革命的主要支柱是: （1）语言嵌入实体的分布式表征，（2）由于嵌入而产生的语义泛化， （3）自然语言的大跨度深序列建模，（4）能够从低到高表示语言层次的分层网络，以及（5）解决许多联合 NLP 问题的端对端深度学习方法。</p>
<h3 id="第一个浪潮：理性主义">第一个浪潮：理性主义</h3>
<p>在第一个浪潮中，NLP的实验持续了很长一段时间，可以追溯到20世纪50年代。1950年，阿兰·图灵提出了图灵测试，以评估计算机表现出与人类无法区分的智能行为的能力。这项测试是基于人类和计算机之间的自然语言对话，旨在生成类似人类的反应。1954年，George-IBM 实验产出了能够将60多个俄语句子翻译成英语的rrst机器翻译系统。</p>
<p>这些方法是基于这样一种信念，即人类思维中的语言知识是由泛型继承提前进行的，而这种信念，在大约1960年至1980年代后期，占据了NLP的大部分研究中的主导地位。这些方法被称为理性主义方法（Church 2007）。理性主义方法在 NLP 中的主导地位主要是由于诺姆·乔姆斯基（Noam Chomsky）关于先天语言结构的论点被广泛接受以及他对 N-grams 方法的批评（Chomsky 1957）。理性主义者一般假设语言的关键部分在出生时就被硬连接到大脑中，作为人类遗传遗传的一部分，因此他们试图设计手工制作的规则，将知识和推理机制纳入智能 NLP 系统。直到20世纪80年代，最著名的成功的NLP系统，如为模拟 Rogerian psychotherapist 的 ELIZA 系统和为了规则化真实世界信息为规则本体的 MARGIE 系统，都是基于复杂的手写规则。</p>
<p>这一时期恰逢以专家知识工程为特点的早期智能的早期发展，即领域专家根据其所掌握的（非常狭窄的）应用领域的知识设计计算机程序（Nilsson 1982; Winston 1993）。专家们使用符号逻辑规则设计了这些程序，这些规则基于对这些知识的仔细表征和工程。这些以知识为基础的智能系统往往通过检测&quot;Head&quot;或最重要的参数，并就每种特殊情况采取特定的解决办法，而这在解决狭义问题方面往往是有效的。这些“Head”参数由人类专家预先确定，使“tail”参数和案例不受影响。由于缺乏学习能力，他们有必要将解决方案推广到新的情况和领域。这一时期的典型方法是专家系统所提供的证据，这是一个模拟人类专家决策能力的计算机系统。这种系统旨在通过知识推理来解决复杂的问题（Nilsson 1982）。第一个专家系统建立于1970年代，然后在1980年代推广。使用的主要&quot;算法&quot;是以&quot;if-then-else&quot;为形式的推断规则（Jackson 1998）。这些智能系统的主要优点是其在进行逻辑推理方面（有限）能力的透明度和可解释性。像NLP系统，如 ELIZA 和 MARGIE ，一般专家系统在早期使用手工制作的专家知识，这往往是有效的狭隘的问题，虽然推理无法处理不确定性，是普遍存在的实际应用。</p>
<p>同样，语音识别研究和系统设计，这又是另一个长期存在的 NLP 和反智能挑战，在这个理性主义时代，主要基于专家知识工程的范式，如elegantly analyzed in（Church and Mercer 1993）。在1970年代和1980年代初，专家系统的语音识别方法相当流行（Reddy 1976; Zue 1985）。然而，研究人员敏锐地认识到，缺乏从数据中学习和处理推理不确定性的能力，导致了接下来描述的第二波语音识别、NLP和对于文本的人工智能浪潮也走向失败。</p>
<h3 id="第二波浪潮：经验主义">第二波浪潮：经验主义</h3>
<p>第二波 NLP 浪潮的特点是利用语料库数据以及基于（浅层）机器学习、统计学等来利用这些数据（Manning and Schtze 1999）。由于许多自然语言的结构和理论都被贬低或抛弃，而倾向于数据驱动的方法，这个时代发展的主要方法被称为经验或务实的方法（ChurchandMercer 1993;Church 2014）。NLP 的一个主要会议甚至被命名为“自然语言处理的经验方法（Empirical Methods in Natural Language Processing）（EMNLP）”，最直接地反映了NLP研究人员在那个时代对经验方法的强烈积极情绪。</p>
<p>与理性主义方法相反，经验方法认为人类的思维只是从关联、模式识别和泛化的常规操作开始。丰富的感官输入需要使大脑学习自然语言的详细结构。经验主义盛行于1920年至1960年间，自1990年以来一直在兴起。NLP的早期经验方法主要是开发生成模型，如隐马尔可夫模型 （HMM） （Baum and Petrie 1966）， IBM 翻译模型 （Brown et al. 1993）， 和 head-driven parsing 模型（Collins 1997），以发现大型语料库的规律性。自1990年代后期以来，在各种NLP任务中，歧视性模式已成为事实上的做法。NLP的典型判别模型和方法包括最大熵模型（ratnaparkhi 1997）、支持向量机（Vapnik 1998）、条件随机（Lafferty et al. 2001）、最大相互信息和最小区分器错误（He et al. 2008）还有感知器（Collins 2002）。</p>
<p>在这种经验主义时代中、NLP 与同样的智能方法如语音识别和计算机视觉是平行的。这是在明确的证据表明，学习和感知能力对复杂的智能系统至关重要，但在前一波流行的专家系统中却不存在。例如，当 DARPA 开始对自动驾驶提出重大挑战时，大多数车辆随后依赖于基于知识的智能智能。正如语音识别和NLP 一样，自主驾驶和计算机视觉研究人员意识到基于知识的范式的局限性，因为机器学习需要进行不确定性处理和泛化能力。</p>
<p>在第二波浪潮中，NLP的经验主义和语音识别是基于数据密集型机器学习的，我们现在称之为“shallow”，因为在下一节中描述的第三波浪潮中，数据的多层或“deep”表征通常缺乏抽象结构。在机器学习中，在第一次浪潮中，研究人员不需要考虑构造精确规则，为知识为基础的 NLP 和语音系统。相反，他们把重点放在统计模型（Bishop 2006; Murphy 2012）或作为一个基本引擎的简单的神经网络（Bishop 1995）。然后，他们使用足够的训练数据进行自动学习或“tune（调整）”系统的参数，使它们能够处理不确定性，并尝试从一个条件泛化到另一个条件，从一个领域泛化到另一个领域。机器学习的关键算法和方法包括EM （期望最大化）、贝叶斯网络、支持向量机、决策树以及神经网络的反向传播算法。</p>
<p>一般来说，基于机器学习的NLP、语音和其他智能系统的性能比早期的基于知识的智能系统要好得多。成功的例子包括语音识别 （Jelinek 1998）， 脸部识别 （Viola and Jones 2004）， 实体识别 （Fei-Fei and Perona 2005）， 手写字体识别 （Plamondon and Srihari 2000）， 以及机器翻译 （Och 2003）。</p>
<p>在语音识别方面，从20世纪80年代初到2010年前后近30年，利用基于 HMM 与高斯混合模型相结合的统计生成模型，以及其推广的各种版本（Baker et al. 2009a，b; Deng and O’Shaughnessy 2003; Rabiner and Juang 1993）的统计生成模式。泛化 HMM 的许多版本都是基于统计和神经网络的隐动态模型（Deng 1998; Bridle et al. 1998; Deng and Yu 2007）。前者采用 EM 和 switching extended Kalman ﬁlter 算法学习模型参数（Ma and Deng 2004; Lee et al. 2004），后者采用反向传播（Picone et al. 1999），两者都广泛地利用多个潜在层表示法进行语音分析的生成过程。将这种“深度”生成过程转化为端到端过程的对应方案，导致了深度学习的工业化成功（Deng et al. 2010， 2013; Hinton et al. 2012） ，从而形成了第三波浪潮的驱动力。</p>
<h3 id="第三波浪潮：深度学习">第三波浪潮：深度学习</h3>
<p>在第二波浪潮中开发的 NLP 系统，包括语音识别、语言理解和机器翻译，表现得比在第一波浪潮时更好，鲁棒性更高，但它们远远没有达到人的水平，而这留下了很多需求。除了少数例外，NLP的（浅层）机器学习模型通常没有足够的容量来吸收大量的训练数据。此外，学习算法、方法和基础设施也都不够强大。所有这一切都在几年前发生了变化，而这导致了第三波 NLP 浪潮，这股浪潮是由深层机器学习或深度学习的新范式推动的（Bengio 2009; Deng and Yu 2014; LeCun et al. 2015; Goodfellow et al. 2016）。</p>
<p>深度学习起源于人工神经网络，它可以被看作是受生物神经系统启发的细胞类型的级联模型。随着反向传播算法的出现（Rumelhart et al. 1986），90年代对深度神经网络的训练引起了广泛关注。在没有大量训练数据和没有适当的设计和学习范式的情况下，在神经网络训练过程中，学习信号随着层次数（或更严格的信用分配深度）在层层传播时呈指数形式消失，使得调整深层神经网络特别是递归的版本的连接权重变得异常艰难。Hinton 等人（2006）克服了这个问题，使用无人监督的预训练模型来进行学习有用的特征探测器。然后，通过监督学习进一步训练网络，对标记数据进行分类。因此，可以学习使用低维表征的方式来学习高维的表征的分布。这项开创性的工作标志着神经网络的复兴。此后提出和发展了各种网络结构，包括 Deep Belief 网络（Hinton et al.2006）、堆积自编码器（Vincent et al.2010）、深层玻尔兹曼机（Hinton and Salakhutdinov 2012）、深度卷积神经网络（Krizhevsky et al. 2012），深层堆积网络 （Deng et al. 2012），和深层 Q-networks （Mnih et al. 2015）。深度学习自2010年以来已成功地应用于实际智能领域的实际任务，包括语音识别（Yu et al. 2010; Hinton et al. 2012），图像识别（Krizhevsky et al. 2012; He et al. 2016），以及 NLP 绝大多数领域。</p>
<p>其中由于微软公司在工业化上的成功，以及愈来愈高的准确率等迹象，这些2010-2011年语音识别的惊人成功预示着 NLP 的第三波浪潮和人工智能的到来。随着深度学习在语音识别方面取得成功，计算机视觉（Krizhevsky et al. 2012）和机器翻译（Bahdanau et al. 2015）被类似的深度学习范式所取代。特别是，虽然 Bengio 等人在2001的工作，在2011年就开发了强大的神经词嵌入技术（Bengio et al. 2001），但由于大数据的可用性和更快的计算，它直到10多年后才被证明在一个大规模和实际有用的规模上才能够实际有用（Mikolov et al. 2013）。此外，许多其他现实世界的NLP应用，如图像字幕（Karpathy and Fei-Fei 2015; Fang et al. 2015; Gan et al. 2017），视觉问题回答（Fei-Fei and Perona 2016），语音理解系统（Mesnil et al. 2013），网络搜索（Huang et al. 2013b）和推荐系统由于深度学习而取得成功，此外还有许多非NLP任务，包括药物发现和药理学、客户关系管理、推荐系统、手势识别、医学信息、广告投放、医学图像分析、机器人、自动驾驶车辆、纸板和电子游戏（例如 Atari， Go， Poker， and the latest， DOTA2）等。详情请参阅维基上的深度学习领域。</p>
<p>在更多基于文本的应用领域中，机器翻译可能受到深度学习的影响最大。从 NLP 第二波浪潮中发展起来的浅层——统计机器翻译开始看起的话，目前在实际应用中最好的机器翻译系统是基于深神经网络的。例如，谷歌在2016年9月宣布了其转向神经机器翻译的阶段，两个月后微软也发布了类似的声明。Facebook已经进行了大约一年的机器神经网络翻译的转换工作，到2017年8月它已经完全将这个系统部署成功。</p>
<p>在口语理解和对话系统领域，深度学习也正在产生巨大影响。目前流行的技术以多种方式维护和扩展了第二波时代浪潮中发展起来的统计方法。与经验（浅层）机器学习方法一样，深度学习也是基于数据密集型方法，以降低手工制作规则的成本，对噪声环境下的语音识别错误和语言理解错误具有很强的鲁棒性，并利用决策过程和强化学习的力量来设计对话策略，例如（Gasic et al. 2017; Dhingra et al. 2017）。与早期的方法相比，深度神经网络模型和表征方法更强大，它们使端到端学习成为可能。然而，深度学习也没有解决可解释性和领域泛化问题。</p>
<p>将深度学习应用于 NLP 问题方面的最近的两个重要技术突破是序列到序列学习（Sutskevar et al. 2014）和注意力机制建模（Bahdanau et al. 2015），以及最近的 BERT模型（Jacob el al.2018） 。序列到序列学习引入了一个强大的学习范式，即使用递归神经网络以端到端的方式进行编码和解码。注意力机制建模最初是为了克服编码一个长序列的难度而开发的，后来的持续发展又扩展了它的能力，提供了两个任意序列的高度可塑对齐能力，而其两个可以同时学习神经网络参数。而 BERT 则是实现了双向建模获取以得到更好的语言表征能力。序列到序列学习和注意力机制的关键概念在基于统计学习和词局部表征的最佳系统上提高了基于分布式单词嵌入的神经机器翻译的性能，而 BERT 更重要的意义是双向获取同一文段的高维意义。在这一成功之后，这些概念也被成功地应用到许多其他与NLP相关的任务中，如图像字幕（Karpathy and Fei-Fei 2015; Devlin et al. 2015）、语音识别（Chorowski et al. 2015）、一次性学习、句法分析、唇读、文本理解、摘要以及问答系统等。撇开他们巨大的经验成功不谈，基于神经网络的深度学习模型往往比早期浪潮中的传统机器学习模型更简单、更容易设计。在许多应用中，在端到端的任务中，模型的所有部分都同时进行深度学习，从特征抽取到预测。导致神经网络模型相对简单的另一个因素是，相同的模型构建成的块（即不同类型的层）通常在许多不同的应用中使用。为多种任务使用相同的构建块，这种方法使得模型更容易迁移到其它任务和数据上。此外，谷歌等公司还开发了软件工具包，以便更快、更有效地实现这些模型。由于以上这些原因，神经网络在数据量大而且基于云的方式上，是更常用的。</p>
<p>尽管深度学习在重塑语音、图像和视频的处理方面被证明是有效的，而且具有它的革命性，但在将深度学习与基于文本的 NLP 相结合方面的有效性并不那么明确，尽管它在一些实用的 NLP 任务中取得了经验上的成功。在语音、图像和视频处理中，深度学习通过直接从原始数据学习规律来解决语义差距问题。然而，在 NLP 中，人们提出了更强的理论和结构化模型，即语音、语法和语义，来提取理解和生成自然语言的基本机制，这些机制与神经网络不那么容易兼容。与语音、图像和视频信号相比，从文本数据中学习的神经表征可以对自然语言提供同样直接的见解，但是这个也不够直接。因此，将神经网络，特别是那些具有复杂层次结构的神经网络应用于 NLP，已成为 NLP 和深度学习社区中最活跃的领域，近年来取得了非常显著的进展（Deng 2016; Manning and Socher 2017;Jacob el al.2018）。</p>
<h2 id="16-1-如何理解序列到序列模型？">16.1 如何理解序列到序列模型？</h2>
<h2 id="16-2-序列到序列模型有什么限制吗？">16.2 序列到序列模型有什么限制吗？</h2>
<h2 id="16-3-如果不采用序列到序列模型，可以考虑用其它模型方法吗？">16.3 如果不采用序列到序列模型，可以考虑用其它模型方法吗？</h2>
<h2 id="16-4-如何理解词向量？">16.4 如何理解词向量？</h2>
<h2 id="16-5-词向量哪家好？">16.5 词向量哪家好？</h2>
<h2 id="16-6-解释一下注意力机制的原理？">16.6 解释一下注意力机制的原理？</h2>
<h2 id="16-7-注意力机制是不是适用于所有场景呢？它的鲁棒性如何？">16.7 注意力机制是不是适用于所有场景呢？它的鲁棒性如何？</h2>
<h2 id="16-8-怎么将原有的模型加上注意力机制呢？">16.8 怎么将原有的模型加上注意力机制呢？</h2>
<h2 id="16-9-通俗地解释一下词法分析是什么？有什么应用场景？">16.9 通俗地解释一下词法分析是什么？有什么应用场景？</h2>
<h2 id="16-10-深度学习中的词法分析有哪些常见模型呢？">16.10 深度学习中的词法分析有哪些常见模型呢？</h2>
<h2 id="16-11-通俗地解释一下知识图谱是什么？有什么应用场景？">16.11 通俗地解释一下知识图谱是什么？有什么应用场景？</h2>
<h2 id="16-12-深度学习中的知识图谱有哪些常见模型呢？">16.12 深度学习中的知识图谱有哪些常见模型呢？</h2>
<h2 id="16-13-深度学习中的机器翻译有哪些常见模型呢？">16.13 深度学习中的机器翻译有哪些常见模型呢？</h2>
<h2 id="16-14-机器翻译的通俗实现以及部署过程是怎样的呢？">16.14 机器翻译的通俗实现以及部署过程是怎样的呢？</h2>
<h2 id="16-15-通俗地解释一下文本情感分析是什么？常见的应用场景是？">16.15 通俗地解释一下文本情感分析是什么？常见的应用场景是？</h2>
<h2 id="16-16-最常用的情感分析模型是什么呢？如何快速部署呢？">16.16 最常用的情感分析模型是什么呢？如何快速部署呢？</h2>
<h2 id="16-17-通俗地解释一下问答系统？它涵盖哪些领域？常见的应用场景是？">16.17 通俗地解释一下问答系统？它涵盖哪些领域？常见的应用场景是？</h2>
<h2 id="16-18-常见的问答系统模型是什么？如何快速部署呢？">16.18 常见的问答系统模型是什么？如何快速部署呢？</h2>
<h2 id="16-19-图像文字生成是什么？它的技术原理是什么？">16.19 图像文字生成是什么？它的技术原理是什么？</h2>
<h2 id="16-20-常见的图像文字生成模型是什么？">16.20 常见的图像文字生成模型是什么？</h2>
<h2 id="16-21-NLP-的无监督学习发展动态是怎样的？有哪些领域在尝试无监督学习？">16.21 NLP 的无监督学习发展动态是怎样的？有哪些领域在尝试无监督学习？</h2>
<h2 id="16-22-NLP-和强化学习的结合方式是怎样的？有哪些方向在尝试强化学习？">16.22 NLP 和强化学习的结合方式是怎样的？有哪些方向在尝试强化学习？</h2>
<h2 id="16-23-NLP-和元学习？元学习如何能够和-NLP-结合起来？">16.23 NLP 和元学习？元学习如何能够和 NLP 结合起来？</h2>
<h2 id="16-24-能说一下各自领域最常用且常见的基准模型有哪些吗">16.24 能说一下各自领域最常用且常见的基准模型有哪些吗</h2>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/19/deep_learning/ch4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tom">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="算法工程师的日常">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/19/deep_learning/ch4/" class="post-title-link" itemprop="url">经典网络面试题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-19 23:29:20" itemprop="dateCreated datePublished" datetime="2024-03-19T23:29:20+08:00">2024-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-24 10:13:46" itemprop="dateModified" datetime="2024-03-24T10:13:46+08:00">2024-03-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">算法面试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">深度学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>经典网络解读</h1>
<h2 id="4-1-LeNet-5">4.1 LeNet-5</h2>
<h3 id="4-1-1-模型介绍">4.1.1 模型介绍</h3>
<p>​	LeNet-5是由 $LeCun$  提出的一种用于识别手写数字和机器印刷字符的卷积神经网络（Convolutional Neural Network，CNN） $^{[1]}$ ，其命名来源于作者 $LeCun$ 的名字，5则是其研究成果的代号，在LeNet-5之前还有LeNet-4和LeNet-1鲜为人知。LeNet-5阐述了图像中像素特征之间的相关性能够由参数共享的卷积操作所提取，同时使用卷积、下采样（池化）和非线性映射这样的组合结构，是当前流行的大多数深度图像识别网络的基础。</p>
<h3 id="4-1-2-模型结构">4.1.2 模型结构</h3>
<p><img src="image1.png" alt></p>
<p>​                                                                 图4.1 LeNet-5网络结构图</p>
<p>​	如图4.1所示，LeNet-5一共包含7层（输入层不作为网络结构），分别由2个卷积层、2个下采样层和3个连接层组成，网络的参数配置如表4.1所示，其中下采样层和全连接层的核尺寸分别代表采样范围和连接矩阵的尺寸（如卷积核尺寸中的 $“5\times5\times1/1,6”$ 表示核大小为 $5\times5\times1$ 、步长为 $1​$ 且核个数为6的卷积核）。</p>
<p>​                                                                 表4.1 LeNet-5网络参数配置</p>
<table>
<thead>
<tr>
<th style="text-align:center">网络层</th>
<th style="text-align:center">输入尺寸</th>
<th style="text-align:center">核尺寸</th>
<th style="text-align:center">输出尺寸</th>
<th style="text-align:center">可训练参数量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">卷积层 $C_1$</td>
<td style="text-align:center">$32\times32\times1$</td>
<td style="text-align:center">$5\times5\times1/1,6$</td>
<td style="text-align:center">$28\times28\times6$</td>
<td style="text-align:center">$(5\times5\times1+1)\times6$</td>
</tr>
<tr>
<td style="text-align:center">下采样层 $S_2$</td>
<td style="text-align:center">$28\times28\times6$</td>
<td style="text-align:center">$2\times2/2$</td>
<td style="text-align:center">$14\times14\times6$</td>
<td style="text-align:center">$(1+1)\times6$   $^*$</td>
</tr>
<tr>
<td style="text-align:center">卷积层 $C_3$</td>
<td style="text-align:center">$14\times14\times6$</td>
<td style="text-align:center">$5\times5\times6/1,16$</td>
<td style="text-align:center">$10\times10\times16$</td>
<td style="text-align:center">$1516^*$</td>
</tr>
<tr>
<td style="text-align:center">下采样层 $S_4$</td>
<td style="text-align:center">$10\times10\times16$</td>
<td style="text-align:center">$2\times2/2$</td>
<td style="text-align:center">$5\times5\times16$</td>
<td style="text-align:center">$(1+1)\times16$</td>
</tr>
<tr>
<td style="text-align:center">卷积层 $C_5 {% raw%}$$^*${% endraw %}</td>
<td style="text-align:center">{% raw%}$5\times5\times16${% endraw %}</td>
<td style="text-align:center">{% raw%}$5\times5\times16/1,120${% endraw %}</td>
<td style="text-align:center">{% raw%}$1\times1\times120${% endraw %}</td>
<td style="text-align:center">{% raw%}$(5\times5\times16+1)\times120${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">全连接层 {% raw%}$F_6${% endraw %}</td>
<td style="text-align:center">{% raw%}$1\times1\times120${% endraw %}</td>
<td style="text-align:center">{% raw%}$120\times84${% endraw %}</td>
<td style="text-align:center">{% raw%}$1\times1\times84${% endraw %}</td>
<td style="text-align:center">{% raw%}$(120+1)\times84${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">输出层</td>
<td style="text-align:center">{% raw%}$1\times1\times84${% endraw %}</td>
<td style="text-align:center">{% raw%}$84\times10${% endraw %}</td>
<td style="text-align:center">{% raw%}$1\times1\times10${% endraw %}</td>
<td style="text-align:center">{% raw%}$(84+1)\times10${% endraw %}</td>
</tr>
</tbody>
</table>
<blockquote>
<p>​	 {% raw%}$^*${% endraw %}  在LeNet中，下采样操作和池化操作类似，但是在得到采样结果后会乘以一个系数和加上一个偏置项，所以下采样的参数个数是 {% raw%}$(1+1)\times6​${% endraw %} 而不是零。</p>
<p>​	 {% raw%}$^*${% endraw %}   {% raw%}$C_3${% endraw %} 卷积层可训练参数并未直接连接 {% raw%}$S_2${% endraw %} 中所有的特征图（Feature Map），而是采用如图4.2所示的采样特征方式进行连接（稀疏连接），生成的16个通道特征图中分别按照相邻3个特征图、相邻4个特征图、非相邻4个特征图和全部6个特征图进行映射，得到的参数个数计算公式为 {% raw%}$6\times(25\times3+1)+6\times(25\times4+1)+3\times(25\times4+1)+1\times(25\times6+1)=1516${% endraw %} ，在原论文中解释了使用这种采样方式原因包含两点：限制了连接数不至于过大（当年的计算能力比较弱）;强制限定不同特征图的组合可以使映射得到的特征图学习到不同的特征模式。</p>
</blockquote>
<p><img src="featureMap.jpg" alt="FeatureMap"></p>
<p>​                                                                图4.2  {% raw%}$S_2${% endraw %} 与 {% raw%}$C_3${% endraw %} 之间的特征图稀疏连接</p>
<blockquote>
<p>​	 {% raw%}$^*${% endraw %}   {% raw%}$C_5${% endraw %} 卷积层在图4.1中显示为全连接层，原论文中解释这里实际采用的是卷积操作，只是刚好在 {% raw%}$5\times5${% endraw %} 卷积后尺寸被压缩为 {% raw%}$1\times1​${% endraw %} ，输出结果看起来和全连接很相似。</p>
</blockquote>
<h3 id="4-1-3-模型特性">4.1.3 模型特性</h3>
<ul>
<li>卷积网络使用一个3层的序列组合：卷积、下采样（池化）、非线性映射（LeNet-5最重要的特性，奠定了目前深层卷积网络的基础）</li>
<li>使用卷积提取空间特征</li>
<li>使用映射的空间均值进行下采样</li>
<li>使用 {% raw%}$tanh${% endraw %} 或 {% raw%}$sigmoid${% endraw %} 进行非线性映射</li>
<li>多层神经网络（MLP）作为最终的分类器</li>
<li>层间的稀疏连接矩阵以避免巨大的计算开销</li>
</ul>
<h2 id="4-2-AlexNet">4.2 AlexNet</h2>
<h3 id="4-2-1-模型介绍">4.2.1 模型介绍</h3>
<p>​	AlexNet是由 {% raw%}$Alex${% endraw %}   {% raw%}$Krizhevsky ${% endraw %} 提出的首个应用于图像分类的深层卷积神经网络，该网络在2012年ILSVRC（ImageNet Large Scale Visual Recognition Competition）图像分类竞赛中以15.3%的top-5测试错误率赢得第一名 {% raw%}$^{[2]}${% endraw %} 。AlexNet使用GPU代替CPU进行运算，使得在可接受的时间范围内模型结构能够更加复杂，它的出现证明了深层卷积神经网络在复杂模型下的有效性，使CNN在计算机视觉中流行开来，直接或间接地引发了深度学习的热潮。</p>
<h3 id="4-2-2-模型结构">4.2.2 模型结构</h3>
<p><img src="alexnet.png" alt></p>
<p>​                                                                         图4.3 AlexNet网络结构图</p>
<p>​	如图4.3所示，除去下采样（池化层）和局部响应规范化操作（Local Responsible Normalization, LRN），AlexNet一共包含8层，前5层由卷积层组成，而剩下的3层为全连接层。网络结构分为上下两层，分别对应两个GPU的操作过程，除了中间某些层（ {% raw%}$C_3${% endraw %} 卷积层和 {% raw%}$F_{6-8}${% endraw %} 全连接层会有GPU间的交互），其他层两个GPU分别计算结 果。最后一层全连接层的输出作为 {% raw%}$softmax${% endraw %} 的输入，得到1000个图像分类标签对应的概率值。除去GPU并行结构的设计，AlexNet网络结构与LeNet十分相似，其网络的参数配置如表4.2所示。</p>
<p>​									表4.2 AlexNet网络参数配置</p>
<table>
<thead>
<tr>
<th style="text-align:center">网络层</th>
<th style="text-align:center">输入尺寸</th>
<th style="text-align:center">核尺寸</th>
<th style="text-align:center">输出尺寸</th>
<th style="text-align:center">可训练参数量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">卷积层 {% raw%}$C_1${% endraw %}   {% raw%}$^*${% endraw %}</td>
<td style="text-align:center">{% raw%}$224\times224\times3${% endraw %}</td>
<td style="text-align:center">{% raw%}$11\times11\times3/4,48(\times2_{GPU})${% endraw %}</td>
<td style="text-align:center">{% raw%}$55\times55\times48(\times2_{GPU})${% endraw %}</td>
<td style="text-align:center">{% raw%}$(11\times11\times3+1)\times48\times2${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">下采样层 {% raw%}$S_{max}$${% endraw %} ^*$</td>
<td style="text-align:center">$55\times55\times48(\times2_{GPU})$</td>
<td style="text-align:center">$3\times3/2(\times2_{GPU})$</td>
<td style="text-align:center">$27\times27\times48(\times2_{GPU})$</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">卷积层 $C_2$</td>
<td style="text-align:center">$27\times27\times48(\times2_{GPU})$</td>
<td style="text-align:center">$5\times5\times48/1,128(\times2_{GPU})$</td>
<td style="text-align:center">$27\times27\times128(\times2_{GPU})$</td>
<td style="text-align:center">$(5\times5\times48+1)\times128\times2$</td>
</tr>
<tr>
<td style="text-align:center">下采样层 $S_{max}$</td>
<td style="text-align:center">$27\times27\times128(\times2_{GPU})$</td>
<td style="text-align:center">$3\times3/2(\times2_{GPU})$</td>
<td style="text-align:center">$13\times13\times128(\times2_{GPU})$</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">卷积层 $C_3$   $^*$</td>
<td style="text-align:center">$13\times13\times128\times2_{GPU}$</td>
<td style="text-align:center">$3\times3\times256/1,192(\times2_{GPU})$</td>
<td style="text-align:center">$13\times13\times192(\times2_{GPU})$</td>
<td style="text-align:center">$(3\times3\times256+1)\times192\times2$</td>
</tr>
<tr>
<td style="text-align:center">卷积层 $C_4$</td>
<td style="text-align:center">$13\times13\times192(\times2_{GPU})$</td>
<td style="text-align:center">$3\times3\times192/1,192(\times2_{GPU})$</td>
<td style="text-align:center">$13\times13\times192(\times2_{GPU})$</td>
<td style="text-align:center">$(3\times3\times192+1)\times192\times2$</td>
</tr>
<tr>
<td style="text-align:center">卷积层 $C_5$</td>
<td style="text-align:center">$13\times13\times192(\times2_{GPU})$</td>
<td style="text-align:center">$3\times3\times192/1,128(\times2_{GPU})$</td>
<td style="text-align:center">$13\times13\times128(\times2_{GPU})$</td>
<td style="text-align:center">$(3\times3\times192+1)\times128\times2$</td>
</tr>
<tr>
<td style="text-align:center">下采样层 $S_{max}$</td>
<td style="text-align:center">$13\times13\times128(\times2_{GPU})$</td>
<td style="text-align:center">$3\times3/2(\times2_{GPU})$</td>
<td style="text-align:center">$6\times6\times128(\times2_{GPU})$</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">全连接层 $F_6$    $^*$</td>
<td style="text-align:center">$6\times6\times128\times2_{GPU}$</td>
<td style="text-align:center">$9216\times2048(\times2_{GPU})$</td>
<td style="text-align:center">$1\times1\times2048(\times2_{GPU})$</td>
<td style="text-align:center">$(9216+1)\times2048\times2$</td>
</tr>
<tr>
<td style="text-align:center">全连接层 $F_7$</td>
<td style="text-align:center">$1\times1\times2048\times2_{GPU}$</td>
<td style="text-align:center">$4096\times2048(\times2_{GPU})$</td>
<td style="text-align:center">$1\times1\times2048(\times2_{GPU})$</td>
<td style="text-align:center">$(4096+1)\times2048\times2$</td>
</tr>
<tr>
<td style="text-align:center">全连接层 $F_8$</td>
<td style="text-align:center">$1\times1\times2048\times2_{GPU}$</td>
<td style="text-align:center">$4096\times1000$</td>
<td style="text-align:center">$1\times1\times1000$</td>
<td style="text-align:center">$(4096+1)\times1000\times2$</td>
</tr>
</tbody>
</table>
<blockquote>
<p>卷积层 $C_1$ 输入为 $224\times224\times3$ 的图片数据，分别在两个GPU中经过核为 $11\times11\times3$ 、步长（stride）为4的卷积卷积后，分别得到两条独立的 $55\times55\times48$ 的输出数据。</p>
<p>下采样层 $S_{max}$ 实际上是嵌套在卷积中的最大池化操作，但是为了区分没有采用最大池化的卷积层单独列出来。在 $C_{1-2}$ 卷积层中的池化操作之后（ReLU激活操作之前），还有一个LRN操作，用作对相邻特征点的归一化处理。</p>
<p>卷积层 $C_3$  的输入与其他卷积层不同， $13\times13\times192\times2_{GPU}$ 表示汇聚了上一层网络在两个GPU上的输出结果作为输入，所以在进行卷积操作时通道上的卷积核维度为384。</p>
<p>全连接层 $F_{6-8}$ 中输入数据尺寸也和 $C_3$ 类似，都是融合了两个GPU流向的输出结果作为输入。</p>
</blockquote>
<h3 id="4-2-3-模型特性">4.2.3 模型特性</h3>
<ul>
<li>所有卷积层都使用ReLU作为非线性映射函数，使模型收敛速度更快</li>
<li>在多个GPU上进行模型的训练，不但可以提高模型的训练速度，还能提升数据的使用规模</li>
<li>使用LRN对局部的特征进行归一化，结果作为ReLU激活函数的输入能有效降低错误率</li>
<li>重叠最大池化（overlapping max pooling），即池化范围z与步长s存在关系 $z>s$ （如 $S_{max}$ 中核尺度为 $3\times3/2$ ），避免平均池化（average pooling）的平均效应</li>
<li>使用随机丢弃技术（dropout）选择性地忽略训练中的单个神经元，避免模型的过拟合</li>
</ul>
<h2 id="4-3-ZFNet">4.3 ZFNet</h2>
<h3 id="4-3-1-模型介绍">4.3.1 模型介绍</h3>
<p>​	ZFNet是由 $Matthew$   $D. Zeiler$ 和 $Rob$   $Fergus$ 在AlexNet基础上提出的大型卷积网络，在2013年ILSVRC图像分类竞赛中以11.19%的错误率获得冠军（实际上原ZFNet所在的队伍并不是真正的冠军，原ZFNet以13.51%错误率排在第8，真正的冠军是 $Clarifai$ 这个队伍，而 $Clarifai$ 这个队伍所对应的一家初创公司的CEO又是 $Zeiler$ ，而且 $Clarifai$ 对ZFNet的改动比较小，所以通常认为是ZFNet获得了冠军） $^{[3-4]}​$ 。ZFNet实际上是微调（fine-tuning）了的AlexNet，并通过反卷积（Deconvolution）的方式可视化各层的输出特征图，进一步解释了卷积操作在大型网络中效果显著的原因。</p>
<h3 id="4-3-2-模型结构">4.3.2 模型结构</h3>
<p><img src="image21.png" alt></p>
<p><img src="image21.jpeg" alt></p>
<p>​						图4.4 ZFNet网络结构图（原始结构图与AlexNet风格结构图）</p>
<p>​	如图4.4所示，ZFNet与AlexNet类似，都是由8层网络组成的卷积神经网络，其中包含5层卷积层和3层全连接层。两个网络结构最大的不同在于，ZFNet第一层卷积采用了 $7\times7\times3/2$ 的卷积核替代了AlexNet中第一层卷积核 $11\times11\times3/4$ 的卷积核。图4.5中ZFNet相比于AlexNet在第一层输出的特征图中包含更多中间频率的信息，而AlexNet第一层输出的特征图大多是低频或高频的信息，对中间频率特征的缺失导致后续网络层次如图4.5（c）能够学习到的特征不够细致，而导致这个问题的根本原因在于AlexNet在第一层中采用的卷积核和步长过大。</p>
<p><img src="zfnet-layer1.png" alt></p>
<p><img src="zfnet-layer2.png" alt></p>
<p>​	图4.5 （a）ZFNet第一层输出的特征图（b）AlexNet第一层输出的特征图（c）AlexNet第二层输出的特征图（d）ZFNet第二层输出的特征图</p>
<p>​									表4.3 ZFNet网络参数配置</p>
<table>
<thead>
<tr>
<th style="text-align:center">网络层</th>
<th style="text-align:center">输入尺寸</th>
<th style="text-align:center">核尺寸</th>
<th style="text-align:center">输出尺寸</th>
<th style="text-align:center">可训练参数量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">卷积层 $C_1$   $^*$</td>
<td style="text-align:center">$224\times224\times3$</td>
<td style="text-align:center">$7\times7\times3/2,96$</td>
<td style="text-align:center">$110\times110\times96$</td>
<td style="text-align:center">$(7\times7\times3+1)\times96$</td>
</tr>
<tr>
<td style="text-align:center">下采样层 $S_{max}$</td>
<td style="text-align:center">$110\times110\times96$</td>
<td style="text-align:center">$3\times3/2$</td>
<td style="text-align:center">$55\times55\times96$</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">卷积层 $C_2$   $^*$</td>
<td style="text-align:center">$55\times55\times96$</td>
<td style="text-align:center">$5\times5\times96/2,256$</td>
<td style="text-align:center">$26\times26\times256$</td>
<td style="text-align:center">$(5\times5\times96+1)\times256$</td>
</tr>
<tr>
<td style="text-align:center">下采样层 $S_{max}$</td>
<td style="text-align:center">$26\times26\times256$</td>
<td style="text-align:center">$3\times3/2$</td>
<td style="text-align:center">$13\times13\times256$</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">卷积层 $C_3$</td>
<td style="text-align:center">$13\times13\times256$</td>
<td style="text-align:center">$3\times3\times256/1,384$</td>
<td style="text-align:center">$13\times13\times384$</td>
<td style="text-align:center">$(3\times3\times256+1)\times384$</td>
</tr>
<tr>
<td style="text-align:center">卷积层 $C_4$</td>
<td style="text-align:center">$13\times13\times384$</td>
<td style="text-align:center">$3\times3\times384/1,384$</td>
<td style="text-align:center">$13\times13\times384$</td>
<td style="text-align:center">$(3\times3\times384+1)\times384$</td>
</tr>
<tr>
<td style="text-align:center">卷积层 $C_5$</td>
<td style="text-align:center">$13\times13\times384$</td>
<td style="text-align:center">$3\times3\times384/1,256$</td>
<td style="text-align:center">$13\times13\times256$</td>
<td style="text-align:center">$(3\times3\times384+1)\times256$</td>
</tr>
<tr>
<td style="text-align:center">下采样层 $S_{max}$</td>
<td style="text-align:center">$13\times13\times256$</td>
<td style="text-align:center">$3\times3/2$</td>
<td style="text-align:center">$6\times6\times256$</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">全连接层 $F_6$</td>
<td style="text-align:center">$6\times6\times256$</td>
<td style="text-align:center">$9216\times4096$</td>
<td style="text-align:center">$1\times1\times4096$</td>
<td style="text-align:center">$(9216+1)\times4096$</td>
</tr>
<tr>
<td style="text-align:center">全连接层 $F_7$</td>
<td style="text-align:center">$1\times1\times4096$</td>
<td style="text-align:center">$4096\times4096$</td>
<td style="text-align:center">$1\times1\times4096$</td>
<td style="text-align:center">$(4096+1)\times4096$</td>
</tr>
<tr>
<td style="text-align:center">全连接层 $F_8$</td>
<td style="text-align:center">$1\times1\times4096$</td>
<td style="text-align:center">$4096\times1000$</td>
<td style="text-align:center">$1\times1\times1000$</td>
<td style="text-align:center">$(4096+1)\times1000$</td>
</tr>
</tbody>
</table>
<blockquote>
<p>卷积层 $C_1$ 与AlexNet中的 $C_1$ 有所不同，采用 $7\times7\times3/2$ 的卷积核代替 $11\times11\times3/4​$ ，使第一层卷积输出的结果可以包含更多的中频率特征，对后续网络层中多样化的特征组合提供更多选择，有利于捕捉更细致的特征。</p>
<p>卷积层 $C_2$ 采用了步长2的卷积核，区别于AlexNet中 $C_2$ 的卷积核步长，所以输出的维度有所差异。</p>
</blockquote>
<h3 id="4-3-3-模型特性">4.3.3 模型特性</h3>
<p>​	ZFNet与AlexNet在结构上几乎相同，此部分虽属于模型特性，但准确地说应该是ZFNet原论文中可视化技术的贡献。</p>
<ul>
<li>可视化技术揭露了激发模型中每层单独的特征图。</li>
<li>可视化技术允许观察在训练阶段特征的演变过程且诊断出模型的潜在问题。</li>
<li>可视化技术用到了多层解卷积网络，即由特征激活返回到输入像素空间。</li>
<li>可视化技术进行了分类器输出的敏感性分析，即通过阻止部分输入图像来揭示那部分对于分类是重要的。</li>
<li>可视化技术提供了一个非参数的不变性来展示来自训练集的哪一块激活哪个特征图，不仅需要裁剪输入图片，而且自上而下的投影来揭露来自每块的结构激活一个特征图。</li>
<li>可视化技术依赖于解卷积操作，即卷积操作的逆过程，将特征映射到像素上。</li>
</ul>
<h2 id="4-4-Network-in-Network">4.4 Network in Network</h2>
<h3 id="4-4-1-模型介绍">4.4.1 模型介绍</h3>
<p>​	Network In Network (NIN)是由 $Min Lin$ 等人提出，在CIFAR-10和CIFAR-100分类任务中达到当时的最好水平，因其网络结构是由三个多层感知机堆叠而被成为NIN $^{[5]}$ 。NIN以一种全新的角度审视了卷积神经网络中的卷积核设计，通过引入子网络结构代替纯卷积中的线性映射部分，这种形式的网络结构激发了更复杂的卷积神经网络的结构设计，其中下一节中介绍的GoogLeNet的Inception结构就是来源于这个思想。</p>
<h3 id="4-4-2-模型结构">4.4.2 模型结构</h3>
<p><img src="image23.png" alt><br>
​									图 4.6 NIN网络结构图</p>
<p>​	NIN由三层的多层感知卷积层（MLPConv Layer）构成，每一层多层感知卷积层内部由若干层的局部全连接层和非线性激活函数组成，代替了传统卷积层中采用的线性卷积核。在网络推理（inference）时，这个多层感知器会对输入特征图的局部特征进行划窗计算，并且每个划窗的局部特征图对应的乘积的权重是共享的，这两点是和传统卷积操作完全一致的，最大的不同在于多层感知器对局部特征进行了非线性的映射，而传统卷积的方式是线性的。NIN的网络参数配置表4.4所示（原论文并未给出网络参数，表中参数为编者结合网络结构图和CIFAR-100数据集以 $3\times3$ 卷积为例给出）。</p>
<p>​					表4.4 NIN网络参数配置（结合原论文NIN结构和CIFAR-100数据给出）</p>
<table>
<thead>
<tr>
<th style="text-align:center">网络层</th>
<th style="text-align:center">输入尺寸</th>
<th style="text-align:center">核尺寸</th>
<th style="text-align:center">输出尺寸</th>
<th style="text-align:center">参数个数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">局部全连接层 $L_{11}$   $^*$</td>
<td style="text-align:center">$32\times32\times3$</td>
<td style="text-align:center">$(3\times3)\times16/1$</td>
<td style="text-align:center">$30\times30\times16$</td>
<td style="text-align:center">$(3\times3\times3+1)\times16$</td>
</tr>
<tr>
<td style="text-align:center">全连接层 $L_{12}$   $^*$</td>
<td style="text-align:center">$30\times30\times16$</td>
<td style="text-align:center">$16\times16$</td>
<td style="text-align:center">$30\times30\times16$</td>
<td style="text-align:center">$((16+1)\times16)$</td>
</tr>
<tr>
<td style="text-align:center">局部全连接层 $L_{21}$</td>
<td style="text-align:center">$30\times30\times16$</td>
<td style="text-align:center">$(3\times3)\times64/1$</td>
<td style="text-align:center">$28\times28\times64$</td>
<td style="text-align:center">$(3\times3\times16+1)\times64$</td>
</tr>
<tr>
<td style="text-align:center">全连接层 $L_{22}$</td>
<td style="text-align:center">$28\times28\times64$</td>
<td style="text-align:center">$64\times64$</td>
<td style="text-align:center">$28\times28\times64$</td>
<td style="text-align:center">$((64+1)\times64)$</td>
</tr>
<tr>
<td style="text-align:center">局部全连接层 $L_{31}$</td>
<td style="text-align:center">$28\times28\times64$</td>
<td style="text-align:center">$(3\times3)\times100/1$</td>
<td style="text-align:center">$26\times26\times100$</td>
<td style="text-align:center">$(3\times3\times64+1)\times100$</td>
</tr>
<tr>
<td style="text-align:center">全连接层 $L_{32}$</td>
<td style="text-align:center">$26\times26\times100$</td>
<td style="text-align:center">$100\times100$</td>
<td style="text-align:center">$26\times26\times100$</td>
<td style="text-align:center">$((100+1)\times100)$</td>
</tr>
<tr>
<td style="text-align:center">全局平均采样 $GAP$   $^*$</td>
<td style="text-align:center">$26\times26\times100$</td>
<td style="text-align:center">$26\times26\times100/1$</td>
<td style="text-align:center">$1\times1\times100$</td>
<td style="text-align:center">$0$</td>
</tr>
</tbody>
</table>
<blockquote>
<p>局部全连接层 $L_{11}$ 实际上是对原始输入图像进行划窗式的全连接操作，因此划窗得到的输出特征尺寸为 $30\times30$ （ $\frac{32-3_k+1}{1_{stride}}=30$ ）<br>
全连接层 $L_{12}$ 是紧跟 $L_{11}$ 后的全连接操作，输入的特征是划窗后经过激活的局部响应特征，因此仅需连接 $L_{11}$ 和 $L_{12}$ 的节点即可，而每个局部全连接层和紧接的全连接层构成代替卷积操作的多层感知卷积层（MLPConv）。<br>
全局平均采样层或全局平均池化层 $GAP$ （Global Average Pooling）将 $L_{32}$ 输出的每一个特征图进行全局的平均池化操作，直接得到最后的类别数，可以有效地减少参数量。</p>
</blockquote>
<h3 id="4-4-3-模型特点">4.4.3 模型特点</h3>
<ul>
<li>使用多层感知机结构来代替卷积的滤波操作，不但有效减少卷积核数过多而导致的参数量暴涨问题，还能通过引入非线性的映射来提高模型对特征的抽象能力。</li>
<li>使用全局平均池化来代替最后一个全连接层，能够有效地减少参数量（没有可训练参数），同时池化用到了整个特征图的信息，对空间信息的转换更加鲁棒，最后得到的输出结果可直接作为对应类别的置信度。</li>
</ul>
<h2 id="4-5-VGGNet">4.5 VGGNet</h2>
<h3 id="4-5-1-模型介绍">4.5.1 模型介绍</h3>
<p>​	VGGNet是由牛津大学视觉几何小组（Visual Geometry Group, VGG）提出的一种深层卷积网络结构，他们以7.32%的错误率赢得了2014年ILSVRC分类任务的亚军（冠军由GoogLeNet以6.65%的错误率夺得）和25.32%的错误率夺得定位任务（Localization）的第一名（GoogLeNet错误率为26.44%） $^{[5]}$ ，网络名称VGGNet取自该小组名缩写。VGGNet是首批把图像分类的错误率降低到10%以内模型，同时该网络所采用的 $3\times3$ 卷积核的思想是后来许多模型的基础，该模型发表在2015年国际学习表征会议（International Conference On Learning Representations, ICLR）后至今被引用的次数已经超过1万4千余次。</p>
<h3 id="4-5-2-模型结构">4.5.2 模型结构</h3>
<p><img src="vgg16.png" alt></p>
<p>​								图 4.7 VGG16网络结构图</p>
<p>​	在原论文中的VGGNet包含了6个版本的演进，分别对应VGG11、VGG11-LRN、VGG13、VGG16-1、VGG16-3和VGG19，不同的后缀数值表示不同的网络层数（VGG11-LRN表示在第一层中采用了LRN的VGG11，VGG16-1表示后三组卷积块中最后一层卷积采用卷积核尺寸为 $1\times1$ ，相应的VGG16-3表示卷积核尺寸为 $3\times3$ ），本节介绍的VGG16为VGG16-3。图4.7中的VGG16体现了VGGNet的核心思路，使用 $3\times3$ 的卷积组合代替大尺寸的卷积（2个 $3\times3卷积即可与 {% raw%}$$5\times5${% endraw %} 卷积拥有相同的感受视野），网络参数设置如表4.5所示。</p>
<p>​								表4.5 VGG16网络参数配置</p>
<table>
<thead>
<tr>
<th style="text-align:center">网络层</th>
<th style="text-align:center">输入尺寸</th>
<th style="text-align:center">核尺寸</th>
<th style="text-align:center">输出尺寸</th>
<th style="text-align:center">参数个数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">卷积层 {% raw%}$C_{11}${% endraw %}</td>
<td style="text-align:center">{% raw%}$224\times224\times3${% endraw %}</td>
<td style="text-align:center">{% raw%}$3\times3\times64/1${% endraw %}</td>
<td style="text-align:center">{% raw%}$224\times224\times64${% endraw %}</td>
<td style="text-align:center">{% raw%}$(3\times3\times3+1)\times64${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">卷积层 {% raw%}$C_{12}${% endraw %}</td>
<td style="text-align:center">{% raw%}$224\times224\times64${% endraw %}</td>
<td style="text-align:center">{% raw%}$3\times3\times64/1${% endraw %}</td>
<td style="text-align:center">{% raw%}$224\times224\times64${% endraw %}</td>
<td style="text-align:center">{% raw%}$(3\times3\times64+1)\times64${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">下采样层 {% raw%}$S_{max1}${% endraw %}</td>
<td style="text-align:center">{% raw%}$224\times224\times64${% endraw %}</td>
<td style="text-align:center">{% raw%}$2\times2/2${% endraw %}</td>
<td style="text-align:center">{% raw%}$112\times112\times64${% endraw %}</td>
<td style="text-align:center">{% raw%}$0${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">卷积层 {% raw%}$C_{21}${% endraw %}</td>
<td style="text-align:center">{% raw%}$112\times112\times64${% endraw %}</td>
<td style="text-align:center">{% raw%}$3\times3\times128/1${% endraw %}</td>
<td style="text-align:center">{% raw%}$112\times112\times128${% endraw %}</td>
<td style="text-align:center">{% raw%}$(3\times3\times64+1)\times128${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">卷积层 {% raw%}$C_{22}${% endraw %}</td>
<td style="text-align:center">{% raw%}$112\times112\times128${% endraw %}</td>
<td style="text-align:center">{% raw%}$3\times3\times128/1${% endraw %}</td>
<td style="text-align:center">{% raw%}$112\times112\times128${% endraw %}</td>
<td style="text-align:center">{% raw%}$(3\times3\times128+1)\times128${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">下采样层 {% raw%}$S_{max2}${% endraw %}</td>
<td style="text-align:center">{% raw%}$112\times112\times128${% endraw %}</td>
<td style="text-align:center">{% raw%}$2\times2/2${% endraw %}</td>
<td style="text-align:center">{% raw%}$56\times56\times128${% endraw %}</td>
<td style="text-align:center">{% raw%}$0${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">卷积层 {% raw%}$C_{31}${% endraw %}</td>
<td style="text-align:center">{% raw%}$56\times56\times128${% endraw %}</td>
<td style="text-align:center">{% raw%}$3\times3\times256/1${% endraw %}</td>
<td style="text-align:center">{% raw%}$56\times56\times256${% endraw %}</td>
<td style="text-align:center">{% raw%}$(3\times3\times128+1)\times256${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">卷积层 {% raw%}$C_{32}${% endraw %}</td>
<td style="text-align:center">{% raw%}$56\times56\times256${% endraw %}</td>
<td style="text-align:center">{% raw%}$3\times3\times256/1${% endraw %}</td>
<td style="text-align:center">{% raw%}$56\times56\times256${% endraw %}</td>
<td style="text-align:center">{% raw%}$(3\times3\times256+1)\times256${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">卷积层 {% raw%}$C_{33}${% endraw %}</td>
<td style="text-align:center">{% raw%}$56\times56\times256${% endraw %}</td>
<td style="text-align:center">{% raw%}$3\times3\times256/1${% endraw %}</td>
<td style="text-align:center">{% raw%}$56\times56\times256${% endraw %}</td>
<td style="text-align:center">{% raw%}$(3\times3\times256+1)\times256${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">下采样层 {% raw%}$S_{max3}${% endraw %}</td>
<td style="text-align:center">{% raw%}$56\times56\times256${% endraw %}</td>
<td style="text-align:center">{% raw%}$2\times2/2${% endraw %}</td>
<td style="text-align:center">{% raw%}$28\times28\times256${% endraw %}</td>
<td style="text-align:center">{% raw%}$0${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">卷积层 {% raw%}$C_{41}${% endraw %}</td>
<td style="text-align:center">{% raw%}$28\times28\times256${% endraw %}</td>
<td style="text-align:center">{% raw%}$3\times3\times512/1${% endraw %}</td>
<td style="text-align:center">{% raw%}$28\times28\times512${% endraw %}</td>
<td style="text-align:center">{% raw%}$(3\times3\times256+1)\times512${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">卷积层 {% raw%}$C_{42}${% endraw %}</td>
<td style="text-align:center">{% raw%}$28\times28\times512${% endraw %}</td>
<td style="text-align:center">{% raw%}$3\times3\times512/1${% endraw %}</td>
<td style="text-align:center">{% raw%}$28\times28\times512${% endraw %}</td>
<td style="text-align:center">{% raw%}$(3\times3\times512+1)\times512${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">卷积层 {% raw%}$C_{43}${% endraw %}</td>
<td style="text-align:center">{% raw%}$28\times28\times512${% endraw %}</td>
<td style="text-align:center">{% raw%}$3\times3\times512/1${% endraw %}</td>
<td style="text-align:center">{% raw%}$28\times28\times512${% endraw %}</td>
<td style="text-align:center">{% raw%}$(3\times3\times512+1)\times512${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">下采样层 {% raw%}$S_{max4}${% endraw %}</td>
<td style="text-align:center">{% raw%}$28\times28\times512${% endraw %}</td>
<td style="text-align:center">{% raw%}$2\times2/2${% endraw %}</td>
<td style="text-align:center">{% raw%}$14\times14\times512${% endraw %}</td>
<td style="text-align:center">{% raw%}$0${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">卷积层 {% raw%}$C_{51}${% endraw %}</td>
<td style="text-align:center">{% raw%}$14\times14\times512${% endraw %}</td>
<td style="text-align:center">{% raw%}$3\times3\times512/1${% endraw %}</td>
<td style="text-align:center">{% raw%}$14\times14\times512${% endraw %}</td>
<td style="text-align:center">{% raw%}$(3\times3\times512+1)\times512${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">卷积层 {% raw%}$C_{52}${% endraw %}</td>
<td style="text-align:center">{% raw%}$14\times14\times512${% endraw %}</td>
<td style="text-align:center">{% raw%}$3\times3\times512/1${% endraw %}</td>
<td style="text-align:center">{% raw%}$14\times14\times512${% endraw %}</td>
<td style="text-align:center">{% raw%}$(3\times3\times512+1)\times512${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">卷积层 {% raw%}$C_{53}${% endraw %}</td>
<td style="text-align:center">{% raw%}$14\times14\times512${% endraw %}</td>
<td style="text-align:center">{% raw%}$3\times3\times512/1${% endraw %}</td>
<td style="text-align:center">{% raw%}$14\times14\times512${% endraw %}</td>
<td style="text-align:center">{% raw%}$(3\times3\times512+1)\times512${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">下采样层 {% raw%}$S_{max5}${% endraw %}</td>
<td style="text-align:center">{% raw%}$14\times14\times512${% endraw %}</td>
<td style="text-align:center">{% raw%}$2\times2/2${% endraw %}</td>
<td style="text-align:center">{% raw%}$7\times7\times512${% endraw %}</td>
<td style="text-align:center">{% raw%}$0${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">全连接层 {% raw%}$FC_{1}${% endraw %}</td>
<td style="text-align:center">{% raw%}$7\times7\times512${% endraw %}</td>
<td style="text-align:center">{% raw%}$(7\times7\times512)\times4096${% endraw %}</td>
<td style="text-align:center">{% raw%}$1\times4096${% endraw %}</td>
<td style="text-align:center">{% raw%}$(7\times7\times512+1)\times4096${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">全连接层 {% raw%}$FC_{2}${% endraw %}</td>
<td style="text-align:center">{% raw%}$1\times4096${% endraw %}</td>
<td style="text-align:center">{% raw%}$4096\times4096${% endraw %}</td>
<td style="text-align:center">{% raw%}$1\times4096${% endraw %}</td>
<td style="text-align:center">{% raw%}$(4096+1)\times4096${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">全连接层 {% raw%}$FC_{3}${% endraw %}</td>
<td style="text-align:center">{% raw%}$1\times4096${% endraw %}</td>
<td style="text-align:center">{% raw%}$4096\times1000${% endraw %}</td>
<td style="text-align:center">{% raw%}$1\times1000${% endraw %}</td>
<td style="text-align:center">{% raw%}$(4096+1)\times1000${% endraw %}</td>
</tr>
</tbody>
</table>
<h3 id="4-5-3-模型特性">4.5.3 模型特性</h3>
<ul>
<li>整个网络都使用了同样大小的卷积核尺寸 {% raw%}$3\times3${% endraw %} 和最大池化尺寸 {% raw%}$2\times2${% endraw %} 。</li>
<li>
{% raw%}$1\times1${% endraw %} 卷积的意义主要在于线性变换，而输入通道数和输出通道数不变，没有发生降维。
</li>
<li>两个 {% raw%}$3\times3${% endraw %} 的卷积层串联相当于1个 {% raw%}$5\times5${% endraw %} 的卷积层，感受野大小为 {% raw%}$5\times5${% endraw %} 。同样地，3个 {% raw%}$3\times3${% endraw %} 的卷积层串联的效果则相当于1个 {% raw%}$7\times7${% endraw %} 的卷积层。这样的连接方式使得网络参数量更小，而且多层的激活函数令网络对特征的学习能力更强。</li>
<li>VGGNet在训练时有一个小技巧，先训练浅层的的简单网络VGG11，再复用VGG11的权重来初始化VGG13，如此反复训练并初始化VGG19，能够使训练时收敛的速度更快。</li>
<li>在训练过程中使用多尺度的变换对原始数据做数据增强，使得模型不易过拟合。</li>
</ul>
<h2 id="4-6-GoogLeNet">4.6 GoogLeNet</h2>
<h3 id="4-6-1-模型介绍">4.6.1 模型介绍</h3>
<p>​	GoogLeNet作为2014年ILSVRC在分类任务上的冠军，以6.65%的错误率力压VGGNet等模型，在分类的准确率上面相比过去两届冠军ZFNet和AlexNet都有很大的提升。从名字<strong>GoogLe</strong>Net可以知道这是来自谷歌工程师所设计的网络结构，而名字中Goog<strong>LeNet</strong>更是致敬了LeNet {% raw%}$^{[0]}${% endraw %} 。GoogLeNet中最核心的部分是其内部子网络结构Inception，该结构灵感来源于NIN，至今已经经历了四次版本迭代（Inception {% raw%}$_{v1-4}${% endraw %} ）。</p>
<p><img src="img_inception_01.png" alt><br>
​					图 4.8 Inception性能比较图</p>
<h3 id="4-6-2-模型结构">4.6.2 模型结构</h3>
<p><img src="image25.jpeg" alt><br>
​					图 4.9 GoogLeNet网络结构图<br>
​	如图4.9中所示，GoogLeNet相比于以前的卷积神经网络结构，除了在深度上进行了延伸，还对网络的宽度进行了扩展，整个网络由许多块状子网络的堆叠而成，这个子网络构成了Inception结构。图4.9为Inception的四个版本： {% raw%}$Inception_{v1}​${% endraw %} 在同一层中采用不同的卷积核，并对卷积结果进行合并; {% raw%}$Inception_{v2}​${% endraw %} 组合不同卷积核的堆叠形式，并对卷积结果进行合并; {% raw%}$Inception_{v3}​${% endraw %} 则在 {% raw%}$v_2​${% endraw %} 基础上进行深度组合的尝试; {% raw%}$Inception_{v4}​${% endraw %} 结构相比于前面的版本更加复杂，子网络中嵌套着子网络。</p>
 {% raw%}$Inception_{v1}${% endraw %} 
<p><img src="image27.png" alt></p>
<p><img src="image28.png" alt></p>
 {% raw%}$Inception_{v2}${% endraw %} 
<p><img src="image34.png" alt></p>
<p><img src="image36.png" alt></p>
<p><img src="image38.png" alt></p>
 {% raw%}$Inception_{v3}${% endraw %} 
<p><img src="image37.png" alt></p>
 {% raw%}$Inception_{v4}${% endraw %} 
<p><img src="image46.png" alt></p>
<p><img src="image47.png" alt></p>
<p><img src="image63.png" alt></p>
<p>​					图 4.10 Inception {% raw%}$_{v1-4}${% endraw %} 结构图</p>
<p>​					表 4.6 GoogLeNet中Inception {% raw%}$_{v1}${% endraw %} 网络参数配置</p>
<table>
<thead>
<tr>
<th style="text-align:center">网络层</th>
<th style="text-align:center">输入尺寸</th>
<th style="text-align:center">核尺寸</th>
<th style="text-align:center">输出尺寸</th>
<th style="text-align:center">参数个数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">卷积层 {% raw%}$C_{11}${% endraw %}</td>
<td style="text-align:center">{% raw%}$H\times{W}\times{C_1}${% endraw %}</td>
<td style="text-align:center">{% raw%}$1\times1\times{C_2}/2${% endraw %}</td>
<td style="text-align:center">{% raw%}$\frac{H}{2}\times\frac{W}{2}\times{C_2}${% endraw %}</td>
<td style="text-align:center">{% raw%}$(1\times1\times{C_1}+1)\times{C_2}${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">卷积层 {% raw%}$C_{21}${% endraw %}</td>
<td style="text-align:center">{% raw%}$H\times{W}\times{C_2}${% endraw %}</td>
<td style="text-align:center">{% raw%}$1\times1\times{C_2}/2${% endraw %}</td>
<td style="text-align:center">{% raw%}$\frac{H}{2}\times\frac{W}{2}\times{C_2}${% endraw %}</td>
<td style="text-align:center">{% raw%}$(1\times1\times{C_2}+1)\times{C_2}${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">卷积层 {% raw%}$C_{22}${% endraw %}</td>
<td style="text-align:center">{% raw%}$H\times{W}\times{C_2}${% endraw %}</td>
<td style="text-align:center">{% raw%}$3\times3\times{C_2}/1${% endraw %}</td>
<td style="text-align:center">{% raw%}$H\times{W}\times{C_2}/1${% endraw %}</td>
<td style="text-align:center">{% raw%}$(3\times3\times{C_2}+1)\times{C_2}${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">卷积层 {% raw%}$C_{31}${% endraw %}</td>
<td style="text-align:center">{% raw%}$H\times{W}\times{C_1}${% endraw %}</td>
<td style="text-align:center">{% raw%}$1\times1\times{C_2}/2${% endraw %}</td>
<td style="text-align:center">{% raw%}$\frac{H}{2}\times\frac{W}{2}\times{C_2}${% endraw %}</td>
<td style="text-align:center">{% raw%}$(1\times1\times{C_1}+1)\times{C_2}${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">卷积层 {% raw%}$C_{32}${% endraw %}</td>
<td style="text-align:center">{% raw%}$H\times{W}\times{C_2}${% endraw %}</td>
<td style="text-align:center">{% raw%}$5\times5\times{C_2}/1${% endraw %}</td>
<td style="text-align:center">{% raw%}$H\times{W}\times{C_2}/1${% endraw %}</td>
<td style="text-align:center">{% raw%}$(5\times5\times{C_2}+1)\times{C_2}${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">下采样层 {% raw%}$S_{41}${% endraw %}</td>
<td style="text-align:center">{% raw%}$H\times{W}\times{C_1}${% endraw %}</td>
<td style="text-align:center">{% raw%}$3\times3/2${% endraw %}</td>
<td style="text-align:center">{% raw%}$\frac{H}{2}\times\frac{W}{2}\times{C_2}${% endraw %}</td>
<td style="text-align:center">{% raw%}$0${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">卷积层 {% raw%}$C_{42}${% endraw %}</td>
<td style="text-align:center">{% raw%}$\frac{H}{2}\times\frac{W}{2}\times{C_2}${% endraw %}</td>
<td style="text-align:center">{% raw%}$1\times1\times{C_2}/1${% endraw %}</td>
<td style="text-align:center">{% raw%}$\frac{H}{2}\times\frac{W}{2}\times{C_2}${% endraw %}</td>
<td style="text-align:center">{% raw%}$(3\times3\times{C_2}+1)\times{C_2}${% endraw %}</td>
</tr>
<tr>
<td style="text-align:center">合并层 {% raw%}$M${% endraw %}</td>
<td style="text-align:center">{% raw%}$\frac{H}{2}\times\frac{W}{2}\times{C_2}(\times4)${% endraw %}</td>
<td style="text-align:center">拼接</td>
<td style="text-align:center">{% raw%}$\frac{H}{2}\times\frac{W}{2}\times({C_2}\times4)${% endraw %}</td>
<td style="text-align:center">{% raw%}$0${% endraw %}</td>
</tr>
</tbody>
</table>
<h3 id="4-6-3-模型特性">4.6.3 模型特性</h3>
<ul>
<li>
<p>采用不同大小的卷积核意味着不同大小的感受野，最后拼接意味着不同尺度特征的融合；</p>
</li>
<li>
<p>之所以卷积核大小采用1、3和5，主要是为了方便对齐。设定卷积步长stride=1之后，只要分别设定pad=0、1、2，那么卷积之后便可以得到相同维度的特征，然后这些特征就可以直接拼接在一起了；</p>
</li>
<li>
<p>网络越到后面，特征越抽象，而且每个特征所涉及的感受野也更大了，因此随着层数的增加，3x3和5x5卷积的比例也要增加。但是，使用5x5的卷积核仍然会带来巨大的计算量。 为此，文章借鉴NIN2，采用1x1卷积核来进行降维。</p>
<h1></h1>
</li>
</ul>
<h2 id="Restnet">Restnet</h2>
<h2 id="Densenet">Densenet</h2>
<h2 id="4-7-为什么现在的CNN模型都是在GoogleNet、VGGNet或者AlexNet上调整的？">4.7 为什么现在的CNN模型都是在GoogleNet、VGGNet或者AlexNet上调整的？</h2>
<ul>
<li>评测对比：为了让自己的结果更有说服力，在发表自己成果的时候会同一个标准的baseline及在baseline上改进而进行比较，常见的比如各种检测分割的问题都会基于VGG或者Resnet101这样的基础网络。</li>
<li>时间和精力有限：在科研压力和工作压力中，时间和精力只允许大家在有限的范围探索。</li>
<li>模型创新难度大：进行基本模型的改进需要大量的实验和尝试，并且需要大量的实验积累和强大灵感，很有可能投入产出比比较小。</li>
<li>资源限制：创造一个新的模型需要大量的时间和计算资源，往往在学校和小型商业团队不可行。</li>
<li>在实际的应用场景中，其实是有大量的非标准模型的配置。</li>
</ul>
<h2 id="参考文献">参考文献</h2>
<p>[1] Y. LeCun, L. Bottou, Y. Bengio, and P. Haffner. Gradient-based learning applied to document recognition. <em>Proceedings of the IEEE</em>, november 1998.</p>
<p>[2] A. Krizhevsky, I. Sutskever and G. E. Hinton. ImageNet Classification with Deep Convolutional Neural Networks. <em>Advances in Neural Information Processing Systems 25</em>. Curran Associates, Inc. 1097–1105.</p>
<p>[3] LSVRC-2013. <a target="_blank" rel="noopener" href="http://www.image-net.org/challenges/LSVRC/2013/results.php">http://www.image-net.org/challenges/LSVRC/2013/results.php</a></p>
<p>[4] M. D. Zeiler and R. Fergus. Visualizing and Understanding Convolutional Networks. <em>European Conference on Computer Vision</em>.</p>
<p>[5] M. Lin,  Q. Chen,  and S. Yan.   Network in network. <em>Computing Research Repository</em>, abs/1312.4400, 2013.</p>
<p>[6] K. Simonyan and A. Zisserman.  Very Deep Convolutional Networks for Large-Scale Image Recognition. <em>International Conference on Machine Learning</em>, 2015.</p>
<p>[7] Bharath Raj. <a target="_blank" rel="noopener" href="https://towardsdatascience.com/a-simple-guide-to-the-versions-of-the-inception-network-7fc52b863202">a-simple-guide-to-the-versions-of-the-inception-network</a>, 2018.</p>
<p>[8] Christian Szegedy, Sergey Ioffe, Vincent Vanhoucke, Alex Alemi. <a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1602.07261.pdf">Inception-v4, Inception-ResNet and<br>
the Impact of Residual Connections on Learning</a>, 2016.</p>
<p>[9] Sik-Ho Tsang. <a target="_blank" rel="noopener" href="https://towardsdatascience.com/review-inception-v4-evolved-from-googlenet-merged-with-resnet-idea-image-classification-5e8c339d18bc">review-inception-v4-evolved-from-googlenet-merged-with-resnet-idea-image-classification</a>, 2018.</p>
<p>[10] Zbigniew Wojna, Christian Szegedy, Vincent Vanhoucke, Sergey Ioffe, Jonathon Shlens. <a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1512.00567v3.pdf">Rethinking the Inception Architecture for Computer Vision</a>, 2015.</p>
<p>[11] Christian Szegedy, Wei Liu, Yangqing Jia, Pierre Sermanet, Scott Reed, Dragomir Anguelov, Dumitru Erhan, Vincent Vanhoucke, Andrew Rabinovich. <a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1409.4842v1.pdf">Going deeper with convolutions</a>, 2014.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/19/deep_learning/ch5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tom">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="算法工程师的日常">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/19/deep_learning/ch5/" class="post-title-link" itemprop="url">卷积神经网络面试题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-19 23:29:20" itemprop="dateCreated datePublished" datetime="2024-03-19T23:29:20+08:00">2024-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-24 10:13:49" itemprop="dateModified" datetime="2024-03-24T10:13:49+08:00">2024-03-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">算法面试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">深度学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>卷积神经网络（CNN）</h1>
<p>​	卷积神经网络是一种用来处理局部和整体相关性的计算网络结构，被应用在图像识别、自然语言处理甚至是语音识别领域，因为图像数据具有显著的局部与整体关系，其在图像识别领域的应用获得了巨大的成功。</p>
<h2 id="5-1-卷积神经网络的组成层">5.1 卷积神经网络的组成层</h2>
<p>​	以图像分类任务为例，在表5.1所示卷积神经网络中，一般包含5种类型的网络层次结构：</p>
<p>​                                                                 表5.1 卷积神经网络的组成</p>
<table>
<thead>
<tr>
<th style="text-align:center">CNN层次结构</th>
<th style="text-align:center">输出尺寸</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">输入层</td>
<td style="text-align:center">$W_1\times H_1\times 3$</td>
<td style="text-align:left">卷积网络的原始输入，可以是原始或预处理后的像素矩阵</td>
</tr>
<tr>
<td style="text-align:center">卷积层</td>
<td style="text-align:center">$W_1\times H_1\times K$</td>
<td style="text-align:left">参数共享、局部连接，利用平移不变性从全局特征图提取局部特征</td>
</tr>
<tr>
<td style="text-align:center">激活层</td>
<td style="text-align:center">$W_1\times H_1\times K$</td>
<td style="text-align:left">将卷积层的输出结果进行非线性映射</td>
</tr>
<tr>
<td style="text-align:center">池化层</td>
<td style="text-align:center">$W_2\times H_2\times K$</td>
<td style="text-align:left">进一步筛选特征，可以有效减少后续网络层次所需的参数量</td>
</tr>
<tr>
<td style="text-align:center">全连接层</td>
<td style="text-align:center">$(W_2 \cdot H_2 \cdot K)\times C$</td>
<td style="text-align:left">将多维特征展平为2维特征，通常低维度特征对应任务的学习目标（类别或回归值）</td>
</tr>
</tbody>
</table>
<blockquote>
 $W_1\times H_1\times 3$ 对应原始图像或经过预处理的像素值矩阵，3对应RGB图像的通道; $K$ 表示卷积层中卷积核（滤波器）的个数; $W_2\times H_2$  为池化后特征图的尺度，在全局池化中尺度对应 $1\times 1$ ; $(W_2 \cdot H_2 \cdot K)$ 是将多维特征压缩到1维之后的大小， $C$ 对应的则是图像类别个数。
</blockquote>
<h3 id="5-1-1-输入层">5.1.1 输入层</h3>
<p>​	输入层(Input Layer)通常是输入卷积神经网络的原始数据或经过预处理的数据，可以是图像识别领域中原始三维的多彩图像，也可以是音频识别领域中经过傅利叶变换的二维波形数据，甚至是自然语言处理中一维表示的句子向量。以图像分类任务为例，输入层输入的图像一般包含RGB三个通道，是一个由长宽分别为 $H$ 和 $W$ 组成的3维像素值矩阵 $H\times W \times 3$ ，卷积网络会将输入层的数据传递到一系列卷积、池化等操作进行特征提取和转化，最终由全连接层对特征进行汇总和结果输出。根据计算能力、存储大小和模型结构的不同，卷积神经网络每次可以批量处理的图像个数不尽相同，若指定输入层接收到的图像个数为 $N$ ，则输入层的输出数据为 $N\times H\times W\times 3$ 。</p>
<h3 id="5-1-2-卷积层">5.1.2 卷积层</h3>
<p>​	卷积层(Convolution Layer)通常用作对输入层输入数据进行特征提取，通过卷积核矩阵对原始数据中隐含关联性的一种抽象。卷积操作原理上其实是对两张像素矩阵进行点乘求和的数学操作，其中一个矩阵为输入的数据矩阵，另一个矩阵则为卷积核（滤波器或特征矩阵），求得的结果表示为原始图像中提取的特定局部特征。图5.1表示卷积操作过程中的不同填充策略，上半部分采用零填充，下半部分采用有效卷积（舍弃不能完整运算的边缘部分）。<br>
​                                                 <img src="convolution.png" alt="conv-same"><br>
​                                                        图5.1 卷积操作示意图</p>
<h3 id="5-1-3-激活层">5.1.3 激活层</h3>
<p>​	激活层(Activation Layer)负责对卷积层抽取的特征进行激活，由于卷积操作是由输入矩阵与卷积核矩阵进行相差的线性变化关系，需要激活层对其进行非线性的映射。激活层主要由激活函数组成，即在卷积层输出结果的基础上嵌套一个非线性函数，让输出的特征图具有非线性关系。卷积网络中通常采用ReLU来充当激活函数（还包括tanh和sigmoid等）ReLU的函数形式如公式（5-1）所示，能够限制小于0的值为0,同时大于等于0的值保持不变。</p>
 $$
f(x)=\begin{cases}
   0 &\text{if } x<0 0 \\ x &\text{if } x\ge \end{cases} \tag{5-1} $$ <h3 id="5-1-4-池化层">5.1.4 池化层
<p>​	池化层又称为降采样层(Downsampling Layer)，作用是对感受域内的特征进行筛选，提取区域内最具代表性的特征，能够有效地降低输出特征尺度，进而减少模型所需要的参数量。按操作类型通常分为最大池化(Max Pooling)、平均池化(Average Pooling)和求和池化(Sum Pooling)，它们分别提取感受域内最大、平均与总和的特征值作为输出，最常用的是最大池化。</p>
<h3 id="5-1-5-全连接层">5.1.5 全连接层</h3>
<p>​	全连接层(Full Connected Layer)负责对卷积神经网络学习提取到的特征进行汇总，将多维的特征输入映射为二维的特征输出，高维表示样本批次，低位常常对应任务目标。</p>
<h2 id="5-2-卷积在图像中有什么直观作用">5.2 卷积在图像中有什么直观作用</h2>
<p>​	在卷积神经网络中，卷积常用来提取图像的特征，但不同层次的卷积操作提取到的特征类型是不相同的，特征类型粗分如表5.2所示。<br>
​                                                                 表5.2 卷积提取的特征类型</p>
<table>
<thead>
<tr>
<th style="text-align:center">卷积层次</th>
<th style="text-align:center">特征类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">浅层卷积</td>
<td style="text-align:center">边缘特征</td>
</tr>
<tr>
<td style="text-align:center">中层卷积</td>
<td style="text-align:center">局部特征</td>
</tr>
<tr>
<td style="text-align:center">深层卷积</td>
<td style="text-align:center">全局特征</td>
</tr>
</tbody>
</table>
<p>图像与不同卷积核的卷积可以用来执行边缘检测、锐化和模糊等操作。表5.3显示了应用不同类型的卷积核（滤波器）后的各种卷积图像。<br>
​                                                                 表5.3 一些常见卷积核的作用</p>
<table>
<thead>
<tr>
<th style="text-align:center">卷积作用</th>
<th style="text-align:center">卷积核</th>
<th style="text-align:center">卷积后图像</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">输出原图</td>
<td style="text-align:center">$\begin{bmatrix} 0 & 0 & 0 \\ 0 & 1 & 0 \\ 0 & 0 & 0 \end{bmatrix}$</td>
<td style="text-align:center"><img src="cat.jpg" alt="origin_img"></td>
</tr>
<tr>
<td style="text-align:center">边缘检测（突出边缘差异）</td>
<td style="text-align:center">$\begin{bmatrix} 1 & 0 & -1 \\ 0 & 0 & 0 \\ -1 & 0 & 1 \end{bmatrix}$</td>
<td style="text-align:center"><img src="cat-edgeDetect.jpg" alt="edgeDetect-1"></td>
</tr>
<tr>
<td style="text-align:center">边缘检测（突出中间值）</td>
<td style="text-align:center">$\begin{bmatrix} -1 & -1 & -1 \\ -1 & 8 & -1 \\ -1 & -1 & -1 \end{bmatrix}$</td>
<td style="text-align:center"><img src="cat-edgeDetect-2.jpg" alt="edgeDetect-2"></td>
</tr>
<tr>
<td style="text-align:center">图像锐化</td>
<td style="text-align:center">$\begin{bmatrix} 0 & -1 & 0 \\ -1 & 5 & -1 \\ 0 & -1 & 0 \end{bmatrix}$</td>
<td style="text-align:center"><img src="cat-sharpen.jpg" alt="sharpen_img"></td>
</tr>
<tr>
<td style="text-align:center">方块模糊</td>
<td style="text-align:center">$\begin{bmatrix} 1 & 1 & 1 \\ 1 & 1 & 1 \\ 1 & 1 & 1 \end{bmatrix} \times \frac{1}{9}$</td>
<td style="text-align:center"><img src="cat-boxblur.jpg" alt="box_blur"></td>
</tr>
<tr>
<td style="text-align:center">高斯模糊</td>
<td style="text-align:center">$\begin{bmatrix} 1 & 2 & 1 \\ 2 & 4 & 2 \\ 1 & 2 & 1 \end{bmatrix} \times \frac{1}{16}$</td>
<td style="text-align:center"><img src="cat-blur-gaussian.jpg" alt="gaussian_blur"></td>
</tr>
</tbody>
</table>
<h2 id="5-3-卷积层有哪些基本参数？">5.3 卷积层有哪些基本参数？</h2>
<p>​	卷积层中需要用到卷积核（滤波器或特征检测器）与图像特征矩阵进行点乘运算，利用卷积核与对应的特征感受域进行划窗式运算时，需要设定卷积核对应的大小、步长、个数以及填充的方式，如表5.4所示。</p>
<p>​                                                            		     表5.4 卷积层的基本参数</p>
<table>
<thead>
<tr>
<th style="text-align:center">参数名</th>
<th style="text-align:left">作用</th>
<th style="text-align:left">常见设置</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">卷积核大小 (Kernel Size)</td>
<td style="text-align:left">卷积核的大小定义了卷积的感受野</td>
<td style="text-align:left">在过去常设为5，如LeNet-5；现在多设为3，通过堆叠 $3\times3$ 的卷积核来达到更大的感受域</td>
</tr>
<tr>
<td style="text-align:center">卷积核步长 (Stride)</td>
<td style="text-align:left">定义了卷积核在卷积过程中的步长</td>
<td style="text-align:left">常见设置为1，表示滑窗距离为1，可以覆盖所有相邻位置特征的组合；当设置为更大值时相当于对特征组合降采样</td>
</tr>
<tr>
<td style="text-align:center">填充方式 (Padding)</td>
<td style="text-align:left">在卷积核尺寸不能完美匹配输入的图像矩阵时需要进行一定的填充策略</td>
<td style="text-align:left">设置为’SAME’表示对不足卷积核大小的边界位置进行某种填充（通常零填充）以保证卷积输出维度与与输入维度一致；当设置为’VALID’时则对不足卷积尺寸的部分进行舍弃，输出维度就无法保证与输入维度一致</td>
</tr>
<tr>
<td style="text-align:center">输入通道数 (In Channels)</td>
<td style="text-align:left">指定卷积操作时卷积核的深度</td>
<td style="text-align:left">默认与输入的特征矩阵通道数（深度）一致；在某些压缩模型中会采用通道分离的卷积方式</td>
</tr>
<tr>
<td style="text-align:center">输出通道数 (Out Channels)</td>
<td style="text-align:left">指定卷积核的个数</td>
<td style="text-align:left">若设置为与输入通道数一样的大小，可以保持输入输出维度的一致性；若采用比输入通道数更小的值，则可以减少整体网络的参数量</td>
</tr>
</tbody>
</table>
<blockquote>
<p>卷积操作维度变换公式：</p>
 $O_d =\begin{cases} \lceil \frac{(I_d - k_{size})+ 1)}{s}\rceil ,& \text{padding=VALID}\\ \lceil \frac{I_d}{s}\rceil,&\text{padding=SAME} \end{cases}$ 
<p>其中， $I_d$ 为输入维度， $O_d$ 为输出维度， $k_{size}$ 为卷积核大小， $s$ 为步长</p>
</blockquote>
<h2 id="5-4-卷积核有什么类型？">5.4 卷积核有什么类型？</h2>
<p>​	常见的卷积主要是由连续紧密的卷积核对输入的图像特征进行滑窗式点乘求和操作，除此之外还有其他类型的卷积核在不同的任务中会用到，具体分类如表5.5所示。<br>
​                                                                 	表5.5 卷积核分类</p>
<table>
<thead>
<tr>
<th style="text-align:center">卷积类别</th>
<th style="text-align:center">示意图</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">标准卷积</td>
<td style="text-align:center"><img src="img7.png" alt="image"></td>
<td style="text-align:left">最常用的卷积核，连续紧密的矩阵形式可以提取图像区域中的相邻像素之间的关联关系， $3\times3$ 的卷积核可以获得 $3\times3$ 像素范围的感受视野</td>
</tr>
<tr>
<td style="text-align:center">扩张卷积（带孔卷积或空洞卷积）</td>
<td style="text-align:center"><img src="img8.png" alt="image"></td>
<td style="text-align:left">引入一个称作扩张率（Dilation Rate）的参数，使同样尺寸的卷积核可以获得更大的感受视野，相应的在相同感受视野的前提下比普通卷积采用更少的参数。同样是 $3\times3$ 的卷积核尺寸，扩张卷积可以提取 $5\times5$ 范围的区域特征，在实时图像分割领域广泛应用</td>
</tr>
<tr>
<td style="text-align:center">转置卷积</td>
<td style="text-align:center"><img src="img10.png" alt="image"></td>
<td style="text-align:left">先对原始特征矩阵进行填充使其维度扩大到适配卷积目标输出维度，然后进行普通的卷积操作的一个过程，其输入到输出的维度变换关系恰好与普通卷积的变换关系相反，但这个变换并不是真正的逆变换操作，通常称为转置卷积(Transpose Convolution)而不是反卷积(Deconvolution)。转置卷积常见于目标检测领域中对小目标的检测和图像分割领域还原输入图像尺度。</td>
</tr>
<tr>
<td style="text-align:center">可分离卷积</td>
<td style="text-align:center"><img src="img11.png" alt="image"></td>
<td style="text-align:left">标准的卷积操作是同时对原始图像 $H\times W\times C$ 三个方向的卷积运算，假设有 $K$ 个相同尺寸的卷积核，这样的卷积操作需要用到的参数为 $H\times W\times C\times K$ 个；若将长宽与深度方向的卷积操作分离出变为 $H\times W$ 与 $C$ 的两步卷积操作，则同样的卷积核个数 $K$ ，只需要 $(H\times W + C)\times K$ 个参数，便可得到同样的输出尺度。可分离卷积(Seperable Convolution)通常应用在模型压缩或一些轻量的卷积神经网络中，如MobileNet $^{[1]}$ 、Xception $^{[2]}$ 等</td>
</tr>
</tbody>
</table>
<h2 id="5-5-二维卷积与三维卷积有什么区别？">5.5 二维卷积与三维卷积有什么区别？</h2>
<ul>
<li><strong>二维卷积</strong><br>
二维卷积操作如图5.3所示，为了更直观的说明，分别展示在单通道和多通道输入中，对单个通道输出的卷积操作。在单通道输入的情况下，若输入卷积核尺寸为  $(k_h, k_w, 1)​$ ，卷积核在输入图像的空间维度上进行滑窗操作，每次滑窗和  $(k_h, k_w)​$ 窗口内的值进行卷积操作，得到输出图像中的一个值。在多通道输入的情况下，假定输入图像特征通道数为3，卷积核尺寸则为 $(k_h, k_w, 3)​$ ，每次滑窗与3个通道上的 $(k_h, k_w)​$ 窗口内的所有值进行卷积操作，得到输出图像中的一个值。</li>
</ul>
<p><img src="5.6.1.png" alt="image"></p>
<ul>
<li><strong>三维卷积</strong><br>
3D卷积操作如图所示，同样分为单通道和多通道，且假定只使用1个卷积核，即输出图像仅有一个通道。对于单通道输入，与2D卷积不同之处在于，输入图像多了一个深度(depth)维度，卷积核也多了一个 $k_d​$ 维度，因此3D卷积核的尺寸为 $(k_h, k_w, k_d)​$ ，每次滑窗与 $(k_h, k_w, k_d)​$ 窗口内的值进行相关操作，得到输出3D图像中的一个值。对于多通道输入，则与2D卷积的操作一样，每次滑窗与3个channels上的 $(k_h, k_w, k_d)​$ 窗口内的所有值进行相关操作，得到输出3D图像中的一个值。</li>
</ul>
<p><img src="5.6.2.png" alt="image"></p>
<h2 id="5-7-有哪些池化方法？">5.7 有哪些池化方法？</h2>
<p>​	池化操作通常也叫做子采样(Subsampling)或降采样(Downsampling)，在构建卷积神经网络时，往往会用在卷积层之后，通过池化来降低卷积层输出的特征维度，有效减少网络参数的同时还可以防止过拟合现象。池化操作可以降低图像维度的原因，本质上是因为图像具有一种“静态性”的属性，这个意思是说在一个图像区域有用的特征极有可能在另一个区域同样有用。因此，为了描述一个大的图像，很直观的想法就是对不同位置的特征进行聚合统计。例如，可以计算图像在固定区域上特征的平均值 (或最大值)来代表这个区域的特征。<br>
​                                                                              表5.6 池化分类</p>
<table>
<thead>
<tr>
<th style="text-align:center">池化类型</th>
<th style="text-align:center">示意图</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">一般池化(General Pooling)</td>
<td style="text-align:center"><img src="general_pooling.png" alt="max_pooling"></td>
<td style="text-align:left">通常包括最大池化(Max Pooling)和平均池化(Mean Pooling)。以最大池化为例，池化范围 $(2\times2)$ 和滑窗步长 $(stride=2)$  相同，仅提取一次相同区域的范化特征。</td>
</tr>
<tr>
<td style="text-align:center">重叠池化(Overlapping Pooling)</td>
<td style="text-align:center"><img src="overlap_pooling.png" alt="overlap_pooling"></td>
<td style="text-align:left">与一般池化操作相同，但是池化范围 $P_{size}$ 与滑窗步长 $stride$ 关系为 $P_{size}>stride$ ，同一区域内的像素特征可以参与多次滑窗提取，得到的特征表达能力更强，但计算量更大。</td>
</tr>
<tr>
<td style="text-align:center">空间金字塔池化 $^*$ (Spatial Pyramid Pooling)</td>
<td style="text-align:center"><img src="spatial_pooling.png" alt="spatial_pooling"></td>
<td style="text-align:left">在进行多尺度目标的训练时，卷积层允许输入的图像特征尺度是可变的，紧接的池化层若采用一般的池化方法会使得不同的输入特征输出相应变化尺度的特征，而卷积神经网络中最后的全连接层则无法对可变尺度进行运算，因此需要对不同尺度的输出特征采样到相同输出尺度。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>SPPNet $^{[3]}$ 就引入了空间池化的组合，对不同输出尺度采用不同的滑窗大小和步长以确保输出尺度相同 $(win_{size}=\lceil \frac{in}{out}\rceil; stride=\lfloor \frac{in}{out}\rfloor; )$ ，同时用如金字塔式叠加的多种池化尺度组合，以提取更加丰富的图像特征。常用于多尺度训练和目标检测中的区域提议网络(Region Proposal Network)的兴趣区域(Region of Interest)提取</p>
</blockquote>
<h2 id="5-8-swig￼58-卷积作用？">5.8  $1\times1$ 卷积作用？</h2>
<p>​	NIN(Network in Network) $^{[4]}​$ 是第一篇探索 $1\times1​$ 卷积核的论文，这篇论文通过在卷积层中使用MLP替代传统线性的卷积核，使单层卷积层内具有非线性映射的能力，也因其网络结构中嵌套MLP子网络而得名NIN。NIN对不同通道的特征整合到MLP自网络中，让不同通道的特征能够交互整合，使通道之间的信息得以流通，其中的MLP子网络恰恰可以用 $1\times1​$ 的卷积进行代替。</p>
<p>​	GoogLeNet $^{[5]}​$ 则采用 $1\times1​$ 卷积核来减少模型的参数量。在原始版本的Inception模块中，由于每一层网络采用了更多的卷积核，大大增加了模型的参数量。此时在每一个较大卷积核的卷积层前引入 $1\times1​$ 卷积，可以通过分离通道与宽高卷积来减少模型参数量。以图5.2为例，在不考虑参数偏置项的情况下，若输入和输出的通道数为 $C_1=16​$ ，则左半边网络模块所需的参数为 $(1\times1+3\times3+5\times5+0)\times C_1\times C_1=8960​$ ；假定右半边网络模块采用的 $1\times1​$ 卷积通道数为 $C_2=8​ {% raw%}$$(满足C_1>C_2)​${% endraw %} ，则右半部分的网络结构所需参数量为 {% raw%}$(1\times1\times (3C_1+C_2)+3\times3\times C_2 +5\times5\times C_2)\times C_1=5248​${% endraw %}  ，可以在不改变模型表达能力的前提下大大减少所使用的参数量。</p>
<p><img src="5.8-1.png" alt="image"></p>
<p>​								图5.2 Inception模块</p>
<p>综上所述， {% raw%}$1\times 1​${% endraw %} 卷积的作用主要为以下两点：</p>
<ul>
<li>实现信息的跨通道交互和整合。</li>
<li>对卷积核通道数进行降维和升维，减小参数量。</li>
</ul>
<h2 id="5-9-卷积层和池化层有什么区别？">5.9 卷积层和池化层有什么区别？</h2>
<p>​	卷积层核池化层在结构上具有一定的相似性，都是对感受域内的特征进行提取，并且根据步长设置获取到不同维度的输出，但是其内在操作是有本质区别的，如表5.7所示。</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">卷积层</th>
<th style="text-align:center">池化层</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>结构</strong></td>
<td style="text-align:center">零填充时输出维度不变，而通道数改变</td>
<td style="text-align:center">通常特征维度会降低，通道数不变</td>
</tr>
<tr>
<td style="text-align:center"><strong>稳定性</strong></td>
<td style="text-align:center">输入特征发生细微改变时，输出结果会改变</td>
<td style="text-align:center">感受域内的细微变化不影响输出结果</td>
</tr>
<tr>
<td style="text-align:center"><strong>作用</strong></td>
<td style="text-align:center">感受域内提取局部关联特征</td>
<td style="text-align:center">感受域内提取泛化特征，降低维度</td>
</tr>
<tr>
<td style="text-align:center"><strong>参数量</strong></td>
<td style="text-align:center">与卷积核尺寸、卷积核个数相关</td>
<td style="text-align:center">不引入额外参数</td>
</tr>
</tbody>
</table>
<h2 id="5-10-卷积核是否一定越大越好？">5.10 卷积核是否一定越大越好？</h2>
<p>​	在早期的卷积神经网络中（如LeNet-5、AlexNet），用到了一些较大的卷积核（ {% raw%}$11\times11${% endraw %} 和 {% raw%}$5\times 5${% endraw %} ），受限于当时的计算能力和模型结构的设计，无法将网络叠加得很深，因此卷积网络中的卷积层需要设置较大的卷积核以获取更大的感受域。但是这种大卷积核反而会导致计算量大幅增加，不利于训练更深层的模型，相应的计算性能也会降低。后来的卷积神经网络（VGG、GoogLeNet等），发现通过堆叠2个 {% raw%}$3\times 3${% endraw %} 卷积核可以获得与 {% raw%}$5\times 5${% endraw %} 卷积核相同的感受视野，同时参数量会更少（ {% raw%}$3×3×2+1${% endraw %}  &lt;  {% raw%}$ 5×5×1+1${% endraw %} ）， {% raw%}$3\times 3${% endraw %} 卷积核被广泛应用在许多卷积神经网络中。因此可以认为，在大多数情况下通过堆叠较小的卷积核比直接采用单个更大的卷积核会更加有效。</p>
<p>​	但是，这并不是表示更大的卷积核就没有作用，在某些领域应用卷积神经网络时仍然可以采用较大的卷积核。譬如在自然语言处理领域，由于文本内容不像图像数据可以对特征进行很深层的抽象，往往在该领域的特征提取只需要较浅层的神经网络即可。在将卷积神经网络应用在自然语言处理领域时，通常都是较为浅层的卷积层组成，但是文本特征有时又需要有较广的感受域让模型能够组合更多的特征（如词组和字符），此时直接采用较大的卷积核将是更好的选择。</p>
<p>​	综上所述，卷积核的大小并没有绝对的优劣，需要视具体的应用场景而定，但是极大和极小的卷积核都是不合适的，单独的 {% raw%}$1\times 1${% endraw %} 极小卷积核只能用作分离卷积而不能对输入的原始特征进行有效的组合，极大的卷积核通常会组合过多的无意义特征从而浪费了大量的计算资源。</p>
<h2 id="5-11-每层卷积是否只能用一种尺寸的卷积核？">5.11 每层卷积是否只能用一种尺寸的卷积核？</h2>
<p>​	经典的神经网络一般都属于层叠式网络，每层仅用一个尺寸的卷积核，如VGG结构中使用了大量的 {% raw%}$3×3${% endraw %} 卷积层。事实上，同一层特征图可以分别使用多个不同尺寸的卷积核，以获得不同尺度的特征，再把这些特征结合起来，得到的特征往往比使用单一卷积核的要好，如GoogLeNet、Inception系列的网络，均是每层使用了多个卷积核结构。如图5.3所示，输入的特征在同一层分别经过 {% raw%}$1×1${% endraw %} 、 {% raw%}$3×3${% endraw %} 和 {% raw%}$5×5${% endraw %} 三种不同尺寸的卷积核，再将分别得到的特征进行整合，得到的新特征可以看作不同感受域提取的特征组合，相比于单一卷积核会有更强的表达能力。</p>
<p><img src="5.11-1.png" alt="image"></p>
<p>​								图5.3 Inception模块结构</p>
<h2 id="5-12-怎样才能减少卷积层参数量？">5.12 怎样才能减少卷积层参数量？</h2>
<p>减少卷积层参数量的方法可以简要地归为以下几点：</p>
<ul>
<li>使用堆叠小卷积核代替大卷积核：VGG网络中2个 {% raw%}$3\times 3${% endraw %} 的卷积核可以代替1个 {% raw%}$5\times 5${% endraw %} 的卷积核</li>
<li>使用分离卷积操作：将原本 {% raw%}$K\times K\times C${% endraw %} 的卷积操作分离为 {% raw%}$K\times K\times 1${% endraw %} 和 {% raw%}$1\times1\times C${% endraw %} 的两部分操作</li>
<li>添加 {% raw%}$1\times 1${% endraw %} 的卷积操作：与分离卷积类似，但是通道数可变，在 {% raw%}$K\times K\times C_1${% endraw %} 卷积前添加 {% raw%}$1\times1\times C_2${% endraw %} 的卷积核（满足 {% raw%}$C_2 <C_1${% endraw %} ）< li>
<li>在卷积层前使用池化操作：池化可以降低卷积层的输入特征维度</li>
</C_1${%></li></ul>
<h2 id="5-13-在进行卷积操作时，必须同时考虑通道和区域吗？">5.13 在进行卷积操作时，必须同时考虑通道和区域吗？</h2>
<p>​	标准卷积中，采用区域与通道同时处理的操作，如下图所示：</p>
<p><img src="5.13-1.png" alt="image"></p>
<p>​	这样做可以简化卷积层内部的结构，每一个输出的特征像素都由所有通道的同一个区域提取而来。</p>
<p>​	但是这种方式缺乏灵活性，并且在深层的网络结构中使得运算变得相对低效，更为灵活的方式是使区域和通道的卷积分离开来，通道分离（深度分离）卷积网络由此诞生。如下图所示，Xception网络可解决上述问题。</p>
<p><img src="5.13-2.png" alt="image"></p>
<p>​	我们首先对每一个通道进行各自的卷积操作，有多少个通道就有多少个过滤器。得到新的通道特征矩阵之后，再对这批新通道特征进行标准的 {% raw%}$1×1​${% endraw %} 跨通道卷积操作。</p>
<h2 id="5-14-采用宽卷积的好处有什么？">5.14 采用宽卷积的好处有什么？</h2>
<p>​	宽卷积对应的是窄卷积，实际上并不是卷积操作的类型，指的是卷积过程中的填充方法，对应的是’SAME’填充和’VALID’填充。'SAME’填充通常采用零填充的方式对卷积核不满足整除条件的输入特征进行补全，以使卷积层的输出维度保持与输入特征维度一致；'VALID’填充的方式则相反，实际并不进行任何填充，在输入特征边缘位置若不足以进行卷积操作，则对边缘信息进行舍弃，因此在步长为1的情况下该填充方式的卷积层输出特征维度可能会略小于输入特征的维度。此外，由于前一种方式通过补零来进行完整的卷积操作，可以有效地保留原始的输入特征信息。</p>
<p>​	比如下图左部分为窄卷积。注意到越在边缘的位置被卷积的次数越少。宽卷积可以看作在卷积之前在边缘用0补充，常见有两种情况，一个是全补充，如下图右部分，这样输出大于输入的维度。另一种常用的方法是补充一一部分0值，使得输出和输入的维度一致。</p>
<p><img src="5.14.1.png" alt="image"></p>
<h2 id="5-15-理解转置卷积与棋盘效应">5.15 理解转置卷积与棋盘效应</h2>
<h3 id="5-15-1-标准卷积">5.15.1 标准卷积</h3>
<p>在理解转置卷积之前，需要先理解标准卷积的运算方式。</p>
<p>首先给出一个输入输出结果</p>
<p><img src="img32.png" alt="image"></p>
<p>那是怎样计算的呢？</p>
<p>卷积的时候需要对卷积核进行180的旋转，同时卷积核中心与需计算的图像像素对齐，输出结构为中心对齐像素的一个新的像素值，计算例子如下：</p>
<p><img src="5.19.1-2.png" alt="image"></p>
<p>这样计算出左上角(即第一行第一列)像素的卷积后像素值。</p>
<p>给出一个更直观的例子，从左到右看，原像素经过卷积由1变成-8。</p>
<p><img src="5.19.1-3.png" alt="image"></p>
<p>通过滑动卷积核，就可以得到整张图片的卷积结果。</p>
<h3 id="5-15-2-转置卷积">5.15.2 转置卷积</h3>
<p>图像的deconvolution过程如下：</p>
<p><img src="5.19.2-5.png" alt="image"></p>
<p>输入：2x2， 卷积核：4x4， 滑动步长：3， 输出：7x7</p>
<p>过程如下：</p>
<ol>
<li>
<p>输入图片每个像素进行一次full卷积，根据full卷积大小计算可以知道每个像素的卷积后大小为 1+4-1=4， 即4x4大小的特征图，输入有4个像素所以4个4x4的特征图</p>
</li>
<li>
<p>将4个特征图进行步长为3的相加； 输出的位置和输入的位置相同。步长为3是指每隔3个像素进行相加，重叠部分进行相加，即输出的第1行第4列是由红色特阵图的第一行第四列与绿色特征图的第一行第一列相加得到，其他如此类推。</p>
<p>可以看出翻卷积的大小是由卷积核大小与滑动步长决定， in是输入大小， k是卷积核大小， s是滑动步长， out是输出大小 得到 out = (in - 1) * s + k 上图过程就是， (2 - 1) * 3 + 4 = 7。</p>
</li>
</ol>
<h3 id="5-15-3-棋盘效应">5.15.3 棋盘效应</h3>
<h2 id="5-16-卷积神经网络的参数设置">5.16 卷积神经网络的参数设置</h2>
<p>​	卷积神经网络中常见的参数在其他类型的神经网络中也是类似的，但是参数的设置还得结合具体的任务才能设置在合理的范围，具体的参数列表如表XX所示。<br>
​                                                    表XX 卷积神经网络常见参数</p>
<table>
<thead>
<tr>
<th style="text-align:center">参数名</th>
<th style="text-align:center">常见设置</th>
<th style="text-align:left">参数说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">学习率(Learning Rate)</td>
<td style="text-align:center">{% raw%}$0-1${% endraw %}</td>
<td style="text-align:left">反向传播网络中更新权值矩阵的步长，在一些常见的网络中会在固定迭代次数或模型不再收敛后对学习率进行指数下降(如 {% raw%}$lr=lr\times 0.1${% endraw %} )。当学习率越大计算误差对权值矩阵的影响越大，容易在某个局部最优解附近震荡；越小的学习率对网络权值的更新越精细，但是需要花费更多的时间去迭代</td>
</tr>
<tr>
<td style="text-align:center">批次大小(Batch Size)</td>
<td style="text-align:center">{% raw%}$1-N${% endraw %}</td>
<td style="text-align:left">批次大小指定一次性流入模型的数据样本个数，根据任务和计算性能限制判断实际取值，在一些图像任务中往往由于计算性能和存储容量限制只能选取较小的值。在相同迭代次数的前提下，数值越大模型越稳定，泛化能力越强，损失值曲线越平滑，模型也更快地收敛，但是每次迭代需要花费更多的时间</td>
</tr>
<tr>
<td style="text-align:center">数据轮次(Epoch)</td>
<td style="text-align:center">{% raw%}$1-N${% endraw %}</td>
<td style="text-align:left">数据轮次指定所有训练数据在模型中训练的次数，根据数据集规模和分布情况会设置为不同的值。当模型较为简单或训练数据规模较小时，通常轮次不宜过高，否则模型容易过拟合；模型较为复杂或训练数据规模足够大时，可适当提高数据的训练轮次。</td>
</tr>
<tr>
<td style="text-align:center">权重衰减系数(Weight Decay)</td>
<td style="text-align:center">{% raw%}$0-0.001${% endraw %}</td>
<td style="text-align:left">模型训练过程中反向传播权值更新的权重衰减值</td>
</tr>
</tbody>
</table>
<h2 id="5-17-提高卷积神经网络的泛化能力">5.17 提高卷积神经网络的泛化能力</h2>
<p>​	卷积神经网络与其他类型的神经网络类似，在采用反向传播进行训练的过程中比较依赖输入的数据分布，当数据分布较为极端的情况下容易导致模型欠拟合或过拟合，表XX记录了提高卷积网络泛化能力的方法。<br>
​                                                                   表XX 提高卷积网络化能力的方法</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">使用更多数据</td>
<td style="text-align:left">在有条件的前提下，尽可能多地获取训练数据是最理想的方法，更多的数据可以让模型得到充分的学习，也更容易提高泛化能力</td>
</tr>
<tr>
<td style="text-align:center">使用更大批次</td>
<td style="text-align:left">在相同迭代次数和学习率的条件下，每批次采用更多的数据将有助于模型更好的学习到正确的模式，模型输出结果也会更加稳定</td>
</tr>
<tr>
<td style="text-align:center">调整数据分布</td>
<td style="text-align:left">大多数场景下的数据分布是不均匀的，模型过多地学习某类数据容易导致其输出结果偏向于该类型的数据，此时通过调整输入的数据分布可以一定程度提高泛化能力</td>
</tr>
<tr>
<td style="text-align:center">调整目标函数</td>
<td style="text-align:left">在某些情况下，目标函数的选择会影响模型的泛化能力，如目标函数 {% raw%}$f(y,y')=|y-y'|${% endraw %} 在某类样本已经识别较为准确而其他样本误差较大的侵害概况下，不同类别在计算损失结果的时候距离权重是相同的，若将目标函数改成 {% raw%}$f(y,y')=(y-y')^2${% endraw %} 则可以使误差小的样本计算损失的梯度比误差大的样本更小，进而有效地平衡样本作用，提高模型泛化能力</td>
</tr>
<tr>
<td style="text-align:center">调整网络结构</td>
<td style="text-align:left">在浅层卷积神经网络中，参数量较少往往使模型的泛化能力不足而导致欠拟合，此时通过叠加卷积层可以有效地增加网络参数，提高模型表达能力；在深层卷积网络中，若没有充足的训练数据则容易导致模型过拟合，此时通过简化网络结构减少卷积层数可以起到提高模型泛化能力的作用</td>
</tr>
<tr>
<td style="text-align:center">数据增强</td>
<td style="text-align:left">数据增强又叫数据增广，在有限数据的前提下通过平移、旋转、加噪声等一些列变换来增加训练数据，同类数据的表现形式也变得更多样，有助于模型提高泛化能力，需要注意的是数据变化应尽可能不破坏元数数据的主体特征(如在图像分类任务中对图像进行裁剪时不能将分类主体目标裁出边界)。</td>
</tr>
<tr>
<td style="text-align:center">权值正则化</td>
<td style="text-align:left">权值正则化就是通常意义上的正则化，一般是在损失函数中添加一项权重矩阵的正则项作为惩罚项，用来惩罚损失值较小时网络权重过大的情况，此时往往是网络权值过拟合了数据样本(如 {% raw%}$Loss=f(WX+b,y')+\frac{\lambda}{\eta}\sum{|W|}${% endraw %} )。</td>
</tr>
<tr>
<td style="text-align:center">屏蔽网络节点</td>
<td style="text-align:left">该方法可以认为是网络结构上的正则化，通过随机性地屏蔽某些神经元的输出让剩余激活的神经元作用，可以使模型的容错性更强。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>对大多数神经网络模型同样通用</p>
</blockquote>
<h2 id="5-18-卷积神经网络在不同领域的应用">5.18 卷积神经网络在不同领域的应用</h2>
<p>​	卷积神经网络中的卷积操作是其关键组成，而卷积操作只是一种数学运算方式，实际上对不同类型的数值表示数据都是通用的，尽管这些数值可能表示的是图像像素值、文本序列中单个字符或是语音片段中单字的音频。只要使原始数据能够得到有效地数值化表示，卷积神经网络能够在不同的领域中得到应用，要关注的是如何将卷积的特性更好地在不同领域中应用，如表XX所示。<br>
​                                                    表XX 卷积神经网络不同领域的应用</p>
<table>
<thead>
<tr>
<th style="text-align:center">应用领域</th>
<th style="text-align:center">输入数据图示</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">图像处理</td>
<td style="text-align:center"><img src="Image-process.png" alt="image_process"></td>
<td style="text-align:left">卷积神经网络在图像处理领域有非常广泛的应用，这是因为图像数据本身具有的局部完整性非常</td>
</tr>
<tr>
<td style="text-align:center">自然语言处理</td>
<td style="text-align:center"><img src="NLP.png" alt="NLP"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">语音处理</td>
<td style="text-align:center"><img src="audio-recognition.png" alt="audio_process"></td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<h3 id="5-18-1-联系">5.18.1 联系</h3>
<p>​	自然语言处理是对一维信号（词序列）做操作。<br>
​	计算机视觉是对二维（图像）或三维（视频流）信号做操作。</p>
<h3 id="5-18-2-区别">5.18.2 区别</h3>
<p>​	自然语言处理的输入数据通常是离散取值（例如表示一个单词或字母通常表示为词典中的one hot向量），计算机视觉则是连续取值（比如归一化到0，1之间的灰度值）。CNN有两个主要特点，区域不变性(location invariance)和组合性(Compositionality)。</p>
<ol>
<li>区域不变性：滤波器在每层的输入向量(图像)上滑动，检测的是局部信息，然后通过pooling取最大值或均值。pooling这步综合了局部特征，失去了每个特征的位置信息。这很适合基于图像的任务，比如要判断一幅图里有没有猫这种生物，你可能不会去关心这只猫出现在图像的哪个区域。但是在NLP里，词语在句子或是段落里出现的位置，顺序，都是很重要的信息。</li>
<li>局部组合性：CNN中，每个滤波器都把较低层的局部特征组合生成较高层的更全局化的特征。这在CV里很好理解，像素组合成边缘，边缘生成形状，最后把各种形状组合起来得到复杂的物体表达。在语言里，当然也有类似的组合关系，但是远不如图像来的直接。而且在图像里，相邻像素必须是相关的，相邻的词语却未必相关。</li>
</ol>
<h2 id="5-19-卷积神经网络凸显共性的方法？">5.19 卷积神经网络凸显共性的方法？</h2>
<h3 id="5-19-1-局部连接">5.19.1 局部连接</h3>
<p>​	我们首先了解一个概念，感受野，即每个神经元仅与输入神经元相连接的一块区域。<br>
在图像卷积操作中，神经元在空间维度上是局部连接，但在深度上是全连接。局部连接的思想，是受启发于生物学里的视觉系统结构，视觉皮层的神经元就是仅用局部接受信息。对于二维图像，局部像素关联性较强。这种局部连接保证了训练后的滤波器能够对局部特征有最强的响应，使神经网络可以提取数据的局部特征；<br>
下图是一个很经典的图示，左边是全连接，右边是局部连接。</p>
<p><img src="5.27.1.png" alt="image"></p>
<p>对于一个1000 × 1000的输入图像而言，如果下一个隐藏层的神经元数目为10^6个，采用全连接则有1000 × 1000 × 10^6 = 10^12个权值参数，如此巨大的参数量几乎难以训练；而采用局部连接，隐藏层的每个神经元仅与图像中10 × 10的局部图像相连接，那么此时的权值参数数量为10 × 10 × 10^6 = 10^8，将直接减少4个数量级。</p>
<h3 id="5-19-2-权值共享">5.19.2 权值共享</h3>
<p>​	权值共享，即计算同一深度的神经元时采用的卷积核参数是共享的。权值共享在一定程度上讲是有意义的，是由于在神经网络中，提取的底层边缘特征与其在图中的位置无关。但是在另一些场景中是无意的，如在人脸识别任务，我们期望在不同的位置学到不同的特征。<br>
需要注意的是，权重只是对于同一深度切片的神经元是共享的。在卷积层中，通常采用多组卷积核提取不同的特征，即对应的是不同深度切片的特征，而不同深度切片的神经元权重是不共享。相反，偏置这一权值对于同一深度切片的所有神经元都是共享的。<br>
权值共享带来的好处是大大降低了网络的训练难度。如下图，假设在局部连接中隐藏层的每一个神经元连接的是一个10 × 10的局部图像，因此有10 × 10个权值参数，将这10 × 10个权值参数共享给剩下的神经元，也就是说隐藏层中10^6个神经元的权值参数相同，那么此时不管隐藏层神经元的数目是多少，需要训练的参数就是这 10 × 10个权值参数（也就是卷积核的大小）。</p>
<p><img src="5.27.2.png" alt="image"></p>
<p>这里就体现了卷积神经网络的奇妙之处，使用少量的参数，却依然能有非常出色的性能。上述仅仅是提取图像一种特征的过程。如果要多提取出一些特征，可以增加多个卷积核，不同的卷积核能够得到图像不同尺度下的特征，称之为特征图（feature map）。</p>
<h3 id="5-19-3-池化操作">5.19.3 池化操作</h3>
<p>池化操作与多层次结构一起，实现了数据的降维，将低层次的局部特征组合成为较高层次的特征，从而对整个图片进行表示。如下图：</p>
<p><img src="5.27.3.png" alt="image"></p>
<h2 id="5-20-全连接、局部连接、全卷积与局部卷积">5.20 全连接、局部连接、全卷积与局部卷积</h2>
<p>​	大多数神经网络中高层网络通常会采用全连接层(Global Connected Layer)，通过多对多的连接方式对特征进行全局汇总，可以有效地提取全局信息。但是全连接的方式需要大量的参数，是神经网络中最占资源的部分之一，因此就需要由局部连接(Local Connected Layer)，仅在局部区域范围内产生神经元连接，能够有效地减少参数量。根据卷积操作的作用范围可以分为全卷积(Global Convolution)和局部卷积(Local Convolution)。实际上这里所说的全卷积就是标准卷积，即在整个输入特征维度范围内采用相同的卷积核参数进行运算，全局共享参数的连接方式可以使神经元之间的连接参数大大减少;局部卷积又叫平铺卷积(Tiled Convolution)或非共享卷积(Unshared Convolution)，是局部连接与全卷积的折衷。四者的比较如表XX所示。<br>
​                                                     表XX 卷积网络中连接方式的对比</p>
<table>
<thead>
<tr>
<th style="text-align:center">连接方式</th>
<th style="text-align:center">示意图</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">全连接</td>
<td style="text-align:center"><img src="full-connected.png" alt="full-connected"></td>
<td style="text-align:left">层间神经元完全连接，每个输出神经元可以获取到所有输入神经元的信息，有利于信息汇总，常置于网络末层；连接与连接之间独立参数，大量的连接大大增加模型的参数规模。</td>
</tr>
<tr>
<td style="text-align:center">局部连接</td>
<td style="text-align:center"><img src="local-connected.png" alt="local-connected"></td>
<td style="text-align:left">层间神经元只有局部范围内的连接，在这个范围内采用全连接的方式，超过这个范围的神经元则没有连接；连接与连接之间独立参数，相比于全连接减少了感受域外的连接，有效减少参数规模</td>
</tr>
<tr>
<td style="text-align:center">全卷积</td>
<td style="text-align:center"><img src="conv.png" alt="convolution"></td>
<td style="text-align:left">层间神经元只有局部范围内的连接，在这个范围内采用全连接的方式，连接所采用的参数在不同感受域之间共享，有利于提取特定模式的特征；相比于局部连接，共用感受域之间的参数可以进一步减少参数量。</td>
</tr>
<tr>
<td style="text-align:center">局部卷积</td>
<td style="text-align:center"><img src="local-conv.png" alt="local-conv"></td>
<td style="text-align:left">层间神经元只有局部范围内的连接，感受域内采用全连接的方式，而感受域之间间隔采用局部连接与全卷积的连接方式；相比与全卷积成倍引入额外参数，但有更强的灵活性和表达能力；相比于局部连接，可以有效控制参数量</td>
</tr>
</tbody>
</table>
<h2 id="5-21-局部卷积的应用">5.21 局部卷积的应用</h2>
<p>并不是所有的卷积都会进行权重共享，在某些特定任务中，会使用不权重共享的卷积。下面通过人脸这一任务来进行讲解。在读人脸方向的一些paper时，会发现很多都会在最后加入一个Local Connected Conv，也就是不进行权重共享的卷积层。总的来说，这一步的作用就是使用3D模型来将人脸对齐，从而使CNN发挥最大的效果。<br>
<img src="img66.png" alt="image"></p>
<p>截取论文中的一部分图，经过3D对齐以后，形成的图像均是152×152，输入到上述的网络结构中。该结构的参数如下：</p>
<p>Conv：32个11×11×3的卷积核，</p>
<p>Max-pooling: 3×3，stride=2，</p>
<p>Conv: 16个9×9的卷积核，</p>
<p>Local-Conv: 16个9×9的卷积核，</p>
<p>Local-Conv: 16个7×7的卷积核，</p>
<p>Local-Conv: 16个5×5的卷积核，</p>
<p>Fully-connected: 4096维，</p>
<p>Softmax: 4030维。</p>
<p>前三层的目的在于提取低层次的特征，比如简单的边和纹理。其中Max-pooling层使得卷积的输出对微小的偏移情况更加鲁棒。但不能使用更多的Max-pooling层，因为太多的Max-pooling层会使得网络损失图像信息。全连接层将上一层的每个单元和本层的所有单元相连，用来捕捉人脸图像不同位置特征之间的相关性。最后使用softmax层用于人脸分类。<br>
中间三层都是使用参数不共享的卷积核，之所以使用参数不共享，有如下原因：</p>
<p>（1）对齐的人脸图片中，不同的区域会有不同的统计特征，因此并不存在特征的局部稳定性，所以使用相同的卷积核会导致信息的丢失。</p>
<p>（2）不共享的卷积核并不增加inference时特征的计算量，仅会增加训练时的计算量。<br>
使用不共享的卷积核，由于需要训练的参数量大大增加，因此往往需要通过其他方法增加数据量。</p>
<h2 id="5-22-NetVLAD池化-（贡献者：熊楚原-中国人民大学）">5.22 NetVLAD池化    （贡献者：熊楚原-中国人民大学）</h2>
<p>NetVLAD是论文[15]提出的一个局部特征聚合的方法。</p>
<p>在传统的网络里面，例如VGG啊，最后一层卷积层输出的特征都是类似于Batchsize x 3 x 3 x 512的这种东西，然后会经过FC聚合，或者进行一个Global Average Pooling（NIN里的做法），或者怎么样，变成一个向量型的特征，然后进行Softmax or 其他的Loss。</p>
<p>这种方法说简单点也就是输入一个图片或者什么的结构性数据，然后经过特征提取得到一个长度固定的向量，之后可以用度量的方法去进行后续的操作，比如分类啊，检索啊，相似度对比等等。</p>
<p>那么NetVLAD考虑的主要是最后一层卷积层输出的特征这里，我们不想直接进行欠采样或者全局映射得到特征，对于最后一层输出的W x H x D，设计一个新的池化，去聚合一个“局部特征“，这即是NetVLAD的作用。</p>
<p>NetVLAD的一个输入是一个W x H x D的图像特征，例如VGG-Net最后的3 x 3 x 512这样的矩阵，在网络中还需加一个维度为Batchsize。</p>
<p>NetVLAD还需要另输入一个标量K即表示VLAD的聚类中心数量，它主要是来构成一个矩阵C，是通过原数据算出来的每一个 {% raw%}$W \times H${% endraw %} 特征的聚类中心，C的shape即 {% raw%}$C: K \times D${% endraw %} ，然后根据三个输入，VLAD是计算下式的V:</p>
<p>$$ V(j, k) = \sum_{i=1}^{N}{a_k(x_i)(x_i(j) - c_k(j))} $$

其中j表示维度，从1到D，可以看到V的j是和输入与c对应的，对每个类别k，都对所有的x进行了计算，如果 {% raw%}$x_i${% endraw %} 属于当前类别k， {% raw%}$a_k=1${% endraw %} ，否则 {% raw%}$a_k=0${% endraw %} ，计算每一个x和它聚类中心的残差，然后把残差加起来，即是每个类别k的结果，最后分别L2正则后拉成一个长向量后再做L2正则，正则非常的重要，因为这样才能统一所有聚类算出来的值，而残差和的目的主要是消减不同聚类上的分布不均，两者共同作用才能得到最后正常的输出。</p>
<p>输入与输出如下图所示：</p>
<p><img src="http://www.ecohnoch.cn/netvlad.jpeg" alt="image"></p>
<p>中间得到的K个D维向量即是对D个x都进行了与聚类中心计算残差和的过程，最终把K个D维向量合起来后进行即得到最终输出的 {% raw%}$K \times D${% endraw %} 长度的一维向量。</p>
<p>而VLAD本身是不可微的，因为上面的a要么是0要么是1，表示要么当前描述x是当前聚类，要么不是，是个离散的，NetVLAD为了能够在深度卷积网络里使用反向传播进行训练，对a进行了修正。</p>
<p>那么问题就是如何重构一个a，使其能够评估当前的这个x和各个聚类的关联程度？用softmax来得到：</p>
<p>$$ a_k = \frac{e^{W_k^T x_i + b_k}}{e^{W_{k’}^T x_i + b_{k’}}} $$

将这个把上面的a替换后，即是NetVLAD的公式，可以进行反向传播更新参数。

所以一共有三个可训练参数，上式a中的 {% raw%}$W: K \times D${% endraw %} ，上式a中的 {% raw%}$b: K \times 1${% endraw %} ，聚类中心 {% raw%}$c: K \times D${% endraw %} ，而原始VLAD只有一个参数c。</p>
<p>最终池化得到的输出是一个恒定的K x D的一维向量（经过了L2正则），如果带Batchsize，输出即为Batchsize x (K x D)的二维矩阵。</p>
<p>NetVLAD作为池化层嵌入CNN网络即如下图所示，</p>
<p><img src="http://www.ecohnoch.cn/netvlad_emb.png" alt="image"></p>
<p>原论文中采用将传统图像检索方法VLAD进行改进后应用在CNN的池化部分作为一种另类的局部特征池化，在场景检索上取得了很好的效果。</p>
<p>后续相继又提出了ActionVLAD、ghostVLAD等改进。</p>
<h2 id="参考文献">参考文献</h2>
<p>[1] 卷积神经网络研究综述[J]. 计算机学报, 2017, 40(6):1229-1251.</p>
<p>[2] 常亮, 邓小明, 周明全,等. 图像理解中的卷积神经网络[J]. 自动化学报, 2016, 42(9):1300-1312.</p>
<p>[3] Chua L O. CNN: A Paradigm for Complexity[M]// CNN a paradigm for complexity /.  1998.</p>
<p>[4] He K, Gkioxari G, Dollar P, et al. Mask R-CNN[J]. IEEE Transactions on Pattern Analysis &amp; Machine Intelligence, 2017, PP(99):1-1.</p>
<p>[5] Hoochang S, Roth H R, Gao M, et al. Deep Convolutional Neural Networks for Computer-Aided Detection: CNN Architectures, Dataset Characteristics and Transfer Learning[J]. IEEE Transactions on Medical Imaging, 2016, 35(5):1285-1298.</p>
<p>[6] 许可. 卷积神经网络在图像识别上的应用的研究[D]. 浙江大学, 2012.</p>
<p>[7] 陈先昌. 基于卷积神经网络的深度学习算法与应用研究[D]. 浙江工商大学, 2014.</p>
<p>[8] <a target="_blank" rel="noopener" href="http://cs231n.github.io/convolutional-networks/">CS231n Convolutional Neural Networks for Visual Recognition, Stanford</a></p>
<p>[9] <a target="_blank" rel="noopener" href="https://medium.com/@ageitgey/machine-learning-is-fun-part-3-deep-learning-and-convolutional-neural-networks-f40359318721#.2gfx5zcw3">Machine Learning is Fun! Part 3: Deep Learning and Convolutional Neural Networks</a></p>
<p>[10] cs231n 动态卷积图：<a target="_blank" rel="noopener" href="http://cs231n.github.io/assets/conv-demo/index.html">http://cs231n.github.io/assets/conv-demo/index.html</a></p>
<p>[11] Krizhevsky A, Sutskever I, Hinton G E. Imagenet classification with deep convolutional neural networks[C]//Advances in neural information processing systems. 2012: 1097-1105.</p>
<p>[12] Sun Y, Wang X, Tang X. Deep learning face representation from predicting 10,000 classes[C]//Computer Vision and Pattern Recognition (CVPR), 2014 IEEE Conference on. IEEE, 2014: 1891-1898.</p>
<p>[13] 魏秀参.解析深度学习——卷积神经网络原理与视觉实践[M].电子工业出版社, 2018</p>
<p>[14]  Jianxin W U ,  Gao B B ,  Wei X S , et al. Resource-constrained deep learning: challenges and practices[J]. Scientia Sinica(Informationis), 2018.</p>
<p>[15] Arandjelovic R , Gronat P , Torii A , et al. [IEEE 2016 IEEE Conference on Computer Vision and Pattern Recognition (CVPR) - Las Vegas, NV, USA (2016.6.27-2016.6.30)] 2016 IEEE Conference on Computer Vision and Pattern Recognition (CVPR) - NetVLAD: CNN Architecture for Weakly Supervised Place Recognition[C]// 2016:5297-5307.</p>
</0>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Tom</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">33</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tom</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
